/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/@firebase/app/dist/index.cjs.js":
/*!*******************************************************!*\
  !*** ../node_modules/@firebase/app/dist/index.cjs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

var tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.js");

var util = __webpack_require__(/*! @firebase/util */ "../node_modules/@firebase/util/dist/index.cjs.js");

var logger$1 = __webpack_require__(/*! @firebase/logger */ "../node_modules/@firebase/logger/dist/index.esm.js");
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var _a;

var ERRORS = (_a = {}, _a["no-app"
/* NO_APP */
] = "No Firebase App '{$name}' has been created - " + 'call Firebase App.initializeApp()', _a["bad-app-name"
/* BAD_APP_NAME */
] = "Illegal App name: '{$name}", _a["duplicate-app"
/* DUPLICATE_APP */
] = "Firebase App named '{$name}' already exists", _a["app-deleted"
/* APP_DELETED */
] = "Firebase App named '{$name}' already deleted", _a["duplicate-service"
/* DUPLICATE_SERVICE */
] = "Firebase service named '{$name}' already registered", _a["invalid-app-argument"
/* INVALID_APP_ARGUMENT */
] = 'firebase.{$name}() takes either no argument or a ' + 'Firebase App instance.', _a);
var ERROR_FACTORY = new util.ErrorFactory('app', 'Firebase', ERRORS);
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DEFAULT_ENTRY_NAME = '[DEFAULT]';
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// An array to capture listeners before the true auth functions
// exist

var tokenListeners = [];
/**
 * Global context object for a collection of services using
 * a shared authentication state.
 */

var FirebaseAppImpl =
/** @class */
function () {
  function FirebaseAppImpl(options, config, firebase_) {
    this.firebase_ = firebase_;
    this.isDeleted_ = false;
    this.services_ = {};
    this.name_ = config.name;
    this.automaticDataCollectionEnabled_ = config.automaticDataCollectionEnabled || false;
    this.options_ = util.deepCopy(options);
    this.INTERNAL = {
      getUid: function () {
        return null;
      },
      getToken: function () {
        return Promise.resolve(null);
      },
      addAuthTokenListener: function (callback) {
        tokenListeners.push(callback); // Make sure callback is called, asynchronously, in the absence of the auth module

        setTimeout(function () {
          return callback(null);
        }, 0);
      },
      removeAuthTokenListener: function (callback) {
        tokenListeners = tokenListeners.filter(function (listener) {
          return listener !== callback;
        });
      }
    };
  }

  Object.defineProperty(FirebaseAppImpl.prototype, "automaticDataCollectionEnabled", {
    get: function () {
      this.checkDestroyed_();
      return this.automaticDataCollectionEnabled_;
    },
    set: function (val) {
      this.checkDestroyed_();
      this.automaticDataCollectionEnabled_ = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FirebaseAppImpl.prototype, "name", {
    get: function () {
      this.checkDestroyed_();
      return this.name_;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FirebaseAppImpl.prototype, "options", {
    get: function () {
      this.checkDestroyed_();
      return this.options_;
    },
    enumerable: true,
    configurable: true
  });

  FirebaseAppImpl.prototype.delete = function () {
    var _this = this;

    return new Promise(function (resolve) {
      _this.checkDestroyed_();

      resolve();
    }).then(function () {
      _this.firebase_.INTERNAL.removeApp(_this.name_);

      var services = [];

      for (var _i = 0, _a = Object.keys(_this.services_); _i < _a.length; _i++) {
        var serviceKey = _a[_i];

        for (var _b = 0, _c = Object.keys(_this.services_[serviceKey]); _b < _c.length; _b++) {
          var instanceKey = _c[_b];
          services.push(_this.services_[serviceKey][instanceKey]);
        }
      }

      return Promise.all(services.filter(function (service) {
        return 'INTERNAL' in service;
      }).map(function (service) {
        return service.INTERNAL.delete();
      }));
    }).then(function () {
      _this.isDeleted_ = true;
      _this.services_ = {};
    });
  };
  /**
   * Return a service instance associated with this app (creating it
   * on demand), identified by the passed instanceIdentifier.
   *
   * NOTE: Currently storage is the only one that is leveraging this
   * functionality. They invoke it by calling:
   *
   * ```javascript
   * firebase.app().storage('STORAGE BUCKET ID')
   * ```
   *
   * The service name is passed to this already
   * @internal
   */


  FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {
    if (instanceIdentifier === void 0) {
      instanceIdentifier = DEFAULT_ENTRY_NAME;
    }

    this.checkDestroyed_();

    if (!this.services_[name]) {
      this.services_[name] = {};
    }

    if (!this.services_[name][instanceIdentifier]) {
      /**
       * If a custom instance has been defined (i.e. not '[DEFAULT]')
       * then we will pass that instance on, otherwise we pass `null`
       */
      var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : undefined;
      var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);
      this.services_[name][instanceIdentifier] = service;
    }

    return this.services_[name][instanceIdentifier];
  };
  /**
   * Callback function used to extend an App instance at the time
   * of service instance creation.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any


  FirebaseAppImpl.prototype.extendApp = function (props) {
    var _this = this; // Copy the object onto the FirebaseAppImpl prototype


    util.deepExtend(this, props);
    /**
     * If the app has overwritten the addAuthTokenListener stub, forward
     * the active token listeners on to the true fxn.
     *
     * TODO: This function is required due to our current module
     * structure. Once we are able to rely strictly upon a single module
     * implementation, this code should be refactored and Auth should
     * provide these stubs and the upgrade logic
     */

    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {
      tokenListeners.forEach(function (listener) {
        _this.INTERNAL.addAuthTokenListener(listener);
      });
      tokenListeners = [];
    }
  };
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */


  FirebaseAppImpl.prototype.checkDestroyed_ = function () {
    if (this.isDeleted_) {
      throw ERROR_FACTORY.create("app-deleted"
      /* APP_DELETED */
      , {
        name: this.name_
      });
    }
  };

  return FirebaseAppImpl;
}(); // Prevent dead-code elimination of these methods w/o invalid property
// copying.


FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log('dc');
var version = "6.2.2";
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Because auth can't share code with other components, we attach the utility functions
 * in an internal namespace to share code.
 * This function return a firebase namespace object without
 * any utility functions, so it can be shared between the regular firebaseNamespace and
 * the lite version.
 */

function createFirebaseNamespaceCore(firebaseAppImpl) {
  var apps = {};
  var factories = {};
  var appHooks = {}; // A namespace is a plain JavaScript Object.

  var namespace = {
    // Hack to prevent Babel from modifying the object returned
    // as the firebase namespace.
    // @ts-ignore
    __esModule: true,
    initializeApp: initializeApp,
    // @ts-ignore
    app: app,
    // @ts-ignore
    apps: null,
    SDK_VERSION: version,
    INTERNAL: {
      registerService: registerService,
      removeApp: removeApp,
      factories: factories,
      useAsService: useAsService
    }
  }; // Inject a circular default export to allow Babel users who were previously
  // using:
  //
  //   import firebase from 'firebase';
  //   which becomes: var firebase = require('firebase').default;
  //
  // instead of
  //
  //   import * as firebase from 'firebase';
  //   which becomes: var firebase = require('firebase');
  // eslint-disable-next-line @typescript-eslint/no-explicit-any

  namespace['default'] = namespace; // firebase.apps is a read-only getter.

  Object.defineProperty(namespace, 'apps', {
    get: getApps
  });
  /**
   * Called by App.delete() - but before any services associated with the App
   * are deleted.
   */

  function removeApp(name) {
    var app = apps[name];
    callAppHooks(app, 'delete');
    delete apps[name];
  }
  /**
   * Get the App object for a given name (or DEFAULT).
   */


  function app(name) {
    name = name || DEFAULT_ENTRY_NAME;

    if (!util.contains(apps, name)) {
      throw ERROR_FACTORY.create("no-app"
      /* NO_APP */
      , {
        name: name
      });
    }

    return apps[name];
  } // @ts-ignore


  app['App'] = firebaseAppImpl;

  function initializeApp(options, rawConfig) {
    if (rawConfig === void 0) {
      rawConfig = {};
    }

    if (typeof rawConfig !== 'object' || rawConfig === null) {
      var name_1 = rawConfig;
      rawConfig = {
        name: name_1
      };
    }

    var config = rawConfig;

    if (config.name === undefined) {
      config.name = DEFAULT_ENTRY_NAME;
    }

    var name = config.name;

    if (typeof name !== 'string' || !name) {
      throw ERROR_FACTORY.create("bad-app-name"
      /* BAD_APP_NAME */
      , {
        name: String(name)
      });
    }

    if (util.contains(apps, name)) {
      throw ERROR_FACTORY.create("duplicate-app"
      /* DUPLICATE_APP */
      , {
        name: name
      });
    }

    var app = new firebaseAppImpl(options, config, namespace);
    apps[name] = app;
    callAppHooks(app, 'create');
    return app;
  }
  /*
   * Return an array of all the non-deleted FirebaseApps.
   */


  function getApps() {
    // Make a copy so caller cannot mutate the apps list.
    return Object.keys(apps).map(function (name) {
      return apps[name];
    });
  }
  /*
   * Register a Firebase Service.
   *
   * firebase.INTERNAL.registerService()
   *
   * TODO: Implement serviceProperties.
   */


  function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {
    if (allowMultipleInstances === void 0) {
      allowMultipleInstances = false;
    } // Cannot re-register a service that already exists


    if (factories[name]) {
      throw ERROR_FACTORY.create("duplicate-service"
      /* DUPLICATE_SERVICE */
      , {
        name: name
      });
    } // Capture the service factory for later service instantiation


    factories[name] = createService; // Capture the appHook, if passed

    if (appHook) {
      appHooks[name] = appHook; // Run the **new** app hook on all existing apps

      getApps().forEach(function (app) {
        appHook('create', app);
      });
    } // The Service namespace is an accessor function ...


    function serviceNamespace(appArg) {
      if (appArg === void 0) {
        appArg = app();
      } // @ts-ignore


      if (typeof appArg[name] !== 'function') {
        // Invalid argument.
        // This happens in the following case: firebase.storage('gs:/')
        throw ERROR_FACTORY.create("invalid-app-argument"
        /* INVALID_APP_ARGUMENT */
        , {
          name: name
        });
      } // Forward service instance lookup to the FirebaseApp.
      // @ts-ignore


      return appArg[name]();
    } // ... and a container for service-level properties.


    if (serviceProperties !== undefined) {
      util.deepExtend(serviceNamespace, serviceProperties);
    } // Monkey-patch the serviceNamespace onto the firebase namespace
    // @ts-ignore


    namespace[name] = serviceNamespace; // Patch the FirebaseAppImpl prototype
    // @ts-ignore

    firebaseAppImpl.prototype[name] = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var serviceFxn = this._getService.bind(this, name);

      return serviceFxn.apply(this, allowMultipleInstances ? args : []);
    };

    return serviceNamespace;
  }

  function callAppHooks(app, eventName) {
    for (var _i = 0, _a = Object.keys(factories); _i < _a.length; _i++) {
      var serviceName = _a[_i]; // Ignore virtual services

      var factoryName = useAsService(app, serviceName);

      if (factoryName === null) {
        return;
      }

      if (appHooks[factoryName]) {
        appHooks[factoryName](eventName, app);
      }
    }
  } // Map the requested service to a registered service name
  // (used to map auth to serverAuth service when needed).


  function useAsService(app, name) {
    if (name === 'serverAuth') {
      return null;
    }

    var useService = name;
    return useService;
  }

  return namespace;
}
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Return a firebase namespace object.
 *
 * In production, this will be called exactly once and the result
 * assigned to the 'firebase' global.  It may be called multiple times
 * in unit tests.
 */


function createFirebaseNamespace() {
  var namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
  namespace.INTERNAL = tslib_1.__assign({}, namespace.INTERNAL, {
    createFirebaseNamespace: createFirebaseNamespace,
    extendNamespace: extendNamespace,
    createSubscribe: util.createSubscribe,
    ErrorFactory: util.ErrorFactory,
    deepExtend: util.deepExtend
  });
  /**
   * Patch the top-level firebase namespace with additional properties.
   *
   * firebase.INTERNAL.extendNamespace()
   */

  function extendNamespace(props) {
    util.deepExtend(namespace, props);
  }

  return namespace;
}
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var logger = new logger$1.Logger('@firebase/app'); // Firebase Lite detection
// eslint-disable-next-line @typescript-eslint/no-explicit-any

if (util.isBrowser() && self.firebase !== undefined) {
  logger.warn("\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  "); // eslint-disable-next-line

  var sdkVersion = self.firebase.SDK_VERSION;

  if (sdkVersion && sdkVersion.indexOf('LITE') >= 0) {
    logger.warn("\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    ");
  }
}

var firebaseNamespace = createFirebaseNamespace();
var initializeApp = firebaseNamespace.initializeApp;

firebaseNamespace.initializeApp = function () {
  // Environment check before initializing app
  // Do the check in initializeApp, so people have a chance to disable it by setting logLevel
  // in @firebase/logger
  if (util.isNode()) {
    logger.warn("\n      Warning: This is a browser-targeted Firebase bundle but it appears it is being\n      run in a Node environment.  If running in a Node environment, make sure you\n      are using the bundle specified by the \"main\" field in package.json.\n      \n      If you are using Webpack, you can specify \"main\" as the first item in\n      \"resolve.mainFields\":\n      https://webpack.js.org/configuration/resolve/#resolvemainfields\n      \n      If using Rollup, use the rollup-plugin-node-resolve plugin and set \"module\"\n      to false and \"main\" to true:\n      https://github.com/rollup/rollup-plugin-node-resolve\n      ");
  }

  return initializeApp.apply(undefined, arguments);
};

var firebase = firebaseNamespace;
exports.default = firebase;
exports.firebase = firebase;

/***/ }),

/***/ "../node_modules/@firebase/database/dist/index.cjs.js":
/*!************************************************************!*\
  !*** ../node_modules/@firebase/database/dist/index.cjs.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {Object.defineProperty(exports,'__esModule',{value:true});function _interopDefault(ex){return ex&&typeof ex==='object'&&'default'in ex?ex['default']:ex;}var firebase=_interopDefault(__webpack_require__(/*! @firebase/app */ "../node_modules/@firebase/app/dist/index.cjs.js"));var tslib_1=__webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.js");var util=__webpack_require__(/*! @firebase/util */ "../node_modules/@firebase/util/dist/index.cjs.js");var logger$1=__webpack_require__(/*! @firebase/logger */ "../node_modules/@firebase/logger/dist/index.esm.js");/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Wraps a DOM Storage object and:
 * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.
 * - prefixes names with "firebase:" to avoid collisions with app data.
 *
 * We automatically (see storage.js) create two such wrappers, one for sessionStorage,
 * and one for localStorage.
 *
 * @constructor
 */var DOMStorageWrapper=/** @class */function(){/**
     * @param {Storage} domStorage_ The underlying storage object (e.g. localStorage or sessionStorage)
     */function DOMStorageWrapper(domStorage_){this.domStorage_=domStorage_;// Use a prefix to avoid collisions with other stuff saved by the app.
this.prefix_='firebase:';}/**
     * @param {string} key The key to save the value under
     * @param {?Object} value The value being stored, or null to remove the key.
     */DOMStorageWrapper.prototype.set=function(key,value){if(value==null){this.domStorage_.removeItem(this.prefixedName_(key));}else{this.domStorage_.setItem(this.prefixedName_(key),util.stringify(value));}};/**
     * @param {string} key
     * @return {*} The value that was stored under this key, or null
     */DOMStorageWrapper.prototype.get=function(key){var storedVal=this.domStorage_.getItem(this.prefixedName_(key));if(storedVal==null){return null;}else{return util.jsonEval(storedVal);}};/**
     * @param {string} key
     */DOMStorageWrapper.prototype.remove=function(key){this.domStorage_.removeItem(this.prefixedName_(key));};/**
     * @param {string} name
     * @return {string}
     */DOMStorageWrapper.prototype.prefixedName_=function(name){return this.prefix_+name;};DOMStorageWrapper.prototype.toString=function(){return this.domStorage_.toString();};return DOMStorageWrapper;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An in-memory storage implementation that matches the API of DOMStorageWrapper
 * (TODO: create interface for both to implement).
 *
 * @constructor
 */var MemoryStorage=/** @class */function(){function MemoryStorage(){this.cache_={};this.isInMemoryStorage=true;}MemoryStorage.prototype.set=function(key,value){if(value==null){delete this.cache_[key];}else{this.cache_[key]=value;}};MemoryStorage.prototype.get=function(key){if(util.contains(this.cache_,key)){return this.cache_[key];}return null;};MemoryStorage.prototype.remove=function(key){delete this.cache_[key];};return MemoryStorage;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.
 * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change
 * to reflect this type
 *
 * @param {string} domStorageName Name of the underlying storage object
 *   (e.g. 'localStorage' or 'sessionStorage').
 * @return {?} Turning off type information until a common interface is defined.
 */var createStoragefor=function(domStorageName){try{// NOTE: just accessing "localStorage" or "window['localStorage']" may throw a security exception,
// so it must be inside the try/catch.
if(typeof window!=='undefined'&&typeof window[domStorageName]!=='undefined'){// Need to test cache. Just because it's here doesn't mean it works
var domStorage=window[domStorageName];domStorage.setItem('firebase:sentinel','cache');domStorage.removeItem('firebase:sentinel');return new DOMStorageWrapper(domStorage);}}catch(e){}// Failed to create wrapper.  Just return in-memory storage.
// TODO: log?
return new MemoryStorage();};/** A storage object that lasts across sessions */var PersistentStorage=createStoragefor('localStorage');/** A storage object that only lasts one session */var SessionStorage=createStoragefor('sessionStorage');/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var logClient=new logger$1.Logger('@firebase/database');/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 * @type {function(): number} Generated ID.
 */var LUIDGenerator=function(){var id=1;return function(){return id++;};}();/**
 * Sha1 hash of the input string
 * @param {!string} str The string to hash
 * @return {!string} The resulting hash
 */var sha1=function(str){var utf8Bytes=util.stringToByteArray(str);var sha1=new util.Sha1();sha1.update(utf8Bytes);var sha1Bytes=sha1.digest();return util.base64.encodeByteArray(sha1Bytes);};/**
 * @param {...*} var_args
 * @return {string}
 * @private
 */var buildLogMessage_=function(){var var_args=[];for(var _i=0;_i<arguments.length;_i++){var_args[_i]=arguments[_i];}var message='';for(var i=0;i<var_args.length;i++){if(Array.isArray(var_args[i])||var_args[i]&&typeof var_args[i]==='object'&&typeof var_args[i].length==='number'){message+=buildLogMessage_.apply(null,var_args[i]);}else if(typeof var_args[i]==='object'){message+=util.stringify(var_args[i]);}else{message+=var_args[i];}message+=' ';}return message;};/**
 * Use this for all debug messages in Firebase.
 * @type {?function(string)}
 */var logger=null;/**
 * Flag to check for log availability on first log message
 * @type {boolean}
 * @private
 */var firstLog_=true;/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param {boolean|?function(string)} logger_ A flag to turn on logging, or a custom logger
 * @param {boolean=} persistent Whether or not to persist logging settings across refreshes
 */var enableLogging=function(logger_,persistent){util.assert(!persistent||logger_===true||logger_===false,"Can't turn on custom loggers persistently.");if(logger_===true){logClient.logLevel=logger$1.LogLevel.VERBOSE;logger=logClient.log.bind(logClient);if(persistent)SessionStorage.set('logging_enabled',true);}else if(typeof logger_==='function'){logger=logger_;}else{logger=null;SessionStorage.remove('logging_enabled');}};/**
 *
 * @param {...(string|Arguments)} var_args
 */var log=function(){var var_args=[];for(var _i=0;_i<arguments.length;_i++){var_args[_i]=arguments[_i];}if(firstLog_===true){firstLog_=false;if(logger===null&&SessionStorage.get('logging_enabled')===true)enableLogging(true);}if(logger){var message=buildLogMessage_.apply(null,var_args);logger(message);}};/**
 * @param {!string} prefix
 * @return {function(...[*])}
 */var logWrapper=function(prefix){return function(){var var_args=[];for(var _i=0;_i<arguments.length;_i++){var_args[_i]=arguments[_i];}log.apply(void 0,[prefix].concat(var_args));};};/**
 * @param {...string} var_args
 */var error=function(){var var_args=[];for(var _i=0;_i<arguments.length;_i++){var_args[_i]=arguments[_i];}var message='FIREBASE INTERNAL ERROR: '+buildLogMessage_.apply(void 0,var_args);logClient.error(message);};/**
 * @param {...string} var_args
 */var fatal=function(){var var_args=[];for(var _i=0;_i<arguments.length;_i++){var_args[_i]=arguments[_i];}var message="FIREBASE FATAL ERROR: "+buildLogMessage_.apply(void 0,var_args);logClient.error(message);throw new Error(message);};/**
 * @param {...*} var_args
 */var warn=function(){var var_args=[];for(var _i=0;_i<arguments.length;_i++){var_args[_i]=arguments[_i];}var message='FIREBASE WARNING: '+buildLogMessage_.apply(void 0,var_args);logClient.warn(message);};/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */var warnIfPageIsSecure=function(){// Be very careful accessing browser globals. Who knows what may or may not exist.
if(typeof window!=='undefined'&&window.location&&window.location.protocol&&window.location.protocol.indexOf('https:')!==-1){warn('Insecure Firebase access from a secure page. '+'Please use https in calls to new Firebase().');}};/**
 * Returns true if data is NaN, or +/- Infinity.
 * @param {*} data
 * @return {boolean}
 */var isInvalidJSONNumber=function(data){return typeof data==='number'&&(data!=data||// NaN
data==Number.POSITIVE_INFINITY||data==Number.NEGATIVE_INFINITY);};/**
 * @param {function()} fn
 */var executeWhenDOMReady=function(fn){if(util.isNodeSdk()||document.readyState==='complete'){fn();}else{// Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
// fire before onload), but fall back to onload.
var called_1=false;var wrappedFn_1=function(){if(!document.body){setTimeout(wrappedFn_1,Math.floor(10));return;}if(!called_1){called_1=true;fn();}};if(document.addEventListener){document.addEventListener('DOMContentLoaded',wrappedFn_1,false);// fallback to onload.
window.addEventListener('load',wrappedFn_1,false);}else if(document.attachEvent){// IE.
document.attachEvent('onreadystatechange',function(){if(document.readyState==='complete')wrappedFn_1();});// fallback to onload.
window.attachEvent('onload',wrappedFn_1);// jQuery has an extra hack for IE that we could employ (based on
// http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
// I'm hoping we don't need it.
}}};/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 * @type {!string}
 */var MIN_NAME='[MIN_NAME]';/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 * @type {!string}
 */var MAX_NAME='[MAX_NAME]';/**
 * Compares valid Firebase key names, plus min and max name
 * @param {!string} a
 * @param {!string} b
 * @return {!number}
 */var nameCompare=function(a,b){if(a===b){return 0;}else if(a===MIN_NAME||b===MAX_NAME){return-1;}else if(b===MIN_NAME||a===MAX_NAME){return 1;}else{var aAsInt=tryParseInt(a),bAsInt=tryParseInt(b);if(aAsInt!==null){if(bAsInt!==null){return aAsInt-bAsInt==0?a.length-b.length:aAsInt-bAsInt;}else{return-1;}}else if(bAsInt!==null){return 1;}else{return a<b?-1:1;}}};/**
 * @param {!string} a
 * @param {!string} b
 * @return {!number} comparison result.
 */var stringCompare=function(a,b){if(a===b){return 0;}else if(a<b){return-1;}else{return 1;}};/**
 * @param {string} key
 * @param {Object} obj
 * @return {*}
 */var requireKey=function(key,obj){if(obj&&key in obj){return obj[key];}else{throw new Error('Missing required key ('+key+') in object: '+util.stringify(obj));}};/**
 * @param {*} obj
 * @return {string}
 */var ObjectToUniqueKey=function(obj){if(typeof obj!=='object'||obj===null)return util.stringify(obj);var keys=[];for(var k in obj){keys.push(k);}// Export as json, but with the keys sorted.
keys.sort();var key='{';for(var i=0;i<keys.length;i++){if(i!==0)key+=',';key+=util.stringify(keys[i]);key+=':';key+=ObjectToUniqueKey(obj[keys[i]]);}key+='}';return key;};/**
 * Splits a string into a number of smaller segments of maximum size
 * @param {!string} str The string
 * @param {!number} segsize The maximum number of chars in the string.
 * @return {Array.<string>} The string, split into appropriately-sized chunks
 */var splitStringBySize=function(str,segsize){var len=str.length;if(len<=segsize){return[str];}var dataSegs=[];for(var c=0;c<len;c+=segsize){if(c+segsize>len){dataSegs.push(str.substring(c,len));}else{dataSegs.push(str.substring(c,c+segsize));}}return dataSegs;};/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param {!(Object|Array)} obj The object or array to iterate over
 * @param {function(?, ?)} fn The function to apply
 */var each=function(obj,fn){if(Array.isArray(obj)){for(var i=0;i<obj.length;++i){fn(i,obj[i]);}}else{/**
         * in the conversion of code we removed the goog.object.forEach
         * function which did a value,key callback. We standardized on
         * a single impl that does a key, value callback. So we invert
         * to not have to touch the `each` code points
         */util.forEach(obj,function(key,val){return fn(val,key);});}};/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param {!number} v A double
 * @return {string}
 */var doubleToIEEE754String=function(v){util.assert(!isInvalidJSONNumber(v),'Invalid JSON number');// MJL
var ebits=11,fbits=52;var bias=(1<<ebits-1)-1,s,e,f,ln,i,bits,str;// Compute sign, exponent, fraction
// Skip NaN / Infinity handling --MJL.
if(v===0){e=0;f=0;s=1/v===-Infinity?1:0;}else{s=v<0;v=Math.abs(v);if(v>=Math.pow(2,1-bias)){// Normalized
ln=Math.min(Math.floor(Math.log(v)/Math.LN2),bias);e=ln+bias;f=Math.round(v*Math.pow(2,fbits-ln)-Math.pow(2,fbits));}else{// Denormalized
e=0;f=Math.round(v/Math.pow(2,1-bias-fbits));}}// Pack sign, exponent, fraction
bits=[];for(i=fbits;i;i-=1){bits.push(f%2?1:0);f=Math.floor(f/2);}for(i=ebits;i;i-=1){bits.push(e%2?1:0);e=Math.floor(e/2);}bits.push(s?1:0);bits.reverse();str=bits.join('');// Return the data as a hex string. --MJL
var hexByteString='';for(i=0;i<64;i+=8){var hexByte=parseInt(str.substr(i,8),2).toString(16);if(hexByte.length===1)hexByte='0'+hexByte;hexByteString=hexByteString+hexByte;}return hexByteString.toLowerCase();};/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 * @return {boolean}
 */var isChromeExtensionContentScript=function(){return!!(typeof window==='object'&&window['chrome']&&window['chrome']['extension']&&!/^chrome/.test(window.location.href));};/**
 * Used to detect if we're in a Windows 8 Store app.
 * @return {boolean}
 */var isWindowsStoreApp=function(){// Check for the presence of a couple WinRT globals
return typeof Windows==='object'&&typeof Windows.UI==='object';};/**
 * Converts a server error code to a Javascript Error
 * @param {!string} code
 * @param {!Query} query
 * @return {Error}
 */var errorForServerCode=function(code,query){var reason='Unknown Error';if(code==='too_big'){reason='The data requested exceeds the maximum size '+'that can be accessed with a single request.';}else if(code=='permission_denied'){reason="Client doesn't have permission to access the desired data.";}else if(code=='unavailable'){reason='The service is unavailable';}var error=new Error(code+' at '+query.path.toString()+': '+reason);error.code=code.toUpperCase();return error;};/**
 * Used to test for integer-looking strings
 * @type {RegExp}
 * @private
 */var INTEGER_REGEXP_=new RegExp('^-?\\d{1,10}$');/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 * @param {!string} str
 * @return {?number}
 */var tryParseInt=function(str){if(INTEGER_REGEXP_.test(str)){var intVal=Number(str);if(intVal>=-2147483648&&intVal<=2147483647){return intVal;}}return null;};/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param {!function()} fn The code to guard.
 */var exceptionGuard=function(fn){try{fn();}catch(e){// Re-throw exception when it's safe.
setTimeout(function(){// It used to be that "throw e" would result in a good console error with
// relevant context, but as of Chrome 39, you just get the firebase.js
// file/line number where we re-throw it, which is useless. So we log
// e.stack explicitly.
var stack=e.stack||'';warn('Exception was thrown by user callback.',stack);throw e;},Math.floor(0));}};/**
 * @return {boolean} true if we think we're currently being crawled.
 */var beingCrawled=function(){var userAgent=typeof window==='object'&&window['navigator']&&window['navigator']['userAgent']||'';// For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
// believe to support JavaScript/AJAX rendering.
// NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
// would have seen the page" is flaky if we don't treat it as a crawler.
return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i)>=0;};/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param {Function} fn Function to run.
 * @param {number} time Milliseconds to wait before running.
 * @return {number|Object} The setTimeout() return value.
 */var setTimeoutNonBlocking=function(fn,time){var timeout=setTimeout(fn,time);if(typeof timeout==='object'&&timeout['unref']){timeout['unref']();}return timeout;};/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An immutable object representing a parsed path.  It's immutable so that you
 * can pass them around to other functions without worrying about them changing
 * it.
 */var Path=/** @class */function(){/**
     * @param {string|Array.<string>} pathOrString Path string to parse,
     *      or another path, or the raw tokens array
     * @param {number=} pieceNum
     */function Path(pathOrString,pieceNum){if(pieceNum===void 0){this.pieces_=pathOrString.split('/');// Remove empty pieces.
var copyTo=0;for(var i=0;i<this.pieces_.length;i++){if(this.pieces_[i].length>0){this.pieces_[copyTo]=this.pieces_[i];copyTo++;}}this.pieces_.length=copyTo;this.pieceNum_=0;}else{this.pieces_=pathOrString;this.pieceNum_=pieceNum;}}Object.defineProperty(Path,"Empty",{/**
         * Singleton to represent an empty path
         *
         * @const
         */get:function(){return new Path('');},enumerable:true,configurable:true});Path.prototype.getFront=function(){if(this.pieceNum_>=this.pieces_.length)return null;return this.pieces_[this.pieceNum_];};/**
     * @return {number} The number of segments in this path
     */Path.prototype.getLength=function(){return this.pieces_.length-this.pieceNum_;};/**
     * @return {!Path}
     */Path.prototype.popFront=function(){var pieceNum=this.pieceNum_;if(pieceNum<this.pieces_.length){pieceNum++;}return new Path(this.pieces_,pieceNum);};/**
     * @return {?string}
     */Path.prototype.getBack=function(){if(this.pieceNum_<this.pieces_.length)return this.pieces_[this.pieces_.length-1];return null;};Path.prototype.toString=function(){var pathString='';for(var i=this.pieceNum_;i<this.pieces_.length;i++){if(this.pieces_[i]!=='')pathString+='/'+this.pieces_[i];}return pathString||'/';};Path.prototype.toUrlEncodedString=function(){var pathString='';for(var i=this.pieceNum_;i<this.pieces_.length;i++){if(this.pieces_[i]!=='')pathString+='/'+encodeURIComponent(String(this.pieces_[i]));}return pathString||'/';};/**
     * Shallow copy of the parts of the path.
     *
     * @param {number=} begin
     * @return {!Array<string>}
     */Path.prototype.slice=function(begin){if(begin===void 0){begin=0;}return this.pieces_.slice(this.pieceNum_+begin);};/**
     * @return {?Path}
     */Path.prototype.parent=function(){if(this.pieceNum_>=this.pieces_.length)return null;var pieces=[];for(var i=this.pieceNum_;i<this.pieces_.length-1;i++)pieces.push(this.pieces_[i]);return new Path(pieces,0);};/**
     * @param {string|!Path} childPathObj
     * @return {!Path}
     */Path.prototype.child=function(childPathObj){var pieces=[];for(var i=this.pieceNum_;i<this.pieces_.length;i++)pieces.push(this.pieces_[i]);if(childPathObj instanceof Path){for(var i=childPathObj.pieceNum_;i<childPathObj.pieces_.length;i++){pieces.push(childPathObj.pieces_[i]);}}else{var childPieces=childPathObj.split('/');for(var i=0;i<childPieces.length;i++){if(childPieces[i].length>0)pieces.push(childPieces[i]);}}return new Path(pieces,0);};/**
     * @return {boolean} True if there are no segments in this path
     */Path.prototype.isEmpty=function(){return this.pieceNum_>=this.pieces_.length;};/**
     * @param {!Path} outerPath
     * @param {!Path} innerPath
     * @return {!Path} The path from outerPath to innerPath
     */Path.relativePath=function(outerPath,innerPath){var outer=outerPath.getFront(),inner=innerPath.getFront();if(outer===null){return innerPath;}else if(outer===inner){return Path.relativePath(outerPath.popFront(),innerPath.popFront());}else{throw new Error('INTERNAL ERROR: innerPath ('+innerPath+') is not within '+'outerPath ('+outerPath+')');}};/**
     * @param {!Path} left
     * @param {!Path} right
     * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.
     */Path.comparePaths=function(left,right){var leftKeys=left.slice();var rightKeys=right.slice();for(var i=0;i<leftKeys.length&&i<rightKeys.length;i++){var cmp=nameCompare(leftKeys[i],rightKeys[i]);if(cmp!==0)return cmp;}if(leftKeys.length===rightKeys.length)return 0;return leftKeys.length<rightKeys.length?-1:1;};/**
     *
     * @param {Path} other
     * @return {boolean} true if paths are the same.
     */Path.prototype.equals=function(other){if(this.getLength()!==other.getLength()){return false;}for(var i=this.pieceNum_,j=other.pieceNum_;i<=this.pieces_.length;i++,j++){if(this.pieces_[i]!==other.pieces_[j]){return false;}}return true;};/**
     *
     * @param {!Path} other
     * @return {boolean} True if this path is a parent (or the same as) other
     */Path.prototype.contains=function(other){var i=this.pieceNum_;var j=other.pieceNum_;if(this.getLength()>other.getLength()){return false;}while(i<this.pieces_.length){if(this.pieces_[i]!==other.pieces_[j]){return false;}++i;++j;}return true;};return Path;}();// end Path
/**
 * Dynamic (mutable) path used to count path lengths.
 *
 * This class is used to efficiently check paths for valid
 * length (in UTF8 bytes) and depth (used in path validation).
 *
 * Throws Error exception if path is ever invalid.
 *
 * The definition of a path always begins with '/'.
 */var ValidationPath=/** @class */function(){/**
     * @param {!Path} path Initial Path.
     * @param {string} errorPrefix_ Prefix for any error messages.
     */function ValidationPath(path,errorPrefix_){this.errorPrefix_=errorPrefix_;/** @type {!Array<string>} */this.parts_=path.slice();/** @type {number} Initialize to number of '/' chars needed in path. */this.byteLength_=Math.max(1,this.parts_.length);for(var i=0;i<this.parts_.length;i++){this.byteLength_+=util.stringLength(this.parts_[i]);}this.checkValid_();}Object.defineProperty(ValidationPath,"MAX_PATH_DEPTH",{/** @const {number} Maximum key depth. */get:function(){return 32;},enumerable:true,configurable:true});Object.defineProperty(ValidationPath,"MAX_PATH_LENGTH_BYTES",{/** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */get:function(){return 768;},enumerable:true,configurable:true});/** @param {string} child */ValidationPath.prototype.push=function(child){// Count the needed '/'
if(this.parts_.length>0){this.byteLength_+=1;}this.parts_.push(child);this.byteLength_+=util.stringLength(child);this.checkValid_();};ValidationPath.prototype.pop=function(){var last=this.parts_.pop();this.byteLength_-=util.stringLength(last);// Un-count the previous '/'
if(this.parts_.length>0){this.byteLength_-=1;}};ValidationPath.prototype.checkValid_=function(){if(this.byteLength_>ValidationPath.MAX_PATH_LENGTH_BYTES){throw new Error(this.errorPrefix_+'has a key path longer than '+ValidationPath.MAX_PATH_LENGTH_BYTES+' bytes ('+this.byteLength_+').');}if(this.parts_.length>ValidationPath.MAX_PATH_DEPTH){throw new Error(this.errorPrefix_+'path specified exceeds the maximum depth that can be written ('+ValidationPath.MAX_PATH_DEPTH+') or object contains a cycle '+this.toErrorString());}};/**
     * String for use in error messages - uses '.' notation for path.
     *
     * @return {string}
     */ValidationPath.prototype.toErrorString=function(){if(this.parts_.length==0){return'';}return"in property '"+this.parts_.join('.')+"'";};return ValidationPath;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var PROTOCOL_VERSION='5';var VERSION_PARAM='v';var TRANSPORT_SESSION_PARAM='s';var REFERER_PARAM='r';var FORGE_REF='f';var FORGE_DOMAIN='firebaseio.com';var LAST_SESSION_PARAM='ls';var WEBSOCKET='websocket';var LONG_POLLING='long_polling';/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A class that holds metadata about a Repo object
 *
 * @constructor
 */var RepoInfo=/** @class */function(){/**
     * @param {string} host Hostname portion of the url for the repo
     * @param {boolean} secure Whether or not this repo is accessed over ssl
     * @param {string} namespace The namespace represented by the repo
     * @param {boolean} webSocketOnly Whether to prefer websockets over all other transports (used by Nest).
     * @param {string=} persistenceKey Override the default session persistence storage key
     */function RepoInfo(host,secure,namespace,webSocketOnly,persistenceKey){if(persistenceKey===void 0){persistenceKey='';}this.secure=secure;this.namespace=namespace;this.webSocketOnly=webSocketOnly;this.persistenceKey=persistenceKey;this.host=host.toLowerCase();this.domain=this.host.substr(this.host.indexOf('.')+1);this.internalHost=PersistentStorage.get('host:'+host)||this.host;}RepoInfo.prototype.needsQueryParam=function(){return this.host!==this.internalHost||this.isCustomHost();};RepoInfo.prototype.isCacheableHost=function(){return this.internalHost.substr(0,2)==='s-';};RepoInfo.prototype.isDemoHost=function(){return this.domain==='firebaseio-demo.com';};RepoInfo.prototype.isCustomHost=function(){return this.domain!=='firebaseio.com'&&this.domain!=='firebaseio-demo.com';};RepoInfo.prototype.updateHost=function(newHost){if(newHost!==this.internalHost){this.internalHost=newHost;if(this.isCacheableHost()){PersistentStorage.set('host:'+this.host,this.internalHost);}}};/**
     * Returns the websocket URL for this repo
     * @param {string} type of connection
     * @param {Object} params list
     * @return {string} The URL for this repo
     */RepoInfo.prototype.connectionURL=function(type,params){util.assert(typeof type==='string','typeof type must == string');util.assert(typeof params==='object','typeof params must == object');var connURL;if(type===WEBSOCKET){connURL=(this.secure?'wss://':'ws://')+this.internalHost+'/.ws?';}else if(type===LONG_POLLING){connURL=(this.secure?'https://':'http://')+this.internalHost+'/.lp?';}else{throw new Error('Unknown connection type: '+type);}if(this.needsQueryParam()){params['ns']=this.namespace;}var pairs=[];util.forEach(params,function(key,value){pairs.push(key+'='+value);});return connURL+pairs.join('&');};/** @return {string} */RepoInfo.prototype.toString=function(){var str=this.toURLString();if(this.persistenceKey){str+='<'+this.persistenceKey+'>';}return str;};/** @return {string} */RepoInfo.prototype.toURLString=function(){return(this.secure?'https://':'http://')+this.host;};return RepoInfo;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @param {!string} pathString
 * @return {string}
 */function decodePath(pathString){var pathStringDecoded='';var pieces=pathString.split('/');for(var i=0;i<pieces.length;i++){if(pieces[i].length>0){var piece=pieces[i];try{piece=decodeURIComponent(piece.replace(/\+/g,' '));}catch(e){}pathStringDecoded+='/'+piece;}}return pathStringDecoded;}/**
 * @param {!string} queryString
 * @return {!{[key:string]:string}} key value hash
 */function decodeQuery(queryString){var results={};if(queryString.charAt(0)==='?'){queryString=queryString.substring(1);}for(var _i=0,_a=queryString.split('&');_i<_a.length;_i++){var segment=_a[_i];if(segment.length===0){continue;}var kv=segment.split('=');if(kv.length===2){results[decodeURIComponent(kv[0])]=decodeURIComponent(kv[1]);}else{warn("Invalid query segment '"+segment+"' in query '"+queryString+"'");}}return results;}/**
 *
 * @param {!string} dataURL
 * @return {{repoInfo: !RepoInfo, path: !Path}}
 */var parseRepoInfo=function(dataURL){var parsedUrl=parseURL(dataURL),namespace=parsedUrl.subdomain;if(parsedUrl.domain==='firebase'){fatal(parsedUrl.host+' is no longer supported. '+'Please use <YOUR FIREBASE>.firebaseio.com instead');}// Catch common error of uninitialized namespace value.
if((!namespace||namespace=='undefined')&&parsedUrl.domain!=='localhost'){fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');}if(!parsedUrl.secure){warnIfPageIsSecure();}var webSocketOnly=parsedUrl.scheme==='ws'||parsedUrl.scheme==='wss';return{repoInfo:new RepoInfo(parsedUrl.host,parsedUrl.secure,namespace,webSocketOnly),path:new Path(parsedUrl.pathString)};};/**
 *
 * @param {!string} dataURL
 * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}
 */var parseURL=function(dataURL){// Default to empty strings in the event of a malformed string.
var host='',domain='',subdomain='',pathString='';// Always default to SSL, unless otherwise specified.
var secure=true,scheme='https',port=443;// Don't do any validation here. The caller is responsible for validating the result of parsing.
if(typeof dataURL==='string'){// Parse scheme.
var colonInd=dataURL.indexOf('//');if(colonInd>=0){scheme=dataURL.substring(0,colonInd-1);dataURL=dataURL.substring(colonInd+2);}// Parse host, path, and query string.
var slashInd=dataURL.indexOf('/');if(slashInd===-1){slashInd=dataURL.length;}var questionMarkInd=dataURL.indexOf('?');if(questionMarkInd===-1){questionMarkInd=dataURL.length;}host=dataURL.substring(0,Math.min(slashInd,questionMarkInd));if(slashInd<questionMarkInd){// For pathString, questionMarkInd will always come after slashInd
pathString=decodePath(dataURL.substring(slashInd,questionMarkInd));}var queryParams=decodeQuery(dataURL.substring(Math.min(dataURL.length,questionMarkInd)));// If we have a port, use scheme for determining if it's secure.
colonInd=host.indexOf(':');if(colonInd>=0){secure=scheme==='https'||scheme==='wss';port=parseInt(host.substring(colonInd+1),10);}else{colonInd=dataURL.length;}var parts=host.split('.');if(parts.length===3){// Normalize namespaces to lowercase to share storage / connection.
domain=parts[1];subdomain=parts[0].toLowerCase();}else if(parts.length===2){domain=parts[0];}else if(parts[0].slice(0,colonInd).toLowerCase()==='localhost'){domain='localhost';}// Support `ns` query param if subdomain not already set
if(subdomain===''&&'ns'in queryParams){subdomain=queryParams['ns'];}}return{host:host,port:port,domain:domain,subdomain:subdomain,secure:secure,scheme:scheme,pathString:pathString};};/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * True for invalid Firebase keys
 * @type {RegExp}
 * @private
 */var INVALID_KEY_REGEX_=/[\[\].#$\/\u0000-\u001F\u007F]/;/**
 * True for invalid Firebase paths.
 * Allows '/' in paths.
 * @type {RegExp}
 * @private
 */var INVALID_PATH_REGEX_=/[\[\].#$\u0000-\u001F\u007F]/;/**
 * Maximum number of characters to allow in leaf value
 * @type {number}
 * @private
 */var MAX_LEAF_SIZE_=10*1024*1024;/**
 * @param {*} key
 * @return {boolean}
 */var isValidKey=function(key){return typeof key==='string'&&key.length!==0&&!INVALID_KEY_REGEX_.test(key);};/**
 * @param {string} pathString
 * @return {boolean}
 */var isValidPathString=function(pathString){return typeof pathString==='string'&&pathString.length!==0&&!INVALID_PATH_REGEX_.test(pathString);};/**
 * @param {string} pathString
 * @return {boolean}
 */var isValidRootPathString=function(pathString){if(pathString){// Allow '/.info/' at the beginning.
pathString=pathString.replace(/^\/*\.info(\/|$)/,'/');}return isValidPathString(pathString);};/**
 * @param {*} priority
 * @return {boolean}
 */var isValidPriority=function(priority){return priority===null||typeof priority==='string'||typeof priority==='number'&&!isInvalidJSONNumber(priority)||priority&&typeof priority==='object'&&util.contains(priority,'.sv');};/**
 * Pre-validate a datum passed as an argument to Firebase function.
 *
 * @param {string} fnName
 * @param {number} argumentNumber
 * @param {*} data
 * @param {!Path} path
 * @param {boolean} optional
 */var validateFirebaseDataArg=function(fnName,argumentNumber,data,path,optional){if(optional&&data===undefined)return;validateFirebaseData(util.errorPrefix(fnName,argumentNumber,optional),data,path);};/**
 * Validate a data object client-side before sending to server.
 *
 * @param {string} errorPrefix
 * @param {*} data
 * @param {!Path|!ValidationPath} path_
 */var validateFirebaseData=function(errorPrefix,data,path_){var path=path_ instanceof Path?new ValidationPath(path_,errorPrefix):path_;if(data===undefined){throw new Error(errorPrefix+'contains undefined '+path.toErrorString());}if(typeof data==='function'){throw new Error(errorPrefix+'contains a function '+path.toErrorString()+' with contents = '+data.toString());}if(isInvalidJSONNumber(data)){throw new Error(errorPrefix+'contains '+data.toString()+' '+path.toErrorString());}// Check max leaf size, but try to avoid the utf8 conversion if we can.
if(typeof data==='string'&&data.length>MAX_LEAF_SIZE_/3&&util.stringLength(data)>MAX_LEAF_SIZE_){throw new Error(errorPrefix+'contains a string greater than '+MAX_LEAF_SIZE_+' utf8 bytes '+path.toErrorString()+" ('"+data.substring(0,50)+"...')");}// TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON
// to save extra walking of large objects.
if(data&&typeof data==='object'){var hasDotValue_1=false,hasActualChild_1=false;util.forEach(data,function(key,value){if(key==='.value'){hasDotValue_1=true;}else if(key!=='.priority'&&key!=='.sv'){hasActualChild_1=true;if(!isValidKey(key)){throw new Error(errorPrefix+' contains an invalid key ('+key+') '+path.toErrorString()+'.  Keys must be non-empty strings '+'and can\'t contain ".", "#", "$", "/", "[", or "]"');}}path.push(key);validateFirebaseData(errorPrefix,value,path);path.pop();});if(hasDotValue_1&&hasActualChild_1){throw new Error(errorPrefix+' contains ".value" child '+path.toErrorString()+' in addition to actual children.');}}};/**
 * Pre-validate paths passed in the firebase function.
 *
 * @param {string} errorPrefix
 * @param {Array<!Path>} mergePaths
 */var validateFirebaseMergePaths=function(errorPrefix,mergePaths){var i,curPath;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];var keys=curPath.slice();for(var j=0;j<keys.length;j++){if(keys[j]==='.priority'&&j===keys.length-1);else if(!isValidKey(keys[j])){throw new Error(errorPrefix+'contains an invalid key ('+keys[j]+') in path '+curPath.toString()+'. Keys must be non-empty strings '+'and can\'t contain ".", "#", "$", "/", "[", or "]"');}}}// Check that update keys are not descendants of each other.
// We rely on the property that sorting guarantees that ancestors come
// right before descendants.
mergePaths.sort(Path.comparePaths);var prevPath=null;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];if(prevPath!==null&&prevPath.contains(curPath)){throw new Error(errorPrefix+'contains a path '+prevPath.toString()+' that is ancestor of another path '+curPath.toString());}prevPath=curPath;}};/**
 * pre-validate an object passed as an argument to firebase function (
 * must be an object - e.g. for firebase.update()).
 *
 * @param {string} fnName
 * @param {number} argumentNumber
 * @param {*} data
 * @param {!Path} path
 * @param {boolean} optional
 */var validateFirebaseMergeDataArg=function(fnName,argumentNumber,data,path,optional){if(optional&&data===undefined)return;var errorPrefix=util.errorPrefix(fnName,argumentNumber,optional);if(!(data&&typeof data==='object')||Array.isArray(data)){throw new Error(errorPrefix+' must be an object containing the children to replace.');}var mergePaths=[];util.forEach(data,function(key,value){var curPath=new Path(key);validateFirebaseData(errorPrefix,value,path.child(curPath));if(curPath.getBack()==='.priority'){if(!isValidPriority(value)){throw new Error(errorPrefix+"contains an invalid value for '"+curPath.toString()+"', which must be a valid "+'Firebase priority (a string, finite number, server value, or null).');}}mergePaths.push(curPath);});validateFirebaseMergePaths(errorPrefix,mergePaths);};var validatePriority=function(fnName,argumentNumber,priority,optional){if(optional&&priority===undefined)return;if(isInvalidJSONNumber(priority))throw new Error(util.errorPrefix(fnName,argumentNumber,optional)+'is '+priority.toString()+', but must be a valid Firebase priority (a string, finite number, '+'server value, or null).');// Special case to allow importing data with a .sv.
if(!isValidPriority(priority))throw new Error(util.errorPrefix(fnName,argumentNumber,optional)+'must be a valid Firebase priority '+'(a string, finite number, server value, or null).');};var validateEventType=function(fnName,argumentNumber,eventType,optional){if(optional&&eventType===undefined)return;switch(eventType){case'value':case'child_added':case'child_removed':case'child_changed':case'child_moved':break;default:throw new Error(util.errorPrefix(fnName,argumentNumber,optional)+'must be a valid event type = "value", "child_added", "child_removed", '+'"child_changed", or "child_moved".');}};var validateKey=function(fnName,argumentNumber,key,optional){if(optional&&key===undefined)return;if(!isValidKey(key))throw new Error(util.errorPrefix(fnName,argumentNumber,optional)+'was an invalid key = "'+key+'".  Firebase keys must be non-empty strings and '+'can\'t contain ".", "#", "$", "/", "[", or "]").');};var validatePathString=function(fnName,argumentNumber,pathString,optional){if(optional&&pathString===undefined)return;if(!isValidPathString(pathString))throw new Error(util.errorPrefix(fnName,argumentNumber,optional)+'was an invalid path = "'+pathString+'". Paths must be non-empty strings and '+'can\'t contain ".", "#", "$", "[", or "]"');};var validateRootPathString=function(fnName,argumentNumber,pathString,optional){if(pathString){// Allow '/.info/' at the beginning.
pathString=pathString.replace(/^\/*\.info(\/|$)/,'/');}validatePathString(fnName,argumentNumber,pathString,optional);};var validateWritablePath=function(fnName,path){if(path.getFront()==='.info'){throw new Error(fnName+" failed = Can't modify data under /.info/");}};var validateUrl=function(fnName,argumentNumber,parsedUrl){// TODO = Validate server better.
var pathString=parsedUrl.path.toString();if(!(typeof parsedUrl.repoInfo.host==='string')||parsedUrl.repoInfo.host.length===0||!isValidKey(parsedUrl.repoInfo.namespace)&&parsedUrl.repoInfo.host.split(':')[0]!=='localhost'||pathString.length!==0&&!isValidRootPathString(pathString)){throw new Error(util.errorPrefix(fnName,argumentNumber,false)+'must be a valid firebase URL and '+'the path can\'t contain ".", "#", "$", "[", or "]".');}};var validateBoolean=function(fnName,argumentNumber,bool,optional){if(optional&&bool===undefined)return;if(typeof bool!=='boolean')throw new Error(util.errorPrefix(fnName,argumentNumber,optional)+'must be a boolean.');};/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @constructor
 */var OnDisconnect=/** @class */function(){/**
     * @param {!Repo} repo_
     * @param {!Path} path_
     */function OnDisconnect(repo_,path_){this.repo_=repo_;this.path_=path_;}/**
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */OnDisconnect.prototype.cancel=function(onComplete){util.validateArgCount('OnDisconnect.cancel',0,1,arguments.length);util.validateCallback('OnDisconnect.cancel',1,onComplete,true);var deferred=new util.Deferred();this.repo_.onDisconnectCancel(this.path_,deferred.wrapCallback(onComplete));return deferred.promise;};/**
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */OnDisconnect.prototype.remove=function(onComplete){util.validateArgCount('OnDisconnect.remove',0,1,arguments.length);validateWritablePath('OnDisconnect.remove',this.path_);util.validateCallback('OnDisconnect.remove',1,onComplete,true);var deferred=new util.Deferred();this.repo_.onDisconnectSet(this.path_,null,deferred.wrapCallback(onComplete));return deferred.promise;};/**
     * @param {*} value
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */OnDisconnect.prototype.set=function(value,onComplete){util.validateArgCount('OnDisconnect.set',1,2,arguments.length);validateWritablePath('OnDisconnect.set',this.path_);validateFirebaseDataArg('OnDisconnect.set',1,value,this.path_,false);util.validateCallback('OnDisconnect.set',2,onComplete,true);var deferred=new util.Deferred();this.repo_.onDisconnectSet(this.path_,value,deferred.wrapCallback(onComplete));return deferred.promise;};/**
     * @param {*} value
     * @param {number|string|null} priority
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */OnDisconnect.prototype.setWithPriority=function(value,priority,onComplete){util.validateArgCount('OnDisconnect.setWithPriority',2,3,arguments.length);validateWritablePath('OnDisconnect.setWithPriority',this.path_);validateFirebaseDataArg('OnDisconnect.setWithPriority',1,value,this.path_,false);validatePriority('OnDisconnect.setWithPriority',2,priority,false);util.validateCallback('OnDisconnect.setWithPriority',3,onComplete,true);var deferred=new util.Deferred();this.repo_.onDisconnectSetWithPriority(this.path_,value,priority,deferred.wrapCallback(onComplete));return deferred.promise;};/**
     * @param {!Object} objectToMerge
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */OnDisconnect.prototype.update=function(objectToMerge,onComplete){util.validateArgCount('OnDisconnect.update',1,2,arguments.length);validateWritablePath('OnDisconnect.update',this.path_);if(Array.isArray(objectToMerge)){var newObjectToMerge={};for(var i=0;i<objectToMerge.length;++i){newObjectToMerge[''+i]=objectToMerge[i];}objectToMerge=newObjectToMerge;warn('Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the '+'existing data, or an Object with integer keys if you really do want to only update some of the children.');}validateFirebaseMergeDataArg('OnDisconnect.update',1,objectToMerge,this.path_,false);util.validateCallback('OnDisconnect.update',2,onComplete,true);var deferred=new util.Deferred();this.repo_.onDisconnectUpdate(this.path_,objectToMerge,deferred.wrapCallback(onComplete));return deferred.promise;};return OnDisconnect;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var TransactionResult=/** @class */function(){/**
     * A type for the resolve value of Firebase.transaction.
     * @constructor
     * @dict
     * @param {boolean} committed
     * @param {DataSnapshot} snapshot
     */function TransactionResult(committed,snapshot){this.committed=committed;this.snapshot=snapshot;}// Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
// for end-users
TransactionResult.prototype.toJSON=function(){util.validateArgCount('TransactionResult.toJSON',0,1,arguments.length);return{committed:this.committed,snapshot:this.snapshot.toJSON()};};return TransactionResult;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Fancy ID generator that creates 20-character string identifiers with the
 * following properties:
 *
 * 1. They're based on timestamp so that they sort *after* any existing ids.
 * 2. They contain 72-bits of random data after the timestamp so that IDs won't
 *    collide with other clients' IDs.
 * 3. They sort *lexicographically* (so the timestamp is converted to characters
 *    that will sort properly).
 * 4. They're monotonically increasing. Even if you generate more than one in
 *    the same timestamp, the latter ones will sort after the former ones. We do
 *    this by using the previous random bits but "incrementing" them by 1 (only
 *    in the case of a timestamp collision).
 */var nextPushId=function(){// Modeled after base64 web-safe chars, but ordered by ASCII.
var PUSH_CHARS='-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';// Timestamp of last push, used to prevent local collisions if you push twice
// in one ms.
var lastPushTime=0;// We generate 72-bits of randomness which get turned into 12 characters and
// appended to the timestamp to prevent collisions with other clients. We
// store the last characters we generated because in the event of a collision,
// we'll use those same characters except "incremented" by one.
var lastRandChars=[];return function(now){var duplicateTime=now===lastPushTime;lastPushTime=now;var i;var timeStampChars=new Array(8);for(i=7;i>=0;i--){timeStampChars[i]=PUSH_CHARS.charAt(now%64);// NOTE: Can't use << here because javascript will convert to int and lose
// the upper bits.
now=Math.floor(now/64);}util.assert(now===0,'Cannot push at time == 0');var id=timeStampChars.join('');if(!duplicateTime){for(i=0;i<12;i++){lastRandChars[i]=Math.floor(Math.random()*64);}}else{// If the timestamp hasn't changed since last push, use the same random
// number, except incremented by 1.
for(i=11;i>=0&&lastRandChars[i]===63;i--){lastRandChars[i]=0;}lastRandChars[i]++;}for(i=0;i<12;i++){id+=PUSH_CHARS.charAt(lastRandChars[i]);}util.assert(id.length===20,'nextPushId: Length should be 20.');return id;};}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 *
 * @param {!string} name
 * @param {!Node} node
 * @constructor
 * @struct
 */var NamedNode=/** @class */function(){function NamedNode(name,node){this.name=name;this.node=node;}/**
     *
     * @param {!string} name
     * @param {!Node} node
     * @return {NamedNode}
     */NamedNode.Wrap=function(name,node){return new NamedNode(name,node);};return NamedNode;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 *
 * @constructor
 */var Index=/** @class */function(){function Index(){}/**
     * @return {function(!NamedNode, !NamedNode):number} A standalone comparison function for
     * this index
     */Index.prototype.getCompare=function(){return this.compare.bind(this);};/**
     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
     *
     * @param {!Node} oldNode
     * @param {!Node} newNode
     * @return {boolean} True if the portion of the snapshot being indexed changed between oldNode and newNode
     */Index.prototype.indexedValueChanged=function(oldNode,newNode){var oldWrapped=new NamedNode(MIN_NAME,oldNode);var newWrapped=new NamedNode(MIN_NAME,newNode);return this.compare(oldWrapped,newWrapped)!==0;};/**
     * @return {!NamedNode} a node wrapper that will sort equal to or less than
     * any other node wrapper, using this index
     */Index.prototype.minPost=function(){return NamedNode.MIN;};return Index;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __EMPTY_NODE;var KeyIndex=/** @class */function(_super){tslib_1.__extends(KeyIndex,_super);function KeyIndex(){return _super!==null&&_super.apply(this,arguments)||this;}Object.defineProperty(KeyIndex,"__EMPTY_NODE",{get:function(){return __EMPTY_NODE;},set:function(val){__EMPTY_NODE=val;},enumerable:true,configurable:true});/**
     * @inheritDoc
     */KeyIndex.prototype.compare=function(a,b){return nameCompare(a.name,b.name);};/**
     * @inheritDoc
     */KeyIndex.prototype.isDefinedOn=function(node){// We could probably return true here (since every node has a key), but it's never called
// so just leaving unimplemented for now.
throw util.assertionError('KeyIndex.isDefinedOn not expected to be called.');};/**
     * @inheritDoc
     */KeyIndex.prototype.indexedValueChanged=function(oldNode,newNode){return false;// The key for a node never changes.
};/**
     * @inheritDoc
     */KeyIndex.prototype.minPost=function(){return NamedNode.MIN;};/**
     * @inheritDoc
     */KeyIndex.prototype.maxPost=function(){// TODO: This should really be created once and cached in a static property, but
// NamedNode isn't defined yet, so I can't use it in a static.  Bleh.
return new NamedNode(MAX_NAME,__EMPTY_NODE);};/**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */KeyIndex.prototype.makePost=function(indexValue,name){util.assert(typeof indexValue==='string','KeyIndex indexValue must always be a string.');// We just use empty node, but it'll never be compared, since our comparator only looks at name.
return new NamedNode(indexValue,__EMPTY_NODE);};/**
     * @return {!string} String representation for inclusion in a query spec
     */KeyIndex.prototype.toString=function(){return'.key';};return KeyIndex;}(Index);var KEY_INDEX=new KeyIndex();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var MAX_NODE;function setMaxNode(val){MAX_NODE=val;}/**
 * @param {(!string|!number)} priority
 * @return {!string}
 */var priorityHashText=function(priority){if(typeof priority==='number')return'number:'+doubleToIEEE754String(priority);else return'string:'+priority;};/**
 * Validates that a priority snapshot Node is valid.
 *
 * @param {!Node} priorityNode
 */var validatePriorityNode=function(priorityNode){if(priorityNode.isLeafNode()){var val=priorityNode.val();util.assert(typeof val==='string'||typeof val==='number'||typeof val==='object'&&util.contains(val,'.sv'),'Priority must be a string or number.');}else{util.assert(priorityNode===MAX_NODE||priorityNode.isEmpty(),'priority of unexpected type.');}// Don't call getPriority() on MAX_NODE to avoid hitting assertion.
util.assert(priorityNode===MAX_NODE||priorityNode.getPriority().isEmpty(),"Priority nodes can't have a priority of their own.");};/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __childrenNodeConstructor;/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */var LeafNode=/** @class */function(){/**
     * @implements {Node}
     * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.
     *                                         The object type is possible in the event of a deferred value
     * @param {!Node=} priorityNode_ The priority of this node.
     */function LeafNode(value_,priorityNode_){if(priorityNode_===void 0){priorityNode_=LeafNode.__childrenNodeConstructor.EMPTY_NODE;}this.value_=value_;this.priorityNode_=priorityNode_;this.lazyHash_=null;util.assert(this.value_!==undefined&&this.value_!==null,"LeafNode shouldn't be created with null/undefined value.");validatePriorityNode(this.priorityNode_);}Object.defineProperty(LeafNode,"__childrenNodeConstructor",{get:function(){return __childrenNodeConstructor;},set:function(val){__childrenNodeConstructor=val;},enumerable:true,configurable:true});/** @inheritDoc */LeafNode.prototype.isLeafNode=function(){return true;};/** @inheritDoc */LeafNode.prototype.getPriority=function(){return this.priorityNode_;};/** @inheritDoc */LeafNode.prototype.updatePriority=function(newPriorityNode){return new LeafNode(this.value_,newPriorityNode);};/** @inheritDoc */LeafNode.prototype.getImmediateChild=function(childName){// Hack to treat priority as a regular child
if(childName==='.priority'){return this.priorityNode_;}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE;}};/** @inheritDoc */LeafNode.prototype.getChild=function(path){if(path.isEmpty()){return this;}else if(path.getFront()==='.priority'){return this.priorityNode_;}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE;}};/**
     * @inheritDoc
     */LeafNode.prototype.hasChild=function(){return false;};/** @inheritDoc */LeafNode.prototype.getPredecessorChildName=function(childName,childNode){return null;};/** @inheritDoc */LeafNode.prototype.updateImmediateChild=function(childName,newChildNode){if(childName==='.priority'){return this.updatePriority(newChildNode);}else if(newChildNode.isEmpty()&&childName!=='.priority'){return this;}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName,newChildNode).updatePriority(this.priorityNode_);}};/** @inheritDoc */LeafNode.prototype.updateChild=function(path,newChildNode){var front=path.getFront();if(front===null){return newChildNode;}else if(newChildNode.isEmpty()&&front!=='.priority'){return this;}else{util.assert(front!=='.priority'||path.getLength()===1,'.priority must be the last token in a path');return this.updateImmediateChild(front,LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(),newChildNode));}};/** @inheritDoc */LeafNode.prototype.isEmpty=function(){return false;};/** @inheritDoc */LeafNode.prototype.numChildren=function(){return 0;};/** @inheritDoc */LeafNode.prototype.forEachChild=function(index,action){return false;};/**
     * @inheritDoc
     */LeafNode.prototype.val=function(exportFormat){if(exportFormat&&!this.getPriority().isEmpty())return{'.value':this.getValue(),'.priority':this.getPriority().val()};else return this.getValue();};/** @inheritDoc */LeafNode.prototype.hash=function(){if(this.lazyHash_===null){var toHash='';if(!this.priorityNode_.isEmpty())toHash+='priority:'+priorityHashText(this.priorityNode_.val())+':';var type=typeof this.value_;toHash+=type+':';if(type==='number'){toHash+=doubleToIEEE754String(this.value_);}else{toHash+=this.value_;}this.lazyHash_=sha1(toHash);}return this.lazyHash_;};/**
     * Returns the value of the leaf node.
     * @return {Object|string|number|boolean} The value of the node.
     */LeafNode.prototype.getValue=function(){return this.value_;};/**
     * @inheritDoc
     */LeafNode.prototype.compareTo=function(other){if(other===LeafNode.__childrenNodeConstructor.EMPTY_NODE){return 1;}else if(other instanceof LeafNode.__childrenNodeConstructor){return-1;}else{util.assert(other.isLeafNode(),'Unknown node type');return this.compareToLeafNode_(other);}};/**
     * Comparison specifically for two leaf nodes
     * @param {!LeafNode} otherLeaf
     * @return {!number}
     * @private
     */LeafNode.prototype.compareToLeafNode_=function(otherLeaf){var otherLeafType=typeof otherLeaf.value_;var thisLeafType=typeof this.value_;var otherIndex=LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);var thisIndex=LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);util.assert(otherIndex>=0,'Unknown leaf type: '+otherLeafType);util.assert(thisIndex>=0,'Unknown leaf type: '+thisLeafType);if(otherIndex===thisIndex){// Same type, compare values
if(thisLeafType==='object'){// Deferred value nodes are all equal, but we should also never get to this point...
return 0;}else{// Note that this works because true > false, all others are number or string comparisons
if(this.value_<otherLeaf.value_){return-1;}else if(this.value_===otherLeaf.value_){return 0;}else{return 1;}}}else{return thisIndex-otherIndex;}};/**
     * @inheritDoc
     */LeafNode.prototype.withIndex=function(){return this;};/**
     * @inheritDoc
     */LeafNode.prototype.isIndexed=function(){return true;};/**
     * @inheritDoc
     */LeafNode.prototype.equals=function(other){/**
         * @inheritDoc
         */if(other===this){return true;}else if(other.isLeafNode()){var otherLeaf=other;return this.value_===otherLeaf.value_&&this.priorityNode_.equals(otherLeaf.priorityNode_);}else{return false;}};/**
     * The sort order for comparing leaf nodes of different types. If two leaf nodes have
     * the same type, the comparison falls back to their value
     * @type {Array.<!string>}
     * @const
     */LeafNode.VALUE_TYPE_ORDER=['object','boolean','number','string'];return LeafNode;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var nodeFromJSON;var MAX_NODE$1;function setNodeFromJSON(val){nodeFromJSON=val;}function setMaxNode$1(val){MAX_NODE$1=val;}/**
 * @constructor
 * @extends {Index}
 * @private
 */var PriorityIndex=/** @class */function(_super){tslib_1.__extends(PriorityIndex,_super);function PriorityIndex(){return _super!==null&&_super.apply(this,arguments)||this;}/**
     * @inheritDoc
     */PriorityIndex.prototype.compare=function(a,b){var aPriority=a.node.getPriority();var bPriority=b.node.getPriority();var indexCmp=aPriority.compareTo(bPriority);if(indexCmp===0){return nameCompare(a.name,b.name);}else{return indexCmp;}};/**
     * @inheritDoc
     */PriorityIndex.prototype.isDefinedOn=function(node){return!node.getPriority().isEmpty();};/**
     * @inheritDoc
     */PriorityIndex.prototype.indexedValueChanged=function(oldNode,newNode){return!oldNode.getPriority().equals(newNode.getPriority());};/**
     * @inheritDoc
     */PriorityIndex.prototype.minPost=function(){return NamedNode.MIN;};/**
     * @inheritDoc
     */PriorityIndex.prototype.maxPost=function(){return new NamedNode(MAX_NAME,new LeafNode('[PRIORITY-POST]',MAX_NODE$1));};/**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */PriorityIndex.prototype.makePost=function(indexValue,name){var priorityNode=nodeFromJSON(indexValue);return new NamedNode(name,new LeafNode('[PRIORITY-POST]',priorityNode));};/**
     * @return {!string} String representation for inclusion in a query spec
     */PriorityIndex.prototype.toString=function(){return'.priority';};return PriorityIndex;}(Index);var PRIORITY_INDEX=new PriorityIndex();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An iterator over an LLRBNode.
 */var SortedMapIterator=/** @class */function(){/**
     * @template K, V, T
     * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.
     * @param {?K} startKey
     * @param {function(K, K): number} comparator
     * @param {boolean} isReverse_ Whether or not to iterate in reverse
     * @param {(function(K, V):T)=} resultGenerator_
     */function SortedMapIterator(node,startKey,comparator,isReverse_,resultGenerator_){if(resultGenerator_===void 0){resultGenerator_=null;}this.isReverse_=isReverse_;this.resultGenerator_=resultGenerator_;/** @private
         * @type {Array.<!LLRBNode>}
         */this.nodeStack_=[];var cmp=1;while(!node.isEmpty()){node=node;cmp=startKey?comparator(node.key,startKey):1;// flip the comparison if we're going in reverse
if(isReverse_)cmp*=-1;if(cmp<0){// This node is less than our start key. ignore it
if(this.isReverse_){node=node.left;}else{node=node.right;}}else if(cmp===0){// This node is exactly equal to our start key. Push it on the stack, but stop iterating;
this.nodeStack_.push(node);break;}else{// This node is greater than our start key, add it to the stack and move to the next one
this.nodeStack_.push(node);if(this.isReverse_){node=node.right;}else{node=node.left;}}}}SortedMapIterator.prototype.getNext=function(){if(this.nodeStack_.length===0)return null;var node=this.nodeStack_.pop();var result;if(this.resultGenerator_)result=this.resultGenerator_(node.key,node.value);else result={key:node.key,value:node.value};if(this.isReverse_){node=node.left;while(!node.isEmpty()){this.nodeStack_.push(node);node=node.right;}}else{node=node.right;while(!node.isEmpty()){this.nodeStack_.push(node);node=node.left;}}return result;};SortedMapIterator.prototype.hasNext=function(){return this.nodeStack_.length>0;};SortedMapIterator.prototype.peek=function(){if(this.nodeStack_.length===0)return null;var node=this.nodeStack_[this.nodeStack_.length-1];if(this.resultGenerator_){return this.resultGenerator_(node.key,node.value);}else{return{key:node.key,value:node.value};}};return SortedMapIterator;}();/**
 * Represents a node in a Left-leaning Red-Black tree.
 */var LLRBNode=/** @class */function(){/**
     * @template K, V
     * @param {!K} key Key associated with this node.
     * @param {!V} value Value associated with this node.
     * @param {?boolean} color Whether this node is red.
     * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.
     * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.
     */function LLRBNode(key,value,color,left,right){this.key=key;this.value=value;this.color=color!=null?color:LLRBNode.RED;this.left=left!=null?left:SortedMap.EMPTY_NODE;this.right=right!=null?right:SortedMap.EMPTY_NODE;}/**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param {?K} key New key for the node, or null.
     * @param {?V} value New value for the node, or null.
     * @param {?boolean} color New color for the node, or null.
     * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.
     * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.
     * @return {!LLRBNode} The node copy.
     */LLRBNode.prototype.copy=function(key,value,color,left,right){return new LLRBNode(key!=null?key:this.key,value!=null?value:this.value,color!=null?color:this.color,left!=null?left:this.left,right!=null?right:this.right);};/**
     * @return {number} The total number of nodes in the tree.
     */LLRBNode.prototype.count=function(){return this.left.count()+1+this.right.count();};/**
     * @return {boolean} True if the tree is empty.
     */LLRBNode.prototype.isEmpty=function(){return false;};/**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V):*} action Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @return {*} The first truthy value returned by action, or the last falsey
     *   value returned by action
     */LLRBNode.prototype.inorderTraversal=function(action){return this.left.inorderTraversal(action)||action(this.key,this.value)||this.right.inorderTraversal(action);};/**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param {function(!Object, !Object)} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {*} True if traversal was aborted.
     */LLRBNode.prototype.reverseTraversal=function(action){return this.right.reverseTraversal(action)||action(this.key,this.value)||this.left.reverseTraversal(action);};/**
     * @return {!Object} The minimum node in the tree.
     * @private
     */LLRBNode.prototype.min_=function(){if(this.left.isEmpty()){return this;}else{return this.left.min_();}};/**
     * @return {!K} The maximum key in the tree.
     */LLRBNode.prototype.minKey=function(){return this.min_().key;};/**
     * @return {!K} The maximum key in the tree.
     */LLRBNode.prototype.maxKey=function(){if(this.right.isEmpty()){return this.key;}else{return this.right.maxKey();}};/**
     *
     * @param {!Object} key Key to insert.
     * @param {!Object} value Value to insert.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode} New tree, with the key/value added.
     */LLRBNode.prototype.insert=function(key,value,comparator){var cmp,n;n=this;cmp=comparator(key,n.key);if(cmp<0){n=n.copy(null,null,null,n.left.insert(key,value,comparator),null);}else if(cmp===0){n=n.copy(null,value,null,null,null);}else{n=n.copy(null,null,null,null,n.right.insert(key,value,comparator));}return n.fixUp_();};/**
     * @private
     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.
     */LLRBNode.prototype.removeMin_=function(){if(this.left.isEmpty()){return SortedMap.EMPTY_NODE;}var n=this;if(!n.left.isRed_()&&!n.left.left.isRed_())n=n.moveRedLeft_();n=n.copy(null,null,null,n.left.removeMin_(),null);return n.fixUp_();};/**
     * @param {!Object} key The key of the item to remove.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.
     */LLRBNode.prototype.remove=function(key,comparator){var n,smallest;n=this;if(comparator(key,n.key)<0){if(!n.left.isEmpty()&&!n.left.isRed_()&&!n.left.left.isRed_()){n=n.moveRedLeft_();}n=n.copy(null,null,null,n.left.remove(key,comparator),null);}else{if(n.left.isRed_())n=n.rotateRight_();if(!n.right.isEmpty()&&!n.right.isRed_()&&!n.right.left.isRed_()){n=n.moveRedRight_();}if(comparator(key,n.key)===0){if(n.right.isEmpty()){return SortedMap.EMPTY_NODE;}else{smallest=n.right.min_();n=n.copy(smallest.key,smallest.value,null,null,n.right.removeMin_());}}n=n.copy(null,null,null,null,n.right.remove(key,comparator));}return n.fixUp_();};/**
     * @private
     * @return {boolean} Whether this is a RED node.
     */LLRBNode.prototype.isRed_=function(){return this.color;};/**
     * @private
     * @return {!LLRBNode} New tree after performing any needed rotations.
     */LLRBNode.prototype.fixUp_=function(){var n=this;if(n.right.isRed_()&&!n.left.isRed_())n=n.rotateLeft_();if(n.left.isRed_()&&n.left.left.isRed_())n=n.rotateRight_();if(n.left.isRed_()&&n.right.isRed_())n=n.colorFlip_();return n;};/**
     * @private
     * @return {!LLRBNode} New tree, after moveRedLeft.
     */LLRBNode.prototype.moveRedLeft_=function(){var n=this.colorFlip_();if(n.right.left.isRed_()){n=n.copy(null,null,null,null,n.right.rotateRight_());n=n.rotateLeft_();n=n.colorFlip_();}return n;};/**
     * @private
     * @return {!LLRBNode} New tree, after moveRedRight.
     */LLRBNode.prototype.moveRedRight_=function(){var n=this.colorFlip_();if(n.left.left.isRed_()){n=n.rotateRight_();n=n.colorFlip_();}return n;};/**
     * @private
     * @return {!LLRBNode} New tree, after rotateLeft.
     */LLRBNode.prototype.rotateLeft_=function(){var nl=this.copy(null,null,LLRBNode.RED,null,this.right.left);return this.right.copy(null,null,this.color,nl,null);};/**
     * @private
     * @return {!LLRBNode} New tree, after rotateRight.
     */LLRBNode.prototype.rotateRight_=function(){var nr=this.copy(null,null,LLRBNode.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,nr);};/**
     * @private
     * @return {!LLRBNode} New tree, after colorFlip.
     */LLRBNode.prototype.colorFlip_=function(){var left=this.left.copy(null,null,!this.left.color,null,null);var right=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,left,right);};/**
     * For testing.
     *
     * @private
     * @return {boolean} True if all is well.
     */LLRBNode.prototype.checkMaxDepth_=function(){var blackDepth=this.check_();return Math.pow(2.0,blackDepth)<=this.count()+1;};/**
     * @private
     * @return {number} Not sure what this returns exactly. :-).
     */LLRBNode.prototype.check_=function(){var blackDepth;if(this.isRed_()&&this.left.isRed_()){throw new Error('Red node has red child('+this.key+','+this.value+')');}if(this.right.isRed_()){throw new Error('Right child of ('+this.key+','+this.value+') is red');}blackDepth=this.left.check_();if(blackDepth!==this.right.check_()){throw new Error('Black depths differ');}else{return blackDepth+(this.isRed_()?0:1);}};LLRBNode.RED=true;LLRBNode.BLACK=false;return LLRBNode;}();/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */var LLRBEmptyNode=/** @class */function(){function LLRBEmptyNode(){}/**
     * Returns a copy of the current node.
     *
     * @return {!LLRBEmptyNode} The node copy.
     */LLRBEmptyNode.prototype.copy=function(key,value,color,left,right){return this;};/**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param {!K} key Key to be added.
     * @param {!V} value Value to be added.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode} New tree, with item added.
     */LLRBEmptyNode.prototype.insert=function(key,value,comparator){return new LLRBNode(key,value,null);};/**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param {!K} key The key to remove.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBEmptyNode} New tree, with item removed.
     */LLRBEmptyNode.prototype.remove=function(key,comparator){return this;};/**
     * @return {number} The total number of nodes in the tree.
     */LLRBEmptyNode.prototype.count=function(){return 0;};/**
     * @return {boolean} True if the tree is empty.
     */LLRBEmptyNode.prototype.isEmpty=function(){return true;};/**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V):*} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {boolean} True if traversal was aborted.
     */LLRBEmptyNode.prototype.inorderTraversal=function(action){return false;};/**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V)} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {boolean} True if traversal was aborted.
     */LLRBEmptyNode.prototype.reverseTraversal=function(action){return false;};/**
     * @return {null}
     */LLRBEmptyNode.prototype.minKey=function(){return null;};/**
     * @return {null}
     */LLRBEmptyNode.prototype.maxKey=function(){return null;};/**
     * @private
     * @return {number} Not sure what this returns exactly. :-).
     */LLRBEmptyNode.prototype.check_=function(){return 0;};/**
     * @private
     * @return {boolean} Whether this node is red.
     */LLRBEmptyNode.prototype.isRed_=function(){return false;};return LLRBEmptyNode;}();/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */var SortedMap=/** @class */function(){/**
     * @template K, V
     * @param {function(K, K):number} comparator_ Key comparator.
     * @param {LLRBNode=} root_ (Optional) Root node for the map.
     */function SortedMap(comparator_,root_){if(root_===void 0){root_=SortedMap.EMPTY_NODE;}this.comparator_=comparator_;this.root_=root_;}/**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param {!K} key Key to be added.
     * @param {!V} value Value to be added.
     * @return {!SortedMap.<K, V>} New map, with item added.
     */SortedMap.prototype.insert=function(key,value){return new SortedMap(this.comparator_,this.root_.insert(key,value,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null));};/**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param {!K} key The key to remove.
     * @return {!SortedMap.<K, V>} New map, with item removed.
     */SortedMap.prototype.remove=function(key){return new SortedMap(this.comparator_,this.root_.remove(key,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null));};/**
     * Returns the value of the node with the given key, or null.
     *
     * @param {!K} key The key to look up.
     * @return {?V} The value of the node with the given key, or null if the
     * key doesn't exist.
     */SortedMap.prototype.get=function(key){var cmp;var node=this.root_;while(!node.isEmpty()){cmp=this.comparator_(key,node.key);if(cmp===0){return node.value;}else if(cmp<0){node=node.left;}else if(cmp>0){node=node.right;}}return null;};/**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param {K} key The key to find the predecessor of
     * @return {?K} The predecessor key.
     */SortedMap.prototype.getPredecessorKey=function(key){var cmp,node=this.root_,rightParent=null;while(!node.isEmpty()){cmp=this.comparator_(key,node.key);if(cmp===0){if(!node.left.isEmpty()){node=node.left;while(!node.right.isEmpty())node=node.right;return node.key;}else if(rightParent){return rightParent.key;}else{return null;// first item.
}}else if(cmp<0){node=node.left;}else if(cmp>0){rightParent=node;node=node.right;}}throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');};/**
     * @return {boolean} True if the map is empty.
     */SortedMap.prototype.isEmpty=function(){return this.root_.isEmpty();};/**
     * @return {number} The total number of nodes in the map.
     */SortedMap.prototype.count=function(){return this.root_.count();};/**
     * @return {?K} The minimum key in the map.
     */SortedMap.prototype.minKey=function(){return this.root_.minKey();};/**
     * @return {?K} The maximum key in the map.
     */SortedMap.prototype.maxKey=function(){return this.root_.maxKey();};/**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param {function(!K, !V):*} action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return {*} The first truthy value returned by action, or the last falsey
     *   value returned by action
     */SortedMap.prototype.inorderTraversal=function(action){return this.root_.inorderTraversal(action);};/**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param {function(!Object, !Object)} action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return {*} True if the traversal was aborted.
     */SortedMap.prototype.reverseTraversal=function(action){return this.root_.reverseTraversal(action);};/**
     * Returns an iterator over the SortedMap.
     * @template T
     * @param {(function(K, V):T)=} resultGenerator
     * @return {SortedMapIterator.<K, V, T>} The iterator.
     */SortedMap.prototype.getIterator=function(resultGenerator){return new SortedMapIterator(this.root_,null,this.comparator_,false,resultGenerator);};SortedMap.prototype.getIteratorFrom=function(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,false,resultGenerator);};SortedMap.prototype.getReverseIteratorFrom=function(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,true,resultGenerator);};SortedMap.prototype.getReverseIterator=function(resultGenerator){return new SortedMapIterator(this.root_,null,this.comparator_,true,resultGenerator);};/**
     * Always use the same empty node, to reduce memory.
     * @const
     */SortedMap.EMPTY_NODE=new LLRBEmptyNode();return SortedMap;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_2=Math.log(2);/**
 * @constructor
 */var Base12Num=/** @class */function(){/**
     * @param {number} length
     */function Base12Num(length){var logBase2=function(num){return parseInt(Math.log(num)/LOG_2,10);};var bitMask=function(bits){return parseInt(Array(bits+1).join('1'),2);};this.count=logBase2(length+1);this.current_=this.count-1;var mask=bitMask(this.count);this.bits_=length+1&mask;}/**
     * @return {boolean}
     */Base12Num.prototype.nextBitIsOne=function(){//noinspection JSBitwiseOperatorUsage
var result=!(this.bits_&0x1<<this.current_);this.current_--;return result;};return Base12Num;}();/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @template K, V
 * @param {Array.<!NamedNode>} childList Unsorted list of children
 * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used
 * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's
 *                                                        type is not NamedNode
 * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map
 * @return {SortedMap.<K, V>}
 */var buildChildSet=function(childList,cmp,keyFn,mapSortFn){childList.sort(cmp);var buildBalancedTree=function(low,high){var length=high-low;var namedNode;var key;if(length==0){return null;}else if(length==1){namedNode=childList[low];key=keyFn?keyFn(namedNode):namedNode;return new LLRBNode(key,namedNode.node,LLRBNode.BLACK,null,null);}else{var middle=parseInt(length/2,10)+low;var left=buildBalancedTree(low,middle);var right=buildBalancedTree(middle+1,high);namedNode=childList[middle];key=keyFn?keyFn(namedNode):namedNode;return new LLRBNode(key,namedNode.node,LLRBNode.BLACK,left,right);}};var buildFrom12Array=function(base12){var node=null;var root=null;var index=childList.length;var buildPennant=function(chunkSize,color){var low=index-chunkSize;var high=index;index-=chunkSize;var childTree=buildBalancedTree(low+1,high);var namedNode=childList[low];var key=keyFn?keyFn(namedNode):namedNode;attachPennant(new LLRBNode(key,namedNode.node,color,null,childTree));};var attachPennant=function(pennant){if(node){node.left=pennant;node=pennant;}else{root=pennant;node=pennant;}};for(var i=0;i<base12.count;++i){var isOne=base12.nextBitIsOne();// The number of nodes taken in each slice is 2^(arr.length - (i + 1))
var chunkSize=Math.pow(2,base12.count-(i+1));if(isOne){buildPennant(chunkSize,LLRBNode.BLACK);}else{// current == 2
buildPennant(chunkSize,LLRBNode.BLACK);buildPennant(chunkSize,LLRBNode.RED);}}return root;};var base12=new Base12Num(childList.length);var root=buildFrom12Array(base12);return new SortedMap(mapSortFn||cmp,root);};/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var _defaultIndexMap;var fallbackObject={};/**
 *
 * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes
 * @param {Object.<string, Index>} indexSet
 * @constructor
 */var IndexMap=/** @class */function(){function IndexMap(indexes_,indexSet_){this.indexes_=indexes_;this.indexSet_=indexSet_;}Object.defineProperty(IndexMap,"Default",{/**
         * The default IndexMap for nodes without a priority
         * @type {!IndexMap}
         * @const
         */get:function(){util.assert(fallbackObject&&PRIORITY_INDEX,'ChildrenNode.ts has not been loaded');_defaultIndexMap=_defaultIndexMap||new IndexMap({'.priority':fallbackObject},{'.priority':PRIORITY_INDEX});return _defaultIndexMap;},enumerable:true,configurable:true});/**
     *
     * @param {!string} indexKey
     * @return {?SortedMap.<NamedNode, Node>}
     */IndexMap.prototype.get=function(indexKey){var sortedMap=util.safeGet(this.indexes_,indexKey);if(!sortedMap)throw new Error('No index defined for '+indexKey);if(sortedMap===fallbackObject){// The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
// regular child map
return null;}else{return sortedMap;}};/**
     * @param {!Index} indexDefinition
     * @return {boolean}
     */IndexMap.prototype.hasIndex=function(indexDefinition){return util.contains(this.indexSet_,indexDefinition.toString());};/**
     * @param {!Index} indexDefinition
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */IndexMap.prototype.addIndex=function(indexDefinition,existingChildren){util.assert(indexDefinition!==KEY_INDEX,"KeyIndex always exists and isn't meant to be added to the IndexMap.");var childList=[];var sawIndexedValue=false;var iter=existingChildren.getIterator(NamedNode.Wrap);var next=iter.getNext();while(next){sawIndexedValue=sawIndexedValue||indexDefinition.isDefinedOn(next.node);childList.push(next);next=iter.getNext();}var newIndex;if(sawIndexedValue){newIndex=buildChildSet(childList,indexDefinition.getCompare());}else{newIndex=fallbackObject;}var indexName=indexDefinition.toString();var newIndexSet=util.clone(this.indexSet_);newIndexSet[indexName]=indexDefinition;var newIndexes=util.clone(this.indexes_);newIndexes[indexName]=newIndex;return new IndexMap(newIndexes,newIndexSet);};/**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     * @param {!NamedNode} namedNode
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */IndexMap.prototype.addToIndexes=function(namedNode,existingChildren){var _this=this;var newIndexes=util.map(this.indexes_,function(indexedChildren,indexName){var index=util.safeGet(_this.indexSet_,indexName);util.assert(index,'Missing index implementation for '+indexName);if(indexedChildren===fallbackObject){// Check to see if we need to index everything
if(index.isDefinedOn(namedNode.node)){// We need to build this index
var childList=[];var iter=existingChildren.getIterator(NamedNode.Wrap);var next=iter.getNext();while(next){if(next.name!=namedNode.name){childList.push(next);}next=iter.getNext();}childList.push(namedNode);return buildChildSet(childList,index.getCompare());}else{// No change, this remains a fallback
return fallbackObject;}}else{var existingSnap=existingChildren.get(namedNode.name);var newChildren=indexedChildren;if(existingSnap){newChildren=newChildren.remove(new NamedNode(namedNode.name,existingSnap));}return newChildren.insert(namedNode,namedNode.node);}});return new IndexMap(newIndexes,this.indexSet_);};/**
     * Create a new IndexMap instance with the given value removed
     * @param {!NamedNode} namedNode
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */IndexMap.prototype.removeFromIndexes=function(namedNode,existingChildren){var newIndexes=util.map(this.indexes_,function(indexedChildren){if(indexedChildren===fallbackObject){// This is the fallback. Just return it, nothing to do in this case
return indexedChildren;}else{var existingSnap=existingChildren.get(namedNode.name);if(existingSnap){return indexedChildren.remove(new NamedNode(namedNode.name,existingSnap));}else{// No record of this child
return indexedChildren;}}});return new IndexMap(newIndexes,this.indexSet_);};return IndexMap;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function NAME_ONLY_COMPARATOR(left,right){return nameCompare(left.name,right.name);}function NAME_COMPARATOR(left,right){return nameCompare(left,right);}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // TODO: For memory savings, don't store priorityNode_ if it's empty.
var EMPTY_NODE;/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 *
 * @constructor
 * @implements {Node}
 */var ChildrenNode=/** @class */function(){/**
     *
     * @param {!SortedMap.<string, !Node>} children_ List of children
     * of this node..
     * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).
     * @param {!IndexMap} indexMap_
     */function ChildrenNode(children_,priorityNode_,indexMap_){this.children_=children_;this.priorityNode_=priorityNode_;this.indexMap_=indexMap_;this.lazyHash_=null;/**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */if(this.priorityNode_){validatePriorityNode(this.priorityNode_);}if(this.children_.isEmpty()){util.assert(!this.priorityNode_||this.priorityNode_.isEmpty(),'An empty node cannot have a priority');}}Object.defineProperty(ChildrenNode,"EMPTY_NODE",{get:function(){return EMPTY_NODE||(EMPTY_NODE=new ChildrenNode(new SortedMap(NAME_COMPARATOR),null,IndexMap.Default));},enumerable:true,configurable:true});/** @inheritDoc */ChildrenNode.prototype.isLeafNode=function(){return false;};/** @inheritDoc */ChildrenNode.prototype.getPriority=function(){return this.priorityNode_||EMPTY_NODE;};/** @inheritDoc */ChildrenNode.prototype.updatePriority=function(newPriorityNode){if(this.children_.isEmpty()){// Don't allow priorities on empty nodes
return this;}else{return new ChildrenNode(this.children_,newPriorityNode,this.indexMap_);}};/** @inheritDoc */ChildrenNode.prototype.getImmediateChild=function(childName){// Hack to treat priority as a regular child
if(childName==='.priority'){return this.getPriority();}else{var child=this.children_.get(childName);return child===null?EMPTY_NODE:child;}};/** @inheritDoc */ChildrenNode.prototype.getChild=function(path){var front=path.getFront();if(front===null)return this;return this.getImmediateChild(front).getChild(path.popFront());};/** @inheritDoc */ChildrenNode.prototype.hasChild=function(childName){return this.children_.get(childName)!==null;};/** @inheritDoc */ChildrenNode.prototype.updateImmediateChild=function(childName,newChildNode){util.assert(newChildNode,'We should always be passing snapshot nodes');if(childName==='.priority'){return this.updatePriority(newChildNode);}else{var namedNode=new NamedNode(childName,newChildNode);var newChildren=void 0,newIndexMap=void 0,newPriority=void 0;if(newChildNode.isEmpty()){newChildren=this.children_.remove(childName);newIndexMap=this.indexMap_.removeFromIndexes(namedNode,this.children_);}else{newChildren=this.children_.insert(childName,newChildNode);newIndexMap=this.indexMap_.addToIndexes(namedNode,this.children_);}newPriority=newChildren.isEmpty()?EMPTY_NODE:this.priorityNode_;return new ChildrenNode(newChildren,newPriority,newIndexMap);}};/** @inheritDoc */ChildrenNode.prototype.updateChild=function(path,newChildNode){var front=path.getFront();if(front===null){return newChildNode;}else{util.assert(path.getFront()!=='.priority'||path.getLength()===1,'.priority must be the last token in a path');var newImmediateChild=this.getImmediateChild(front).updateChild(path.popFront(),newChildNode);return this.updateImmediateChild(front,newImmediateChild);}};/** @inheritDoc */ChildrenNode.prototype.isEmpty=function(){return this.children_.isEmpty();};/** @inheritDoc */ChildrenNode.prototype.numChildren=function(){return this.children_.count();};/** @inheritDoc */ChildrenNode.prototype.val=function(exportFormat){if(this.isEmpty())return null;var obj={};var numKeys=0,maxKey=0,allIntegerKeys=true;this.forEachChild(PRIORITY_INDEX,function(key,childNode){obj[key]=childNode.val(exportFormat);numKeys++;if(allIntegerKeys&&ChildrenNode.INTEGER_REGEXP_.test(key)){maxKey=Math.max(maxKey,Number(key));}else{allIntegerKeys=false;}});if(!exportFormat&&allIntegerKeys&&maxKey<2*numKeys){// convert to array.
var array=[];for(var key in obj)array[key]=obj[key];return array;}else{if(exportFormat&&!this.getPriority().isEmpty()){obj['.priority']=this.getPriority().val();}return obj;}};/** @inheritDoc */ChildrenNode.prototype.hash=function(){if(this.lazyHash_===null){var toHash_1='';if(!this.getPriority().isEmpty())toHash_1+='priority:'+priorityHashText(this.getPriority().val())+':';this.forEachChild(PRIORITY_INDEX,function(key,childNode){var childHash=childNode.hash();if(childHash!=='')toHash_1+=':'+key+':'+childHash;});this.lazyHash_=toHash_1===''?'':sha1(toHash_1);}return this.lazyHash_;};/** @inheritDoc */ChildrenNode.prototype.getPredecessorChildName=function(childName,childNode,index){var idx=this.resolveIndex_(index);if(idx){var predecessor=idx.getPredecessorKey(new NamedNode(childName,childNode));return predecessor?predecessor.name:null;}else{return this.children_.getPredecessorKey(childName);}};/**
     * @param {!Index} indexDefinition
     * @return {?string}
     */ChildrenNode.prototype.getFirstChildName=function(indexDefinition){var idx=this.resolveIndex_(indexDefinition);if(idx){var minKey=idx.minKey();return minKey&&minKey.name;}else{return this.children_.minKey();}};/**
     * @param {!Index} indexDefinition
     * @return {?NamedNode}
     */ChildrenNode.prototype.getFirstChild=function(indexDefinition){var minKey=this.getFirstChildName(indexDefinition);if(minKey){return new NamedNode(minKey,this.children_.get(minKey));}else{return null;}};/**
     * Given an index, return the key name of the largest value we have, according to that index
     * @param {!Index} indexDefinition
     * @return {?string}
     */ChildrenNode.prototype.getLastChildName=function(indexDefinition){var idx=this.resolveIndex_(indexDefinition);if(idx){var maxKey=idx.maxKey();return maxKey&&maxKey.name;}else{return this.children_.maxKey();}};/**
     * @param {!Index} indexDefinition
     * @return {?NamedNode}
     */ChildrenNode.prototype.getLastChild=function(indexDefinition){var maxKey=this.getLastChildName(indexDefinition);if(maxKey){return new NamedNode(maxKey,this.children_.get(maxKey));}else{return null;}};/**
     * @inheritDoc
     */ChildrenNode.prototype.forEachChild=function(index,action){var idx=this.resolveIndex_(index);if(idx){return idx.inorderTraversal(function(wrappedNode){return action(wrappedNode.name,wrappedNode.node);});}else{return this.children_.inorderTraversal(action);}};/**
     * @param {!Index} indexDefinition
     * @return {SortedMapIterator}
     */ChildrenNode.prototype.getIterator=function(indexDefinition){return this.getIteratorFrom(indexDefinition.minPost(),indexDefinition);};/**
     *
     * @param {!NamedNode} startPost
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */ChildrenNode.prototype.getIteratorFrom=function(startPost,indexDefinition){var idx=this.resolveIndex_(indexDefinition);if(idx){return idx.getIteratorFrom(startPost,function(key){return key;});}else{var iterator=this.children_.getIteratorFrom(startPost.name,NamedNode.Wrap);var next=iterator.peek();while(next!=null&&indexDefinition.compare(next,startPost)<0){iterator.getNext();next=iterator.peek();}return iterator;}};/**
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */ChildrenNode.prototype.getReverseIterator=function(indexDefinition){return this.getReverseIteratorFrom(indexDefinition.maxPost(),indexDefinition);};/**
     * @param {!NamedNode} endPost
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */ChildrenNode.prototype.getReverseIteratorFrom=function(endPost,indexDefinition){var idx=this.resolveIndex_(indexDefinition);if(idx){return idx.getReverseIteratorFrom(endPost,function(key){return key;});}else{var iterator=this.children_.getReverseIteratorFrom(endPost.name,NamedNode.Wrap);var next=iterator.peek();while(next!=null&&indexDefinition.compare(next,endPost)>0){iterator.getNext();next=iterator.peek();}return iterator;}};/**
     * @inheritDoc
     */ChildrenNode.prototype.compareTo=function(other){if(this.isEmpty()){if(other.isEmpty()){return 0;}else{return-1;}}else if(other.isLeafNode()||other.isEmpty()){return 1;}else if(other===MAX_NODE$2){return-1;}else{// Must be another node with children.
return 0;}};/**
     * @inheritDoc
     */ChildrenNode.prototype.withIndex=function(indexDefinition){if(indexDefinition===KEY_INDEX||this.indexMap_.hasIndex(indexDefinition)){return this;}else{var newIndexMap=this.indexMap_.addIndex(indexDefinition,this.children_);return new ChildrenNode(this.children_,this.priorityNode_,newIndexMap);}};/**
     * @inheritDoc
     */ChildrenNode.prototype.isIndexed=function(index){return index===KEY_INDEX||this.indexMap_.hasIndex(index);};/**
     * @inheritDoc
     */ChildrenNode.prototype.equals=function(other){if(other===this){return true;}else if(other.isLeafNode()){return false;}else{var otherChildrenNode=other;if(!this.getPriority().equals(otherChildrenNode.getPriority())){return false;}else if(this.children_.count()===otherChildrenNode.children_.count()){var thisIter=this.getIterator(PRIORITY_INDEX);var otherIter=otherChildrenNode.getIterator(PRIORITY_INDEX);var thisCurrent=thisIter.getNext();var otherCurrent=otherIter.getNext();while(thisCurrent&&otherCurrent){if(thisCurrent.name!==otherCurrent.name||!thisCurrent.node.equals(otherCurrent.node)){return false;}thisCurrent=thisIter.getNext();otherCurrent=otherIter.getNext();}return thisCurrent===null&&otherCurrent===null;}else{return false;}}};/**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     * @private
     * @param {!Index} indexDefinition
     * @return {?SortedMap.<NamedNode, Node>}
     */ChildrenNode.prototype.resolveIndex_=function(indexDefinition){if(indexDefinition===KEY_INDEX){return null;}else{return this.indexMap_.get(indexDefinition.toString());}};/**
     * @private
     * @type {RegExp}
     */ChildrenNode.INTEGER_REGEXP_=/^(0|[1-9]\d*)$/;return ChildrenNode;}();/**
 * @constructor
 * @extends {ChildrenNode}
 * @private
 */var MaxNode=/** @class */function(_super){tslib_1.__extends(MaxNode,_super);function MaxNode(){return _super.call(this,new SortedMap(NAME_COMPARATOR),ChildrenNode.EMPTY_NODE,IndexMap.Default)||this;}MaxNode.prototype.compareTo=function(other){if(other===this){return 0;}else{return 1;}};MaxNode.prototype.equals=function(other){// Not that we every compare it, but MAX_NODE is only ever equal to itself
return other===this;};MaxNode.prototype.getPriority=function(){return this;};MaxNode.prototype.getImmediateChild=function(childName){return ChildrenNode.EMPTY_NODE;};MaxNode.prototype.isEmpty=function(){return false;};return MaxNode;}(ChildrenNode);/**
 * Marker that will sort higher than any other snapshot.
 * @type {!MAX_NODE}
 * @const
 */var MAX_NODE$2=new MaxNode();Object.defineProperties(NamedNode,{MIN:{value:new NamedNode(MIN_NAME,ChildrenNode.EMPTY_NODE)},MAX:{value:new NamedNode(MAX_NAME,MAX_NODE$2)}});/**
 * Reference Extensions
 */KeyIndex.__EMPTY_NODE=ChildrenNode.EMPTY_NODE;LeafNode.__childrenNodeConstructor=ChildrenNode;setMaxNode(MAX_NODE$2);setMaxNode$1(MAX_NODE$2);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var USE_HINZE=true;/**
 * Constructs a snapshot node representing the passed JSON and returns it.
 * @param {*} json JSON to create a node for.
 * @param {?string|?number=} priority Optional priority to use.  This will be ignored if the
 * passed JSON contains a .priority property.
 * @return {!Node}
 */function nodeFromJSON$1(json,priority){if(priority===void 0){priority=null;}if(json===null){return ChildrenNode.EMPTY_NODE;}if(typeof json==='object'&&'.priority'in json){priority=json['.priority'];}util.assert(priority===null||typeof priority==='string'||typeof priority==='number'||typeof priority==='object'&&'.sv'in priority,'Invalid priority type found: '+typeof priority);if(typeof json==='object'&&'.value'in json&&json['.value']!==null){json=json['.value'];}// Valid leaf nodes include non-objects or server-value wrapper objects
if(typeof json!=='object'||'.sv'in json){var jsonLeaf=json;return new LeafNode(jsonLeaf,nodeFromJSON$1(priority));}if(!(json instanceof Array)&&USE_HINZE){var children_1=[];var childrenHavePriority_1=false;var hinzeJsonObj_1=json;util.forEach(hinzeJsonObj_1,function(key,child){if(typeof key!=='string'||key.substring(0,1)!=='.'){// Ignore metadata nodes
var childNode=nodeFromJSON$1(hinzeJsonObj_1[key]);if(!childNode.isEmpty()){childrenHavePriority_1=childrenHavePriority_1||!childNode.getPriority().isEmpty();children_1.push(new NamedNode(key,childNode));}}});if(children_1.length==0){return ChildrenNode.EMPTY_NODE;}var childSet=buildChildSet(children_1,NAME_ONLY_COMPARATOR,function(namedNode){return namedNode.name;},NAME_COMPARATOR);if(childrenHavePriority_1){var sortedChildSet=buildChildSet(children_1,PRIORITY_INDEX.getCompare());return new ChildrenNode(childSet,nodeFromJSON$1(priority),new IndexMap({'.priority':sortedChildSet},{'.priority':PRIORITY_INDEX}));}else{return new ChildrenNode(childSet,nodeFromJSON$1(priority),IndexMap.Default);}}else{var node_1=ChildrenNode.EMPTY_NODE;var jsonObj_1=json;util.forEach(jsonObj_1,function(key,childData){if(util.contains(jsonObj_1,key)){if(key.substring(0,1)!=='.'){// ignore metadata nodes.
var childNode=nodeFromJSON$1(childData);if(childNode.isLeafNode()||!childNode.isEmpty())node_1=node_1.updateImmediateChild(key,childNode);}}});return node_1.updatePriority(nodeFromJSON$1(priority));}}setNodeFromJSON(nodeFromJSON$1);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @constructor
 * @extends {Index}
 * @private
 */var ValueIndex=/** @class */function(_super){tslib_1.__extends(ValueIndex,_super);function ValueIndex(){return _super!==null&&_super.apply(this,arguments)||this;}/**
     * @inheritDoc
     */ValueIndex.prototype.compare=function(a,b){var indexCmp=a.node.compareTo(b.node);if(indexCmp===0){return nameCompare(a.name,b.name);}else{return indexCmp;}};/**
     * @inheritDoc
     */ValueIndex.prototype.isDefinedOn=function(node){return true;};/**
     * @inheritDoc
     */ValueIndex.prototype.indexedValueChanged=function(oldNode,newNode){return!oldNode.equals(newNode);};/**
     * @inheritDoc
     */ValueIndex.prototype.minPost=function(){return NamedNode.MIN;};/**
     * @inheritDoc
     */ValueIndex.prototype.maxPost=function(){return NamedNode.MAX;};/**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */ValueIndex.prototype.makePost=function(indexValue,name){var valueNode=nodeFromJSON$1(indexValue);return new NamedNode(name,valueNode);};/**
     * @return {!string} String representation for inclusion in a query spec
     */ValueIndex.prototype.toString=function(){return'.value';};return ValueIndex;}(Index);var VALUE_INDEX=new ValueIndex();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @param {!Path} indexPath
 * @constructor
 * @extends {Index}
 */var PathIndex=/** @class */function(_super){tslib_1.__extends(PathIndex,_super);function PathIndex(indexPath_){var _this=_super.call(this)||this;_this.indexPath_=indexPath_;util.assert(!indexPath_.isEmpty()&&indexPath_.getFront()!=='.priority',"Can't create PathIndex with empty path or .priority key");return _this;}/**
     * @param {!Node} snap
     * @return {!Node}
     * @protected
     */PathIndex.prototype.extractChild=function(snap){return snap.getChild(this.indexPath_);};/**
     * @inheritDoc
     */PathIndex.prototype.isDefinedOn=function(node){return!node.getChild(this.indexPath_).isEmpty();};/**
     * @inheritDoc
     */PathIndex.prototype.compare=function(a,b){var aChild=this.extractChild(a.node);var bChild=this.extractChild(b.node);var indexCmp=aChild.compareTo(bChild);if(indexCmp===0){return nameCompare(a.name,b.name);}else{return indexCmp;}};/**
     * @inheritDoc
     */PathIndex.prototype.makePost=function(indexValue,name){var valueNode=nodeFromJSON$1(indexValue);var node=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,valueNode);return new NamedNode(name,node);};/**
     * @inheritDoc
     */PathIndex.prototype.maxPost=function(){var node=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,MAX_NODE$2);return new NamedNode(MAX_NAME,node);};/**
     * @inheritDoc
     */PathIndex.prototype.toString=function(){return this.indexPath_.slice().join('/');};return PathIndex;}(Index);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Class representing a firebase data snapshot.  It wraps a SnapshotNode and
 * surfaces the public methods (val, forEach, etc.) we want to expose.
 */var DataSnapshot=/** @class */function(){/**
     * @param {!Node} node_ A SnapshotNode to wrap.
     * @param {!Reference} ref_ The ref of the location this snapshot came from.
     * @param {!Index} index_ The iteration order for this snapshot
     */function DataSnapshot(node_,ref_,index_){this.node_=node_;this.ref_=ref_;this.index_=index_;}/**
     * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is
     * empty.
     *
     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.
     */DataSnapshot.prototype.val=function(){util.validateArgCount('DataSnapshot.val',0,0,arguments.length);return this.node_.val();};/**
     * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting
     * the entire node contents.
     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.
     */DataSnapshot.prototype.exportVal=function(){util.validateArgCount('DataSnapshot.exportVal',0,0,arguments.length);return this.node_.val(true);};// Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
// for end-users
DataSnapshot.prototype.toJSON=function(){// Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content
util.validateArgCount('DataSnapshot.toJSON',0,1,arguments.length);return this.exportVal();};/**
     * Returns whether the snapshot contains a non-null value.
     *
     * @return {boolean} Whether the snapshot contains a non-null value, or is empty.
     */DataSnapshot.prototype.exists=function(){util.validateArgCount('DataSnapshot.exists',0,0,arguments.length);return!this.node_.isEmpty();};/**
     * Returns a DataSnapshot of the specified child node's contents.
     *
     * @param {!string} childPathString Path to a child.
     * @return {!DataSnapshot} DataSnapshot for child node.
     */DataSnapshot.prototype.child=function(childPathString){util.validateArgCount('DataSnapshot.child',0,1,arguments.length);// Ensure the childPath is a string (can be a number)
childPathString=String(childPathString);validatePathString('DataSnapshot.child',1,childPathString,false);var childPath=new Path(childPathString);var childRef=this.ref_.child(childPath);return new DataSnapshot(this.node_.getChild(childPath),childRef,PRIORITY_INDEX);};/**
     * Returns whether the snapshot contains a child at the specified path.
     *
     * @param {!string} childPathString Path to a child.
     * @return {boolean} Whether the child exists.
     */DataSnapshot.prototype.hasChild=function(childPathString){util.validateArgCount('DataSnapshot.hasChild',1,1,arguments.length);validatePathString('DataSnapshot.hasChild',1,childPathString,false);var childPath=new Path(childPathString);return!this.node_.getChild(childPath).isEmpty();};/**
     * Returns the priority of the object, or null if no priority was set.
     *
     * @return {string|number|null} The priority.
     */DataSnapshot.prototype.getPriority=function(){util.validateArgCount('DataSnapshot.getPriority',0,0,arguments.length);// typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)
return this.node_.getPriority().val();};/**
     * Iterates through child nodes and calls the specified action for each one.
     *
     * @param {function(!DataSnapshot)} action Callback function to be called
     * for each child.
     * @return {boolean} True if forEach was canceled by action returning true for
     * one of the child nodes.
     */DataSnapshot.prototype.forEach=function(action){var _this=this;util.validateArgCount('DataSnapshot.forEach',1,1,arguments.length);util.validateCallback('DataSnapshot.forEach',1,action,false);if(this.node_.isLeafNode())return false;var childrenNode=this.node_;// Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...
return!!childrenNode.forEachChild(this.index_,function(key,node){return action(new DataSnapshot(node,_this.ref_.child(key),PRIORITY_INDEX));});};/**
     * Returns whether this DataSnapshot has children.
     * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.
     */DataSnapshot.prototype.hasChildren=function(){util.validateArgCount('DataSnapshot.hasChildren',0,0,arguments.length);if(this.node_.isLeafNode())return false;else return!this.node_.isEmpty();};Object.defineProperty(DataSnapshot.prototype,"key",{get:function(){return this.ref_.getKey();},enumerable:true,configurable:true});/**
     * Returns the number of children for this DataSnapshot.
     * @return {number} The number of children that this DataSnapshot contains.
     */DataSnapshot.prototype.numChildren=function(){util.validateArgCount('DataSnapshot.numChildren',0,0,arguments.length);return this.node_.numChildren();};/**
     * @return {Reference} The Firebase reference for the location this snapshot's data came from.
     */DataSnapshot.prototype.getRef=function(){util.validateArgCount('DataSnapshot.ref',0,0,arguments.length);return this.ref_;};Object.defineProperty(DataSnapshot.prototype,"ref",{get:function(){return this.getRef();},enumerable:true,configurable:true});return DataSnapshot;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Encapsulates the data needed to raise an event
 * @implements {Event}
 */var DataEvent=/** @class */function(){/**
     * @param {!string} eventType One of: value, child_added, child_changed, child_moved, child_removed
     * @param {!EventRegistration} eventRegistration The function to call to with the event data. User provided
     * @param {!DataSnapshot} snapshot The data backing the event
     * @param {?string=} prevName Optional, the name of the previous child for child_* events.
     */function DataEvent(eventType,eventRegistration,snapshot,prevName){this.eventType=eventType;this.eventRegistration=eventRegistration;this.snapshot=snapshot;this.prevName=prevName;}/**
     * @inheritDoc
     */DataEvent.prototype.getPath=function(){var ref=this.snapshot.getRef();if(this.eventType==='value'){return ref.path;}else{return ref.getParent().path;}};/**
     * @inheritDoc
     */DataEvent.prototype.getEventType=function(){return this.eventType;};/**
     * @inheritDoc
     */DataEvent.prototype.getEventRunner=function(){return this.eventRegistration.getEventRunner(this);};/**
     * @inheritDoc
     */DataEvent.prototype.toString=function(){return this.getPath().toString()+':'+this.eventType+':'+util.stringify(this.snapshot.exportVal());};return DataEvent;}();var CancelEvent=/** @class */function(){/**
     * @param {EventRegistration} eventRegistration
     * @param {Error} error
     * @param {!Path} path
     */function CancelEvent(eventRegistration,error,path){this.eventRegistration=eventRegistration;this.error=error;this.path=path;}/**
     * @inheritDoc
     */CancelEvent.prototype.getPath=function(){return this.path;};/**
     * @inheritDoc
     */CancelEvent.prototype.getEventType=function(){return'cancel';};/**
     * @inheritDoc
     */CancelEvent.prototype.getEventRunner=function(){return this.eventRegistration.getEventRunner(this);};/**
     * @inheritDoc
     */CancelEvent.prototype.toString=function(){return this.path.toString()+':cancel';};return CancelEvent;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Represents registration for 'value' events.
 */var ValueEventRegistration=/** @class */function(){/**
     * @param {?function(!DataSnapshot)} callback_
     * @param {?function(Error)} cancelCallback_
     * @param {?Object} context_
     */function ValueEventRegistration(callback_,cancelCallback_,context_){this.callback_=callback_;this.cancelCallback_=cancelCallback_;this.context_=context_;}/**
     * @inheritDoc
     */ValueEventRegistration.prototype.respondsTo=function(eventType){return eventType==='value';};/**
     * @inheritDoc
     */ValueEventRegistration.prototype.createEvent=function(change,query){var index=query.getQueryParams().getIndex();return new DataEvent('value',this,new DataSnapshot(change.snapshotNode,query.getRef(),index));};/**
     * @inheritDoc
     */ValueEventRegistration.prototype.getEventRunner=function(eventData){var ctx=this.context_;if(eventData.getEventType()==='cancel'){util.assert(this.cancelCallback_,'Raising a cancel event on a listener with no cancel callback');var cancelCB_1=this.cancelCallback_;return function(){// We know that error exists, we checked above that this is a cancel event
cancelCB_1.call(ctx,eventData.error);};}else{var cb_1=this.callback_;return function(){cb_1.call(ctx,eventData.snapshot);};}};/**
     * @inheritDoc
     */ValueEventRegistration.prototype.createCancelEvent=function(error,path){if(this.cancelCallback_){return new CancelEvent(this,error,path);}else{return null;}};/**
     * @inheritDoc
     */ValueEventRegistration.prototype.matches=function(other){if(!(other instanceof ValueEventRegistration)){return false;}else if(!other.callback_||!this.callback_){// If no callback specified, we consider it to match any callback.
return true;}else{return other.callback_===this.callback_&&other.context_===this.context_;}};/**
     * @inheritDoc
     */ValueEventRegistration.prototype.hasAnyCallback=function(){return this.callback_!==null;};return ValueEventRegistration;}();/**
 * Represents the registration of 1 or more child_xxx events.
 *
 * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you
 * register a group of callbacks together in the future.
 *
 * @constructor
 * @implements {EventRegistration}
 */var ChildEventRegistration=/** @class */function(){/**
     * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_
     * @param {?function(Error)} cancelCallback_
     * @param {Object=} context_
     */function ChildEventRegistration(callbacks_,cancelCallback_,context_){this.callbacks_=callbacks_;this.cancelCallback_=cancelCallback_;this.context_=context_;}/**
     * @inheritDoc
     */ChildEventRegistration.prototype.respondsTo=function(eventType){var eventToCheck=eventType==='children_added'?'child_added':eventType;eventToCheck=eventToCheck==='children_removed'?'child_removed':eventToCheck;return util.contains(this.callbacks_,eventToCheck);};/**
     * @inheritDoc
     */ChildEventRegistration.prototype.createCancelEvent=function(error,path){if(this.cancelCallback_){return new CancelEvent(this,error,path);}else{return null;}};/**
     * @inheritDoc
     */ChildEventRegistration.prototype.createEvent=function(change,query){util.assert(change.childName!=null,'Child events should have a childName.');var ref=query.getRef().child(/** @type {!string} */change.childName);var index=query.getQueryParams().getIndex();return new DataEvent(change.type,this,new DataSnapshot(change.snapshotNode,ref,index),change.prevName);};/**
     * @inheritDoc
     */ChildEventRegistration.prototype.getEventRunner=function(eventData){var ctx=this.context_;if(eventData.getEventType()==='cancel'){util.assert(this.cancelCallback_,'Raising a cancel event on a listener with no cancel callback');var cancelCB_2=this.cancelCallback_;return function(){// We know that error exists, we checked above that this is a cancel event
cancelCB_2.call(ctx,eventData.error);};}else{var cb_2=this.callbacks_[eventData.eventType];return function(){cb_2.call(ctx,eventData.snapshot,eventData.prevName);};}};/**
     * @inheritDoc
     */ChildEventRegistration.prototype.matches=function(other){if(other instanceof ChildEventRegistration){if(!this.callbacks_||!other.callbacks_){return true;}else if(this.context_===other.context_){var otherCount=util.getCount(other.callbacks_);var thisCount=util.getCount(this.callbacks_);if(otherCount===thisCount){// If count is 1, do an exact match on eventType, if either is defined but null, it's a match.
//  If event types don't match, not a match
// If count is not 1, exact match across all
if(otherCount===1){var otherKey/** @type {!string} */=util.getAnyKey(other.callbacks_);var thisKey/** @type {!string} */=util.getAnyKey(this.callbacks_);return thisKey===otherKey&&(!other.callbacks_[otherKey]||!this.callbacks_[thisKey]||other.callbacks_[otherKey]===this.callbacks_[thisKey]);}else{// Exact match on each key.
return util.every(this.callbacks_,function(eventType,cb){return other.callbacks_[eventType]===cb;});}}}}return false;};/**
     * @inheritDoc
     */ChildEventRegistration.prototype.hasAnyCallback=function(){return this.callbacks_!==null;};return ChildEventRegistration;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __referenceConstructor;/**
 * A Query represents a filter to be applied to a firebase location.  This object purely represents the
 * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.
 *
 * Since every Firebase reference is a query, Firebase inherits from this object.
 */var Query=/** @class */function(){function Query(repo,path,queryParams_,orderByCalled_){this.repo=repo;this.path=path;this.queryParams_=queryParams_;this.orderByCalled_=orderByCalled_;}Object.defineProperty(Query,"__referenceConstructor",{get:function(){util.assert(__referenceConstructor,'Reference.ts has not been loaded');return __referenceConstructor;},set:function(val){__referenceConstructor=val;},enumerable:true,configurable:true});/**
     * Validates start/end values for queries.
     * @param {!QueryParams} params
     * @private
     */Query.validateQueryEndpoints_=function(params){var startNode=null;var endNode=null;if(params.hasStart()){startNode=params.getIndexStartValue();}if(params.hasEnd()){endNode=params.getIndexEndValue();}if(params.getIndex()===KEY_INDEX){var tooManyArgsError='Query: When ordering by key, you may only pass one argument to '+'startAt(), endAt(), or equalTo().';var wrongArgTypeError='Query: When ordering by key, the argument passed to startAt(), endAt(),'+'or equalTo() must be a string.';if(params.hasStart()){var startName=params.getIndexStartName();if(startName!=MIN_NAME){throw new Error(tooManyArgsError);}else if(typeof startNode!=='string'){throw new Error(wrongArgTypeError);}}if(params.hasEnd()){var endName=params.getIndexEndName();if(endName!=MAX_NAME){throw new Error(tooManyArgsError);}else if(typeof endNode!=='string'){throw new Error(wrongArgTypeError);}}}else if(params.getIndex()===PRIORITY_INDEX){if(startNode!=null&&!isValidPriority(startNode)||endNode!=null&&!isValidPriority(endNode)){throw new Error('Query: When ordering by priority, the first argument passed to startAt(), '+'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');}}else{util.assert(params.getIndex()instanceof PathIndex||params.getIndex()===VALUE_INDEX,'unknown index type.');if(startNode!=null&&typeof startNode==='object'||endNode!=null&&typeof endNode==='object'){throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be '+'an object.');}}};/**
     * Validates that limit* has been called with the correct combination of parameters
     * @param {!QueryParams} params
     * @private
     */Query.validateLimit_=function(params){if(params.hasStart()&&params.hasEnd()&&params.hasLimit()&&!params.hasAnchoredLimit()){throw new Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");}};/**
     * Validates that no other order by call has been made
     * @param {!string} fnName
     * @private
     */Query.prototype.validateNoPreviousOrderByCall_=function(fnName){if(this.orderByCalled_===true){throw new Error(fnName+": You can't combine multiple orderBy calls.");}};/**
     * @return {!QueryParams}
     */Query.prototype.getQueryParams=function(){return this.queryParams_;};/**
     * @return {!Reference}
     */Query.prototype.getRef=function(){util.validateArgCount('Query.ref',0,0,arguments.length);// This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.
// However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this
// method gets called.
return new Query.__referenceConstructor(this.repo,this.path);};/**
     * @param {!string} eventType
     * @param {!function(DataSnapshot, string=)} callback
     * @param {(function(Error)|Object)=} cancelCallbackOrContext
     * @param {Object=} context
     * @return {!function(DataSnapshot, string=)}
     */Query.prototype.on=function(eventType,callback,cancelCallbackOrContext,context){util.validateArgCount('Query.on',2,4,arguments.length);validateEventType('Query.on',1,eventType,false);util.validateCallback('Query.on',2,callback,false);var ret=Query.getCancelAndContextArgs_('Query.on',cancelCallbackOrContext,context);if(eventType==='value'){this.onValueEvent(callback,ret.cancel,ret.context);}else{var callbacks={};callbacks[eventType]=callback;this.onChildEvent(callbacks,ret.cancel,ret.context);}return callback;};/**
     * @param {!function(!DataSnapshot)} callback
     * @param {?function(Error)} cancelCallback
     * @param {?Object} context
     * @protected
     */Query.prototype.onValueEvent=function(callback,cancelCallback,context){var container=new ValueEventRegistration(callback,cancelCallback||null,context||null);this.repo.addEventCallbackForQuery(this,container);};/**
     * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks
     * @param {?function(Error)} cancelCallback
     * @param {?Object} context
     * @protected
     */Query.prototype.onChildEvent=function(callbacks,cancelCallback,context){var container=new ChildEventRegistration(callbacks,cancelCallback,context);this.repo.addEventCallbackForQuery(this,container);};/**
     * @param {string=} eventType
     * @param {(function(!DataSnapshot, ?string=))=} callback
     * @param {Object=} context
     */Query.prototype.off=function(eventType,callback,context){util.validateArgCount('Query.off',0,3,arguments.length);validateEventType('Query.off',1,eventType,true);util.validateCallback('Query.off',2,callback,true);util.validateContextObject('Query.off',3,context,true);var container=null;var callbacks=null;if(eventType==='value'){var valueCallback=callback||null;container=new ValueEventRegistration(valueCallback,null,context||null);}else if(eventType){if(callback){callbacks={};callbacks[eventType]=callback;}container=new ChildEventRegistration(callbacks,null,context||null);}this.repo.removeEventCallbackForQuery(this,container);};/**
     * Attaches a listener, waits for the first event, and then removes the listener
     * @param {!string} eventType
     * @param {!function(!DataSnapshot, string=)} userCallback
     * @param failureCallbackOrContext
     * @param context
     * @return {!firebase.Promise}
     */Query.prototype.once=function(eventType,userCallback,failureCallbackOrContext,context){var _this=this;util.validateArgCount('Query.once',1,4,arguments.length);validateEventType('Query.once',1,eventType,false);util.validateCallback('Query.once',2,userCallback,true);var ret=Query.getCancelAndContextArgs_('Query.once',failureCallbackOrContext,context);// TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)
// TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change
// because the API currently expects callbacks will be called synchronously if the data is cached, but this is
// against the Promise specification.
var firstCall=true;var deferred=new util.Deferred();// A dummy error handler in case a user wasn't expecting promises
deferred.promise.catch(function(){});var onceCallback=function(snapshot){// NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)
// triggers multiple events (e.g. child_added or child_changed).
if(firstCall){firstCall=false;_this.off(eventType,onceCallback);if(userCallback){userCallback.bind(ret.context)(snapshot);}deferred.resolve(snapshot);}};this.on(eventType,onceCallback,/*cancel=*/function(err){_this.off(eventType,onceCallback);if(ret.cancel)ret.cancel.bind(ret.context)(err);deferred.reject(err);});return deferred.promise;};/**
     * Set a limit and anchor it to the start of the window.
     * @param {!number} limit
     * @return {!Query}
     */Query.prototype.limitToFirst=function(limit){util.validateArgCount('Query.limitToFirst',1,1,arguments.length);if(typeof limit!=='number'||Math.floor(limit)!==limit||limit<=0){throw new Error('Query.limitToFirst: First argument must be a positive integer.');}if(this.queryParams_.hasLimit()){throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, '+'limitToFirst, or limitToLast).');}return new Query(this.repo,this.path,this.queryParams_.limitToFirst(limit),this.orderByCalled_);};/**
     * Set a limit and anchor it to the end of the window.
     * @param {!number} limit
     * @return {!Query}
     */Query.prototype.limitToLast=function(limit){util.validateArgCount('Query.limitToLast',1,1,arguments.length);if(typeof limit!=='number'||Math.floor(limit)!==limit||limit<=0){throw new Error('Query.limitToLast: First argument must be a positive integer.');}if(this.queryParams_.hasLimit()){throw new Error('Query.limitToLast: Limit was already set (by another call to limit, '+'limitToFirst, or limitToLast).');}return new Query(this.repo,this.path,this.queryParams_.limitToLast(limit),this.orderByCalled_);};/**
     * Given a child path, return a new query ordered by the specified grandchild path.
     * @param {!string} path
     * @return {!Query}
     */Query.prototype.orderByChild=function(path){util.validateArgCount('Query.orderByChild',1,1,arguments.length);if(path==='$key'){throw new Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');}else if(path==='$priority'){throw new Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');}else if(path==='$value'){throw new Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');}validatePathString('Query.orderByChild',1,path,false);this.validateNoPreviousOrderByCall_('Query.orderByChild');var parsedPath=new Path(path);if(parsedPath.isEmpty()){throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');}var index=new PathIndex(parsedPath);var newParams=this.queryParams_.orderBy(index);Query.validateQueryEndpoints_(newParams);return new Query(this.repo,this.path,newParams,/*orderByCalled=*/true);};/**
     * Return a new query ordered by the KeyIndex
     * @return {!Query}
     */Query.prototype.orderByKey=function(){util.validateArgCount('Query.orderByKey',0,0,arguments.length);this.validateNoPreviousOrderByCall_('Query.orderByKey');var newParams=this.queryParams_.orderBy(KEY_INDEX);Query.validateQueryEndpoints_(newParams);return new Query(this.repo,this.path,newParams,/*orderByCalled=*/true);};/**
     * Return a new query ordered by the PriorityIndex
     * @return {!Query}
     */Query.prototype.orderByPriority=function(){util.validateArgCount('Query.orderByPriority',0,0,arguments.length);this.validateNoPreviousOrderByCall_('Query.orderByPriority');var newParams=this.queryParams_.orderBy(PRIORITY_INDEX);Query.validateQueryEndpoints_(newParams);return new Query(this.repo,this.path,newParams,/*orderByCalled=*/true);};/**
     * Return a new query ordered by the ValueIndex
     * @return {!Query}
     */Query.prototype.orderByValue=function(){util.validateArgCount('Query.orderByValue',0,0,arguments.length);this.validateNoPreviousOrderByCall_('Query.orderByValue');var newParams=this.queryParams_.orderBy(VALUE_INDEX);Query.validateQueryEndpoints_(newParams);return new Query(this.repo,this.path,newParams,/*orderByCalled=*/true);};/**
     * @param {number|string|boolean|null} value
     * @param {?string=} name
     * @return {!Query}
     */Query.prototype.startAt=function(value,name){if(value===void 0){value=null;}util.validateArgCount('Query.startAt',0,2,arguments.length);validateFirebaseDataArg('Query.startAt',1,value,this.path,true);validateKey('Query.startAt',2,name,true);var newParams=this.queryParams_.startAt(value,name);Query.validateLimit_(newParams);Query.validateQueryEndpoints_(newParams);if(this.queryParams_.hasStart()){throw new Error('Query.startAt: Starting point was already set (by another call to startAt '+'or equalTo).');}// Calling with no params tells us to start at the beginning.
if(value===undefined){value=null;name=null;}return new Query(this.repo,this.path,newParams,this.orderByCalled_);};/**
     * @param {number|string|boolean|null} value
     * @param {?string=} name
     * @return {!Query}
     */Query.prototype.endAt=function(value,name){if(value===void 0){value=null;}util.validateArgCount('Query.endAt',0,2,arguments.length);validateFirebaseDataArg('Query.endAt',1,value,this.path,true);validateKey('Query.endAt',2,name,true);var newParams=this.queryParams_.endAt(value,name);Query.validateLimit_(newParams);Query.validateQueryEndpoints_(newParams);if(this.queryParams_.hasEnd()){throw new Error('Query.endAt: Ending point was already set (by another call to endAt or '+'equalTo).');}return new Query(this.repo,this.path,newParams,this.orderByCalled_);};/**
     * Load the selection of children with exactly the specified value, and, optionally,
     * the specified name.
     * @param {number|string|boolean|null} value
     * @param {string=} name
     * @return {!Query}
     */Query.prototype.equalTo=function(value,name){util.validateArgCount('Query.equalTo',1,2,arguments.length);validateFirebaseDataArg('Query.equalTo',1,value,this.path,false);validateKey('Query.equalTo',2,name,true);if(this.queryParams_.hasStart()){throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or '+'equalTo).');}if(this.queryParams_.hasEnd()){throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or '+'equalTo).');}return this.startAt(value,name).endAt(value,name);};/**
     * @return {!string} URL for this location.
     */Query.prototype.toString=function(){util.validateArgCount('Query.toString',0,0,arguments.length);return this.repo.toString()+this.path.toUrlEncodedString();};// Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
// for end-users.
Query.prototype.toJSON=function(){// An optional spacer argument is unnecessary for a string.
util.validateArgCount('Query.toJSON',0,1,arguments.length);return this.toString();};/**
     * An object representation of the query parameters used by this Query.
     * @return {!Object}
     */Query.prototype.queryObject=function(){return this.queryParams_.getQueryObject();};/**
     * @return {!string}
     */Query.prototype.queryIdentifier=function(){var obj=this.queryObject();var id=ObjectToUniqueKey(obj);return id==='{}'?'default':id;};/**
     * Return true if this query and the provided query are equivalent; otherwise, return false.
     * @param {Query} other
     * @return {boolean}
     */Query.prototype.isEqual=function(other){util.validateArgCount('Query.isEqual',1,1,arguments.length);if(!(other instanceof Query)){var error='Query.isEqual failed: First argument must be an instance of firebase.database.Query.';throw new Error(error);}var sameRepo=this.repo===other.repo;var samePath=this.path.equals(other.path);var sameQueryIdentifier=this.queryIdentifier()===other.queryIdentifier();return sameRepo&&samePath&&sameQueryIdentifier;};/**
     * Helper used by .on and .once to extract the context and or cancel arguments.
     * @param {!string} fnName The function name (on or once)
     * @param {(function(Error)|Object)=} cancelOrContext
     * @param {Object=} context
     * @return {{cancel: ?function(Error), context: ?Object}}
     * @private
     */Query.getCancelAndContextArgs_=function(fnName,cancelOrContext,context){var ret={cancel:null,context:null};if(cancelOrContext&&context){ret.cancel=cancelOrContext;util.validateCallback(fnName,3,ret.cancel,true);ret.context=context;util.validateContextObject(fnName,4,ret.context,true);}else if(cancelOrContext){// we have either a cancel callback or a context.
if(typeof cancelOrContext==='object'&&cancelOrContext!==null){// it's a context!
ret.context=cancelOrContext;}else if(typeof cancelOrContext==='function'){ret.cancel=cancelOrContext;}else{throw new Error(util.errorPrefix(fnName,3,true)+' must either be a cancel callback or a context object.');}}return ret;};Object.defineProperty(Query.prototype,"ref",{get:function(){return this.getRef();},enumerable:true,configurable:true});return Query;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Implements a set with a count of elements.
 *
 * @template K, V
 */var CountedSet=/** @class */function(){function CountedSet(){this.set={};}/**
     * @param {!K} item
     * @param {V} val
     */CountedSet.prototype.add=function(item,val){this.set[item]=val!==null?val:true;};/**
     * @param {!K} key
     * @return {boolean}
     */CountedSet.prototype.contains=function(key){return util.contains(this.set,key);};/**
     * @param {!K} item
     * @return {V}
     */CountedSet.prototype.get=function(item){return this.contains(item)?this.set[item]:undefined;};/**
     * @param {!K} item
     */CountedSet.prototype.remove=function(item){delete this.set[item];};/**
     * Deletes everything in the set
     */CountedSet.prototype.clear=function(){this.set={};};/**
     * True if there's nothing in the set
     * @return {boolean}
     */CountedSet.prototype.isEmpty=function(){return util.isEmpty(this.set);};/**
     * @return {number} The number of items in the set
     */CountedSet.prototype.count=function(){return util.getCount(this.set);};/**
     * Run a function on each k,v pair in the set
     * @param {function(K, V)} fn
     */CountedSet.prototype.each=function(fn){util.forEach(this.set,function(k,v){return fn(k,v);});};/**
     * Mostly for debugging
     * @return {Array.<K>} The keys present in this CountedSet
     */CountedSet.prototype.keys=function(){var keys=[];util.forEach(this.set,function(k){keys.push(k);});return keys;};return CountedSet;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Helper class to store a sparse set of snapshots.
 *
 * @constructor
 */var SparseSnapshotTree=/** @class */function(){function SparseSnapshotTree(){/**
         * @private
         * @type {Node}
         */this.value_=null;/**
         * @private
         * @type {CountedSet}
         */this.children_=null;}/**
     * Gets the node stored at the given path if one exists.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @return {?Node} The retrieved node, or null.
     */SparseSnapshotTree.prototype.find=function(path){if(this.value_!=null){return this.value_.getChild(path);}else if(!path.isEmpty()&&this.children_!=null){var childKey=path.getFront();path=path.popFront();if(this.children_.contains(childKey)){var childTree=this.children_.get(childKey);return childTree.find(path);}else{return null;}}else{return null;}};/**
     * Stores the given node at the specified path. If there is already a node
     * at a shallower path, it merges the new data into that snapshot node.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @param {!Node} data The new data, or null.
     */SparseSnapshotTree.prototype.remember=function(path,data){if(path.isEmpty()){this.value_=data;this.children_=null;}else if(this.value_!==null){this.value_=this.value_.updateChild(path,data);}else{if(this.children_==null){this.children_=new CountedSet();}var childKey=path.getFront();if(!this.children_.contains(childKey)){this.children_.add(childKey,new SparseSnapshotTree());}var child=this.children_.get(childKey);path=path.popFront();child.remember(path,data);}};/**
     * Purge the data at path from the cache.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @return {boolean} True if this node should now be removed.
     */SparseSnapshotTree.prototype.forget=function(path){if(path.isEmpty()){this.value_=null;this.children_=null;return true;}else{if(this.value_!==null){if(this.value_.isLeafNode()){// We're trying to forget a node that doesn't exist
return false;}else{var value=this.value_;this.value_=null;var self_1=this;value.forEachChild(PRIORITY_INDEX,function(key,tree){self_1.remember(new Path(key),tree);});return this.forget(path);}}else if(this.children_!==null){var childKey=path.getFront();path=path.popFront();if(this.children_.contains(childKey)){var safeToRemove=this.children_.get(childKey).forget(path);if(safeToRemove){this.children_.remove(childKey);}}if(this.children_.isEmpty()){this.children_=null;return true;}else{return false;}}else{return true;}}};/**
     * Recursively iterates through all of the stored tree and calls the
     * callback on each one.
     *
     * @param {!Path} prefixPath Path to look up node for.
     * @param {!Function} func The function to invoke for each tree.
     */SparseSnapshotTree.prototype.forEachTree=function(prefixPath,func){if(this.value_!==null){func(prefixPath,this.value_);}else{this.forEachChild(function(key,tree){var path=new Path(prefixPath.toString()+'/'+key);tree.forEachTree(path,func);});}};/**
     * Iterates through each immediate child and triggers the callback.
     *
     * @param {!Function} func The function to invoke for each child.
     */SparseSnapshotTree.prototype.forEachChild=function(func){if(this.children_!==null){this.children_.each(function(key,tree){func(key,tree);});}};return SparseSnapshotTree;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Generate placeholders for deferred values.
 * @param {?Object} values
 * @return {!Object}
 */var generateWithValues=function(values){values=values||{};values['timestamp']=values['timestamp']||new Date().getTime();return values;};/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 * @param {(Object|string|number|boolean)} value
 * @param {!Object} serverValues
 * @return {!(string|number|boolean)}
 */var resolveDeferredValue=function(value,serverValues){if(!value||typeof value!=='object'){return value;}else{util.assert('.sv'in value,'Unexpected leaf node or priority contents');return serverValues[value['.sv']];}};/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param {!SparseSnapshotTree} tree
 * @param {!Object} serverValues
 * @return {!SparseSnapshotTree}
 */var resolveDeferredValueTree=function(tree,serverValues){var resolvedTree=new SparseSnapshotTree();tree.forEachTree(new Path(''),function(path,node){resolvedTree.remember(path,resolveDeferredValueSnapshot(node,serverValues));});return resolvedTree;};/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 * @param {!Node} node
 * @param {!Object} serverValues
 * @return {!Node}
 */var resolveDeferredValueSnapshot=function(node,serverValues){var rawPri=node.getPriority().val();var priority=resolveDeferredValue(rawPri,serverValues);var newNode;if(node.isLeafNode()){var leafNode=node;var value=resolveDeferredValue(leafNode.getValue(),serverValues);if(value!==leafNode.getValue()||priority!==leafNode.getPriority().val()){return new LeafNode(value,nodeFromJSON$1(priority));}else{return node;}}else{var childrenNode=node;newNode=childrenNode;if(priority!==childrenNode.getPriority().val()){newNode=newNode.updatePriority(new LeafNode(priority));}childrenNode.forEachChild(PRIORITY_INDEX,function(childName,childNode){var newChildNode=resolveDeferredValueSnapshot(childNode,serverValues);if(newChildNode!==childNode){newNode=newNode.updateImmediateChild(childName,newChildNode);}});return newNode;}};/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 *
 * @enum
 */var OperationType;(function(OperationType){OperationType[OperationType["OVERWRITE"]=0]="OVERWRITE";OperationType[OperationType["MERGE"]=1]="MERGE";OperationType[OperationType["ACK_USER_WRITE"]=2]="ACK_USER_WRITE";OperationType[OperationType["LISTEN_COMPLETE"]=3]="LISTEN_COMPLETE";})(OperationType||(OperationType={}));/**
 * @param {boolean} fromUser
 * @param {boolean} fromServer
 * @param {?string} queryId
 * @param {boolean} tagged
 * @constructor
 */var OperationSource=/** @class */function(){function OperationSource(fromUser,fromServer,queryId,tagged){this.fromUser=fromUser;this.fromServer=fromServer;this.queryId=queryId;this.tagged=tagged;util.assert(!tagged||fromServer,'Tagged queries must be from server.');}/**
     * @const
     * @type {!OperationSource}
     */OperationSource.User=new OperationSource(/*fromUser=*/true,false,null,/*tagged=*/false);/**
     * @const
     * @type {!OperationSource}
     */OperationSource.Server=new OperationSource(false,/*fromServer=*/true,null,/*tagged=*/false);/**
     * @param {string} queryId
     * @return {!OperationSource}
     */OperationSource.forServerTaggedQuery=function(queryId){return new OperationSource(false,/*fromServer=*/true,queryId,/*tagged=*/true);};return OperationSource;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var AckUserWrite=/** @class */function(){/**
     *
     * @param {!Path} path
     * @param {!ImmutableTree<!boolean>} affectedTree A tree containing true for each affected path. Affected paths can't overlap.
     * @param {!boolean} revert
     */function AckUserWrite(/**@inheritDoc */path,/**@inheritDoc */affectedTree,/**@inheritDoc */revert){this.path=path;this.affectedTree=affectedTree;this.revert=revert;/** @inheritDoc */this.type=OperationType.ACK_USER_WRITE;/** @inheritDoc */this.source=OperationSource.User;}/**
     * @inheritDoc
     */AckUserWrite.prototype.operationForChild=function(childName){if(!this.path.isEmpty()){util.assert(this.path.getFront()===childName,'operationForChild called for unrelated child.');return new AckUserWrite(this.path.popFront(),this.affectedTree,this.revert);}else if(this.affectedTree.value!=null){util.assert(this.affectedTree.children.isEmpty(),'affectedTree should not have overlapping affected paths.');// All child locations are affected as well; just return same operation.
return this;}else{var childTree=this.affectedTree.subtree(new Path(childName));return new AckUserWrite(Path.Empty,childTree,this.revert);}};return AckUserWrite;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var emptyChildrenSingleton;/**
 * Singleton empty children collection.
 *
 * @const
 * @type {!SortedMap.<string, !ImmutableTree.<?>>}
 */var EmptyChildren=function(){if(!emptyChildrenSingleton){emptyChildrenSingleton=new SortedMap(stringCompare);}return emptyChildrenSingleton;};/**
 * A tree with immutable elements.
 */var ImmutableTree=/** @class */function(){/**
     * @template T
     * @param {?T} value
     * @param {SortedMap.<string, !ImmutableTree.<T>>=} children
     */function ImmutableTree(value,children){if(children===void 0){children=EmptyChildren();}this.value=value;this.children=children;}/**
     * @template T
     * @param {!Object.<string, !T>} obj
     * @return {!ImmutableTree.<!T>}
     */ImmutableTree.fromObject=function(obj){var tree=ImmutableTree.Empty;util.forEach(obj,function(childPath,childSnap){tree=tree.set(new Path(childPath),childSnap);});return tree;};/**
     * True if the value is empty and there are no children
     * @return {boolean}
     */ImmutableTree.prototype.isEmpty=function(){return this.value===null&&this.children.isEmpty();};/**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects
     * on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param {!Path} relativePath The remainder of the path
     * @param {function(T):boolean} predicate The predicate to satisfy to return a
     *   node
     * @return {?{path:!Path, value:!T}}
     */ImmutableTree.prototype.findRootMostMatchingPathAndValue=function(relativePath,predicate){if(this.value!=null&&predicate(this.value)){return{path:Path.Empty,value:this.value};}else{if(relativePath.isEmpty()){return null;}else{var front=relativePath.getFront();var child=this.children.get(front);if(child!==null){var childExistingPathAndValue=child.findRootMostMatchingPathAndValue(relativePath.popFront(),predicate);if(childExistingPathAndValue!=null){var fullPath=new Path(front).child(childExistingPathAndValue.path);return{path:fullPath,value:childExistingPathAndValue.value};}else{return null;}}else{return null;}}}};/**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     * @param {!Path} relativePath
     * @return {?{path: !Path, value: !T}}
     */ImmutableTree.prototype.findRootMostValueAndPath=function(relativePath){return this.findRootMostMatchingPathAndValue(relativePath,function(){return true;});};/**
     * @param {!Path} relativePath
     * @return {!ImmutableTree.<T>} The subtree at the given path
     */ImmutableTree.prototype.subtree=function(relativePath){if(relativePath.isEmpty()){return this;}else{var front=relativePath.getFront();var childTree=this.children.get(front);if(childTree!==null){return childTree.subtree(relativePath.popFront());}else{return ImmutableTree.Empty;}}};/**
     * Sets a value at the specified path.
     *
     * @param {!Path} relativePath Path to set value at.
     * @param {?T} toSet Value to set.
     * @return {!ImmutableTree.<T>} Resulting tree.
     */ImmutableTree.prototype.set=function(relativePath,toSet){if(relativePath.isEmpty()){return new ImmutableTree(toSet,this.children);}else{var front=relativePath.getFront();var child=this.children.get(front)||ImmutableTree.Empty;var newChild=child.set(relativePath.popFront(),toSet);var newChildren=this.children.insert(front,newChild);return new ImmutableTree(this.value,newChildren);}};/**
     * Removes the value at the specified path.
     *
     * @param {!Path} relativePath Path to value to remove.
     * @return {!ImmutableTree.<T>} Resulting tree.
     */ImmutableTree.prototype.remove=function(relativePath){if(relativePath.isEmpty()){if(this.children.isEmpty()){return ImmutableTree.Empty;}else{return new ImmutableTree(null,this.children);}}else{var front=relativePath.getFront();var child=this.children.get(front);if(child){var newChild=child.remove(relativePath.popFront());var newChildren=void 0;if(newChild.isEmpty()){newChildren=this.children.remove(front);}else{newChildren=this.children.insert(front,newChild);}if(this.value===null&&newChildren.isEmpty()){return ImmutableTree.Empty;}else{return new ImmutableTree(this.value,newChildren);}}else{return this;}}};/**
     * Gets a value from the tree.
     *
     * @param {!Path} relativePath Path to get value for.
     * @return {?T} Value at path, or null.
     */ImmutableTree.prototype.get=function(relativePath){if(relativePath.isEmpty()){return this.value;}else{var front=relativePath.getFront();var child=this.children.get(front);if(child){return child.get(relativePath.popFront());}else{return null;}}};/**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param {!Path} relativePath Path to replace subtree for.
     * @param {!ImmutableTree} newTree New tree.
     * @return {!ImmutableTree} Resulting tree.
     */ImmutableTree.prototype.setTree=function(relativePath,newTree){if(relativePath.isEmpty()){return newTree;}else{var front=relativePath.getFront();var child=this.children.get(front)||ImmutableTree.Empty;var newChild=child.setTree(relativePath.popFront(),newTree);var newChildren=void 0;if(newChild.isEmpty()){newChildren=this.children.remove(front);}else{newChildren=this.children.insert(front,newChild);}return new ImmutableTree(this.value,newChildren);}};/**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     * @template V
     * @param {function(Path, ?T, Object.<string, V>):V} fn
     * @return {V}
     */ImmutableTree.prototype.fold=function(fn){return this.fold_(Path.Empty,fn);};/**
     * Recursive helper for public-facing fold() method
     * @template V
     * @param {!Path} pathSoFar
     * @param {function(Path, ?T, Object.<string, V>):V} fn
     * @return {V}
     * @private
     */ImmutableTree.prototype.fold_=function(pathSoFar,fn){var accum={};this.children.inorderTraversal(function(childKey,childTree){accum[childKey]=childTree.fold_(pathSoFar.child(childKey),fn);});return fn(pathSoFar,this.value,accum);};/**
     * Find the first matching value on the given path. Return the result of applying f to it.
     * @template V
     * @param {!Path} path
     * @param {!function(!Path, !T):?V} f
     * @return {?V}
     */ImmutableTree.prototype.findOnPath=function(path,f){return this.findOnPath_(path,Path.Empty,f);};ImmutableTree.prototype.findOnPath_=function(pathToFollow,pathSoFar,f){var result=this.value?f(pathSoFar,this.value):false;if(result){return result;}else{if(pathToFollow.isEmpty()){return null;}else{var front=pathToFollow.getFront();var nextChild=this.children.get(front);if(nextChild){return nextChild.findOnPath_(pathToFollow.popFront(),pathSoFar.child(front),f);}else{return null;}}}};/**
     *
     * @param {!Path} path
     * @param {!function(!Path, !T)} f
     * @returns {!ImmutableTree.<T>}
     */ImmutableTree.prototype.foreachOnPath=function(path,f){return this.foreachOnPath_(path,Path.Empty,f);};ImmutableTree.prototype.foreachOnPath_=function(pathToFollow,currentRelativePath,f){if(pathToFollow.isEmpty()){return this;}else{if(this.value){f(currentRelativePath,this.value);}var front=pathToFollow.getFront();var nextChild=this.children.get(front);if(nextChild){return nextChild.foreachOnPath_(pathToFollow.popFront(),currentRelativePath.child(front),f);}else{return ImmutableTree.Empty;}}};/**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param {function(!Path, !T)} f A function to be called with
     *   the path from the root of the tree to a node, and the value at that node.
     *   Called in depth-first order.
     */ImmutableTree.prototype.foreach=function(f){this.foreach_(Path.Empty,f);};ImmutableTree.prototype.foreach_=function(currentRelativePath,f){this.children.inorderTraversal(function(childName,childTree){childTree.foreach_(currentRelativePath.child(childName),f);});if(this.value){f(currentRelativePath,this.value);}};/**
     *
     * @param {function(string, !T)} f
     */ImmutableTree.prototype.foreachChild=function(f){this.children.inorderTraversal(function(childName,childTree){if(childTree.value){f(childName,childTree.value);}});};ImmutableTree.Empty=new ImmutableTree(null);return ImmutableTree;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @constructor
 * @implements {Operation}
 */var ListenComplete=/** @class */function(){function ListenComplete(source,path){this.source=source;this.path=path;/** @inheritDoc */this.type=OperationType.LISTEN_COMPLETE;}ListenComplete.prototype.operationForChild=function(childName){if(this.path.isEmpty()){return new ListenComplete(this.source,Path.Empty);}else{return new ListenComplete(this.source,this.path.popFront());}};return ListenComplete;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @param {!Node} snap
 * @constructor
 * @implements {Operation}
 */var Overwrite=/** @class */function(){function Overwrite(source,path,snap){this.source=source;this.path=path;this.snap=snap;/** @inheritDoc */this.type=OperationType.OVERWRITE;}Overwrite.prototype.operationForChild=function(childName){if(this.path.isEmpty()){return new Overwrite(this.source,Path.Empty,this.snap.getImmediateChild(childName));}else{return new Overwrite(this.source,this.path.popFront(),this.snap);}};return Overwrite;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @param {!ImmutableTree.<!Node>} children
 * @constructor
 * @implements {Operation}
 */var Merge=/** @class */function(){function Merge(/**@inheritDoc */source,/**@inheritDoc */path,/**@inheritDoc */children){this.source=source;this.path=path;this.children=children;/** @inheritDoc */this.type=OperationType.MERGE;}/**
     * @inheritDoc
     */Merge.prototype.operationForChild=function(childName){if(this.path.isEmpty()){var childTree=this.children.subtree(new Path(childName));if(childTree.isEmpty()){// This child is unaffected
return null;}else if(childTree.value){// We have a snapshot for the child in question.  This becomes an overwrite of the child.
return new Overwrite(this.source,Path.Empty,childTree.value);}else{// This is a merge at a deeper level
return new Merge(this.source,Path.Empty,childTree);}}else{util.assert(this.path.getFront()===childName,"Can't get a merge for a child not on the path of the operation");return new Merge(this.source,this.path.popFront(),this.children);}};/**
     * @inheritDoc
     */Merge.prototype.toString=function(){return'Operation('+this.path+': '+this.source.toString()+' merge: '+this.children.toString()+')';};return Merge;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully
 * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.
 * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks
 * whether a node potentially had children removed due to a filter.
 */var CacheNode=/** @class */function(){/**
     * @param {!Node} node_
     * @param {boolean} fullyInitialized_
     * @param {boolean} filtered_
     */function CacheNode(node_,fullyInitialized_,filtered_){this.node_=node_;this.fullyInitialized_=fullyInitialized_;this.filtered_=filtered_;}/**
     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
     * @return {boolean}
     */CacheNode.prototype.isFullyInitialized=function(){return this.fullyInitialized_;};/**
     * Returns whether this node is potentially missing children due to a filter applied to the node
     * @return {boolean}
     */CacheNode.prototype.isFiltered=function(){return this.filtered_;};/**
     * @param {!Path} path
     * @return {boolean}
     */CacheNode.prototype.isCompleteForPath=function(path){if(path.isEmpty()){return this.isFullyInitialized()&&!this.filtered_;}var childKey=path.getFront();return this.isCompleteForChild(childKey);};/**
     * @param {!string} key
     * @return {boolean}
     */CacheNode.prototype.isCompleteForChild=function(key){return this.isFullyInitialized()&&!this.filtered_||this.node_.hasChild(key);};/**
     * @return {!Node}
     */CacheNode.prototype.getNode=function(){return this.node_;};return CacheNode;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Stores the data we have cached for a view.
 *
 * serverSnap is the cached server data, eventSnap is the cached event data (server data plus any local writes).
 *
 * @constructor
 */var ViewCache=/** @class */function(){/**
     *
     * @param {!CacheNode} eventCache_
     * @param {!CacheNode} serverCache_
     */function ViewCache(eventCache_,serverCache_){this.eventCache_=eventCache_;this.serverCache_=serverCache_;}/**
     * @param {!Node} eventSnap
     * @param {boolean} complete
     * @param {boolean} filtered
     * @return {!ViewCache}
     */ViewCache.prototype.updateEventSnap=function(eventSnap,complete,filtered){return new ViewCache(new CacheNode(eventSnap,complete,filtered),this.serverCache_);};/**
     * @param {!Node} serverSnap
     * @param {boolean} complete
     * @param {boolean} filtered
     * @return {!ViewCache}
     */ViewCache.prototype.updateServerSnap=function(serverSnap,complete,filtered){return new ViewCache(this.eventCache_,new CacheNode(serverSnap,complete,filtered));};/**
     * @return {!CacheNode}
     */ViewCache.prototype.getEventCache=function(){return this.eventCache_;};/**
     * @return {?Node}
     */ViewCache.prototype.getCompleteEventSnap=function(){return this.eventCache_.isFullyInitialized()?this.eventCache_.getNode():null;};/**
     * @return {!CacheNode}
     */ViewCache.prototype.getServerCache=function(){return this.serverCache_;};/**
     * @return {?Node}
     */ViewCache.prototype.getCompleteServerSnap=function(){return this.serverCache_.isFullyInitialized()?this.serverCache_.getNode():null;};/**
     * @const
     * @type {ViewCache}
     */ViewCache.Empty=new ViewCache(new CacheNode(ChildrenNode.EMPTY_NODE,/*fullyInitialized=*/false,/*filtered=*/false),new CacheNode(ChildrenNode.EMPTY_NODE,/*fullyInitialized=*/false,/*filtered=*/false));return ViewCache;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @constructor
 * @struct
 * @param {!string} type The event type
 * @param {!Node} snapshotNode The data
 * @param {string=} childName The name for this child, if it's a child event
 * @param {Node=} oldSnap Used for intermediate processing of child changed events
 * @param {string=} prevName The name for the previous child, if applicable
 */var Change=/** @class */function(){function Change(type,snapshotNode,childName,oldSnap,prevName){this.type=type;this.snapshotNode=snapshotNode;this.childName=childName;this.oldSnap=oldSnap;this.prevName=prevName;}/**
     * @param {!Node} snapshot
     * @return {!Change}
     */Change.valueChange=function(snapshot){return new Change(Change.VALUE,snapshot);};/**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */Change.childAddedChange=function(childKey,snapshot){return new Change(Change.CHILD_ADDED,snapshot,childKey);};/**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */Change.childRemovedChange=function(childKey,snapshot){return new Change(Change.CHILD_REMOVED,snapshot,childKey);};/**
     * @param {string} childKey
     * @param {!Node} newSnapshot
     * @param {!Node} oldSnapshot
     * @return {!Change}
     */Change.childChangedChange=function(childKey,newSnapshot,oldSnapshot){return new Change(Change.CHILD_CHANGED,newSnapshot,childKey,oldSnapshot);};/**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */Change.childMovedChange=function(childKey,snapshot){return new Change(Change.CHILD_MOVED,snapshot,childKey);};//event types
/** Event type for a child added */Change.CHILD_ADDED='child_added';/** Event type for a child removed */Change.CHILD_REMOVED='child_removed';/** Event type for a child changed */Change.CHILD_CHANGED='child_changed';/** Event type for a child moved */Change.CHILD_MOVED='child_moved';/** Event type for a value change */Change.VALUE='value';return Change;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 *
 * @constructor
 * @implements {NodeFilter}
 * @param {!Index} index
 */var IndexedFilter=/** @class */function(){function IndexedFilter(index_){this.index_=index_;}IndexedFilter.prototype.updateChild=function(snap,key,newChild,affectedPath,source,optChangeAccumulator){util.assert(snap.isIndexed(this.index_),'A node must be indexed if only a child is updated');var oldChild=snap.getImmediateChild(key);// Check if anything actually changed.
if(oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))){// There's an edge case where a child can enter or leave the view because affectedPath was set to null.
// In this case, affectedPath will appear null in both the old and new snapshots.  So we need
// to avoid treating these cases as "nothing changed."
if(oldChild.isEmpty()==newChild.isEmpty()){// Nothing changed.
// This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
//assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
return snap;}}if(optChangeAccumulator!=null){if(newChild.isEmpty()){if(snap.hasChild(key)){optChangeAccumulator.trackChildChange(Change.childRemovedChange(key,oldChild));}else{util.assert(snap.isLeafNode(),'A child remove without an old child only makes sense on a leaf node');}}else if(oldChild.isEmpty()){optChangeAccumulator.trackChildChange(Change.childAddedChange(key,newChild));}else{optChangeAccumulator.trackChildChange(Change.childChangedChange(key,newChild,oldChild));}}if(snap.isLeafNode()&&newChild.isEmpty()){return snap;}else{// Make sure the node is indexed
return snap.updateImmediateChild(key,newChild).withIndex(this.index_);}};/**
     * @inheritDoc
     */IndexedFilter.prototype.updateFullNode=function(oldSnap,newSnap,optChangeAccumulator){if(optChangeAccumulator!=null){if(!oldSnap.isLeafNode()){oldSnap.forEachChild(PRIORITY_INDEX,function(key,childNode){if(!newSnap.hasChild(key)){optChangeAccumulator.trackChildChange(Change.childRemovedChange(key,childNode));}});}if(!newSnap.isLeafNode()){newSnap.forEachChild(PRIORITY_INDEX,function(key,childNode){if(oldSnap.hasChild(key)){var oldChild=oldSnap.getImmediateChild(key);if(!oldChild.equals(childNode)){optChangeAccumulator.trackChildChange(Change.childChangedChange(key,childNode,oldChild));}}else{optChangeAccumulator.trackChildChange(Change.childAddedChange(key,childNode));}});}}return newSnap.withIndex(this.index_);};/**
     * @inheritDoc
     */IndexedFilter.prototype.updatePriority=function(oldSnap,newPriority){if(oldSnap.isEmpty()){return ChildrenNode.EMPTY_NODE;}else{return oldSnap.updatePriority(newPriority);}};/**
     * @inheritDoc
     */IndexedFilter.prototype.filtersNodes=function(){return false;};/**
     * @inheritDoc
     */IndexedFilter.prototype.getIndexedFilter=function(){return this;};/**
     * @inheritDoc
     */IndexedFilter.prototype.getIndex=function(){return this.index_;};return IndexedFilter;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @constructor
 */var ChildChangeAccumulator=/** @class */function(){function ChildChangeAccumulator(){this.changeMap_={};}/**
     * @param {!Change} change
     */ChildChangeAccumulator.prototype.trackChildChange=function(change){var type=change.type;var childKey/** @type {!string} */=change.childName;util.assert(type==Change.CHILD_ADDED||type==Change.CHILD_CHANGED||type==Change.CHILD_REMOVED,'Only child changes supported for tracking');util.assert(childKey!=='.priority','Only non-priority child changes can be tracked.');var oldChange=util.safeGet(this.changeMap_,childKey);if(oldChange){var oldType=oldChange.type;if(type==Change.CHILD_ADDED&&oldType==Change.CHILD_REMOVED){this.changeMap_[childKey]=Change.childChangedChange(childKey,change.snapshotNode,oldChange.snapshotNode);}else if(type==Change.CHILD_REMOVED&&oldType==Change.CHILD_ADDED){delete this.changeMap_[childKey];}else if(type==Change.CHILD_REMOVED&&oldType==Change.CHILD_CHANGED){this.changeMap_[childKey]=Change.childRemovedChange(childKey,oldChange.oldSnap);}else if(type==Change.CHILD_CHANGED&&oldType==Change.CHILD_ADDED){this.changeMap_[childKey]=Change.childAddedChange(childKey,change.snapshotNode);}else if(type==Change.CHILD_CHANGED&&oldType==Change.CHILD_CHANGED){this.changeMap_[childKey]=Change.childChangedChange(childKey,change.snapshotNode,oldChange.oldSnap);}else{throw util.assertionError('Illegal combination of changes: '+change+' occurred after '+oldChange);}}else{this.changeMap_[childKey]=change;}};/**
     * @return {!Array.<!Change>}
     */ChildChangeAccumulator.prototype.getChanges=function(){return util.getValues(this.changeMap_);};return ChildChangeAccumulator;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An implementation of CompleteChildSource that never returns any additional children
 *
 * @private
 * @constructor
 * @implements CompleteChildSource
 */var NoCompleteChildSource_=/** @class */function(){function NoCompleteChildSource_(){}/**
     * @inheritDoc
     */NoCompleteChildSource_.prototype.getCompleteChild=function(childKey){return null;};/**
     * @inheritDoc
     */NoCompleteChildSource_.prototype.getChildAfterChild=function(index,child,reverse){return null;};return NoCompleteChildSource_;}();/**
 * Singleton instance.
 * @const
 * @type {!CompleteChildSource}
 */var NO_COMPLETE_CHILD_SOURCE=new NoCompleteChildSource_();/**
 * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or
 * old event caches available to calculate complete children.
 *
 *
 * @implements CompleteChildSource
 */var WriteTreeCompleteChildSource=/** @class */function(){/**
     * @param {!WriteTreeRef} writes_
     * @param {!ViewCache} viewCache_
     * @param {?Node} optCompleteServerCache_
     */function WriteTreeCompleteChildSource(writes_,viewCache_,optCompleteServerCache_){if(optCompleteServerCache_===void 0){optCompleteServerCache_=null;}this.writes_=writes_;this.viewCache_=viewCache_;this.optCompleteServerCache_=optCompleteServerCache_;}/**
     * @inheritDoc
     */WriteTreeCompleteChildSource.prototype.getCompleteChild=function(childKey){var node=this.viewCache_.getEventCache();if(node.isCompleteForChild(childKey)){return node.getNode().getImmediateChild(childKey);}else{var serverNode=this.optCompleteServerCache_!=null?new CacheNode(this.optCompleteServerCache_,true,false):this.viewCache_.getServerCache();return this.writes_.calcCompleteChild(childKey,serverNode);}};/**
     * @inheritDoc
     */WriteTreeCompleteChildSource.prototype.getChildAfterChild=function(index,child,reverse){var completeServerData=this.optCompleteServerCache_!=null?this.optCompleteServerCache_:this.viewCache_.getCompleteServerSnap();var nodes=this.writes_.calcIndexedSlice(completeServerData,child,1,reverse,index);if(nodes.length===0){return null;}else{return nodes[0];}};return WriteTreeCompleteChildSource;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @constructor
 * @struct
 */var ProcessorResult=/** @class */function(){/**
     * @param {!ViewCache} viewCache
     * @param {!Array.<!Change>} changes
     */function ProcessorResult(viewCache,changes){this.viewCache=viewCache;this.changes=changes;}return ProcessorResult;}();/**
 * @constructor
 */var ViewProcessor=/** @class */function(){/**
     * @param {!NodeFilter} filter_
     */function ViewProcessor(filter_){this.filter_=filter_;}/**
     * @param {!ViewCache} viewCache
     */ViewProcessor.prototype.assertIndexed=function(viewCache){util.assert(viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()),'Event snap not indexed');util.assert(viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()),'Server snap not indexed');};/**
     * @param {!ViewCache} oldViewCache
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @return {!ProcessorResult}
     */ViewProcessor.prototype.applyOperation=function(oldViewCache,operation,writesCache,completeCache){var accumulator=new ChildChangeAccumulator();var newViewCache,filterServerNode;if(operation.type===OperationType.OVERWRITE){var overwrite=operation;if(overwrite.source.fromUser){newViewCache=this.applyUserOverwrite_(oldViewCache,overwrite.path,overwrite.snap,writesCache,completeCache,accumulator);}else{util.assert(overwrite.source.fromServer,'Unknown source.');// We filter the node if it's a tagged update or the node has been previously filtered  and the
// update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
// again
filterServerNode=overwrite.source.tagged||oldViewCache.getServerCache().isFiltered()&&!overwrite.path.isEmpty();newViewCache=this.applyServerOverwrite_(oldViewCache,overwrite.path,overwrite.snap,writesCache,completeCache,filterServerNode,accumulator);}}else if(operation.type===OperationType.MERGE){var merge=operation;if(merge.source.fromUser){newViewCache=this.applyUserMerge_(oldViewCache,merge.path,merge.children,writesCache,completeCache,accumulator);}else{util.assert(merge.source.fromServer,'Unknown source.');// We filter the node if it's a tagged update or the node has been previously filtered
filterServerNode=merge.source.tagged||oldViewCache.getServerCache().isFiltered();newViewCache=this.applyServerMerge_(oldViewCache,merge.path,merge.children,writesCache,completeCache,filterServerNode,accumulator);}}else if(operation.type===OperationType.ACK_USER_WRITE){var ackUserWrite=operation;if(!ackUserWrite.revert){newViewCache=this.ackUserWrite_(oldViewCache,ackUserWrite.path,ackUserWrite.affectedTree,writesCache,completeCache,accumulator);}else{newViewCache=this.revertUserWrite_(oldViewCache,ackUserWrite.path,writesCache,completeCache,accumulator);}}else if(operation.type===OperationType.LISTEN_COMPLETE){newViewCache=this.listenComplete_(oldViewCache,operation.path,writesCache,accumulator);}else{throw util.assertionError('Unknown operation type: '+operation.type);}var changes=accumulator.getChanges();ViewProcessor.maybeAddValueEvent_(oldViewCache,newViewCache,changes);return new ProcessorResult(newViewCache,changes);};/**
     * @param {!ViewCache} oldViewCache
     * @param {!ViewCache} newViewCache
     * @param {!Array.<!Change>} accumulator
     * @private
     */ViewProcessor.maybeAddValueEvent_=function(oldViewCache,newViewCache,accumulator){var eventSnap=newViewCache.getEventCache();if(eventSnap.isFullyInitialized()){var isLeafOrEmpty=eventSnap.getNode().isLeafNode()||eventSnap.getNode().isEmpty();var oldCompleteSnap=oldViewCache.getCompleteEventSnap();if(accumulator.length>0||!oldViewCache.getEventCache().isFullyInitialized()||isLeafOrEmpty&&!eventSnap.getNode().equals(/** @type {!Node} */oldCompleteSnap)||!eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())){accumulator.push(Change.valueChange(/** @type {!Node} */newViewCache.getCompleteEventSnap()));}}};/**
     * @param {!ViewCache} viewCache
     * @param {!Path} changePath
     * @param {!WriteTreeRef} writesCache
     * @param {!CompleteChildSource} source
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */ViewProcessor.prototype.generateEventCacheAfterServerEvent_=function(viewCache,changePath,writesCache,source,accumulator){var oldEventSnap=viewCache.getEventCache();if(writesCache.shadowingWrite(changePath)!=null){// we have a shadowing write, ignore changes
return viewCache;}else{var newEventCache=void 0,serverNode=void 0;if(changePath.isEmpty()){// TODO: figure out how this plays with "sliding ack windows"
util.assert(viewCache.getServerCache().isFullyInitialized(),'If change path is empty, we must have complete server data');if(viewCache.getServerCache().isFiltered()){// We need to special case this, because we need to only apply writes to complete children, or
// we might end up raising events for incomplete children. If the server data is filtered deep
// writes cannot be guaranteed to be complete
var serverCache=viewCache.getCompleteServerSnap();var completeChildren=serverCache instanceof ChildrenNode?serverCache:ChildrenNode.EMPTY_NODE;var completeEventChildren=writesCache.calcCompleteEventChildren(completeChildren);newEventCache=this.filter_.updateFullNode(viewCache.getEventCache().getNode(),completeEventChildren,accumulator);}else{var completeNode=writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());newEventCache=this.filter_.updateFullNode(viewCache.getEventCache().getNode(),completeNode,accumulator);}}else{var childKey=changePath.getFront();if(childKey=='.priority'){util.assert(changePath.getLength()==1,"Can't have a priority with additional path components");var oldEventNode=oldEventSnap.getNode();serverNode=viewCache.getServerCache().getNode();// we might have overwrites for this priority
var updatedPriority=writesCache.calcEventCacheAfterServerOverwrite(changePath,oldEventNode,serverNode);if(updatedPriority!=null){newEventCache=this.filter_.updatePriority(oldEventNode,updatedPriority);}else{// priority didn't change, keep old node
newEventCache=oldEventSnap.getNode();}}else{var childChangePath=changePath.popFront();// update child
var newEventChild=void 0;if(oldEventSnap.isCompleteForChild(childKey)){serverNode=viewCache.getServerCache().getNode();var eventChildUpdate=writesCache.calcEventCacheAfterServerOverwrite(changePath,oldEventSnap.getNode(),serverNode);if(eventChildUpdate!=null){newEventChild=oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath,eventChildUpdate);}else{// Nothing changed, just keep the old child
newEventChild=oldEventSnap.getNode().getImmediateChild(childKey);}}else{newEventChild=writesCache.calcCompleteChild(childKey,viewCache.getServerCache());}if(newEventChild!=null){newEventCache=this.filter_.updateChild(oldEventSnap.getNode(),childKey,newEventChild,childChangePath,source,accumulator);}else{// no complete child available or no change
newEventCache=oldEventSnap.getNode();}}}return viewCache.updateEventSnap(newEventCache,oldEventSnap.isFullyInitialized()||changePath.isEmpty(),this.filter_.filtersNodes());}};/**
     * @param {!ViewCache} oldViewCache
     * @param {!Path} changePath
     * @param {!Node} changedSnap
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {boolean} filterServerNode
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */ViewProcessor.prototype.applyServerOverwrite_=function(oldViewCache,changePath,changedSnap,writesCache,completeCache,filterServerNode,accumulator){var oldServerSnap=oldViewCache.getServerCache();var newServerCache;var serverFilter=filterServerNode?this.filter_:this.filter_.getIndexedFilter();if(changePath.isEmpty()){newServerCache=serverFilter.updateFullNode(oldServerSnap.getNode(),changedSnap,null);}else if(serverFilter.filtersNodes()&&!oldServerSnap.isFiltered()){// we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
var newServerNode=oldServerSnap.getNode().updateChild(changePath,changedSnap);newServerCache=serverFilter.updateFullNode(oldServerSnap.getNode(),newServerNode,null);}else{var childKey=changePath.getFront();if(!oldServerSnap.isCompleteForPath(changePath)&&changePath.getLength()>1){// We don't update incomplete nodes with updates intended for other listeners
return oldViewCache;}var childChangePath=changePath.popFront();var childNode=oldServerSnap.getNode().getImmediateChild(childKey);var newChildNode=childNode.updateChild(childChangePath,changedSnap);if(childKey=='.priority'){newServerCache=serverFilter.updatePriority(oldServerSnap.getNode(),newChildNode);}else{newServerCache=serverFilter.updateChild(oldServerSnap.getNode(),childKey,newChildNode,childChangePath,NO_COMPLETE_CHILD_SOURCE,null);}}var newViewCache=oldViewCache.updateServerSnap(newServerCache,oldServerSnap.isFullyInitialized()||changePath.isEmpty(),serverFilter.filtersNodes());var source=new WriteTreeCompleteChildSource(writesCache,newViewCache,completeCache);return this.generateEventCacheAfterServerEvent_(newViewCache,changePath,writesCache,source,accumulator);};/**
     * @param {!ViewCache} oldViewCache
     * @param {!Path} changePath
     * @param {!Node} changedSnap
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */ViewProcessor.prototype.applyUserOverwrite_=function(oldViewCache,changePath,changedSnap,writesCache,completeCache,accumulator){var oldEventSnap=oldViewCache.getEventCache();var newViewCache,newEventCache;var source=new WriteTreeCompleteChildSource(writesCache,oldViewCache,completeCache);if(changePath.isEmpty()){newEventCache=this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(),changedSnap,accumulator);newViewCache=oldViewCache.updateEventSnap(newEventCache,true,this.filter_.filtersNodes());}else{var childKey=changePath.getFront();if(childKey==='.priority'){newEventCache=this.filter_.updatePriority(oldViewCache.getEventCache().getNode(),changedSnap);newViewCache=oldViewCache.updateEventSnap(newEventCache,oldEventSnap.isFullyInitialized(),oldEventSnap.isFiltered());}else{var childChangePath=changePath.popFront();var oldChild=oldEventSnap.getNode().getImmediateChild(childKey);var newChild=void 0;if(childChangePath.isEmpty()){// Child overwrite, we can replace the child
newChild=changedSnap;}else{var childNode=source.getCompleteChild(childKey);if(childNode!=null){if(childChangePath.getBack()==='.priority'&&childNode.getChild(childChangePath.parent()).isEmpty()){// This is a priority update on an empty node. If this node exists on the server, the
// server will send down the priority in the update, so ignore for now
newChild=childNode;}else{newChild=childNode.updateChild(childChangePath,changedSnap);}}else{// There is no complete child node available
newChild=ChildrenNode.EMPTY_NODE;}}if(!oldChild.equals(newChild)){var newEventSnap=this.filter_.updateChild(oldEventSnap.getNode(),childKey,newChild,childChangePath,source,accumulator);newViewCache=oldViewCache.updateEventSnap(newEventSnap,oldEventSnap.isFullyInitialized(),this.filter_.filtersNodes());}else{newViewCache=oldViewCache;}}}return newViewCache;};/**
     * @param {!ViewCache} viewCache
     * @param {string} childKey
     * @return {boolean}
     * @private
     */ViewProcessor.cacheHasChild_=function(viewCache,childKey){return viewCache.getEventCache().isCompleteForChild(childKey);};/**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {ImmutableTree.<!Node>} changedChildren
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */ViewProcessor.prototype.applyUserMerge_=function(viewCache,path,changedChildren,writesCache,serverCache,accumulator){var _this=this;// HACK: In the case of a limit query, there may be some changes that bump things out of the
// window leaving room for new items.  It's important we process these changes first, so we
// iterate the changes twice, first processing any that affect items currently in view.
// TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
// and event snap.  I'm not sure if this will result in edge cases when a child is in one but
// not the other.
var curViewCache=viewCache;changedChildren.foreach(function(relativePath,childNode){var writePath=path.child(relativePath);if(ViewProcessor.cacheHasChild_(viewCache,writePath.getFront())){curViewCache=_this.applyUserOverwrite_(curViewCache,writePath,childNode,writesCache,serverCache,accumulator);}});changedChildren.foreach(function(relativePath,childNode){var writePath=path.child(relativePath);if(!ViewProcessor.cacheHasChild_(viewCache,writePath.getFront())){curViewCache=_this.applyUserOverwrite_(curViewCache,writePath,childNode,writesCache,serverCache,accumulator);}});return curViewCache;};/**
     * @param {!Node} node
     * @param {ImmutableTree.<!Node>} merge
     * @return {!Node}
     * @private
     */ViewProcessor.prototype.applyMerge_=function(node,merge){merge.foreach(function(relativePath,childNode){node=node.updateChild(relativePath,childNode);});return node;};/**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!ImmutableTree.<!Node>} changedChildren
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache
     * @param {boolean} filterServerNode
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */ViewProcessor.prototype.applyServerMerge_=function(viewCache,path,changedChildren,writesCache,serverCache,filterServerNode,accumulator){var _this=this;// If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
// wait for the complete data update coming soon.
if(viewCache.getServerCache().getNode().isEmpty()&&!viewCache.getServerCache().isFullyInitialized()){return viewCache;}// HACK: In the case of a limit query, there may be some changes that bump things out of the
// window leaving room for new items.  It's important we process these changes first, so we
// iterate the changes twice, first processing any that affect items currently in view.
// TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
// and event snap.  I'm not sure if this will result in edge cases when a child is in one but
// not the other.
var curViewCache=viewCache;var viewMergeTree;if(path.isEmpty()){viewMergeTree=changedChildren;}else{viewMergeTree=ImmutableTree.Empty.setTree(path,changedChildren);}var serverNode=viewCache.getServerCache().getNode();viewMergeTree.children.inorderTraversal(function(childKey,childTree){if(serverNode.hasChild(childKey)){var serverChild=viewCache.getServerCache().getNode().getImmediateChild(childKey);var newChild=_this.applyMerge_(serverChild,childTree);curViewCache=_this.applyServerOverwrite_(curViewCache,new Path(childKey),newChild,writesCache,serverCache,filterServerNode,accumulator);}});viewMergeTree.children.inorderTraversal(function(childKey,childMergeTree){var isUnknownDeepMerge=!viewCache.getServerCache().isCompleteForChild(childKey)&&childMergeTree.value==null;if(!serverNode.hasChild(childKey)&&!isUnknownDeepMerge){var serverChild=viewCache.getServerCache().getNode().getImmediateChild(childKey);var newChild=_this.applyMerge_(serverChild,childMergeTree);curViewCache=_this.applyServerOverwrite_(curViewCache,new Path(childKey),newChild,writesCache,serverCache,filterServerNode,accumulator);}});return curViewCache;};/**
     * @param {!ViewCache} viewCache
     * @param {!Path} ackPath
     * @param {!ImmutableTree<!boolean>} affectedTree
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */ViewProcessor.prototype.ackUserWrite_=function(viewCache,ackPath,affectedTree,writesCache,completeCache,accumulator){if(writesCache.shadowingWrite(ackPath)!=null){return viewCache;}// Only filter server node if it is currently filtered
var filterServerNode=viewCache.getServerCache().isFiltered();// Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
// now that it won't be shadowed.
var serverCache=viewCache.getServerCache();if(affectedTree.value!=null){// This is an overwrite.
if(ackPath.isEmpty()&&serverCache.isFullyInitialized()||serverCache.isCompleteForPath(ackPath)){return this.applyServerOverwrite_(viewCache,ackPath,serverCache.getNode().getChild(ackPath),writesCache,completeCache,filterServerNode,accumulator);}else if(ackPath.isEmpty()){// This is a goofy edge case where we are acking data at this location but don't have full data.  We
// should just re-apply whatever we have in our cache as a merge.
var changedChildren_1=ImmutableTree.Empty;serverCache.getNode().forEachChild(KEY_INDEX,function(name,node){changedChildren_1=changedChildren_1.set(new Path(name),node);});return this.applyServerMerge_(viewCache,ackPath,changedChildren_1,writesCache,completeCache,filterServerNode,accumulator);}else{return viewCache;}}else{// This is a merge.
var changedChildren_2=ImmutableTree.Empty;affectedTree.foreach(function(mergePath,value){var serverCachePath=ackPath.child(mergePath);if(serverCache.isCompleteForPath(serverCachePath)){changedChildren_2=changedChildren_2.set(mergePath,serverCache.getNode().getChild(serverCachePath));}});return this.applyServerMerge_(viewCache,ackPath,changedChildren_2,writesCache,completeCache,filterServerNode,accumulator);}};/**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!WriteTreeRef} writesCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */ViewProcessor.prototype.listenComplete_=function(viewCache,path,writesCache,accumulator){var oldServerNode=viewCache.getServerCache();var newViewCache=viewCache.updateServerSnap(oldServerNode.getNode(),oldServerNode.isFullyInitialized()||path.isEmpty(),oldServerNode.isFiltered());return this.generateEventCacheAfterServerEvent_(newViewCache,path,writesCache,NO_COMPLETE_CHILD_SOURCE,accumulator);};/**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeServerCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */ViewProcessor.prototype.revertUserWrite_=function(viewCache,path,writesCache,completeServerCache,accumulator){var complete;if(writesCache.shadowingWrite(path)!=null){return viewCache;}else{var source=new WriteTreeCompleteChildSource(writesCache,viewCache,completeServerCache);var oldEventCache=viewCache.getEventCache().getNode();var newEventCache=void 0;if(path.isEmpty()||path.getFront()==='.priority'){var newNode=void 0;if(viewCache.getServerCache().isFullyInitialized()){newNode=writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());}else{var serverChildren=viewCache.getServerCache().getNode();util.assert(serverChildren instanceof ChildrenNode,'serverChildren would be complete if leaf node');newNode=writesCache.calcCompleteEventChildren(serverChildren);}newNode=newNode;newEventCache=this.filter_.updateFullNode(oldEventCache,newNode,accumulator);}else{var childKey=path.getFront();var newChild=writesCache.calcCompleteChild(childKey,viewCache.getServerCache());if(newChild==null&&viewCache.getServerCache().isCompleteForChild(childKey)){newChild=oldEventCache.getImmediateChild(childKey);}if(newChild!=null){newEventCache=this.filter_.updateChild(oldEventCache,childKey,newChild,path.popFront(),source,accumulator);}else if(viewCache.getEventCache().getNode().hasChild(childKey)){// No complete child available, delete the existing one, if any
newEventCache=this.filter_.updateChild(oldEventCache,childKey,ChildrenNode.EMPTY_NODE,path.popFront(),source,accumulator);}else{newEventCache=oldEventCache;}if(newEventCache.isEmpty()&&viewCache.getServerCache().isFullyInitialized()){// We might have reverted all child writes. Maybe the old event was a leaf node
complete=writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());if(complete.isLeafNode()){newEventCache=this.filter_.updateFullNode(newEventCache,complete,accumulator);}}}complete=viewCache.getServerCache().isFullyInitialized()||writesCache.shadowingWrite(Path.Empty)!=null;return viewCache.updateEventSnap(newEventCache,complete,this.filter_.filtersNodes());}};return ViewProcessor;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An EventGenerator is used to convert "raw" changes (Change) as computed by the
 * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()
 * for details.
 *
 * @constructor
 */var EventGenerator=/** @class */function(){/**
     *
     * @param {!Query} query_
     */function EventGenerator(query_){this.query_=query_;/**
         * @private
         * @type {!Index}
         */this.index_=this.query_.getQueryParams().getIndex();}/**
     * Given a set of raw changes (no moved events and prevName not specified yet), and a set of
     * EventRegistrations that should be notified of these changes, generate the actual events to be raised.
     *
     * Notes:
     *  - child_moved events will be synthesized at this time for any child_changed events that affect
     *    our index.
     *  - prevName will be calculated based on the index ordering.
     *
     * @param {!Array.<!Change>} changes
     * @param {!Node} eventCache
     * @param {!Array.<!EventRegistration>} eventRegistrations
     * @return {!Array.<!Event>}
     */EventGenerator.prototype.generateEventsForChanges=function(changes,eventCache,eventRegistrations){var _this=this;var events=[];var moves=[];changes.forEach(function(change){if(change.type===Change.CHILD_CHANGED&&_this.index_.indexedValueChanged(change.oldSnap,change.snapshotNode)){moves.push(Change.childMovedChange(change.childName,change.snapshotNode));}});this.generateEventsForType_(events,Change.CHILD_REMOVED,changes,eventRegistrations,eventCache);this.generateEventsForType_(events,Change.CHILD_ADDED,changes,eventRegistrations,eventCache);this.generateEventsForType_(events,Change.CHILD_MOVED,moves,eventRegistrations,eventCache);this.generateEventsForType_(events,Change.CHILD_CHANGED,changes,eventRegistrations,eventCache);this.generateEventsForType_(events,Change.VALUE,changes,eventRegistrations,eventCache);return events;};/**
     * Given changes of a single change type, generate the corresponding events.
     *
     * @param {!Array.<!Event>} events
     * @param {!string} eventType
     * @param {!Array.<!Change>} changes
     * @param {!Array.<!EventRegistration>} registrations
     * @param {!Node} eventCache
     * @private
     */EventGenerator.prototype.generateEventsForType_=function(events,eventType,changes,registrations,eventCache){var _this=this;var filteredChanges=changes.filter(function(change){return change.type===eventType;});filteredChanges.sort(this.compareChanges_.bind(this));filteredChanges.forEach(function(change){var materializedChange=_this.materializeSingleChange_(change,eventCache);registrations.forEach(function(registration){if(registration.respondsTo(change.type)){events.push(registration.createEvent(materializedChange,_this.query_));}});});};/**
     * @param {!Change} change
     * @param {!Node} eventCache
     * @return {!Change}
     * @private
     */EventGenerator.prototype.materializeSingleChange_=function(change,eventCache){if(change.type==='value'||change.type==='child_removed'){return change;}else{change.prevName=eventCache.getPredecessorChildName(/** @type {!string} */change.childName,change.snapshotNode,this.index_);return change;}};/**
     * @param {!Change} a
     * @param {!Change} b
     * @return {number}
     * @private
     */EventGenerator.prototype.compareChanges_=function(a,b){if(a.childName==null||b.childName==null){throw util.assertionError('Should only compare child_ events.');}var aWrapped=new NamedNode(a.childName,a.snapshotNode);var bWrapped=new NamedNode(b.childName,b.snapshotNode);return this.index_.compare(aWrapped,bWrapped);};return EventGenerator;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 * @constructor
 */var View=/** @class */function(){/**
     *
     * @param {!Query} query_
     * @param {!ViewCache} initialViewCache
     */function View(query_,initialViewCache){this.query_=query_;this.eventRegistrations_=[];var params=this.query_.getQueryParams();var indexFilter=new IndexedFilter(params.getIndex());var filter=params.getNodeFilter();/**
         * @type {ViewProcessor}
         * @private
         */this.processor_=new ViewProcessor(filter);var initialServerCache=initialViewCache.getServerCache();var initialEventCache=initialViewCache.getEventCache();// Don't filter server node with other filter than index, wait for tagged listen
var serverSnap=indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE,initialServerCache.getNode(),null);var eventSnap=filter.updateFullNode(ChildrenNode.EMPTY_NODE,initialEventCache.getNode(),null);var newServerCache=new CacheNode(serverSnap,initialServerCache.isFullyInitialized(),indexFilter.filtersNodes());var newEventCache=new CacheNode(eventSnap,initialEventCache.isFullyInitialized(),filter.filtersNodes());/**
         * @type {!ViewCache}
         * @private
         */this.viewCache_=new ViewCache(newEventCache,newServerCache);/**
         * @type {!EventGenerator}
         * @private
         */this.eventGenerator_=new EventGenerator(this.query_);}/**
     * @return {!Query}
     */View.prototype.getQuery=function(){return this.query_;};/**
     * @return {?Node}
     */View.prototype.getServerCache=function(){return this.viewCache_.getServerCache().getNode();};/**
     * @param {!Path} path
     * @return {?Node}
     */View.prototype.getCompleteServerCache=function(path){var cache=this.viewCache_.getCompleteServerSnap();if(cache){// If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
// we need to see if it contains the child we're interested in.
if(this.query_.getQueryParams().loadsAllData()||!path.isEmpty()&&!cache.getImmediateChild(path.getFront()).isEmpty()){return cache.getChild(path);}}return null;};/**
     * @return {boolean}
     */View.prototype.isEmpty=function(){return this.eventRegistrations_.length===0;};/**
     * @param {!EventRegistration} eventRegistration
     */View.prototype.addEventRegistration=function(eventRegistration){this.eventRegistrations_.push(eventRegistration);};/**
     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.
     */View.prototype.removeEventRegistration=function(eventRegistration,cancelError){var cancelEvents=[];if(cancelError){util.assert(eventRegistration==null,'A cancel should cancel all event registrations.');var path_1=this.query_.path;this.eventRegistrations_.forEach(function(registration){cancelError/** @type {!Error} */=cancelError;var maybeEvent=registration.createCancelEvent(cancelError,path_1);if(maybeEvent){cancelEvents.push(maybeEvent);}});}if(eventRegistration){var remaining=[];for(var i=0;i<this.eventRegistrations_.length;++i){var existing=this.eventRegistrations_[i];if(!existing.matches(eventRegistration)){remaining.push(existing);}else if(eventRegistration.hasAnyCallback()){// We're removing just this one
remaining=remaining.concat(this.eventRegistrations_.slice(i+1));break;}}this.eventRegistrations_=remaining;}else{this.eventRegistrations_=[];}return cancelEvents;};/**
     * Applies the given Operation, updates our cache, and returns the appropriate events.
     *
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeServerCache
     * @return {!Array.<!Event>}
     */View.prototype.applyOperation=function(operation,writesCache,completeServerCache){if(operation.type===OperationType.MERGE&&operation.source.queryId!==null){util.assert(this.viewCache_.getCompleteServerSnap(),'We should always have a full cache before handling merges');util.assert(this.viewCache_.getCompleteEventSnap(),'Missing event cache, even though we have a server cache');}var oldViewCache=this.viewCache_;var result=this.processor_.applyOperation(oldViewCache,operation,writesCache,completeServerCache);this.processor_.assertIndexed(result.viewCache);util.assert(result.viewCache.getServerCache().isFullyInitialized()||!oldViewCache.getServerCache().isFullyInitialized(),'Once a server snap is complete, it should never go back');this.viewCache_=result.viewCache;return this.generateEventsForChanges_(result.changes,result.viewCache.getEventCache().getNode(),null);};/**
     * @param {!EventRegistration} registration
     * @return {!Array.<!Event>}
     */View.prototype.getInitialEvents=function(registration){var eventSnap=this.viewCache_.getEventCache();var initialChanges=[];if(!eventSnap.getNode().isLeafNode()){var eventNode=eventSnap.getNode();eventNode.forEachChild(PRIORITY_INDEX,function(key,childNode){initialChanges.push(Change.childAddedChange(key,childNode));});}if(eventSnap.isFullyInitialized()){initialChanges.push(Change.valueChange(eventSnap.getNode()));}return this.generateEventsForChanges_(initialChanges,eventSnap.getNode(),registration);};/**
     * @private
     * @param {!Array.<!Change>} changes
     * @param {!Node} eventCache
     * @param {EventRegistration=} eventRegistration
     * @return {!Array.<!Event>}
     */View.prototype.generateEventsForChanges_=function(changes,eventCache,eventRegistration){var registrations=eventRegistration?[eventRegistration]:this.eventRegistrations_;return this.eventGenerator_.generateEventsForChanges(changes,eventCache,registrations);};return View;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __referenceConstructor$1;/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */var SyncPoint=/** @class */function(){function SyncPoint(){/**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         *
         * @type {!Object.<!string, !View>}
         * @private
         */this.views_={};}Object.defineProperty(SyncPoint,"__referenceConstructor",{get:function(){util.assert(__referenceConstructor$1,'Reference.ts has not been loaded');return __referenceConstructor$1;},set:function(val){util.assert(!__referenceConstructor$1,'__referenceConstructor has already been defined');__referenceConstructor$1=val;},enumerable:true,configurable:true});/**
     * @return {boolean}
     */SyncPoint.prototype.isEmpty=function(){return util.isEmpty(this.views_);};/**
     *
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} optCompleteServerCache
     * @return {!Array.<!Event>}
     */SyncPoint.prototype.applyOperation=function(operation,writesCache,optCompleteServerCache){var queryId=operation.source.queryId;if(queryId!==null){var view=util.safeGet(this.views_,queryId);util.assert(view!=null,'SyncTree gave us an op for an invalid query.');return view.applyOperation(operation,writesCache,optCompleteServerCache);}else{var events_1=[];util.forEach(this.views_,function(key,view){events_1=events_1.concat(view.applyOperation(operation,writesCache,optCompleteServerCache));});return events_1;}};/**
     * Add an event callback for the specified query.
     *
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache Complete server cache, if we have it.
     * @param {boolean} serverCacheComplete
     * @return {!Array.<!Event>} Events to raise.
     */SyncPoint.prototype.addEventRegistration=function(query,eventRegistration,writesCache,serverCache,serverCacheComplete){var queryId=query.queryIdentifier();var view=util.safeGet(this.views_,queryId);if(!view){// TODO: make writesCache take flag for complete server node
var eventCache=writesCache.calcCompleteEventCache(serverCacheComplete?serverCache:null);var eventCacheComplete=false;if(eventCache){eventCacheComplete=true;}else if(serverCache instanceof ChildrenNode){eventCache=writesCache.calcCompleteEventChildren(serverCache);eventCacheComplete=false;}else{eventCache=ChildrenNode.EMPTY_NODE;eventCacheComplete=false;}var viewCache=new ViewCache(new CacheNode(/** @type {!Node} */eventCache,eventCacheComplete,false),new CacheNode(/** @type {!Node} */serverCache,serverCacheComplete,false));view=new View(query,viewCache);this.views_[queryId]=view;}// This is guaranteed to exist now, we just created anything that was missing
view.addEventRegistration(eventRegistration);return view.getInitialEvents(eventRegistration);};/**
     * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
     *
     * If query is the default query, we'll check all views for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
     *
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events
     */SyncPoint.prototype.removeEventRegistration=function(query,eventRegistration,cancelError){var queryId=query.queryIdentifier();var removed=[];var cancelEvents=[];var hadCompleteView=this.hasCompleteView();if(queryId==='default'){// When you do ref.off(...), we search all views for the registration to remove.
var self_1=this;util.forEach(this.views_,function(viewQueryId,view){cancelEvents=cancelEvents.concat(view.removeEventRegistration(eventRegistration,cancelError));if(view.isEmpty()){delete self_1.views_[viewQueryId];// We'll deal with complete views later.
if(!view.getQuery().getQueryParams().loadsAllData()){removed.push(view.getQuery());}}});}else{// remove the callback from the specific view.
var view=util.safeGet(this.views_,queryId);if(view){cancelEvents=cancelEvents.concat(view.removeEventRegistration(eventRegistration,cancelError));if(view.isEmpty()){delete this.views_[queryId];// We'll deal with complete views later.
if(!view.getQuery().getQueryParams().loadsAllData()){removed.push(view.getQuery());}}}}if(hadCompleteView&&!this.hasCompleteView()){// We removed our last complete view.
removed.push(new SyncPoint.__referenceConstructor(query.repo,query.path));}return{removed:removed,events:cancelEvents};};/**
     * @return {!Array.<!View>}
     */SyncPoint.prototype.getQueryViews=function(){var _this=this;var values=Object.keys(this.views_).map(function(key){return _this.views_[key];});return values.filter(function(view){return!view.getQuery().getQueryParams().loadsAllData();});};/**
     *
     * @param {!Path} path The path to the desired complete snapshot
     * @return {?Node} A complete cache, if it exists
     */SyncPoint.prototype.getCompleteServerCache=function(path){var serverCache=null;util.forEach(this.views_,function(key,view){serverCache=serverCache||view.getCompleteServerCache(path);});return serverCache;};/**
     * @param {!Query} query
     * @return {?View}
     */SyncPoint.prototype.viewForQuery=function(query){var params=query.getQueryParams();if(params.loadsAllData()){return this.getCompleteView();}else{var queryId=query.queryIdentifier();return util.safeGet(this.views_,queryId);}};/**
     * @param {!Query} query
     * @return {boolean}
     */SyncPoint.prototype.viewExistsForQuery=function(query){return this.viewForQuery(query)!=null;};/**
     * @return {boolean}
     */SyncPoint.prototype.hasCompleteView=function(){return this.getCompleteView()!=null;};/**
     * @return {?View}
     */SyncPoint.prototype.getCompleteView=function(){var completeView=util.findValue(this.views_,function(view){return view.getQuery().getQueryParams().loadsAllData();});return completeView||null;};return SyncPoint;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 *
 * @constructor
 * @param {!ImmutableTree.<!Node>} writeTree
 */var CompoundWrite=/** @class */function(){function CompoundWrite(writeTree_){this.writeTree_=writeTree_;}/**
     * @param {!Path} path
     * @param {!Node} node
     * @return {!CompoundWrite}
     */CompoundWrite.prototype.addWrite=function(path,node){if(path.isEmpty()){return new CompoundWrite(new ImmutableTree(node));}else{var rootmost=this.writeTree_.findRootMostValueAndPath(path);if(rootmost!=null){var rootMostPath=rootmost.path;var value=rootmost.value;var relativePath=Path.relativePath(rootMostPath,path);value=value.updateChild(relativePath,node);return new CompoundWrite(this.writeTree_.set(rootMostPath,value));}else{var subtree=new ImmutableTree(node);var newWriteTree=this.writeTree_.setTree(path,subtree);return new CompoundWrite(newWriteTree);}}};/**
     * @param {!Path} path
     * @param {!Object.<string, !Node>} updates
     * @return {!CompoundWrite}
     */CompoundWrite.prototype.addWrites=function(path,updates){var newWrite=this;util.forEach(updates,function(childKey,node){newWrite=newWrite.addWrite(path.child(childKey),node);});return newWrite;};/**
     * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
     * location, which must be removed by calling this method with that path.
     *
     * @param {!Path} path The path at which a write and all deeper writes should be removed
     * @return {!CompoundWrite} The new CompoundWrite with the removed path
     */CompoundWrite.prototype.removeWrite=function(path){if(path.isEmpty()){return CompoundWrite.Empty;}else{var newWriteTree=this.writeTree_.setTree(path,ImmutableTree.Empty);return new CompoundWrite(newWriteTree);}};/**
     * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
     * considered "complete".
     *
     * @param {!Path} path The path to check for
     * @return {boolean} Whether there is a complete write at that path
     */CompoundWrite.prototype.hasCompleteWrite=function(path){return this.getCompleteNode(path)!=null;};/**
     * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
     * writes from deeper paths, but will return child nodes from a more shallow path.
     *
     * @param {!Path} path The path to get a complete write
     * @return {?Node} The node if complete at that path, or null otherwise.
     */CompoundWrite.prototype.getCompleteNode=function(path){var rootmost=this.writeTree_.findRootMostValueAndPath(path);if(rootmost!=null){return this.writeTree_.get(rootmost.path).getChild(Path.relativePath(rootmost.path,path));}else{return null;}};/**
     * Returns all children that are guaranteed to be a complete overwrite.
     *
     * @return {!Array.<NamedNode>} A list of all complete children.
     */CompoundWrite.prototype.getCompleteChildren=function(){var children=[];var node=this.writeTree_.value;if(node!=null){// If it's a leaf node, it has no children; so nothing to do.
if(!node.isLeafNode()){node.forEachChild(PRIORITY_INDEX,function(childName,childNode){children.push(new NamedNode(childName,childNode));});}}else{this.writeTree_.children.inorderTraversal(function(childName,childTree){if(childTree.value!=null){children.push(new NamedNode(childName,childTree.value));}});}return children;};/**
     * @param {!Path} path
     * @return {!CompoundWrite}
     */CompoundWrite.prototype.childCompoundWrite=function(path){if(path.isEmpty()){return this;}else{var shadowingNode=this.getCompleteNode(path);if(shadowingNode!=null){return new CompoundWrite(new ImmutableTree(shadowingNode));}else{return new CompoundWrite(this.writeTree_.subtree(path));}}};/**
     * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
     * @return {boolean} Whether this CompoundWrite is empty
     */CompoundWrite.prototype.isEmpty=function(){return this.writeTree_.isEmpty();};/**
     * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
     * node
     * @param {!Node} node The node to apply this CompoundWrite to
     * @return {!Node} The node with all writes applied
     */CompoundWrite.prototype.apply=function(node){return CompoundWrite.applySubtreeWrite_(Path.Empty,this.writeTree_,node);};/**
     * @type {!CompoundWrite}
     */CompoundWrite.Empty=new CompoundWrite(new ImmutableTree(null));/**
     * @param {!Path} relativePath
     * @param {!ImmutableTree.<!Node>} writeTree
     * @param {!Node} node
     * @return {!Node}
     * @private
     */CompoundWrite.applySubtreeWrite_=function(relativePath,writeTree,node){if(writeTree.value!=null){// Since there a write is always a leaf, we're done here
return node.updateChild(relativePath,writeTree.value);}else{var priorityWrite_1=null;writeTree.children.inorderTraversal(function(childKey,childTree){if(childKey==='.priority'){// Apply priorities at the end so we don't update priorities for either empty nodes or forget
// to apply priorities to empty nodes that are later filled
util.assert(childTree.value!==null,'Priority writes must always be leaf nodes');priorityWrite_1=childTree.value;}else{node=CompoundWrite.applySubtreeWrite_(relativePath.child(childKey),childTree,node);}});// If there was a priority write, we only apply it if the node is not empty
if(!node.getChild(relativePath).isEmpty()&&priorityWrite_1!==null){node=node.updateChild(relativePath.child('.priority'),priorityWrite_1);}return node;}};return CompoundWrite;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them
 * with underlying server data (to create "event cache" data).  Pending writes are added with addOverwrite()
 * and addMerge(), and removed with removeWrite().
 *
 * @constructor
 */var WriteTree=/** @class */function(){function WriteTree(){/**
         * A tree tracking the result of applying all visible writes.  This does not include transactions with
         * applyLocally=false or writes that are completely shadowed by other writes.
         *
         * @type {!CompoundWrite}
         * @private
         */this.visibleWrites_=CompoundWrite.Empty;/**
         * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary
         * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also
         * used by transactions).
         *
         * @type {!Array.<!WriteRecord>}
         * @private
         */this.allWrites_=[];this.lastWriteId_=-1;}/**
     * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
     *
     * @param {!Path} path
     * @return {!WriteTreeRef}
     */WriteTree.prototype.childWrites=function(path){return new WriteTreeRef(path,this);};/**
     * Record a new overwrite from user code.
     *
     * @param {!Path} path
     * @param {!Node} snap
     * @param {!number} writeId
     * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches
     */WriteTree.prototype.addOverwrite=function(path,snap,writeId,visible){util.assert(writeId>this.lastWriteId_,'Stacking an older write on top of newer ones');if(visible===undefined){visible=true;}this.allWrites_.push({path:path,snap:snap,writeId:writeId,visible:visible});if(visible){this.visibleWrites_=this.visibleWrites_.addWrite(path,snap);}this.lastWriteId_=writeId;};/**
     * Record a new merge from user code.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} writeId
     */WriteTree.prototype.addMerge=function(path,changedChildren,writeId){util.assert(writeId>this.lastWriteId_,'Stacking an older merge on top of newer ones');this.allWrites_.push({path:path,children:changedChildren,writeId:writeId,visible:true});this.visibleWrites_=this.visibleWrites_.addWrites(path,changedChildren);this.lastWriteId_=writeId;};/**
     * @param {!number} writeId
     * @return {?WriteRecord}
     */WriteTree.prototype.getWrite=function(writeId){for(var i=0;i<this.allWrites_.length;i++){var record=this.allWrites_[i];if(record.writeId===writeId){return record;}}return null;};/**
     * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
     * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
     *
     * @param {!number} writeId
     * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise
     * events as a result).
     */WriteTree.prototype.removeWrite=function(writeId){// Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
// out of order.
//const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
//assert(validClear, "Either we don't have this write, or it's the first one in the queue");
var _this=this;var idx=this.allWrites_.findIndex(function(s){return s.writeId===writeId;});util.assert(idx>=0,'removeWrite called with nonexistent writeId.');var writeToRemove=this.allWrites_[idx];this.allWrites_.splice(idx,1);var removedWriteWasVisible=writeToRemove.visible;var removedWriteOverlapsWithOtherWrites=false;var i=this.allWrites_.length-1;while(removedWriteWasVisible&&i>=0){var currentWrite=this.allWrites_[i];if(currentWrite.visible){if(i>=idx&&this.recordContainsPath_(currentWrite,writeToRemove.path)){// The removed write was completely shadowed by a subsequent write.
removedWriteWasVisible=false;}else if(writeToRemove.path.contains(currentWrite.path)){// Either we're covering some writes or they're covering part of us (depending on which came first).
removedWriteOverlapsWithOtherWrites=true;}}i--;}if(!removedWriteWasVisible){return false;}else if(removedWriteOverlapsWithOtherWrites){// There's some shadowing going on. Just rebuild the visible writes from scratch.
this.resetTree_();return true;}else{// There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
if(writeToRemove.snap){this.visibleWrites_=this.visibleWrites_.removeWrite(writeToRemove.path);}else{var children=writeToRemove.children;util.forEach(children,function(childName){_this.visibleWrites_=_this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));});}return true;}};/**
     * Return a complete snapshot for the given path if there's visible write data at that path, else null.
     * No server data is considered.
     *
     * @param {!Path} path
     * @return {?Node}
     */WriteTree.prototype.getCompleteWriteData=function(path){return this.visibleWrites_.getCompleteNode(path);};/**
     * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
     * writes), attempt to calculate a complete snapshot for the given path
     *
     * @param {!Path} treePath
     * @param {?Node} completeServerCache
     * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded
     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return {?Node}
     */WriteTree.prototype.calcCompleteEventCache=function(treePath,completeServerCache,writeIdsToExclude,includeHiddenWrites){if(!writeIdsToExclude&&!includeHiddenWrites){var shadowingNode=this.visibleWrites_.getCompleteNode(treePath);if(shadowingNode!=null){return shadowingNode;}else{var subMerge=this.visibleWrites_.childCompoundWrite(treePath);if(subMerge.isEmpty()){return completeServerCache;}else if(completeServerCache==null&&!subMerge.hasCompleteWrite(Path.Empty)){// We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
return null;}else{var layeredCache=completeServerCache||ChildrenNode.EMPTY_NODE;return subMerge.apply(layeredCache);}}}else{var merge=this.visibleWrites_.childCompoundWrite(treePath);if(!includeHiddenWrites&&merge.isEmpty()){return completeServerCache;}else{// If the server cache is null, and we don't have a complete cache, we need to return null
if(!includeHiddenWrites&&completeServerCache==null&&!merge.hasCompleteWrite(Path.Empty)){return null;}else{var filter=function(write){return(write.visible||includeHiddenWrites)&&(!writeIdsToExclude||!~writeIdsToExclude.indexOf(write.writeId))&&(write.path.contains(treePath)||treePath.contains(write.path));};var mergeAtPath=WriteTree.layerTree_(this.allWrites_,filter,treePath);var layeredCache=completeServerCache||ChildrenNode.EMPTY_NODE;return mergeAtPath.apply(layeredCache);}}}};/**
     * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
     * Used when creating new views, to pre-fill their complete event children snapshot.
     *
     * @param {!Path} treePath
     * @param {?ChildrenNode} completeServerChildren
     * @return {!ChildrenNode}
     */WriteTree.prototype.calcCompleteEventChildren=function(treePath,completeServerChildren){var completeChildren=ChildrenNode.EMPTY_NODE;var topLevelSet=this.visibleWrites_.getCompleteNode(treePath);if(topLevelSet){if(!topLevelSet.isLeafNode()){// we're shadowing everything. Return the children.
topLevelSet.forEachChild(PRIORITY_INDEX,function(childName,childSnap){completeChildren=completeChildren.updateImmediateChild(childName,childSnap);});}return completeChildren;}else if(completeServerChildren){// Layer any children we have on top of this
// We know we don't have a top-level set, so just enumerate existing children
var merge_1=this.visibleWrites_.childCompoundWrite(treePath);completeServerChildren.forEachChild(PRIORITY_INDEX,function(childName,childNode){var node=merge_1.childCompoundWrite(new Path(childName)).apply(childNode);completeChildren=completeChildren.updateImmediateChild(childName,node);});// Add any complete children we have from the set
merge_1.getCompleteChildren().forEach(function(namedNode){completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node);});return completeChildren;}else{// We don't have anything to layer on top of. Layer on any children we have
// Note that we can return an empty snap if we have a defined delete
var merge=this.visibleWrites_.childCompoundWrite(treePath);merge.getCompleteChildren().forEach(function(namedNode){completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node);});return completeChildren;}};/**
     * Given that the underlying server data has updated, determine what, if anything, needs to be
     * applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events
     *
     * Either existingEventSnap or existingServerSnap must exist
     *
     * @param {!Path} treePath
     * @param {!Path} childPath
     * @param {?Node} existingEventSnap
     * @param {?Node} existingServerSnap
     * @return {?Node}
     */WriteTree.prototype.calcEventCacheAfterServerOverwrite=function(treePath,childPath,existingEventSnap,existingServerSnap){util.assert(existingEventSnap||existingServerSnap,'Either existingEventSnap or existingServerSnap must exist');var path=treePath.child(childPath);if(this.visibleWrites_.hasCompleteWrite(path)){// At this point we can probably guarantee that we're in case 2, meaning no events
// May need to check visibility while doing the findRootMostValueAndPath call
return null;}else{// No complete shadowing. We're either partially shadowing or not shadowing at all.
var childMerge=this.visibleWrites_.childCompoundWrite(path);if(childMerge.isEmpty()){// We're not shadowing at all. Case 1
return existingServerSnap.getChild(childPath);}else{// This could be more efficient if the serverNode + updates doesn't change the eventSnap
// However this is tricky to find out, since user updates don't necessary change the server
// snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
// adds nodes, but doesn't change any existing writes. It is therefore not enough to
// only check if the updates change the serverNode.
// Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
return childMerge.apply(existingServerSnap.getChild(childPath));}}};/**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param {!Path} treePath
     * @param {!string} childKey
     * @param {!CacheNode} existingServerSnap
     * @return {?Node}
     */WriteTree.prototype.calcCompleteChild=function(treePath,childKey,existingServerSnap){var path=treePath.child(childKey);var shadowingNode=this.visibleWrites_.getCompleteNode(path);if(shadowingNode!=null){return shadowingNode;}else{if(existingServerSnap.isCompleteForChild(childKey)){var childMerge=this.visibleWrites_.childCompoundWrite(path);return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));}else{return null;}}};/**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param {!Path} path
     * @return {?Node}
     */WriteTree.prototype.shadowingWrite=function(path){return this.visibleWrites_.getCompleteNode(path);};/**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window.
     *
     * @param {!Path} treePath
     * @param {?Node} completeServerData
     * @param {!NamedNode} startPost
     * @param {!number} count
     * @param {boolean} reverse
     * @param {!Index} index
     * @return {!Array.<!NamedNode>}
     */WriteTree.prototype.calcIndexedSlice=function(treePath,completeServerData,startPost,count,reverse,index){var toIterate;var merge=this.visibleWrites_.childCompoundWrite(treePath);var shadowingNode=merge.getCompleteNode(Path.Empty);if(shadowingNode!=null){toIterate=shadowingNode;}else if(completeServerData!=null){toIterate=merge.apply(completeServerData);}else{// no children to iterate on
return[];}toIterate=toIterate.withIndex(index);if(!toIterate.isEmpty()&&!toIterate.isLeafNode()){var nodes=[];var cmp=index.getCompare();var iter=reverse?toIterate.getReverseIteratorFrom(startPost,index):toIterate.getIteratorFrom(startPost,index);var next=iter.getNext();while(next&&nodes.length<count){if(cmp(next,startPost)!==0){nodes.push(next);}next=iter.getNext();}return nodes;}else{return[];}};/**
     * @param {!WriteRecord} writeRecord
     * @param {!Path} path
     * @return {boolean}
     * @private
     */WriteTree.prototype.recordContainsPath_=function(writeRecord,path){if(writeRecord.snap){return writeRecord.path.contains(path);}else{// findKey can return undefined, so use !! to coerce to boolean
return!!util.findKey(writeRecord.children,function(childSnap,childName){return writeRecord.path.child(childName).contains(path);});}};/**
     * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
     * @private
     */WriteTree.prototype.resetTree_=function(){this.visibleWrites_=WriteTree.layerTree_(this.allWrites_,WriteTree.DefaultFilter_,Path.Empty);if(this.allWrites_.length>0){this.lastWriteId_=this.allWrites_[this.allWrites_.length-1].writeId;}else{this.lastWriteId_=-1;}};/**
     * The default filter used when constructing the tree. Keep everything that's visible.
     *
     * @param {!WriteRecord} write
     * @return {boolean}
     * @private
     */WriteTree.DefaultFilter_=function(write){return write.visible;};/**
     * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
     * event data at that path.
     *
     * @param {!Array.<!WriteRecord>} writes
     * @param {!function(!WriteRecord):boolean} filter
     * @param {!Path} treeRoot
     * @return {!CompoundWrite}
     * @private
     */WriteTree.layerTree_=function(writes,filter,treeRoot){var compoundWrite=CompoundWrite.Empty;for(var i=0;i<writes.length;++i){var write=writes[i];// Theory, a later set will either:
// a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
// b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
if(filter(write)){var writePath=write.path;var relativePath=void 0;if(write.snap){if(treeRoot.contains(writePath)){relativePath=Path.relativePath(treeRoot,writePath);compoundWrite=compoundWrite.addWrite(relativePath,write.snap);}else if(writePath.contains(treeRoot)){relativePath=Path.relativePath(writePath,treeRoot);compoundWrite=compoundWrite.addWrite(Path.Empty,write.snap.getChild(relativePath));}}else if(write.children){if(treeRoot.contains(writePath)){relativePath=Path.relativePath(treeRoot,writePath);compoundWrite=compoundWrite.addWrites(relativePath,write.children);}else if(writePath.contains(treeRoot)){relativePath=Path.relativePath(writePath,treeRoot);if(relativePath.isEmpty()){compoundWrite=compoundWrite.addWrites(Path.Empty,write.children);}else{var child=util.safeGet(write.children,relativePath.getFront());if(child){// There exists a child in this node that matches the root path
var deepNode=child.getChild(relativePath.popFront());compoundWrite=compoundWrite.addWrite(Path.Empty,deepNode);}}}}else{throw util.assertionError('WriteRecord should have .snap or .children');}}}return compoundWrite;};return WriteTree;}();/**
 * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods
 * just proxy to the underlying WriteTree.
 *
 * @constructor
 */var WriteTreeRef=/** @class */function(){/**
     * @param {!Path} path
     * @param {!WriteTree} writeTree
     */function WriteTreeRef(path,writeTree){this.treePath_=path;this.writeTree_=writeTree;}/**
     * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
     * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
     * can lead to a more expensive calculation.
     *
     * @param {?Node} completeServerCache
     * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.
     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return {?Node}
     */WriteTreeRef.prototype.calcCompleteEventCache=function(completeServerCache,writeIdsToExclude,includeHiddenWrites){return this.writeTree_.calcCompleteEventCache(this.treePath_,completeServerCache,writeIdsToExclude,includeHiddenWrites);};/**
     * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
     * mix of the given server data and write data.
     *
     * @param {?ChildrenNode} completeServerChildren
     * @return {!ChildrenNode}
     */WriteTreeRef.prototype.calcCompleteEventChildren=function(completeServerChildren){return this.writeTree_.calcCompleteEventChildren(this.treePath_,completeServerChildren);};/**
     * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
     * if anything, needs to be applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events should be raised
     *
     * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
     *
     * @param {!Path} path
     * @param {?Node} existingEventSnap
     * @param {?Node} existingServerSnap
     * @return {?Node}
     */WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite=function(path,existingEventSnap,existingServerSnap){return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_,path,existingEventSnap,existingServerSnap);};/**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param {!Path} path
     * @return {?Node}
     */WriteTreeRef.prototype.shadowingWrite=function(path){return this.writeTree_.shadowingWrite(this.treePath_.child(path));};/**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window
     *
     * @param {?Node} completeServerData
     * @param {!NamedNode} startPost
     * @param {!number} count
     * @param {boolean} reverse
     * @param {!Index} index
     * @return {!Array.<!NamedNode>}
     */WriteTreeRef.prototype.calcIndexedSlice=function(completeServerData,startPost,count,reverse,index){return this.writeTree_.calcIndexedSlice(this.treePath_,completeServerData,startPost,count,reverse,index);};/**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param {!string} childKey
     * @param {!CacheNode} existingServerCache
     * @return {?Node}
     */WriteTreeRef.prototype.calcCompleteChild=function(childKey,existingServerCache){return this.writeTree_.calcCompleteChild(this.treePath_,childKey,existingServerCache);};/**
     * Return a WriteTreeRef for a child.
     *
     * @param {string} childName
     * @return {!WriteTreeRef}
     */WriteTreeRef.prototype.child=function(childName){return new WriteTreeRef(this.treePath_.child(childName),this.writeTree_);};return WriteTreeRef;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 * @constructor
 */var SyncTree=/** @class */function(){/**
     * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening
     *   to server data.
     */function SyncTree(listenProvider_){this.listenProvider_=listenProvider_;/**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         * @type {!ImmutableTree.<!SyncPoint>}
         * @private
         */this.syncPointTree_=ImmutableTree.Empty;/**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         * @type {!WriteTree}
         * @private
         */this.pendingWriteTree_=new WriteTree();this.tagToQueryMap_={};this.queryToTagMap_={};}/**
     * Apply the data changes for a user-generated set() or transaction() call.
     *
     * @param {!Path} path
     * @param {!Node} newData
     * @param {number} writeId
     * @param {boolean=} visible
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.applyUserOverwrite=function(path,newData,writeId,visible){// Record pending write.
this.pendingWriteTree_.addOverwrite(path,newData,writeId,visible);if(!visible){return[];}else{return this.applyOperationToSyncPoints_(new Overwrite(OperationSource.User,path,newData));}};/**
     * Apply the data from a user-generated update() call
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} writeId
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.applyUserMerge=function(path,changedChildren,writeId){// Record pending merge.
this.pendingWriteTree_.addMerge(path,changedChildren,writeId);var changeTree=ImmutableTree.fromObject(changedChildren);return this.applyOperationToSyncPoints_(new Merge(OperationSource.User,path,changeTree));};/**
     * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
     *
     * @param {!number} writeId
     * @param {boolean=} revert True if the given write failed and needs to be reverted
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.ackUserWrite=function(writeId,revert){if(revert===void 0){revert=false;}var write=this.pendingWriteTree_.getWrite(writeId);var needToReevaluate=this.pendingWriteTree_.removeWrite(writeId);if(!needToReevaluate){return[];}else{var affectedTree_1=ImmutableTree.Empty;if(write.snap!=null){// overwrite
affectedTree_1=affectedTree_1.set(Path.Empty,true);}else{util.forEach(write.children,function(pathString,node){affectedTree_1=affectedTree_1.set(new Path(pathString),node);});}return this.applyOperationToSyncPoints_(new AckUserWrite(write.path,affectedTree_1,revert));}};/**
     * Apply new server data for the specified path..
     *
     * @param {!Path} path
     * @param {!Node} newData
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.applyServerOverwrite=function(path,newData){return this.applyOperationToSyncPoints_(new Overwrite(OperationSource.Server,path,newData));};/**
     * Apply new server data to be merged in at the specified path.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.applyServerMerge=function(path,changedChildren){var changeTree=ImmutableTree.fromObject(changedChildren);return this.applyOperationToSyncPoints_(new Merge(OperationSource.Server,path,changeTree));};/**
     * Apply a listen complete for a query
     *
     * @param {!Path} path
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.applyListenComplete=function(path){return this.applyOperationToSyncPoints_(new ListenComplete(OperationSource.Server,path));};/**
     * Apply new server data for the specified tagged query.
     *
     * @param {!Path} path
     * @param {!Node} snap
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.applyTaggedQueryOverwrite=function(path,snap,tag){var queryKey=this.queryKeyForTag_(tag);if(queryKey!=null){var r=SyncTree.parseQueryKey_(queryKey);var queryPath=r.path,queryId=r.queryId;var relativePath=Path.relativePath(queryPath,path);var op=new Overwrite(OperationSource.forServerTaggedQuery(queryId),relativePath,snap);return this.applyTaggedOperation_(queryPath,op);}else{// Query must have been removed already
return[];}};/**
     * Apply server data to be merged in for the specified tagged query.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.applyTaggedQueryMerge=function(path,changedChildren,tag){var queryKey=this.queryKeyForTag_(tag);if(queryKey){var r=SyncTree.parseQueryKey_(queryKey);var queryPath=r.path,queryId=r.queryId;var relativePath=Path.relativePath(queryPath,path);var changeTree=ImmutableTree.fromObject(changedChildren);var op=new Merge(OperationSource.forServerTaggedQuery(queryId),relativePath,changeTree);return this.applyTaggedOperation_(queryPath,op);}else{// We've already removed the query. No big deal, ignore the update
return[];}};/**
     * Apply a listen complete for a tagged query
     *
     * @param {!Path} path
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.applyTaggedListenComplete=function(path,tag){var queryKey=this.queryKeyForTag_(tag);if(queryKey){var r=SyncTree.parseQueryKey_(queryKey);var queryPath=r.path,queryId=r.queryId;var relativePath=Path.relativePath(queryPath,path);var op=new ListenComplete(OperationSource.forServerTaggedQuery(queryId),relativePath);return this.applyTaggedOperation_(queryPath,op);}else{// We've already removed the query. No big deal, ignore the update
return[];}};/**
     * Add an event callback for the specified query.
     *
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     * @return {!Array.<!Event>} Events to raise.
     */SyncTree.prototype.addEventRegistration=function(query,eventRegistration){var path=query.path;var serverCache=null;var foundAncestorDefaultView=false;// Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
// Consider optimizing this once there's a better understanding of what actual behavior will be.
this.syncPointTree_.foreachOnPath(path,function(pathToSyncPoint,sp){var relativePath=Path.relativePath(pathToSyncPoint,path);serverCache=serverCache||sp.getCompleteServerCache(relativePath);foundAncestorDefaultView=foundAncestorDefaultView||sp.hasCompleteView();});var syncPoint=this.syncPointTree_.get(path);if(!syncPoint){syncPoint=new SyncPoint();this.syncPointTree_=this.syncPointTree_.set(path,syncPoint);}else{foundAncestorDefaultView=foundAncestorDefaultView||syncPoint.hasCompleteView();serverCache=serverCache||syncPoint.getCompleteServerCache(Path.Empty);}var serverCacheComplete;if(serverCache!=null){serverCacheComplete=true;}else{serverCacheComplete=false;serverCache=ChildrenNode.EMPTY_NODE;var subtree=this.syncPointTree_.subtree(path);subtree.foreachChild(function(childName,childSyncPoint){var completeCache=childSyncPoint.getCompleteServerCache(Path.Empty);if(completeCache){serverCache=serverCache.updateImmediateChild(childName,completeCache);}});}var viewAlreadyExists=syncPoint.viewExistsForQuery(query);if(!viewAlreadyExists&&!query.getQueryParams().loadsAllData()){// We need to track a tag for this query
var queryKey=SyncTree.makeQueryKey_(query);util.assert(!(queryKey in this.queryToTagMap_),'View does not exist, but we have a tag');var tag=SyncTree.getNextQueryTag_();this.queryToTagMap_[queryKey]=tag;// Coerce to string to avoid sparse arrays.
this.tagToQueryMap_['_'+tag]=queryKey;}var writesCache=this.pendingWriteTree_.childWrites(path);var events=syncPoint.addEventRegistration(query,eventRegistration,writesCache,serverCache,serverCacheComplete);if(!viewAlreadyExists&&!foundAncestorDefaultView){var view/** @type !View */=syncPoint.viewForQuery(query);events=events.concat(this.setupListener_(query,view));}return events;};/**
     * Remove event callback(s).
     *
     * If query is the default query, we'll check all queries for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
     *
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.
     */SyncTree.prototype.removeEventRegistration=function(query,eventRegistration,cancelError){var _this=this;// Find the syncPoint first. Then deal with whether or not it has matching listeners
var path=query.path;var maybeSyncPoint=this.syncPointTree_.get(path);var cancelEvents=[];// A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
// other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
// not loadsAllData().
if(maybeSyncPoint&&(query.queryIdentifier()==='default'||maybeSyncPoint.viewExistsForQuery(query))){/**
             * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}
             */var removedAndEvents=maybeSyncPoint.removeEventRegistration(query,eventRegistration,cancelError);if(maybeSyncPoint.isEmpty()){this.syncPointTree_=this.syncPointTree_.remove(path);}var removed=removedAndEvents.removed;cancelEvents=removedAndEvents.events;// We may have just removed one of many listeners and can short-circuit this whole process
// We may also not have removed a default listener, in which case all of the descendant listeners should already be
// properly set up.
//
// Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
// queryId === 'default'
var removingDefault=-1!==removed.findIndex(function(query){return query.getQueryParams().loadsAllData();});var covered=this.syncPointTree_.findOnPath(path,function(relativePath,parentSyncPoint){return parentSyncPoint.hasCompleteView();});if(removingDefault&&!covered){var subtree=this.syncPointTree_.subtree(path);// There are potentially child listeners. Determine what if any listens we need to send before executing the
// removal
if(!subtree.isEmpty()){// We need to fold over our subtree and collect the listeners to send
var newViews=this.collectDistinctViewsForSubTree_(subtree);// Ok, we've collected all the listens we need. Set them up.
for(var i=0;i<newViews.length;++i){var view=newViews[i],newQuery=view.getQuery();var listener=this.createListenerForView_(view);this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery),this.tagForQuery_(newQuery),listener.hashFn,listener.onComplete);}}}// If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
// The above block has us covered in terms of making sure we're set up on listens lower in the tree.
// Also, note that if we have a cancelError, it's already been removed at the provider level.
if(!covered&&removed.length>0&&!cancelError){// If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
// default. Otherwise, we need to iterate through and cancel each individual query
if(removingDefault){// We don't tag default listeners
var defaultTag=null;this.listenProvider_.stopListening(SyncTree.queryForListening_(query),defaultTag);}else{removed.forEach(function(queryToRemove){var tagToRemove=_this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];_this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove),tagToRemove);});}}// Now, clear all of the tags we're tracking for the removed listens
this.removeTags_(removed);}return cancelEvents;};/**
     * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above
     * it, but as this is only used by transaction code, that should always be the case anyways.
     *
     * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
     * @param {!Path} path The path to the data we want
     * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded
     * @return {?Node}
     */SyncTree.prototype.calcCompleteEventCache=function(path,writeIdsToExclude){var includeHiddenSets=true;var writeTree=this.pendingWriteTree_;var serverCache=this.syncPointTree_.findOnPath(path,function(pathSoFar,syncPoint){var relativePath=Path.relativePath(pathSoFar,path);var serverCache=syncPoint.getCompleteServerCache(relativePath);if(serverCache){return serverCache;}});return writeTree.calcCompleteEventCache(path,serverCache,writeIdsToExclude,includeHiddenSets);};/**
     * This collapses multiple unfiltered views into a single view, since we only need a single
     * listener for them.
     *
     * @param {!ImmutableTree.<!SyncPoint>} subtree
     * @return {!Array.<!View>}
     * @private
     */SyncTree.prototype.collectDistinctViewsForSubTree_=function(subtree){return subtree.fold(function(relativePath,maybeChildSyncPoint,childMap){if(maybeChildSyncPoint&&maybeChildSyncPoint.hasCompleteView()){var completeView=maybeChildSyncPoint.getCompleteView();return[completeView];}else{// No complete view here, flatten any deeper listens into an array
var views_1=[];if(maybeChildSyncPoint){views_1=maybeChildSyncPoint.getQueryViews();}util.forEach(childMap,function(key,childViews){views_1=views_1.concat(childViews);});return views_1;}});};/**
     * @param {!Array.<!Query>} queries
     * @private
     */SyncTree.prototype.removeTags_=function(queries){for(var j=0;j<queries.length;++j){var removedQuery=queries[j];if(!removedQuery.getQueryParams().loadsAllData()){// We should have a tag for this
var removedQueryKey=SyncTree.makeQueryKey_(removedQuery);var removedQueryTag=this.queryToTagMap_[removedQueryKey];delete this.queryToTagMap_[removedQueryKey];delete this.tagToQueryMap_['_'+removedQueryTag];}}};/**
     * Normalizes a query to a query we send the server for listening
     * @param {!Query} query
     * @return {!Query} The normalized query
     * @private
     */SyncTree.queryForListening_=function(query){if(query.getQueryParams().loadsAllData()&&!query.getQueryParams().isDefault()){// We treat queries that load all data as default queries
// Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
// from Query
return(/** @type {!Query} */query.getRef());}else{return query;}};/**
     * For a given new listen, manage the de-duplication of outstanding subscriptions.
     *
     * @param {!Query} query
     * @param {!View} view
     * @return {!Array.<!Event>} This method can return events to support synchronous data sources
     * @private
     */SyncTree.prototype.setupListener_=function(query,view){var path=query.path;var tag=this.tagForQuery_(query);var listener=this.createListenerForView_(view);var events=this.listenProvider_.startListening(SyncTree.queryForListening_(query),tag,listener.hashFn,listener.onComplete);var subtree=this.syncPointTree_.subtree(path);// The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
// may need to shadow other listens as well.
if(tag){util.assert(!subtree.value.hasCompleteView(),"If we're adding a query, it shouldn't be shadowed");}else{// Shadow everything at or below this location, this is a default listener.
var queriesToStop=subtree.fold(function(relativePath,maybeChildSyncPoint,childMap){if(!relativePath.isEmpty()&&maybeChildSyncPoint&&maybeChildSyncPoint.hasCompleteView()){return[maybeChildSyncPoint.getCompleteView().getQuery()];}else{// No default listener here, flatten any deeper queries into an array
var queries_1=[];if(maybeChildSyncPoint){queries_1=queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function(view){return view.getQuery();}));}util.forEach(childMap,function(key,childQueries){queries_1=queries_1.concat(childQueries);});return queries_1;}});for(var i=0;i<queriesToStop.length;++i){var queryToStop=queriesToStop[i];this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop),this.tagForQuery_(queryToStop));}}return events;};/**
     *
     * @param {!View} view
     * @return {{hashFn: function(), onComplete: function(!string, *)}}
     * @private
     */SyncTree.prototype.createListenerForView_=function(view){var _this=this;var query=view.getQuery();var tag=this.tagForQuery_(query);return{hashFn:function(){var cache=view.getServerCache()||ChildrenNode.EMPTY_NODE;return cache.hash();},onComplete:function(status){if(status==='ok'){if(tag){return _this.applyTaggedListenComplete(query.path,tag);}else{return _this.applyListenComplete(query.path);}}else{// If a listen failed, kill all of the listeners here, not just the one that triggered the error.
// Note that this may need to be scoped to just this listener if we change permissions on filtered children
var error=errorForServerCode(status,query);return _this.removeEventRegistration(query,/*eventRegistration*/null,error);}}};};/**
     * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
     * @private
     * @param {!Query} query
     * @return {string}
     */SyncTree.makeQueryKey_=function(query){return query.path.toString()+'$'+query.queryIdentifier();};/**
     * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
     * @private
     * @param {!string} queryKey
     * @return {{queryId: !string, path: !Path}}
     */SyncTree.parseQueryKey_=function(queryKey){var splitIndex=queryKey.indexOf('$');util.assert(splitIndex!==-1&&splitIndex<queryKey.length-1,'Bad queryKey.');return{queryId:queryKey.substr(splitIndex+1),path:new Path(queryKey.substr(0,splitIndex))};};/**
     * Return the query associated with the given tag, if we have one
     * @param {!number} tag
     * @return {?string}
     * @private
     */SyncTree.prototype.queryKeyForTag_=function(tag){return this.tagToQueryMap_['_'+tag];};/**
     * Return the tag associated with the given query.
     * @param {!Query} query
     * @return {?number}
     * @private
     */SyncTree.prototype.tagForQuery_=function(query){var queryKey=SyncTree.makeQueryKey_(query);return util.safeGet(this.queryToTagMap_,queryKey);};/**
     * Static accessor for query tags.
     * @return {number}
     * @private
     */SyncTree.getNextQueryTag_=function(){return SyncTree.nextQueryTag_++;};/**
     * A helper method to apply tagged operations
     *
     * @param {!Path} queryPath
     * @param {!Operation} operation
     * @return {!Array.<!Event>}
     * @private
     */SyncTree.prototype.applyTaggedOperation_=function(queryPath,operation){var syncPoint=this.syncPointTree_.get(queryPath);util.assert(syncPoint,"Missing sync point for query tag that we're tracking");var writesCache=this.pendingWriteTree_.childWrites(queryPath);return syncPoint.applyOperation(operation,writesCache,/*serverCache=*/null);};/**
     * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
     *
     * NOTES:
     * - Descendant SyncPoints will be visited first (since we raise events depth-first).
  
     * - We call applyOperation() on each SyncPoint passing three things:
     *   1. A version of the Operation that has been made relative to the SyncPoint location.
     *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
     *   3. A snapshot Node with cached server data, if we have it.
  
     * - We concatenate all of the events returned by each SyncPoint and return the result.
     *
     * @param {!Operation} operation
     * @return {!Array.<!Event>}
     * @private
     */SyncTree.prototype.applyOperationToSyncPoints_=function(operation){return this.applyOperationHelper_(operation,this.syncPointTree_,/*serverCache=*/null,this.pendingWriteTree_.childWrites(Path.Empty));};/**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param {!Operation} operation
     * @param {ImmutableTree.<!SyncPoint>} syncPointTree
     * @param {?Node} serverCache
     * @param {!WriteTreeRef} writesCache
     * @return {!Array.<!Event>}
     */SyncTree.prototype.applyOperationHelper_=function(operation,syncPointTree,serverCache,writesCache){if(operation.path.isEmpty()){return this.applyOperationDescendantsHelper_(operation,syncPointTree,serverCache,writesCache);}else{var syncPoint=syncPointTree.get(Path.Empty);// If we don't have cached server data, see if we can get it from this SyncPoint.
if(serverCache==null&&syncPoint!=null){serverCache=syncPoint.getCompleteServerCache(Path.Empty);}var events=[];var childName=operation.path.getFront();var childOperation=operation.operationForChild(childName);var childTree=syncPointTree.children.get(childName);if(childTree&&childOperation){var childServerCache=serverCache?serverCache.getImmediateChild(childName):null;var childWritesCache=writesCache.child(childName);events=events.concat(this.applyOperationHelper_(childOperation,childTree,childServerCache,childWritesCache));}if(syncPoint){events=events.concat(syncPoint.applyOperation(operation,writesCache,serverCache));}return events;}};/**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param {!Operation} operation
     * @param {ImmutableTree.<!SyncPoint>} syncPointTree
     * @param {?Node} serverCache
     * @param {!WriteTreeRef} writesCache
     * @return {!Array.<!Event>}
     */SyncTree.prototype.applyOperationDescendantsHelper_=function(operation,syncPointTree,serverCache,writesCache){var _this=this;var syncPoint=syncPointTree.get(Path.Empty);// If we don't have cached server data, see if we can get it from this SyncPoint.
if(serverCache==null&&syncPoint!=null){serverCache=syncPoint.getCompleteServerCache(Path.Empty);}var events=[];syncPointTree.children.inorderTraversal(function(childName,childTree){var childServerCache=serverCache?serverCache.getImmediateChild(childName):null;var childWritesCache=writesCache.child(childName);var childOperation=operation.operationForChild(childName);if(childOperation){events=events.concat(_this.applyOperationDescendantsHelper_(childOperation,childTree,childServerCache,childWritesCache));}});if(syncPoint){events=events.concat(syncPoint.applyOperation(operation,writesCache,serverCache));}return events;};/**
     * Static tracker for next query tag.
     * @type {number}
     * @private
     */SyncTree.nextQueryTag_=1;return SyncTree;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Mutable object which basically just stores a reference to the "latest" immutable snapshot.
 *
 * @constructor
 */var SnapshotHolder=/** @class */function(){function SnapshotHolder(){this.rootNode_=ChildrenNode.EMPTY_NODE;}SnapshotHolder.prototype.getNode=function(path){return this.rootNode_.getChild(path);};SnapshotHolder.prototype.updateSnapshot=function(path,newSnapshotNode){this.rootNode_=this.rootNode_.updateChild(path,newSnapshotNode);};return SnapshotHolder;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Abstraction around FirebaseApp's token fetching capabilities.
 */var AuthTokenProvider=/** @class */function(){/**
     * @param {!FirebaseApp} app_
     */function AuthTokenProvider(app_){this.app_=app_;}/**
     * @param {boolean} forceRefresh
     * @return {!Promise<FirebaseAuthTokenData>}
     */AuthTokenProvider.prototype.getToken=function(forceRefresh){return this.app_['INTERNAL']['getToken'](forceRefresh).then(null,// .catch
function(error){// TODO: Need to figure out all the cases this is raised and whether
// this makes sense.
if(error&&error.code==='auth/token-not-initialized'){log('Got auth/token-not-initialized error.  Treating as null token.');return null;}else{return Promise.reject(error);}});};AuthTokenProvider.prototype.addTokenChangeListener=function(listener){// TODO: We might want to wrap the listener and call it with no args to
// avoid a leaky abstraction, but that makes removing the listener harder.
this.app_['INTERNAL']['addAuthTokenListener'](listener);};AuthTokenProvider.prototype.removeTokenChangeListener=function(listener){this.app_['INTERNAL']['removeAuthTokenListener'](listener);};AuthTokenProvider.prototype.notifyForInvalidToken=function(){var errorMessage='Provided authentication credentials for the app named "'+this.app_.name+'" are invalid. This usually indicates your app was not '+'initialized correctly. ';if('credential'in this.app_.options){errorMessage+='Make sure the "credential" property provided to initializeApp() '+'is authorized to access the specified "databaseURL" and is from the correct '+'project.';}else if('serviceAccount'in this.app_.options){errorMessage+='Make sure the "serviceAccount" property provided to initializeApp() '+'is authorized to access the specified "databaseURL" and is from the correct '+'project.';}else{errorMessage+='Make sure the "apiKey" and "databaseURL" properties provided to '+'initializeApp() match the values provided for your app at '+'https://console.firebase.google.com/.';}warn(errorMessage);};return AuthTokenProvider;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Tracks a collection of stats.
 *
 * @constructor
 */var StatsCollection=/** @class */function(){function StatsCollection(){this.counters_={};}StatsCollection.prototype.incrementCounter=function(name,amount){if(amount===void 0){amount=1;}if(!util.contains(this.counters_,name))this.counters_[name]=0;this.counters_[name]+=amount;};StatsCollection.prototype.get=function(){return util.deepCopy(this.counters_);};return StatsCollection;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var StatsManager=/** @class */function(){function StatsManager(){}StatsManager.getCollection=function(repoInfo){var hashString=repoInfo.toString();if(!this.collections_[hashString]){this.collections_[hashString]=new StatsCollection();}return this.collections_[hashString];};StatsManager.getOrCreateReporter=function(repoInfo,creatorFunction){var hashString=repoInfo.toString();if(!this.reporters_[hashString]){this.reporters_[hashString]=creatorFunction();}return this.reporters_[hashString];};StatsManager.collections_={};StatsManager.reporters_={};return StatsManager;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Returns the delta from the previous call to get stats.
 *
 * @param collection_ The collection to "listen" to.
 * @constructor
 */var StatsListener=/** @class */function(){function StatsListener(collection_){this.collection_=collection_;this.last_=null;}StatsListener.prototype.get=function(){var newStats=this.collection_.get();var delta=util.clone(newStats);if(this.last_){util.forEach(this.last_,function(stat,value){delta[stat]=delta[stat]-value;});}this.last_=newStats;return delta;};return StatsListener;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably
// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10
// seconds to try to ensure the Firebase connection is established / settled.
var FIRST_STATS_MIN_TIME=10*1000;var FIRST_STATS_MAX_TIME=30*1000;// We'll continue to report stats on average every 5 minutes.
var REPORT_STATS_INTERVAL=5*60*1000;/**
 * @constructor
 */var StatsReporter=/** @class */function(){/**
     * @param collection
     * @param server_
     */function StatsReporter(collection,server_){this.server_=server_;this.statsToReport_={};this.statsListener_=new StatsListener(collection);var timeout=FIRST_STATS_MIN_TIME+(FIRST_STATS_MAX_TIME-FIRST_STATS_MIN_TIME)*Math.random();setTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(timeout));}StatsReporter.prototype.includeStat=function(stat){this.statsToReport_[stat]=true;};StatsReporter.prototype.reportStats_=function(){var _this=this;var stats=this.statsListener_.get();var reportedStats={};var haveStatsToReport=false;util.forEach(stats,function(stat,value){if(value>0&&util.contains(_this.statsToReport_,stat)){reportedStats[stat]=value;haveStatsToReport=true;}});if(haveStatsToReport){this.server_.reportStats(reportedStats);}// queue our next run.
setTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(Math.random()*2*REPORT_STATS_INTERVAL));};return StatsReporter;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * The event queue serves a few purposes:
 * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more
 *    events being queued.
 * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,
 *    raiseQueuedEvents() is called again, the "inner" call will pick up raising events where the "outer" call
 *    left off, ensuring that the events are still raised synchronously and in order.
 * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued
 *    events are raised synchronously.
 *
 * NOTE: This can all go away if/when we move to async events.
 *
 * @constructor
 */var EventQueue=/** @class */function(){function EventQueue(){/**
         * @private
         * @type {!Array.<EventList>}
         */this.eventLists_=[];/**
         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.
         * @private
         * @type {!number}
         */this.recursionDepth_=0;}/**
     * @param {!Array.<Event>} eventDataList The new events to queue.
     */EventQueue.prototype.queueEvents=function(eventDataList){// We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.
var currList=null;for(var i=0;i<eventDataList.length;i++){var eventData=eventDataList[i];var eventPath=eventData.getPath();if(currList!==null&&!eventPath.equals(currList.getPath())){this.eventLists_.push(currList);currList=null;}if(currList===null){currList=new EventList(eventPath);}currList.add(eventData);}if(currList){this.eventLists_.push(currList);}};/**
     * Queues the specified events and synchronously raises all events (including previously queued ones)
     * for the specified path.
     *
     * It is assumed that the new events are all for the specified path.
     *
     * @param {!Path} path The path to raise events for.
     * @param {!Array.<Event>} eventDataList The new events to raise.
     */EventQueue.prototype.raiseEventsAtPath=function(path,eventDataList){this.queueEvents(eventDataList);this.raiseQueuedEventsMatchingPredicate_(function(eventPath){return eventPath.equals(path);});};/**
     * Queues the specified events and synchronously raises all events (including previously queued ones) for
     * locations related to the specified change path (i.e. all ancestors and descendants).
     *
     * It is assumed that the new events are all related (ancestor or descendant) to the specified path.
     *
     * @param {!Path} changedPath The path to raise events for.
     * @param {!Array.<!Event>} eventDataList The events to raise
     */EventQueue.prototype.raiseEventsForChangedPath=function(changedPath,eventDataList){this.queueEvents(eventDataList);this.raiseQueuedEventsMatchingPredicate_(function(eventPath){return eventPath.contains(changedPath)||changedPath.contains(eventPath);});};/**
     * @param {!function(!Path):boolean} predicate
     * @private
     */EventQueue.prototype.raiseQueuedEventsMatchingPredicate_=function(predicate){this.recursionDepth_++;var sentAll=true;for(var i=0;i<this.eventLists_.length;i++){var eventList=this.eventLists_[i];if(eventList){var eventPath=eventList.getPath();if(predicate(eventPath)){this.eventLists_[i].raise();this.eventLists_[i]=null;}else{sentAll=false;}}}if(sentAll){this.eventLists_=[];}this.recursionDepth_--;};return EventQueue;}();/**
 * @param {!Path} path
 * @constructor
 */var EventList=/** @class */function(){function EventList(path_){this.path_=path_;/**
         * @type {!Array.<Event>}
         * @private
         */this.events_=[];}/**
     * @param {!Event} eventData
     */EventList.prototype.add=function(eventData){this.events_.push(eventData);};/**
     * Iterates through the list and raises each event
     */EventList.prototype.raise=function(){for(var i=0;i<this.events_.length;i++){var eventData=this.events_[i];if(eventData!==null){this.events_[i]=null;var eventFn=eventData.getEventRunner();if(logger){log('event: '+eventData.toString());}exceptionGuard(eventFn);}}};/**
     * @return {!Path}
     */EventList.prototype.getPath=function(){return this.path_;};return EventList;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Base class to be used if you want to emit events. Call the constructor with
 * the set of allowed event names.
 */var EventEmitter=/** @class */function(){/**
     * @param {!Array.<string>} allowedEvents_
     */function EventEmitter(allowedEvents_){this.allowedEvents_=allowedEvents_;this.listeners_={};util.assert(Array.isArray(allowedEvents_)&&allowedEvents_.length>0,'Requires a non-empty array');}/**
     * To be called by derived classes to trigger events.
     * @param {!string} eventType
     * @param {...*} var_args
     */EventEmitter.prototype.trigger=function(eventType){var var_args=[];for(var _i=1;_i<arguments.length;_i++){var_args[_i-1]=arguments[_i];}if(Array.isArray(this.listeners_[eventType])){// Clone the list, since callbacks could add/remove listeners.
var listeners=this.listeners_[eventType].slice();for(var i=0;i<listeners.length;i++){listeners[i].callback.apply(listeners[i].context,var_args);}}};EventEmitter.prototype.on=function(eventType,callback,context){this.validateEventType_(eventType);this.listeners_[eventType]=this.listeners_[eventType]||[];this.listeners_[eventType].push({callback:callback,context:context});var eventData=this.getInitialEvent(eventType);if(eventData){callback.apply(context,eventData);}};EventEmitter.prototype.off=function(eventType,callback,context){this.validateEventType_(eventType);var listeners=this.listeners_[eventType]||[];for(var i=0;i<listeners.length;i++){if(listeners[i].callback===callback&&(!context||context===listeners[i].context)){listeners.splice(i,1);return;}}};EventEmitter.prototype.validateEventType_=function(eventType){util.assert(this.allowedEvents_.find(function(et){return et===eventType;}),'Unknown event: '+eventType);};return EventEmitter;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @extends {EventEmitter}
 */var VisibilityMonitor=/** @class */function(_super){tslib_1.__extends(VisibilityMonitor,_super);function VisibilityMonitor(){var _this=_super.call(this,['visible'])||this;var hidden;var visibilityChange;if(typeof document!=='undefined'&&typeof document.addEventListener!=='undefined'){if(typeof document['hidden']!=='undefined'){// Opera 12.10 and Firefox 18 and later support
visibilityChange='visibilitychange';hidden='hidden';}else if(typeof document['mozHidden']!=='undefined'){visibilityChange='mozvisibilitychange';hidden='mozHidden';}else if(typeof document['msHidden']!=='undefined'){visibilityChange='msvisibilitychange';hidden='msHidden';}else if(typeof document['webkitHidden']!=='undefined'){visibilityChange='webkitvisibilitychange';hidden='webkitHidden';}}// Initially, we always assume we are visible. This ensures that in browsers
// without page visibility support or in cases where we are never visible
// (e.g. chrome extension), we act as if we are visible, i.e. don't delay
// reconnects
_this.visible_=true;if(visibilityChange){document.addEventListener(visibilityChange,function(){var visible=!document[hidden];if(visible!==_this.visible_){_this.visible_=visible;_this.trigger('visible',visible);}},false);}return _this;}VisibilityMonitor.getInstance=function(){return new VisibilityMonitor();};/**
     * @param {!string} eventType
     * @return {Array.<boolean>}
     */VisibilityMonitor.prototype.getInitialEvent=function(eventType){util.assert(eventType==='visible','Unknown event type: '+eventType);return[this.visible_];};return VisibilityMonitor;}(EventEmitter);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Monitors online state (as reported by window.online/offline events).
 *
 * The expectation is that this could have many false positives (thinks we are online
 * when we're not), but no false negatives.  So we can safely use it to determine when
 * we definitely cannot reach the internet.
 *
 * @extends {EventEmitter}
 */var OnlineMonitor=/** @class */function(_super){tslib_1.__extends(OnlineMonitor,_super);function OnlineMonitor(){var _this=_super.call(this,['online'])||this;_this.online_=true;// We've had repeated complaints that Cordova apps can get stuck "offline", e.g.
// https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810
// It would seem that the 'online' event does not always fire consistently. So we disable it
// for Cordova.
if(typeof window!=='undefined'&&typeof window.addEventListener!=='undefined'&&!util.isMobileCordova()){window.addEventListener('online',function(){if(!_this.online_){_this.online_=true;_this.trigger('online',true);}},false);window.addEventListener('offline',function(){if(_this.online_){_this.online_=false;_this.trigger('online',false);}},false);}return _this;}OnlineMonitor.getInstance=function(){return new OnlineMonitor();};/**
     * @param {!string} eventType
     * @return {Array.<boolean>}
     */OnlineMonitor.prototype.getInitialEvent=function(eventType){util.assert(eventType==='online','Unknown event type: '+eventType);return[this.online_];};/**
     * @return {boolean}
     */OnlineMonitor.prototype.currentlyOnline=function(){return this.online_;};return OnlineMonitor;}(EventEmitter);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * This class ensures the packets from the server arrive in order
 * This class takes data from the server and ensures it gets passed into the callbacks in order.
 * @constructor
 */var PacketReceiver=/** @class */function(){/**
     * @param onMessage_
     */function PacketReceiver(onMessage_){this.onMessage_=onMessage_;this.pendingResponses=[];this.currentResponseNum=0;this.closeAfterResponse=-1;this.onClose=null;}PacketReceiver.prototype.closeAfter=function(responseNum,callback){this.closeAfterResponse=responseNum;this.onClose=callback;if(this.closeAfterResponse<this.currentResponseNum){this.onClose();this.onClose=null;}};/**
     * Each message from the server comes with a response number, and an array of data. The responseNumber
     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all
     * browsers will respond in the same order as the requests we sent
     * @param {number} requestNum
     * @param {Array} data
     */PacketReceiver.prototype.handleResponse=function(requestNum,data){var _this=this;this.pendingResponses[requestNum]=data;var _loop_1=function(){var toProcess=this_1.pendingResponses[this_1.currentResponseNum];delete this_1.pendingResponses[this_1.currentResponseNum];var _loop_2=function(i){if(toProcess[i]){exceptionGuard(function(){_this.onMessage_(toProcess[i]);});}};for(var i=0;i<toProcess.length;++i){_loop_2(i);}if(this_1.currentResponseNum===this_1.closeAfterResponse){if(this_1.onClose){this_1.onClose();this_1.onClose=null;}return"break";}this_1.currentResponseNum++;};var this_1=this;while(this.pendingResponses[this.currentResponseNum]){var state_1=_loop_1();if(state_1==="break")break;}};return PacketReceiver;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // URL query parameters associated with longpolling
var FIREBASE_LONGPOLL_START_PARAM='start';var FIREBASE_LONGPOLL_CLOSE_COMMAND='close';var FIREBASE_LONGPOLL_COMMAND_CB_NAME='pLPCommand';var FIREBASE_LONGPOLL_DATA_CB_NAME='pRTLPCB';var FIREBASE_LONGPOLL_ID_PARAM='id';var FIREBASE_LONGPOLL_PW_PARAM='pw';var FIREBASE_LONGPOLL_SERIAL_PARAM='ser';var FIREBASE_LONGPOLL_CALLBACK_ID_PARAM='cb';var FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM='seg';var FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET='ts';var FIREBASE_LONGPOLL_DATA_PARAM='d';var FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM='disconn';var FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM='dframe';//Data size constants.
//TODO: Perf: the maximum length actually differs from browser to browser.
// We should check what browser we're on and set accordingly.
var MAX_URL_DATA_SIZE=1870;var SEG_HEADER_SIZE=30;//ie: &seg=8299234&ts=982389123&d=
var MAX_PAYLOAD_SIZE=MAX_URL_DATA_SIZE-SEG_HEADER_SIZE;/**
 * Keepalive period
 * send a fresh request at minimum every 25 seconds. Opera has a maximum request
 * length of 30 seconds that we can't exceed.
 * @const
 * @type {number}
 */var KEEPALIVE_REQUEST_INTERVAL=25000;/**
 * How long to wait before aborting a long-polling connection attempt.
 * @const
 * @type {number}
 */var LP_CONNECT_TIMEOUT=30000;/**
 * This class manages a single long-polling connection.
 *
 * @constructor
 * @implements {Transport}
 */var BrowserPollConnection=/** @class */function(){/**
     * @param {string} connId An identifier for this connection, used for logging
     * @param {RepoInfo} repoInfo The info for the endpoint to send data to.
     * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing
     *                                         transport session
     * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a
     *                                     connection previously
     */function BrowserPollConnection(connId,repoInfo,transportSessionId,lastSessionId){this.connId=connId;this.repoInfo=repoInfo;this.transportSessionId=transportSessionId;this.lastSessionId=lastSessionId;this.bytesSent=0;this.bytesReceived=0;this.everConnected_=false;this.log_=logWrapper(connId);this.stats_=StatsManager.getCollection(repoInfo);this.urlFn=function(params){return repoInfo.connectionURL(LONG_POLLING,params);};}/**
     *
     * @param {function(Object)} onMessage Callback when messages arrive
     * @param {function()} onDisconnect Callback with connection lost.
     */BrowserPollConnection.prototype.open=function(onMessage,onDisconnect){var _this=this;this.curSegmentNum=0;this.onDisconnect_=onDisconnect;this.myPacketOrderer=new PacketReceiver(onMessage);this.isClosed_=false;this.connectTimeoutTimer_=setTimeout(function(){_this.log_('Timed out trying to connect.');// Make sure we clear the host cache
_this.onClosed_();_this.connectTimeoutTimer_=null;},Math.floor(LP_CONNECT_TIMEOUT));// Ensure we delay the creation of the iframe until the DOM is loaded.
executeWhenDOMReady(function(){if(_this.isClosed_)return;//Set up a callback that gets triggered once a connection is set up.
_this.scriptTagHolder=new FirebaseIFrameScriptHolder(function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}var command=args[0],arg1=args[1],arg2=args[2];_this.incrementIncomingBytes_(args);if(!_this.scriptTagHolder)return;// we closed the connection.
if(_this.connectTimeoutTimer_){clearTimeout(_this.connectTimeoutTimer_);_this.connectTimeoutTimer_=null;}_this.everConnected_=true;if(command==FIREBASE_LONGPOLL_START_PARAM){_this.id=arg1;_this.password=arg2;}else if(command===FIREBASE_LONGPOLL_CLOSE_COMMAND){// Don't clear the host cache. We got a response from the server, so we know it's reachable
if(arg1){// We aren't expecting any more data (other than what the server's already in the process of sending us
// through our already open polls), so don't send any more.
_this.scriptTagHolder.sendNewPolls=false;// arg1 in this case is the last response number sent by the server. We should try to receive
// all of the responses up to this one before closing
_this.myPacketOrderer.closeAfter(arg1,function(){_this.onClosed_();});}else{_this.onClosed_();}}else{throw new Error('Unrecognized command received: '+command);}},function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}var pN=args[0],data=args[1];_this.incrementIncomingBytes_(args);_this.myPacketOrderer.handleResponse(pN,data);},function(){_this.onClosed_();},_this.urlFn);//Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results
//from cache.
var urlParams={};urlParams[FIREBASE_LONGPOLL_START_PARAM]='t';urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM]=Math.floor(Math.random()*100000000);if(_this.scriptTagHolder.uniqueCallbackIdentifier)urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM]=_this.scriptTagHolder.uniqueCallbackIdentifier;urlParams[VERSION_PARAM]=PROTOCOL_VERSION;if(_this.transportSessionId){urlParams[TRANSPORT_SESSION_PARAM]=_this.transportSessionId;}if(_this.lastSessionId){urlParams[LAST_SESSION_PARAM]=_this.lastSessionId;}if(!util.isNodeSdk()&&typeof location!=='undefined'&&location.href&&location.href.indexOf(FORGE_DOMAIN)!==-1){urlParams[REFERER_PARAM]=FORGE_REF;}var connectURL=_this.urlFn(urlParams);_this.log_('Connecting via long-poll to '+connectURL);_this.scriptTagHolder.addTag(connectURL,function(){/* do nothing */});});};/**
     * Call this when a handshake has completed successfully and we want to consider the connection established
     */BrowserPollConnection.prototype.start=function(){this.scriptTagHolder.startLongPoll(this.id,this.password);this.addDisconnectPingFrame(this.id,this.password);};/**
     * Forces long polling to be considered as a potential transport
     */BrowserPollConnection.forceAllow=function(){BrowserPollConnection.forceAllow_=true;};/**
     * Forces longpolling to not be considered as a potential transport
     */BrowserPollConnection.forceDisallow=function(){BrowserPollConnection.forceDisallow_=true;};// Static method, use string literal so it can be accessed in a generic way
BrowserPollConnection.isAvailable=function(){// NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in
// the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).
return BrowserPollConnection.forceAllow_||!BrowserPollConnection.forceDisallow_&&typeof document!=='undefined'&&document.createElement!=null&&!isChromeExtensionContentScript()&&!isWindowsStoreApp()&&!util.isNodeSdk();};/**
     * No-op for polling
     */BrowserPollConnection.prototype.markConnectionHealthy=function(){};/**
     * Stops polling and cleans up the iframe
     * @private
     */BrowserPollConnection.prototype.shutdown_=function(){this.isClosed_=true;if(this.scriptTagHolder){this.scriptTagHolder.close();this.scriptTagHolder=null;}//remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.
if(this.myDisconnFrame){document.body.removeChild(this.myDisconnFrame);this.myDisconnFrame=null;}if(this.connectTimeoutTimer_){clearTimeout(this.connectTimeoutTimer_);this.connectTimeoutTimer_=null;}};/**
     * Triggered when this transport is closed
     * @private
     */BrowserPollConnection.prototype.onClosed_=function(){if(!this.isClosed_){this.log_('Longpoll is closing itself');this.shutdown_();if(this.onDisconnect_){this.onDisconnect_(this.everConnected_);this.onDisconnect_=null;}}};/**
     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server
     * that we've left.
     */BrowserPollConnection.prototype.close=function(){if(!this.isClosed_){this.log_('Longpoll is being closed.');this.shutdown_();}};/**
     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then
     * broken into chunks (since URLs have a small maximum length).
     * @param {!Object} data The JSON data to transmit.
     */BrowserPollConnection.prototype.send=function(data){var dataStr=util.stringify(data);this.bytesSent+=dataStr.length;this.stats_.incrementCounter('bytes_sent',dataStr.length);//first, lets get the base64-encoded data
var base64data=util.base64Encode(dataStr);//We can only fit a certain amount in each URL, so we need to split this request
//up into multiple pieces if it doesn't fit in one request.
var dataSegs=splitStringBySize(base64data,MAX_PAYLOAD_SIZE);//Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number
//of segments so that we can reassemble the packet on the server.
for(var i=0;i<dataSegs.length;i++){this.scriptTagHolder.enqueueSegment(this.curSegmentNum,dataSegs.length,dataSegs[i]);this.curSegmentNum++;}};/**
     * This is how we notify the server that we're leaving.
     * We aren't able to send requests with DHTML on a window close event, but we can
     * trigger XHR requests in some browsers (everything but Opera basically).
     * @param {!string} id
     * @param {!string} pw
     */BrowserPollConnection.prototype.addDisconnectPingFrame=function(id,pw){if(util.isNodeSdk())return;this.myDisconnFrame=document.createElement('iframe');var urlParams={};urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM]='t';urlParams[FIREBASE_LONGPOLL_ID_PARAM]=id;urlParams[FIREBASE_LONGPOLL_PW_PARAM]=pw;this.myDisconnFrame.src=this.urlFn(urlParams);this.myDisconnFrame.style.display='none';document.body.appendChild(this.myDisconnFrame);};/**
     * Used to track the bytes received by this client
     * @param {*} args
     * @private
     */BrowserPollConnection.prototype.incrementIncomingBytes_=function(args){// TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.
var bytesReceived=util.stringify(args).length;this.bytesReceived+=bytesReceived;this.stats_.incrementCounter('bytes_received',bytesReceived);};return BrowserPollConnection;}();/*********************************************************************************************
 * A wrapper around an iframe that is used as a long-polling script holder.
 * @constructor
 *********************************************************************************************/var FirebaseIFrameScriptHolder=/** @class */function(){/**
     * @param commandCB - The callback to be called when control commands are recevied from the server.
     * @param onMessageCB - The callback to be triggered when responses arrive from the server.
     * @param onDisconnect - The callback to be triggered when this tag holder is closed
     * @param urlFn - A function that provides the URL of the endpoint to send data to.
     */function FirebaseIFrameScriptHolder(commandCB,onMessageCB,onDisconnect,urlFn){this.onDisconnect=onDisconnect;this.urlFn=urlFn;//We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause
//problems in some browsers.
/**
         * @type {CountedSet.<number, number>}
         */this.outstandingRequests=new CountedSet();//A queue of the pending segments waiting for transmission to the server.
this.pendingSegs=[];//A serial number. We use this for two things:
// 1) A way to ensure the browser doesn't cache responses to polls
// 2) A way to make the server aware when long-polls arrive in a different order than we started them. The
//    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute
//    JSONP code in the order it was added to the iframe.
this.currentSerial=Math.floor(Math.random()*100000000);// This gets set to false when we're "closing down" the connection (e.g. we're switching transports but there's still
// incoming data from the server that we're waiting for).
this.sendNewPolls=true;if(!util.isNodeSdk()){//Each script holder registers a couple of uniquely named callbacks with the window. These are called from the
//iframes where we put the long-polling script tags. We have two callbacks:
//   1) Command Callback - Triggered for control issues, like starting a connection.
//   2) Message Callback - Triggered when new data arrives.
this.uniqueCallbackIdentifier=LUIDGenerator();window[FIREBASE_LONGPOLL_COMMAND_CB_NAME+this.uniqueCallbackIdentifier]=commandCB;window[FIREBASE_LONGPOLL_DATA_CB_NAME+this.uniqueCallbackIdentifier]=onMessageCB;//Create an iframe for us to add script tags to.
this.myIFrame=FirebaseIFrameScriptHolder.createIFrame_();// Set the iframe's contents.
var script='';// if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient
// for ie9, but ie8 needs to do it again in the document itself.
if(this.myIFrame.src&&this.myIFrame.src.substr(0,'javascript:'.length)==='javascript:'){var currentDomain=document.domain;script='<script>document.domain="'+currentDomain+'";</script>';}var iframeContents='<html><body>'+script+'</body></html>';try{this.myIFrame.doc.open();this.myIFrame.doc.write(iframeContents);this.myIFrame.doc.close();}catch(e){log('frame writing exception');if(e.stack){log(e.stack);}log(e);}}else{this.commandCB=commandCB;this.onMessageCB=onMessageCB;}}/**
     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can
     * actually use.
     * @private
     * @return {Element}
     */FirebaseIFrameScriptHolder.createIFrame_=function(){var iframe=document.createElement('iframe');iframe.style.display='none';// This is necessary in order to initialize the document inside the iframe
if(document.body){document.body.appendChild(iframe);try{// If document.domain has been modified in IE, this will throw an error, and we need to set the
// domain of the iframe's document manually. We can do this via a javascript: url as the src attribute
// Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.
var a=iframe.contentWindow.document;if(!a){// Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.
log('No IE domain setting required');}}catch(e){var domain=document.domain;iframe.src="javascript:void((function(){document.open();document.domain='"+domain+"';document.close();})())";}}else{// LongPollConnection attempts to delay initialization until the document is ready, so hopefully this
// never gets hit.
throw'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';}// Get the document of the iframe in a browser-specific way.
if(iframe.contentDocument){iframe.doc=iframe.contentDocument;// Firefox, Opera, Safari
}else if(iframe.contentWindow){iframe.doc=iframe.contentWindow.document;// Internet Explorer
}else if(iframe.document){iframe.doc=iframe.document;//others?
}return iframe;};/**
     * Cancel all outstanding queries and remove the frame.
     */FirebaseIFrameScriptHolder.prototype.close=function(){var _this=this;//Mark this iframe as dead, so no new requests are sent.
this.alive=false;if(this.myIFrame){//We have to actually remove all of the html inside this iframe before removing it from the
//window, or IE will continue loading and executing the script tags we've already added, which
//can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.
this.myIFrame.doc.body.innerHTML='';setTimeout(function(){if(_this.myIFrame!==null){document.body.removeChild(_this.myIFrame);_this.myIFrame=null;}},Math.floor(0));}if(util.isNodeSdk()&&this.myID){var urlParams={};urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM]='t';urlParams[FIREBASE_LONGPOLL_ID_PARAM]=this.myID;urlParams[FIREBASE_LONGPOLL_PW_PARAM]=this.myPW;var theURL=this.urlFn(urlParams);FirebaseIFrameScriptHolder.nodeRestRequest(theURL);}// Protect from being called recursively.
var onDisconnect=this.onDisconnect;if(onDisconnect){this.onDisconnect=null;onDisconnect();}};/**
     * Actually start the long-polling session by adding the first script tag(s) to the iframe.
     * @param {!string} id - The ID of this connection
     * @param {!string} pw - The password for this connection
     */FirebaseIFrameScriptHolder.prototype.startLongPoll=function(id,pw){this.myID=id;this.myPW=pw;this.alive=true;//send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.
while(this.newRequest_()){}};/**
     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't
     * too many outstanding requests and we are still alive.
     *
     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if
     * needed.
     */FirebaseIFrameScriptHolder.prototype.newRequest_=function(){// We keep one outstanding request open all the time to receive data, but if we need to send data
// (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically
// close the old request.
if(this.alive&&this.sendNewPolls&&this.outstandingRequests.count()<(this.pendingSegs.length>0?2:1)){//construct our url
this.currentSerial++;var urlParams={};urlParams[FIREBASE_LONGPOLL_ID_PARAM]=this.myID;urlParams[FIREBASE_LONGPOLL_PW_PARAM]=this.myPW;urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM]=this.currentSerial;var theURL=this.urlFn(urlParams);//Now add as much data as we can.
var curDataString='';var i=0;while(this.pendingSegs.length>0){//first, lets see if the next segment will fit.
var nextSeg=this.pendingSegs[0];if(nextSeg.d.length+SEG_HEADER_SIZE+curDataString.length<=MAX_URL_DATA_SIZE){//great, the segment will fit. Lets append it.
var theSeg=this.pendingSegs.shift();curDataString=curDataString+'&'+FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM+i+'='+theSeg.seg+'&'+FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET+i+'='+theSeg.ts+'&'+FIREBASE_LONGPOLL_DATA_PARAM+i+'='+theSeg.d;i++;}else{break;}}theURL=theURL+curDataString;this.addLongPollTag_(theURL,this.currentSerial);return true;}else{return false;}};/**
     * Queue a packet for transmission to the server.
     * @param segnum - A sequential id for this packet segment used for reassembly
     * @param totalsegs - The total number of segments in this packet
     * @param data - The data for this segment.
     */FirebaseIFrameScriptHolder.prototype.enqueueSegment=function(segnum,totalsegs,data){//add this to the queue of segments to send.
this.pendingSegs.push({seg:segnum,ts:totalsegs,d:data});//send the data immediately if there isn't already data being transmitted, unless
//startLongPoll hasn't been called yet.
if(this.alive){this.newRequest_();}};/**
     * Add a script tag for a regular long-poll request.
     * @param {!string} url - The URL of the script tag.
     * @param {!number} serial - The serial number of the request.
     * @private
     */FirebaseIFrameScriptHolder.prototype.addLongPollTag_=function(url,serial){var _this=this;//remember that we sent this request.
this.outstandingRequests.add(serial,1);var doNewRequest=function(){_this.outstandingRequests.remove(serial);_this.newRequest_();};// If this request doesn't return on its own accord (by the server sending us some data), we'll
// create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.
var keepaliveTimeout=setTimeout(doNewRequest,Math.floor(KEEPALIVE_REQUEST_INTERVAL));var readyStateCB=function(){// Request completed.  Cancel the keepalive.
clearTimeout(keepaliveTimeout);// Trigger a new request so we can continue receiving data.
doNewRequest();};this.addTag(url,readyStateCB);};/**
     * Add an arbitrary script tag to the iframe.
     * @param {!string} url - The URL for the script tag source.
     * @param {!function()} loadCB - A callback to be triggered once the script has loaded.
     */FirebaseIFrameScriptHolder.prototype.addTag=function(url,loadCB){var _this=this;if(util.isNodeSdk()){this.doNodeLongPoll(url,loadCB);}else{setTimeout(function(){try{// if we're already closed, don't add this poll
if(!_this.sendNewPolls)return;var newScript_1=_this.myIFrame.doc.createElement('script');newScript_1.type='text/javascript';newScript_1.async=true;newScript_1.src=url;newScript_1.onload=newScript_1.onreadystatechange=function(){var rstate=newScript_1.readyState;if(!rstate||rstate==='loaded'||rstate==='complete'){newScript_1.onload=newScript_1.onreadystatechange=null;if(newScript_1.parentNode){newScript_1.parentNode.removeChild(newScript_1);}loadCB();}};newScript_1.onerror=function(){log('Long-poll script failed to load: '+url);_this.sendNewPolls=false;_this.close();};_this.myIFrame.doc.body.appendChild(newScript_1);}catch(e){// TODO: we should make this error visible somehow
}},Math.floor(1));}};return FirebaseIFrameScriptHolder;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var WEBSOCKET_MAX_FRAME_SIZE=16384;var WEBSOCKET_KEEPALIVE_INTERVAL=45000;var WebSocketImpl=null;if(typeof MozWebSocket!=='undefined'){WebSocketImpl=MozWebSocket;}else if(typeof WebSocket!=='undefined'){WebSocketImpl=WebSocket;}/**
 * Create a new websocket connection with the given callbacks.
 * @constructor
 * @implements {Transport}
 */var WebSocketConnection=/** @class */function(){/**
     * @param {string} connId identifier for this transport
     * @param {RepoInfo} repoInfo The info for the websocket endpoint.
     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection
     */function WebSocketConnection(connId,repoInfo,transportSessionId,lastSessionId){this.connId=connId;this.keepaliveTimer=null;this.frames=null;this.totalFrames=0;this.bytesSent=0;this.bytesReceived=0;this.log_=logWrapper(this.connId);this.stats_=StatsManager.getCollection(repoInfo);this.connURL=WebSocketConnection.connectionURL_(repoInfo,transportSessionId,lastSessionId);}/**
     * @param {RepoInfo} repoInfo The info for the websocket endpoint.
     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection
     * @return {string} connection url
     * @private
     */WebSocketConnection.connectionURL_=function(repoInfo,transportSessionId,lastSessionId){var urlParams={};urlParams[VERSION_PARAM]=PROTOCOL_VERSION;if(!util.isNodeSdk()&&typeof location!=='undefined'&&location.href&&location.href.indexOf(FORGE_DOMAIN)!==-1){urlParams[REFERER_PARAM]=FORGE_REF;}if(transportSessionId){urlParams[TRANSPORT_SESSION_PARAM]=transportSessionId;}if(lastSessionId){urlParams[LAST_SESSION_PARAM]=lastSessionId;}return repoInfo.connectionURL(WEBSOCKET,urlParams);};/**
     *
     * @param onMessage Callback when messages arrive
     * @param onDisconnect Callback with connection lost.
     */WebSocketConnection.prototype.open=function(onMessage,onDisconnect){var _this=this;this.onDisconnect=onDisconnect;this.onMessage=onMessage;this.log_('Websocket connecting to '+this.connURL);this.everConnected_=false;// Assume failure until proven otherwise.
PersistentStorage.set('previous_websocket_failure',true);try{if(util.isNodeSdk()){var device=util.CONSTANTS.NODE_ADMIN?'AdminNode':'Node';// UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>
var options={headers:{'User-Agent':"Firebase/"+PROTOCOL_VERSION+"/"+firebase.SDK_VERSION+"/"+process.platform+"/"+device}};// Plumb appropriate http_proxy environment variable into faye-websocket if it exists.
var env=process['env'];var proxy=this.connURL.indexOf('wss://')==0?env['HTTPS_PROXY']||env['https_proxy']:env['HTTP_PROXY']||env['http_proxy'];if(proxy){options['proxy']={origin:proxy};}this.mySock=new WebSocketImpl(this.connURL,[],options);}else{this.mySock=new WebSocketImpl(this.connURL);}}catch(e){this.log_('Error instantiating WebSocket.');var error=e.message||e.data;if(error){this.log_(error);}this.onClosed_();return;}this.mySock.onopen=function(){_this.log_('Websocket connected.');_this.everConnected_=true;};this.mySock.onclose=function(){_this.log_('Websocket connection was disconnected.');_this.mySock=null;_this.onClosed_();};this.mySock.onmessage=function(m){_this.handleIncomingFrame(m);};this.mySock.onerror=function(e){_this.log_('WebSocket error.  Closing connection.');var error=e.message||e.data;if(error){_this.log_(error);}_this.onClosed_();};};/**
     * No-op for websockets, we don't need to do anything once the connection is confirmed as open
     */WebSocketConnection.prototype.start=function(){};WebSocketConnection.forceDisallow=function(){WebSocketConnection.forceDisallow_=true;};WebSocketConnection.isAvailable=function(){var isOldAndroid=false;if(typeof navigator!=='undefined'&&navigator.userAgent){var oldAndroidRegex=/Android ([0-9]{0,}\.[0-9]{0,})/;var oldAndroidMatch=navigator.userAgent.match(oldAndroidRegex);if(oldAndroidMatch&&oldAndroidMatch.length>1){if(parseFloat(oldAndroidMatch[1])<4.4){isOldAndroid=true;}}}return!isOldAndroid&&WebSocketImpl!==null&&!WebSocketConnection.forceDisallow_;};/**
     * Returns true if we previously failed to connect with this transport.
     * @return {boolean}
     */WebSocketConnection.previouslyFailed=function(){// If our persistent storage is actually only in-memory storage,
// we default to assuming that it previously failed to be safe.
return PersistentStorage.isInMemoryStorage||PersistentStorage.get('previous_websocket_failure')===true;};WebSocketConnection.prototype.markConnectionHealthy=function(){PersistentStorage.remove('previous_websocket_failure');};WebSocketConnection.prototype.appendFrame_=function(data){this.frames.push(data);if(this.frames.length==this.totalFrames){var fullMess=this.frames.join('');this.frames=null;var jsonMess=util.jsonEval(fullMess);//handle the message
this.onMessage(jsonMess);}};/**
     * @param {number} frameCount The number of frames we are expecting from the server
     * @private
     */WebSocketConnection.prototype.handleNewFrameCount_=function(frameCount){this.totalFrames=frameCount;this.frames=[];};/**
     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1
     * @param {!String} data
     * @return {?String} Any remaining data to be process, or null if there is none
     * @private
     */WebSocketConnection.prototype.extractFrameCount_=function(data){util.assert(this.frames===null,'We already have a frame buffer');// TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced
// currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508
if(data.length<=6){var frameCount=Number(data);if(!isNaN(frameCount)){this.handleNewFrameCount_(frameCount);return null;}}this.handleNewFrameCount_(1);return data;};/**
     * Process a websocket frame that has arrived from the server.
     * @param mess The frame data
     */WebSocketConnection.prototype.handleIncomingFrame=function(mess){if(this.mySock===null)return;// Chrome apparently delivers incoming packets even after we .close() the connection sometimes.
var data=mess['data'];this.bytesReceived+=data.length;this.stats_.incrementCounter('bytes_received',data.length);this.resetKeepAlive();if(this.frames!==null){// we're buffering
this.appendFrame_(data);}else{// try to parse out a frame count, otherwise, assume 1 and process it
var remainingData=this.extractFrameCount_(data);if(remainingData!==null){this.appendFrame_(remainingData);}}};/**
     * Send a message to the server
     * @param {Object} data The JSON object to transmit
     */WebSocketConnection.prototype.send=function(data){this.resetKeepAlive();var dataStr=util.stringify(data);this.bytesSent+=dataStr.length;this.stats_.incrementCounter('bytes_sent',dataStr.length);//We can only fit a certain amount in each websocket frame, so we need to split this request
//up into multiple pieces if it doesn't fit in one request.
var dataSegs=splitStringBySize(dataStr,WEBSOCKET_MAX_FRAME_SIZE);//Send the length header
if(dataSegs.length>1){this.sendString_(String(dataSegs.length));}//Send the actual data in segments.
for(var i=0;i<dataSegs.length;i++){this.sendString_(dataSegs[i]);}};WebSocketConnection.prototype.shutdown_=function(){this.isClosed_=true;if(this.keepaliveTimer){clearInterval(this.keepaliveTimer);this.keepaliveTimer=null;}if(this.mySock){this.mySock.close();this.mySock=null;}};WebSocketConnection.prototype.onClosed_=function(){if(!this.isClosed_){this.log_('WebSocket is closing itself');this.shutdown_();// since this is an internal close, trigger the close listener
if(this.onDisconnect){this.onDisconnect(this.everConnected_);this.onDisconnect=null;}}};/**
     * External-facing close handler.
     * Close the websocket and kill the connection.
     */WebSocketConnection.prototype.close=function(){if(!this.isClosed_){this.log_('WebSocket is being closed');this.shutdown_();}};/**
     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after
     * the last activity.
     */WebSocketConnection.prototype.resetKeepAlive=function(){var _this=this;clearInterval(this.keepaliveTimer);this.keepaliveTimer=setInterval(function(){//If there has been no websocket activity for a while, send a no-op
if(_this.mySock){_this.sendString_('0');}_this.resetKeepAlive();},Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));};/**
     * Send a string over the websocket.
     *
     * @param {string} str String to send.
     * @private
     */WebSocketConnection.prototype.sendString_=function(str){// Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()
// calls for some unknown reason.  We treat these as an error and disconnect.
// See https://app.asana.com/0/58926111402292/68021340250410
try{this.mySock.send(str);}catch(e){this.log_('Exception thrown from WebSocket.send():',e.message||e.data,'Closing connection.');setTimeout(this.onClosed_.bind(this),0);}};/**
     * Number of response before we consider the connection "healthy."
     * @type {number}
     */WebSocketConnection.responsesRequiredToBeHealthy=2;/**
     * Time to wait for the connection te become healthy before giving up.
     * @type {number}
     */WebSocketConnection.healthyTimeout=30000;return WebSocketConnection;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Currently simplistic, this class manages what transport a Connection should use at various stages of its
 * lifecycle.
 *
 * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if
 * they are available.
 * @constructor
 */var TransportManager=/** @class */function(){/**
     * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to
     */function TransportManager(repoInfo){this.initTransports_(repoInfo);}Object.defineProperty(TransportManager,"ALL_TRANSPORTS",{/**
         * @const
         * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}
         */get:function(){return[BrowserPollConnection,WebSocketConnection];},enumerable:true,configurable:true});/**
     * @param {!RepoInfo} repoInfo
     * @private
     */TransportManager.prototype.initTransports_=function(repoInfo){var isWebSocketsAvailable=WebSocketConnection&&WebSocketConnection['isAvailable']();var isSkipPollConnection=isWebSocketsAvailable&&!WebSocketConnection.previouslyFailed();if(repoInfo.webSocketOnly){if(!isWebSocketsAvailable)warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");isSkipPollConnection=true;}if(isSkipPollConnection){this.transports_=[WebSocketConnection];}else{var transports_1=this.transports_=[];each(TransportManager.ALL_TRANSPORTS,function(i,transport){if(transport&&transport['isAvailable']()){transports_1.push(transport);}});}};/**
     * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the
     * initial transport to use
     */TransportManager.prototype.initialTransport=function(){if(this.transports_.length>0){return this.transports_[0];}else{throw new Error('No transports available');}};/**
     * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next
     * transport, or null
     */TransportManager.prototype.upgradeTransport=function(){if(this.transports_.length>1){return this.transports_[1];}else{return null;}};return TransportManager;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Abort upgrade attempt if it takes longer than 60s.
var UPGRADE_TIMEOUT=60000;// For some transports (WebSockets), we need to "validate" the transport by exchanging a few requests and responses.
// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.
var DELAY_BEFORE_SENDING_EXTRA_REQUESTS=5000;// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)
// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout
// but we've sent/received enough bytes, we don't cancel the connection.
var BYTES_SENT_HEALTHY_OVERRIDE=10*1024;var BYTES_RECEIVED_HEALTHY_OVERRIDE=100*1024;var MESSAGE_TYPE='t';var MESSAGE_DATA='d';var CONTROL_SHUTDOWN='s';var CONTROL_RESET='r';var CONTROL_ERROR='e';var CONTROL_PONG='o';var SWITCH_ACK='a';var END_TRANSMISSION='n';var PING='p';var SERVER_HELLO='h';/**
 * Creates a new real-time connection to the server using whichever method works
 * best in the current browser.
 *
 * @constructor
 */var Connection=/** @class */function(){/**
     * @param {!string} id - an id for this connection
     * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to
     * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives
     * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.
     * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost
     * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.
     * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server
     */function Connection(id,repoInfo_,onMessage_,onReady_,onDisconnect_,onKill_,lastSessionId){this.id=id;this.repoInfo_=repoInfo_;this.onMessage_=onMessage_;this.onReady_=onReady_;this.onDisconnect_=onDisconnect_;this.onKill_=onKill_;this.lastSessionId=lastSessionId;this.connectionCount=0;this.pendingDataMessages=[];this.state_=0/* CONNECTING */;this.log_=logWrapper('c:'+this.id+':');this.transportManager_=new TransportManager(repoInfo_);this.log_('Connection created');this.start_();}/**
     * Starts a connection attempt
     * @private
     */Connection.prototype.start_=function(){var _this=this;var conn=this.transportManager_.initialTransport();this.conn_=new conn(this.nextTransportId_(),this.repoInfo_,undefined,this.lastSessionId);// For certain transports (WebSockets), we need to send and receive several messages back and forth before we
// can consider the transport healthy.
this.primaryResponsesRequired_=conn['responsesRequiredToBeHealthy']||0;var onMessageReceived=this.connReceiver_(this.conn_);var onConnectionLost=this.disconnReceiver_(this.conn_);this.tx_=this.conn_;this.rx_=this.conn_;this.secondaryConn_=null;this.isHealthy_=false;/*
         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.
         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.
         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should
         * still have the context of your originating frame.
         */setTimeout(function(){// this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it
_this.conn_&&_this.conn_.open(onMessageReceived,onConnectionLost);},Math.floor(0));var healthyTimeout_ms=conn['healthyTimeout']||0;if(healthyTimeout_ms>0){this.healthyTimeout_=setTimeoutNonBlocking(function(){_this.healthyTimeout_=null;if(!_this.isHealthy_){if(_this.conn_&&_this.conn_.bytesReceived>BYTES_RECEIVED_HEALTHY_OVERRIDE){_this.log_('Connection exceeded healthy timeout but has received '+_this.conn_.bytesReceived+' bytes.  Marking connection healthy.');_this.isHealthy_=true;_this.conn_.markConnectionHealthy();}else if(_this.conn_&&_this.conn_.bytesSent>BYTES_SENT_HEALTHY_OVERRIDE){_this.log_('Connection exceeded healthy timeout but has sent '+_this.conn_.bytesSent+' bytes.  Leaving connection alive.');// NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to
// the server.
}else{_this.log_('Closing unhealthy connection after timeout.');_this.close();}}},Math.floor(healthyTimeout_ms));}};/**
     * @return {!string}
     * @private
     */Connection.prototype.nextTransportId_=function(){return'c:'+this.id+':'+this.connectionCount++;};Connection.prototype.disconnReceiver_=function(conn){var _this=this;return function(everConnected){if(conn===_this.conn_){_this.onConnectionLost_(everConnected);}else if(conn===_this.secondaryConn_){_this.log_('Secondary connection lost.');_this.onSecondaryConnectionLost_();}else{_this.log_('closing an old connection');}};};Connection.prototype.connReceiver_=function(conn){var _this=this;return function(message){if(_this.state_!=2/* DISCONNECTED */){if(conn===_this.rx_){_this.onPrimaryMessageReceived_(message);}else if(conn===_this.secondaryConn_){_this.onSecondaryMessageReceived_(message);}else{_this.log_('message on old connection');}}};};/**
     *
     * @param {Object} dataMsg An arbitrary data message to be sent to the server
     */Connection.prototype.sendRequest=function(dataMsg){// wrap in a data message envelope and send it on
var msg={t:'d',d:dataMsg};this.sendData_(msg);};Connection.prototype.tryCleanupConnection=function(){if(this.tx_===this.secondaryConn_&&this.rx_===this.secondaryConn_){this.log_('cleaning up and promoting a connection: '+this.secondaryConn_.connId);this.conn_=this.secondaryConn_;this.secondaryConn_=null;// the server will shutdown the old connection
}};Connection.prototype.onSecondaryControl_=function(controlData){if(MESSAGE_TYPE in controlData){var cmd=controlData[MESSAGE_TYPE];if(cmd===SWITCH_ACK){this.upgradeIfSecondaryHealthy_();}else if(cmd===CONTROL_RESET){// Most likely the session wasn't valid. Abandon the switch attempt
this.log_('Got a reset on secondary, closing it');this.secondaryConn_.close();// If we were already using this connection for something, than we need to fully close
if(this.tx_===this.secondaryConn_||this.rx_===this.secondaryConn_){this.close();}}else if(cmd===CONTROL_PONG){this.log_('got pong on secondary.');this.secondaryResponsesRequired_--;this.upgradeIfSecondaryHealthy_();}}};Connection.prototype.onSecondaryMessageReceived_=function(parsedData){var layer=requireKey('t',parsedData);var data=requireKey('d',parsedData);if(layer=='c'){this.onSecondaryControl_(data);}else if(layer=='d'){// got a data message, but we're still second connection. Need to buffer it up
this.pendingDataMessages.push(data);}else{throw new Error('Unknown protocol layer: '+layer);}};Connection.prototype.upgradeIfSecondaryHealthy_=function(){if(this.secondaryResponsesRequired_<=0){this.log_('Secondary connection is healthy.');this.isHealthy_=true;this.secondaryConn_.markConnectionHealthy();this.proceedWithUpgrade_();}else{// Send a ping to make sure the connection is healthy.
this.log_('sending ping on secondary.');this.secondaryConn_.send({t:'c',d:{t:PING,d:{}}});}};Connection.prototype.proceedWithUpgrade_=function(){// tell this connection to consider itself open
this.secondaryConn_.start();// send ack
this.log_('sending client ack on secondary');this.secondaryConn_.send({t:'c',d:{t:SWITCH_ACK,d:{}}});// send end packet on primary transport, switch to sending on this one
// can receive on this one, buffer responses until end received on primary transport
this.log_('Ending transmission on primary');this.conn_.send({t:'c',d:{t:END_TRANSMISSION,d:{}}});this.tx_=this.secondaryConn_;this.tryCleanupConnection();};Connection.prototype.onPrimaryMessageReceived_=function(parsedData){// Must refer to parsedData properties in quotes, so closure doesn't touch them.
var layer=requireKey('t',parsedData);var data=requireKey('d',parsedData);if(layer=='c'){this.onControl_(data);}else if(layer=='d'){this.onDataMessage_(data);}};Connection.prototype.onDataMessage_=function(message){this.onPrimaryResponse_();// We don't do anything with data messages, just kick them up a level
this.onMessage_(message);};Connection.prototype.onPrimaryResponse_=function(){if(!this.isHealthy_){this.primaryResponsesRequired_--;if(this.primaryResponsesRequired_<=0){this.log_('Primary connection is healthy.');this.isHealthy_=true;this.conn_.markConnectionHealthy();}}};Connection.prototype.onControl_=function(controlData){var cmd=requireKey(MESSAGE_TYPE,controlData);if(MESSAGE_DATA in controlData){var payload=controlData[MESSAGE_DATA];if(cmd===SERVER_HELLO){this.onHandshake_(payload);}else if(cmd===END_TRANSMISSION){this.log_('recvd end transmission on primary');this.rx_=this.secondaryConn_;for(var i=0;i<this.pendingDataMessages.length;++i){this.onDataMessage_(this.pendingDataMessages[i]);}this.pendingDataMessages=[];this.tryCleanupConnection();}else if(cmd===CONTROL_SHUTDOWN){// This was previously the 'onKill' callback passed to the lower-level connection
// payload in this case is the reason for the shutdown. Generally a human-readable error
this.onConnectionShutdown_(payload);}else if(cmd===CONTROL_RESET){// payload in this case is the host we should contact
this.onReset_(payload);}else if(cmd===CONTROL_ERROR){error('Server Error: '+payload);}else if(cmd===CONTROL_PONG){this.log_('got pong on primary.');this.onPrimaryResponse_();this.sendPingOnPrimaryIfNecessary_();}else{error('Unknown control packet command: '+cmd);}}};/**
     *
     * @param {Object} handshake The handshake data returned from the server
     * @private
     */Connection.prototype.onHandshake_=function(handshake){var timestamp=handshake.ts;var version=handshake.v;var host=handshake.h;this.sessionId=handshake.s;this.repoInfo_.updateHost(host);// if we've already closed the connection, then don't bother trying to progress further
if(this.state_==0/* CONNECTING */){this.conn_.start();this.onConnectionEstablished_(this.conn_,timestamp);if(PROTOCOL_VERSION!==version){warn('Protocol version mismatch detected');}// TODO: do we want to upgrade? when? maybe a delay?
this.tryStartUpgrade_();}};Connection.prototype.tryStartUpgrade_=function(){var conn=this.transportManager_.upgradeTransport();if(conn){this.startUpgrade_(conn);}};Connection.prototype.startUpgrade_=function(conn){var _this=this;this.secondaryConn_=new conn(this.nextTransportId_(),this.repoInfo_,this.sessionId);// For certain transports (WebSockets), we need to send and receive several messages back and forth before we
// can consider the transport healthy.
this.secondaryResponsesRequired_=conn['responsesRequiredToBeHealthy']||0;var onMessage=this.connReceiver_(this.secondaryConn_);var onDisconnect=this.disconnReceiver_(this.secondaryConn_);this.secondaryConn_.open(onMessage,onDisconnect);// If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.
setTimeoutNonBlocking(function(){if(_this.secondaryConn_){_this.log_('Timed out trying to upgrade.');_this.secondaryConn_.close();}},Math.floor(UPGRADE_TIMEOUT));};Connection.prototype.onReset_=function(host){this.log_('Reset packet received.  New host: '+host);this.repoInfo_.updateHost(host);// TODO: if we're already "connected", we need to trigger a disconnect at the next layer up.
// We don't currently support resets after the connection has already been established
if(this.state_===1/* CONNECTED */){this.close();}else{// Close whatever connections we have open and start again.
this.closeConnections_();this.start_();}};Connection.prototype.onConnectionEstablished_=function(conn,timestamp){var _this=this;this.log_('Realtime connection established.');this.conn_=conn;this.state_=1/* CONNECTED */;if(this.onReady_){this.onReady_(timestamp,this.sessionId);this.onReady_=null;}// If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,
// send some pings.
if(this.primaryResponsesRequired_===0){this.log_('Primary connection is healthy.');this.isHealthy_=true;}else{setTimeoutNonBlocking(function(){_this.sendPingOnPrimaryIfNecessary_();},Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));}};Connection.prototype.sendPingOnPrimaryIfNecessary_=function(){// If the connection isn't considered healthy yet, we'll send a noop ping packet request.
if(!this.isHealthy_&&this.state_===1/* CONNECTED */){this.log_('sending ping on primary.');this.sendData_({t:'c',d:{t:PING,d:{}}});}};Connection.prototype.onSecondaryConnectionLost_=function(){var conn=this.secondaryConn_;this.secondaryConn_=null;if(this.tx_===conn||this.rx_===conn){// we are relying on this connection already in some capacity. Therefore, a failure is real
this.close();}};/**
     *
     * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if
     * we should flush the host cache
     * @private
     */Connection.prototype.onConnectionLost_=function(everConnected){this.conn_=null;// NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting
// called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.
if(!everConnected&&this.state_===0/* CONNECTING */){this.log_('Realtime connection failed.');// Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away
if(this.repoInfo_.isCacheableHost()){PersistentStorage.remove('host:'+this.repoInfo_.host);// reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com
this.repoInfo_.internalHost=this.repoInfo_.host;}}else if(this.state_===1/* CONNECTED */){this.log_('Realtime connection lost.');}this.close();};/**
     *
     * @param {string} reason
     * @private
     */Connection.prototype.onConnectionShutdown_=function(reason){this.log_('Connection shutdown command received. Shutting down...');if(this.onKill_){this.onKill_(reason);this.onKill_=null;}// We intentionally don't want to fire onDisconnect (kill is a different case),
// so clear the callback.
this.onDisconnect_=null;this.close();};Connection.prototype.sendData_=function(data){if(this.state_!==1/* CONNECTED */){throw'Connection is not connected';}else{this.tx_.send(data);}};/**
     * Cleans up this connection, calling the appropriate callbacks
     */Connection.prototype.close=function(){if(this.state_!==2/* DISCONNECTED */){this.log_('Closing realtime connection.');this.state_=2/* DISCONNECTED */;this.closeConnections_();if(this.onDisconnect_){this.onDisconnect_();this.onDisconnect_=null;}}};/**
     *
     * @private
     */Connection.prototype.closeConnections_=function(){this.log_('Shutting down all connections');if(this.conn_){this.conn_.close();this.conn_=null;}if(this.secondaryConn_){this.secondaryConn_.close();this.secondaryConn_=null;}if(this.healthyTimeout_){clearTimeout(this.healthyTimeout_);this.healthyTimeout_=null;}};return Connection;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Interface defining the set of actions that can be performed against the Firebase server
 * (basically corresponds to our wire protocol).
 *
 * @interface
 */var ServerActions=/** @class */function(){function ServerActions(){}/**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     * @param {string=} hash
     */ServerActions.prototype.put=function(pathString,data,onComplete,hash){};/**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, ?string)} onComplete
     * @param {string=} hash
     */ServerActions.prototype.merge=function(pathString,data,onComplete,hash){};/**
     * Refreshes the auth token for the current connection.
     * @param {string} token The authentication token
     */ServerActions.prototype.refreshAuthToken=function(token){};/**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     */ServerActions.prototype.onDisconnectPut=function(pathString,data,onComplete){};/**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     */ServerActions.prototype.onDisconnectMerge=function(pathString,data,onComplete){};/**
     * @param {string} pathString
     * @param {function(string, string)=} onComplete
     */ServerActions.prototype.onDisconnectCancel=function(pathString,onComplete){};/**
     * @param {Object.<string, *>} stats
     */ServerActions.prototype.reportStats=function(stats){};return ServerActions;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var RECONNECT_MIN_DELAY=1000;var RECONNECT_MAX_DELAY_DEFAULT=60*5*1000;// 5 minutes in milliseconds (Case: 1858)
var RECONNECT_MAX_DELAY_FOR_ADMINS=30*1000;// 30 seconds for admin clients (likely to be a backend server)
var RECONNECT_DELAY_MULTIPLIER=1.3;var RECONNECT_DELAY_RESET_TIMEOUT=30000;// Reset delay back to MIN_DELAY after being connected for 30sec.
var SERVER_KILL_INTERRUPT_REASON='server_kill';// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.
var INVALID_AUTH_TOKEN_THRESHOLD=3;/**
 * Firebase connection.  Abstracts wire protocol and handles reconnecting.
 *
 * NOTE: All JSON objects sent to the realtime connection must have property names enclosed
 * in quotes to make sure the closure compiler does not minify them.
 */var PersistentConnection=/** @class */function(_super){tslib_1.__extends(PersistentConnection,_super);/**
     * @implements {ServerActions}
     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to
     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server
     * @param onConnectStatus_
     * @param onServerInfoUpdate_
     * @param authTokenProvider_
     * @param authOverride_
     */function PersistentConnection(repoInfo_,onDataUpdate_,onConnectStatus_,onServerInfoUpdate_,authTokenProvider_,authOverride_){var _this=_super.call(this)||this;_this.repoInfo_=repoInfo_;_this.onDataUpdate_=onDataUpdate_;_this.onConnectStatus_=onConnectStatus_;_this.onServerInfoUpdate_=onServerInfoUpdate_;_this.authTokenProvider_=authTokenProvider_;_this.authOverride_=authOverride_;// Used for diagnostic logging.
_this.id=PersistentConnection.nextPersistentConnectionId_++;_this.log_=logWrapper('p:'+_this.id+':');/** @private {Object} */_this.interruptReasons_={};_this.listens_={};_this.outstandingPuts_=[];_this.outstandingPutCount_=0;_this.onDisconnectRequestQueue_=[];_this.connected_=false;_this.reconnectDelay_=RECONNECT_MIN_DELAY;_this.maxReconnectDelay_=RECONNECT_MAX_DELAY_DEFAULT;_this.securityDebugCallback_=null;_this.lastSessionId=null;/** @private {number|null} */_this.establishConnectionTimer_=null;/** @private {boolean} */_this.visible_=false;// Before we get connected, we keep a queue of pending messages to send.
_this.requestCBHash_={};_this.requestNumber_=0;/** @private {?{
         *   sendRequest(Object),
         *   close()
         * }} */_this.realtime_=null;/** @private {string|null} */_this.authToken_=null;_this.forceTokenRefresh_=false;_this.invalidAuthTokenCount_=0;_this.firstConnection_=true;_this.lastConnectionAttemptTime_=null;_this.lastConnectionEstablishedTime_=null;if(authOverride_&&!util.isNodeSdk()){throw new Error('Auth override specified in options, but not supported on non Node.js platforms');}_this.scheduleConnect_(0);VisibilityMonitor.getInstance().on('visible',_this.onVisible_,_this);if(repoInfo_.host.indexOf('fblocal')===-1){OnlineMonitor.getInstance().on('online',_this.onOnline_,_this);}return _this;}/**
     * @param {!string} action
     * @param {*} body
     * @param {function(*)=} onResponse
     * @protected
     */PersistentConnection.prototype.sendRequest=function(action,body,onResponse){var curReqNum=++this.requestNumber_;var msg={r:curReqNum,a:action,b:body};this.log_(util.stringify(msg));util.assert(this.connected_,"sendRequest call when we're not connected not allowed.");this.realtime_.sendRequest(msg);if(onResponse){this.requestCBHash_[curReqNum]=onResponse;}};/**
     * @inheritDoc
     */PersistentConnection.prototype.listen=function(query,currentHashFn,tag,onComplete){var queryId=query.queryIdentifier();var pathString=query.path.toString();this.log_('Listen called for '+pathString+' '+queryId);this.listens_[pathString]=this.listens_[pathString]||{};util.assert(query.getQueryParams().isDefault()||!query.getQueryParams().loadsAllData(),'listen() called for non-default but complete query');util.assert(!this.listens_[pathString][queryId],'listen() called twice for same path/queryId.');var listenSpec={onComplete:onComplete,hashFn:currentHashFn,query:query,tag:tag};this.listens_[pathString][queryId]=listenSpec;if(this.connected_){this.sendListen_(listenSpec);}};/**
     * @param {!{onComplete(),
     *           hashFn():!string,
     *           query: !Query,
     *           tag: ?number}} listenSpec
     * @private
     */PersistentConnection.prototype.sendListen_=function(listenSpec){var _this=this;var query=listenSpec.query;var pathString=query.path.toString();var queryId=query.queryIdentifier();this.log_('Listen on '+pathString+' for '+queryId);var req={/*path*/p:pathString};var action='q';// Only bother to send query if it's non-default.
if(listenSpec.tag){req['q']=query.queryObject();req['t']=listenSpec.tag;}req[/*hash*/'h']=listenSpec.hashFn();this.sendRequest(action,req,function(message){var payload=message[/*data*/'d'];var status=message[/*status*/'s'];// print warnings in any case...
PersistentConnection.warnOnListenWarnings_(payload,query);var currentListenSpec=_this.listens_[pathString]&&_this.listens_[pathString][queryId];// only trigger actions if the listen hasn't been removed and readded
if(currentListenSpec===listenSpec){_this.log_('listen response',message);if(status!=='ok'){_this.removeListen_(pathString,queryId);}if(listenSpec.onComplete){listenSpec.onComplete(status,payload);}}});};/**
     * @param {*} payload
     * @param {!Query} query
     * @private
     */PersistentConnection.warnOnListenWarnings_=function(payload,query){if(payload&&typeof payload==='object'&&util.contains(payload,'w')){var warnings=util.safeGet(payload,'w');if(Array.isArray(warnings)&&~warnings.indexOf('no_index')){var indexSpec='".indexOn": "'+query.getQueryParams().getIndex().toString()+'"';var indexPath=query.path.toString();warn("Using an unspecified index. Your data will be downloaded and "+("filtered on the client. Consider adding "+indexSpec+" at ")+(indexPath+" to your security rules for better performance."));}}};/**
     * @inheritDoc
     */PersistentConnection.prototype.refreshAuthToken=function(token){this.authToken_=token;this.log_('Auth token refreshed');if(this.authToken_){this.tryAuth();}else{//If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete
//the credential so we dont become authenticated next time we connect.
if(this.connected_){this.sendRequest('unauth',{},function(){});}}this.reduceReconnectDelayIfAdminCredential_(token);};/**
     * @param {!string} credential
     * @private
     */PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_=function(credential){// NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).
// Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.
var isFirebaseSecret=credential&&credential.length===40;if(isFirebaseSecret||util.isAdmin(credential)){this.log_('Admin auth credential detected.  Reducing max reconnect time.');this.maxReconnectDelay_=RECONNECT_MAX_DELAY_FOR_ADMINS;}};/**
     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like
     * a auth revoked (the connection is closed).
     */PersistentConnection.prototype.tryAuth=function(){var _this=this;if(this.connected_&&this.authToken_){var token_1=this.authToken_;var authMethod=util.isValidFormat(token_1)?'auth':'gauth';var requestData={cred:token_1};if(this.authOverride_===null){requestData['noauth']=true;}else if(typeof this.authOverride_==='object'){requestData['authvar']=this.authOverride_;}this.sendRequest(authMethod,requestData,function(res){var status=res[/*status*/'s'];var data=res[/*data*/'d']||'error';if(_this.authToken_===token_1){if(status==='ok'){_this.invalidAuthTokenCount_=0;}else{// Triggers reconnect and force refresh for auth token
_this.onAuthRevoked_(status,data);}}});}};/**
     * @inheritDoc
     */PersistentConnection.prototype.unlisten=function(query,tag){var pathString=query.path.toString();var queryId=query.queryIdentifier();this.log_('Unlisten called for '+pathString+' '+queryId);util.assert(query.getQueryParams().isDefault()||!query.getQueryParams().loadsAllData(),'unlisten() called for non-default but complete query');var listen=this.removeListen_(pathString,queryId);if(listen&&this.connected_){this.sendUnlisten_(pathString,queryId,query.queryObject(),tag);}};PersistentConnection.prototype.sendUnlisten_=function(pathString,queryId,queryObj,tag){this.log_('Unlisten on '+pathString+' for '+queryId);var req={/*path*/p:pathString};var action='n';// Only bother sending queryId if it's non-default.
if(tag){req['q']=queryObj;req['t']=tag;}this.sendRequest(action,req);};/**
     * @inheritDoc
     */PersistentConnection.prototype.onDisconnectPut=function(pathString,data,onComplete){if(this.connected_){this.sendOnDisconnect_('o',pathString,data,onComplete);}else{this.onDisconnectRequestQueue_.push({pathString:pathString,action:'o',data:data,onComplete:onComplete});}};/**
     * @inheritDoc
     */PersistentConnection.prototype.onDisconnectMerge=function(pathString,data,onComplete){if(this.connected_){this.sendOnDisconnect_('om',pathString,data,onComplete);}else{this.onDisconnectRequestQueue_.push({pathString:pathString,action:'om',data:data,onComplete:onComplete});}};/**
     * @inheritDoc
     */PersistentConnection.prototype.onDisconnectCancel=function(pathString,onComplete){if(this.connected_){this.sendOnDisconnect_('oc',pathString,null,onComplete);}else{this.onDisconnectRequestQueue_.push({pathString:pathString,action:'oc',data:null,onComplete:onComplete});}};PersistentConnection.prototype.sendOnDisconnect_=function(action,pathString,data,onComplete){var request={/*path*/p:pathString,/*data*/d:data};this.log_('onDisconnect '+action,request);this.sendRequest(action,request,function(response){if(onComplete){setTimeout(function(){onComplete(response[/*status*/'s'],response[/* data */'d']);},Math.floor(0));}});};/**
     * @inheritDoc
     */PersistentConnection.prototype.put=function(pathString,data,onComplete,hash){this.putInternal('p',pathString,data,onComplete,hash);};/**
     * @inheritDoc
     */PersistentConnection.prototype.merge=function(pathString,data,onComplete,hash){this.putInternal('m',pathString,data,onComplete,hash);};PersistentConnection.prototype.putInternal=function(action,pathString,data,onComplete,hash){var request={/*path*/p:pathString,/*data*/d:data};if(hash!==undefined)request[/*hash*/'h']=hash;// TODO: Only keep track of the most recent put for a given path?
this.outstandingPuts_.push({action:action,request:request,onComplete:onComplete});this.outstandingPutCount_++;var index=this.outstandingPuts_.length-1;if(this.connected_){this.sendPut_(index);}else{this.log_('Buffering put: '+pathString);}};PersistentConnection.prototype.sendPut_=function(index){var _this=this;var action=this.outstandingPuts_[index].action;var request=this.outstandingPuts_[index].request;var onComplete=this.outstandingPuts_[index].onComplete;this.outstandingPuts_[index].queued=this.connected_;this.sendRequest(action,request,function(message){_this.log_(action+' response',message);delete _this.outstandingPuts_[index];_this.outstandingPutCount_--;// Clean up array occasionally.
if(_this.outstandingPutCount_===0){_this.outstandingPuts_=[];}if(onComplete)onComplete(message[/*status*/'s'],message[/* data */'d']);});};/**
     * @inheritDoc
     */PersistentConnection.prototype.reportStats=function(stats){var _this=this;// If we're not connected, we just drop the stats.
if(this.connected_){var request={/*counters*/c:stats};this.log_('reportStats',request);this.sendRequest(/*stats*/'s',request,function(result){var status=result[/*status*/'s'];if(status!=='ok'){var errorReason=result[/* data */'d'];_this.log_('reportStats','Error sending stats: '+errorReason);}});}};/**
     * @param {*} message
     * @private
     */PersistentConnection.prototype.onDataMessage_=function(message){if('r'in message){// this is a response
this.log_('from server: '+util.stringify(message));var reqNum=message['r'];var onResponse=this.requestCBHash_[reqNum];if(onResponse){delete this.requestCBHash_[reqNum];onResponse(message[/*body*/'b']);}}else if('error'in message){throw'A server-side error has occurred: '+message['error'];}else if('a'in message){// a and b are action and body, respectively
this.onDataPush_(message['a'],message['b']);}};PersistentConnection.prototype.onDataPush_=function(action,body){this.log_('handleServerMessage',action,body);if(action==='d')this.onDataUpdate_(body[/*path*/'p'],body[/*data*/'d'],/*isMerge*/false,body['t']);else if(action==='m')this.onDataUpdate_(body[/*path*/'p'],body[/*data*/'d'],/*isMerge=*/true,body['t']);else if(action==='c')this.onListenRevoked_(body[/*path*/'p'],body[/*query*/'q']);else if(action==='ac')this.onAuthRevoked_(body[/*status code*/'s'],body[/* explanation */'d']);else if(action==='sd')this.onSecurityDebugPacket_(body);else error('Unrecognized action received from server: '+util.stringify(action)+'\nAre you using the latest client?');};PersistentConnection.prototype.onReady_=function(timestamp,sessionId){this.log_('connection ready');this.connected_=true;this.lastConnectionEstablishedTime_=new Date().getTime();this.handleTimestamp_(timestamp);this.lastSessionId=sessionId;if(this.firstConnection_){this.sendConnectStats_();}this.restoreState_();this.firstConnection_=false;this.onConnectStatus_(true);};PersistentConnection.prototype.scheduleConnect_=function(timeout){var _this=this;util.assert(!this.realtime_,"Scheduling a connect when we're already connected/ing?");if(this.establishConnectionTimer_){clearTimeout(this.establishConnectionTimer_);}// NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating "Security Error" in
// Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).
this.establishConnectionTimer_=setTimeout(function(){_this.establishConnectionTimer_=null;_this.establishConnection_();},Math.floor(timeout));};/**
     * @param {boolean} visible
     * @private
     */PersistentConnection.prototype.onVisible_=function(visible){// NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.
if(visible&&!this.visible_&&this.reconnectDelay_===this.maxReconnectDelay_){this.log_('Window became visible.  Reducing delay.');this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0);}}this.visible_=visible;};PersistentConnection.prototype.onOnline_=function(online){if(online){this.log_('Browser went online.');this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0);}}else{this.log_('Browser went offline.  Killing connection.');if(this.realtime_){this.realtime_.close();}}};PersistentConnection.prototype.onRealtimeDisconnect_=function(){this.log_('data client disconnected');this.connected_=false;this.realtime_=null;// Since we don't know if our sent transactions succeeded or not, we need to cancel them.
this.cancelSentTransactions_();// Clear out the pending requests.
this.requestCBHash_={};if(this.shouldReconnect_()){if(!this.visible_){this.log_("Window isn't visible.  Delaying reconnect.");this.reconnectDelay_=this.maxReconnectDelay_;this.lastConnectionAttemptTime_=new Date().getTime();}else if(this.lastConnectionEstablishedTime_){// If we've been connected long enough, reset reconnect delay to minimum.
var timeSinceLastConnectSucceeded=new Date().getTime()-this.lastConnectionEstablishedTime_;if(timeSinceLastConnectSucceeded>RECONNECT_DELAY_RESET_TIMEOUT)this.reconnectDelay_=RECONNECT_MIN_DELAY;this.lastConnectionEstablishedTime_=null;}var timeSinceLastConnectAttempt=new Date().getTime()-this.lastConnectionAttemptTime_;var reconnectDelay=Math.max(0,this.reconnectDelay_-timeSinceLastConnectAttempt);reconnectDelay=Math.random()*reconnectDelay;this.log_('Trying to reconnect in '+reconnectDelay+'ms');this.scheduleConnect_(reconnectDelay);// Adjust reconnect delay for next time.
this.reconnectDelay_=Math.min(this.maxReconnectDelay_,this.reconnectDelay_*RECONNECT_DELAY_MULTIPLIER);}this.onConnectStatus_(false);};PersistentConnection.prototype.establishConnection_=function(){if(this.shouldReconnect_()){this.log_('Making a connection attempt');this.lastConnectionAttemptTime_=new Date().getTime();this.lastConnectionEstablishedTime_=null;var onDataMessage_1=this.onDataMessage_.bind(this);var onReady_1=this.onReady_.bind(this);var onDisconnect_1=this.onRealtimeDisconnect_.bind(this);var connId_1=this.id+':'+PersistentConnection.nextConnectionId_++;var self_1=this;var lastSessionId_1=this.lastSessionId;var canceled_1=false;var connection_1=null;var closeFn_1=function(){if(connection_1){connection_1.close();}else{canceled_1=true;onDisconnect_1();}};var sendRequestFn=function(msg){util.assert(connection_1,"sendRequest call when we're not connected not allowed.");connection_1.sendRequest(msg);};this.realtime_={close:closeFn_1,sendRequest:sendRequestFn};var forceRefresh=this.forceTokenRefresh_;this.forceTokenRefresh_=false;// First fetch auth token, and establish connection after fetching the token was successful
this.authTokenProvider_.getToken(forceRefresh).then(function(result){if(!canceled_1){log('getToken() completed. Creating connection.');self_1.authToken_=result&&result.accessToken;connection_1=new Connection(connId_1,self_1.repoInfo_,onDataMessage_1,onReady_1,onDisconnect_1,/* onKill= */function(reason){warn(reason+' ('+self_1.repoInfo_.toString()+')');self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);},lastSessionId_1);}else{log('getToken() completed but was canceled');}}).then(null,function(error){self_1.log_('Failed to get token: '+error);if(!canceled_1){if(util.CONSTANTS.NODE_ADMIN){// This may be a critical error for the Admin Node.js SDK, so log a warning.
// But getToken() may also just have temporarily failed, so we still want to
// continue retrying.
warn(error);}closeFn_1();}});}};/**
     * @param {string} reason
     */PersistentConnection.prototype.interrupt=function(reason){log('Interrupting connection for reason: '+reason);this.interruptReasons_[reason]=true;if(this.realtime_){this.realtime_.close();}else{if(this.establishConnectionTimer_){clearTimeout(this.establishConnectionTimer_);this.establishConnectionTimer_=null;}if(this.connected_){this.onRealtimeDisconnect_();}}};/**
     * @param {string} reason
     */PersistentConnection.prototype.resume=function(reason){log('Resuming connection for reason: '+reason);delete this.interruptReasons_[reason];if(util.isEmpty(this.interruptReasons_)){this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0);}}};PersistentConnection.prototype.handleTimestamp_=function(timestamp){var delta=timestamp-new Date().getTime();this.onServerInfoUpdate_({serverTimeOffset:delta});};PersistentConnection.prototype.cancelSentTransactions_=function(){for(var i=0;i<this.outstandingPuts_.length;i++){var put=this.outstandingPuts_[i];if(put&&/*hash*/'h'in put.request&&put.queued){if(put.onComplete)put.onComplete('disconnect');delete this.outstandingPuts_[i];this.outstandingPutCount_--;}}// Clean up array occasionally.
if(this.outstandingPutCount_===0)this.outstandingPuts_=[];};/**
     * @param {!string} pathString
     * @param {Array.<*>=} query
     * @private
     */PersistentConnection.prototype.onListenRevoked_=function(pathString,query){// Remove the listen and manufacture a "permission_denied" error for the failed listen.
var queryId;if(!query){queryId='default';}else{queryId=query.map(function(q){return ObjectToUniqueKey(q);}).join('$');}var listen=this.removeListen_(pathString,queryId);if(listen&&listen.onComplete)listen.onComplete('permission_denied');};/**
     * @param {!string} pathString
     * @param {!string} queryId
     * @return {{queries:Array.<Query>, onComplete:function(string)}}
     * @private
     */PersistentConnection.prototype.removeListen_=function(pathString,queryId){var normalizedPathString=new Path(pathString).toString();// normalize path.
var listen;if(this.listens_[normalizedPathString]!==undefined){listen=this.listens_[normalizedPathString][queryId];delete this.listens_[normalizedPathString][queryId];if(util.getCount(this.listens_[normalizedPathString])===0){delete this.listens_[normalizedPathString];}}else{// all listens for this path has already been removed
listen=undefined;}return listen;};PersistentConnection.prototype.onAuthRevoked_=function(statusCode,explanation){log('Auth token revoked: '+statusCode+'/'+explanation);this.authToken_=null;this.forceTokenRefresh_=true;this.realtime_.close();if(statusCode==='invalid_token'||statusCode==='permission_denied'){// We'll wait a couple times before logging the warning / increasing the
// retry period since oauth tokens will report as "invalid" if they're
// just expired. Plus there may be transient issues that resolve themselves.
this.invalidAuthTokenCount_++;if(this.invalidAuthTokenCount_>=INVALID_AUTH_TOKEN_THRESHOLD){// Set a long reconnect delay because recovery is unlikely
this.reconnectDelay_=RECONNECT_MAX_DELAY_FOR_ADMINS;// Notify the auth token provider that the token is invalid, which will log
// a warning
this.authTokenProvider_.notifyForInvalidToken();}}};PersistentConnection.prototype.onSecurityDebugPacket_=function(body){if(this.securityDebugCallback_){this.securityDebugCallback_(body);}else{if('msg'in body){console.log('FIREBASE: '+body['msg'].replace('\n','\nFIREBASE: '));}}};PersistentConnection.prototype.restoreState_=function(){var _this=this;//Re-authenticate ourselves if we have a credential stored.
this.tryAuth();// Puts depend on having received the corresponding data update from the server before they complete, so we must
// make sure to send listens before puts.
util.forEach(this.listens_,function(pathString,queries){util.forEach(queries,function(key,listenSpec){_this.sendListen_(listenSpec);});});for(var i=0;i<this.outstandingPuts_.length;i++){if(this.outstandingPuts_[i])this.sendPut_(i);}while(this.onDisconnectRequestQueue_.length){var request=this.onDisconnectRequestQueue_.shift();this.sendOnDisconnect_(request.action,request.pathString,request.data,request.onComplete);}};/**
     * Sends client stats for first connection
     * @private
     */PersistentConnection.prototype.sendConnectStats_=function(){var stats={};var clientName='js';if(util.CONSTANTS.NODE_ADMIN){clientName='admin_node';}else if(util.CONSTANTS.NODE_CLIENT){clientName='node';}stats['sdk.'+clientName+'.'+firebase.SDK_VERSION.replace(/\./g,'-')]=1;if(util.isMobileCordova()){stats['framework.cordova']=1;}else if(util.isReactNative()){stats['framework.reactnative']=1;}this.reportStats(stats);};/**
     * @return {boolean}
     * @private
     */PersistentConnection.prototype.shouldReconnect_=function(){var online=OnlineMonitor.getInstance().currentlyOnline();return util.isEmpty(this.interruptReasons_)&&online;};/**
     * @private
     */PersistentConnection.nextPersistentConnectionId_=0;/**
     * Counter for number of connections created. Mainly used for tagging in the logs
     * @type {number}
     * @private
     */PersistentConnection.nextConnectionId_=0;return PersistentConnection;}(ServerActions);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */var ReadonlyRestClient=/** @class */function(_super){tslib_1.__extends(ReadonlyRestClient,_super);/**
     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to
     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server
     * @param {AuthTokenProvider} authTokenProvider_
     * @implements {ServerActions}
     */function ReadonlyRestClient(repoInfo_,onDataUpdate_,authTokenProvider_){var _this=_super.call(this)||this;_this.repoInfo_=repoInfo_;_this.onDataUpdate_=onDataUpdate_;_this.authTokenProvider_=authTokenProvider_;/** @private {function(...[*])} */_this.log_=logWrapper('p:rest:');/**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         *
         * @private {!Object.<string, !Object>}
         */_this.listens_={};return _this;}ReadonlyRestClient.prototype.reportStats=function(stats){throw new Error('Method not implemented.');};/**
     * @param {!Query} query
     * @param {?number=} tag
     * @return {string}
     * @private
     */ReadonlyRestClient.getListenId_=function(query,tag){if(tag!==undefined){return'tag$'+tag;}else{util.assert(query.getQueryParams().isDefault(),"should have a tag if it's not a default query.");return query.path.toString();}};/** @inheritDoc */ReadonlyRestClient.prototype.listen=function(query,currentHashFn,tag,onComplete){var _this=this;var pathString=query.path.toString();this.log_('Listen called for '+pathString+' '+query.queryIdentifier());// Mark this listener so we can tell if it's removed.
var listenId=ReadonlyRestClient.getListenId_(query,tag);var thisListen={};this.listens_[listenId]=thisListen;var queryStringParameters=query.getQueryParams().toRestQueryStringParameters();this.restRequest_(pathString+'.json',queryStringParameters,function(error,result){var data=result;if(error===404){data=null;error=null;}if(error===null){_this.onDataUpdate_(pathString,data,/*isMerge=*/false,tag);}if(util.safeGet(_this.listens_,listenId)===thisListen){var status_1;if(!error){status_1='ok';}else if(error==401){status_1='permission_denied';}else{status_1='rest_error:'+error;}onComplete(status_1,null);}});};/** @inheritDoc */ReadonlyRestClient.prototype.unlisten=function(query,tag){var listenId=ReadonlyRestClient.getListenId_(query,tag);delete this.listens_[listenId];};/** @inheritDoc */ReadonlyRestClient.prototype.refreshAuthToken=function(token){// no-op since we just always call getToken.
};/**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     *
     * @param {!string} pathString
     * @param {!Object.<string, *>} queryStringParameters
     * @param {?function(?number, *=)} callback
     * @private
     */ReadonlyRestClient.prototype.restRequest_=function(pathString,queryStringParameters,callback){var _this=this;if(queryStringParameters===void 0){queryStringParameters={};}queryStringParameters['format']='export';this.authTokenProvider_.getToken(/*forceRefresh=*/false).then(function(authTokenData){var authToken=authTokenData&&authTokenData.accessToken;if(authToken){queryStringParameters['auth']=authToken;}var url=(_this.repoInfo_.secure?'https://':'http://')+_this.repoInfo_.host+pathString+'?'+'ns='+_this.repoInfo_.namespace+util.querystring(queryStringParameters);_this.log_('Sending REST request for '+url);var xhr=new XMLHttpRequest();xhr.onreadystatechange=function(){if(callback&&xhr.readyState===4){_this.log_('REST Response for '+url+' received. status:',xhr.status,'response:',xhr.responseText);var res=null;if(xhr.status>=200&&xhr.status<300){try{res=util.jsonEval(xhr.responseText);}catch(e){warn('Failed to parse JSON response for '+url+': '+xhr.responseText);}callback(null,res);}else{// 401 and 404 are expected.
if(xhr.status!==401&&xhr.status!==404){warn('Got unsuccessful REST response for '+url+' Status: '+xhr.status);}callback(xhr.status);}callback=null;}};xhr.open('GET',url,/*asynchronous=*/true);xhr.send();});};return ReadonlyRestClient;}(ServerActions);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var INTERRUPT_REASON='repo_interrupt';/**
 * A connection to a single data repository.
 */var Repo=/** @class */function(){/**
     * @param {!RepoInfo} repoInfo_
     * @param {boolean} forceRestClient
     * @param {!FirebaseApp} app
     */function Repo(repoInfo_,forceRestClient,app){var _this=this;this.repoInfo_=repoInfo_;this.app=app;this.dataUpdateCount=0;this.statsListener_=null;this.eventQueue_=new EventQueue();this.nextWriteId_=1;this.interceptServerDataCallback_=null;// A list of data pieces and paths to be set when this client disconnects.
this.onDisconnect_=new SparseSnapshotTree();/**
         * TODO: This should be @private but it's used by test_access.js and internal.js
         * @type {?PersistentConnection}
         */this.persistentConnection_=null;/** @type {!AuthTokenProvider} */var authTokenProvider=new AuthTokenProvider(app);this.stats_=StatsManager.getCollection(repoInfo_);if(forceRestClient||beingCrawled()){this.server_=new ReadonlyRestClient(this.repoInfo_,this.onDataUpdate_.bind(this),authTokenProvider);// Minor hack: Fire onConnect immediately, since there's no actual connection.
setTimeout(this.onConnectStatus_.bind(this,true),0);}else{var authOverride=app.options['databaseAuthVariableOverride'];// Validate authOverride
if(typeof authOverride!=='undefined'&&authOverride!==null){if(typeof authOverride!=='object'){throw new Error('Only objects are supported for option databaseAuthVariableOverride');}try{util.stringify(authOverride);}catch(e){throw new Error('Invalid authOverride provided: '+e);}}this.persistentConnection_=new PersistentConnection(this.repoInfo_,this.onDataUpdate_.bind(this),this.onConnectStatus_.bind(this),this.onServerInfoUpdate_.bind(this),authTokenProvider,authOverride);this.server_=this.persistentConnection_;}authTokenProvider.addTokenChangeListener(function(token){_this.server_.refreshAuthToken(token);});// In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
// we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
this.statsReporter_=StatsManager.getOrCreateReporter(repoInfo_,function(){return new StatsReporter(_this.stats_,_this.server_);});this.transactions_init_();// Used for .info.
this.infoData_=new SnapshotHolder();this.infoSyncTree_=new SyncTree({startListening:function(query,tag,currentHashFn,onComplete){var infoEvents=[];var node=_this.infoData_.getNode(query.path);// This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
// on initial data...
if(!node.isEmpty()){infoEvents=_this.infoSyncTree_.applyServerOverwrite(query.path,node);setTimeout(function(){onComplete('ok');},0);}return infoEvents;},stopListening:function(){}});this.updateInfo_('connected',false);this.serverSyncTree_=new SyncTree({startListening:function(query,tag,currentHashFn,onComplete){_this.server_.listen(query,currentHashFn,tag,function(status,data){var events=onComplete(status,data);_this.eventQueue_.raiseEventsForChangedPath(query.path,events);});// No synchronous events for network-backed sync trees
return[];},stopListening:function(query,tag){_this.server_.unlisten(query,tag);}});}/**
     * @return {string}  The URL corresponding to the root of this Firebase.
     */Repo.prototype.toString=function(){return(this.repoInfo_.secure?'https://':'http://')+this.repoInfo_.host;};/**
     * @return {!string} The namespace represented by the repo.
     */Repo.prototype.name=function(){return this.repoInfo_.namespace;};/**
     * @return {!number} The time in milliseconds, taking the server offset into account if we have one.
     */Repo.prototype.serverTime=function(){var offsetNode=this.infoData_.getNode(new Path('.info/serverTimeOffset'));var offset=offsetNode.val()||0;return new Date().getTime()+offset;};/**
     * Generate ServerValues using some variables from the repo object.
     * @return {!Object}
     */Repo.prototype.generateServerValues=function(){return generateWithValues({timestamp:this.serverTime()});};/**
     * Called by realtime when we get new messages from the server.
     *
     * @private
     * @param {string} pathString
     * @param {*} data
     * @param {boolean} isMerge
     * @param {?number} tag
     */Repo.prototype.onDataUpdate_=function(pathString,data,isMerge,tag){// For testing.
this.dataUpdateCount++;var path=new Path(pathString);data=this.interceptServerDataCallback_?this.interceptServerDataCallback_(pathString,data):data;var events=[];if(tag){if(isMerge){var taggedChildren=util.map(data,function(raw){return nodeFromJSON$1(raw);});events=this.serverSyncTree_.applyTaggedQueryMerge(path,taggedChildren,tag);}else{var taggedSnap=nodeFromJSON$1(data);events=this.serverSyncTree_.applyTaggedQueryOverwrite(path,taggedSnap,tag);}}else if(isMerge){var changedChildren=util.map(data,function(raw){return nodeFromJSON$1(raw);});events=this.serverSyncTree_.applyServerMerge(path,changedChildren);}else{var snap=nodeFromJSON$1(data);events=this.serverSyncTree_.applyServerOverwrite(path,snap);}var affectedPath=path;if(events.length>0){// Since we have a listener outstanding for each transaction, receiving any events
// is a proxy for some change having occurred.
affectedPath=this.rerunTransactions_(path);}this.eventQueue_.raiseEventsForChangedPath(affectedPath,events);};/**
     * TODO: This should be @private but it's used by test_access.js and internal.js
     * @param {?function(!string, *):*} callback
     * @private
     */Repo.prototype.interceptServerData_=function(callback){this.interceptServerDataCallback_=callback;};/**
     * @param {!boolean} connectStatus
     * @private
     */Repo.prototype.onConnectStatus_=function(connectStatus){this.updateInfo_('connected',connectStatus);if(connectStatus===false){this.runOnDisconnectEvents_();}};/**
     * @param {!Object} updates
     * @private
     */Repo.prototype.onServerInfoUpdate_=function(updates){var _this=this;each(updates,function(value,key){_this.updateInfo_(key,value);});};/**
     *
     * @param {!string} pathString
     * @param {*} value
     * @private
     */Repo.prototype.updateInfo_=function(pathString,value){var path=new Path('/.info/'+pathString);var newNode=nodeFromJSON$1(value);this.infoData_.updateSnapshot(path,newNode);var events=this.infoSyncTree_.applyServerOverwrite(path,newNode);this.eventQueue_.raiseEventsForChangedPath(path,events);};/**
     * @return {!number}
     * @private
     */Repo.prototype.getNextWriteId_=function(){return this.nextWriteId_++;};/**
     * @param {!Path} path
     * @param {*} newVal
     * @param {number|string|null} newPriority
     * @param {?function(?Error, *=)} onComplete
     */Repo.prototype.setWithPriority=function(path,newVal,newPriority,onComplete){var _this=this;this.log_('set',{path:path.toString(),value:newVal,priority:newPriority});// TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
// (b) store unresolved paths on JSON parse
var serverValues=this.generateServerValues();var newNodeUnresolved=nodeFromJSON$1(newVal,newPriority);var newNode=resolveDeferredValueSnapshot(newNodeUnresolved,serverValues);var writeId=this.getNextWriteId_();var events=this.serverSyncTree_.applyUserOverwrite(path,newNode,writeId,true);this.eventQueue_.queueEvents(events);this.server_.put(path.toString(),newNodeUnresolved.val(/*export=*/true),function(status,errorReason){var success=status==='ok';if(!success){warn('set at '+path+' failed: '+status);}var clearEvents=_this.serverSyncTree_.ackUserWrite(writeId,!success);_this.eventQueue_.raiseEventsForChangedPath(path,clearEvents);_this.callOnCompleteCallback(onComplete,status,errorReason);});var affectedPath=this.abortTransactions_(path);this.rerunTransactions_(affectedPath);// We queued the events above, so just flush the queue here
this.eventQueue_.raiseEventsForChangedPath(affectedPath,[]);};/**
     * @param {!Path} path
     * @param {!Object} childrenToMerge
     * @param {?function(?Error, *=)} onComplete
     */Repo.prototype.update=function(path,childrenToMerge,onComplete){var _this=this;this.log_('update',{path:path.toString(),value:childrenToMerge});// Start with our existing data and merge each child into it.
var empty=true;var serverValues=this.generateServerValues();var changedChildren={};util.forEach(childrenToMerge,function(changedKey,changedValue){empty=false;var newNodeUnresolved=nodeFromJSON$1(changedValue);changedChildren[changedKey]=resolveDeferredValueSnapshot(newNodeUnresolved,serverValues);});if(!empty){var writeId_1=this.getNextWriteId_();var events=this.serverSyncTree_.applyUserMerge(path,changedChildren,writeId_1);this.eventQueue_.queueEvents(events);this.server_.merge(path.toString(),childrenToMerge,function(status,errorReason){var success=status==='ok';if(!success){warn('update at '+path+' failed: '+status);}var clearEvents=_this.serverSyncTree_.ackUserWrite(writeId_1,!success);var affectedPath=clearEvents.length>0?_this.rerunTransactions_(path):path;_this.eventQueue_.raiseEventsForChangedPath(affectedPath,clearEvents);_this.callOnCompleteCallback(onComplete,status,errorReason);});util.forEach(childrenToMerge,function(changedPath){var affectedPath=_this.abortTransactions_(path.child(changedPath));_this.rerunTransactions_(affectedPath);});// We queued the events above, so just flush the queue here
this.eventQueue_.raiseEventsForChangedPath(path,[]);}else{log("update() called with empty data.  Don't do anything.");this.callOnCompleteCallback(onComplete,'ok');}};/**
     * Applies all of the changes stored up in the onDisconnect_ tree.
     * @private
     */Repo.prototype.runOnDisconnectEvents_=function(){var _this=this;this.log_('onDisconnectEvents');var serverValues=this.generateServerValues();var resolvedOnDisconnectTree=resolveDeferredValueTree(this.onDisconnect_,serverValues);var events=[];resolvedOnDisconnectTree.forEachTree(Path.Empty,function(path,snap){events=events.concat(_this.serverSyncTree_.applyServerOverwrite(path,snap));var affectedPath=_this.abortTransactions_(path);_this.rerunTransactions_(affectedPath);});this.onDisconnect_=new SparseSnapshotTree();this.eventQueue_.raiseEventsForChangedPath(Path.Empty,events);};/**
     * @param {!Path} path
     * @param {?function(?Error, *=)} onComplete
     */Repo.prototype.onDisconnectCancel=function(path,onComplete){var _this=this;this.server_.onDisconnectCancel(path.toString(),function(status,errorReason){if(status==='ok'){_this.onDisconnect_.forget(path);}_this.callOnCompleteCallback(onComplete,status,errorReason);});};/**
     * @param {!Path} path
     * @param {*} value
     * @param {?function(?Error, *=)} onComplete
     */Repo.prototype.onDisconnectSet=function(path,value,onComplete){var _this=this;var newNode=nodeFromJSON$1(value);this.server_.onDisconnectPut(path.toString(),newNode.val(/*export=*/true),function(status,errorReason){if(status==='ok'){_this.onDisconnect_.remember(path,newNode);}_this.callOnCompleteCallback(onComplete,status,errorReason);});};/**
     * @param {!Path} path
     * @param {*} value
     * @param {*} priority
     * @param {?function(?Error, *=)} onComplete
     */Repo.prototype.onDisconnectSetWithPriority=function(path,value,priority,onComplete){var _this=this;var newNode=nodeFromJSON$1(value,priority);this.server_.onDisconnectPut(path.toString(),newNode.val(/*export=*/true),function(status,errorReason){if(status==='ok'){_this.onDisconnect_.remember(path,newNode);}_this.callOnCompleteCallback(onComplete,status,errorReason);});};/**
     * @param {!Path} path
     * @param {*} childrenToMerge
     * @param {?function(?Error, *=)} onComplete
     */Repo.prototype.onDisconnectUpdate=function(path,childrenToMerge,onComplete){var _this=this;if(util.isEmpty(childrenToMerge)){log("onDisconnect().update() called with empty data.  Don't do anything.");this.callOnCompleteCallback(onComplete,'ok');return;}this.server_.onDisconnectMerge(path.toString(),childrenToMerge,function(status,errorReason){if(status==='ok'){util.forEach(childrenToMerge,function(childName,childNode){var newChildNode=nodeFromJSON$1(childNode);_this.onDisconnect_.remember(path.child(childName),newChildNode);});}_this.callOnCompleteCallback(onComplete,status,errorReason);});};/**
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     */Repo.prototype.addEventCallbackForQuery=function(query,eventRegistration){var events;if(query.path.getFront()==='.info'){events=this.infoSyncTree_.addEventRegistration(query,eventRegistration);}else{events=this.serverSyncTree_.addEventRegistration(query,eventRegistration);}this.eventQueue_.raiseEventsAtPath(query.path,events);};/**
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration
     */Repo.prototype.removeEventCallbackForQuery=function(query,eventRegistration){// These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
// a little bit by handling the return values anyways.
var events;if(query.path.getFront()==='.info'){events=this.infoSyncTree_.removeEventRegistration(query,eventRegistration);}else{events=this.serverSyncTree_.removeEventRegistration(query,eventRegistration);}this.eventQueue_.raiseEventsAtPath(query.path,events);};Repo.prototype.interrupt=function(){if(this.persistentConnection_){this.persistentConnection_.interrupt(INTERRUPT_REASON);}};Repo.prototype.resume=function(){if(this.persistentConnection_){this.persistentConnection_.resume(INTERRUPT_REASON);}};Repo.prototype.stats=function(showDelta){if(showDelta===void 0){showDelta=false;}if(typeof console==='undefined')return;var stats;if(showDelta){if(!this.statsListener_)this.statsListener_=new StatsListener(this.stats_);stats=this.statsListener_.get();}else{stats=this.stats_.get();}var longestName=Object.keys(stats).reduce(function(previousValue,currentValue){return Math.max(currentValue.length,previousValue);},0);util.forEach(stats,function(stat,value){// pad stat names to be the same length (plus 2 extra spaces).
for(var i=stat.length;i<longestName+2;i++)stat+=' ';console.log(stat+value);});};Repo.prototype.statsIncrementCounter=function(metric){this.stats_.incrementCounter(metric);this.statsReporter_.includeStat(metric);};/**
     * @param {...*} var_args
     * @private
     */Repo.prototype.log_=function(){var var_args=[];for(var _i=0;_i<arguments.length;_i++){var_args[_i]=arguments[_i];}var prefix='';if(this.persistentConnection_){prefix=this.persistentConnection_.id+':';}log.apply(void 0,[prefix].concat(var_args));};/**
     * @param {?function(?Error, *=)} callback
     * @param {!string} status
     * @param {?string=} errorReason
     */Repo.prototype.callOnCompleteCallback=function(callback,status,errorReason){if(callback){exceptionGuard(function(){if(status=='ok'){callback(null);}else{var code=(status||'error').toUpperCase();var message=code;if(errorReason)message+=': '+errorReason;var error=new Error(message);error.code=code;callback(error);}});}};Object.defineProperty(Repo.prototype,"database",{get:function(){return this.__database||(this.__database=new Database(this));},enumerable:true,configurable:true});return Repo;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node
 *
 * @constructor
 * @implements {NodeFilter}
 */var RangedFilter=/** @class */function(){/**
     * @param {!QueryParams} params
     */function RangedFilter(params){this.indexedFilter_=new IndexedFilter(params.getIndex());this.index_=params.getIndex();this.startPost_=RangedFilter.getStartPost_(params);this.endPost_=RangedFilter.getEndPost_(params);}/**
     * @return {!NamedNode}
     */RangedFilter.prototype.getStartPost=function(){return this.startPost_;};/**
     * @return {!NamedNode}
     */RangedFilter.prototype.getEndPost=function(){return this.endPost_;};/**
     * @param {!NamedNode} node
     * @return {boolean}
     */RangedFilter.prototype.matches=function(node){return this.index_.compare(this.getStartPost(),node)<=0&&this.index_.compare(node,this.getEndPost())<=0;};/**
     * @inheritDoc
     */RangedFilter.prototype.updateChild=function(snap,key,newChild,affectedPath,source,optChangeAccumulator){if(!this.matches(new NamedNode(key,newChild))){newChild=ChildrenNode.EMPTY_NODE;}return this.indexedFilter_.updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator);};/**
     * @inheritDoc
     */RangedFilter.prototype.updateFullNode=function(oldSnap,newSnap,optChangeAccumulator){if(newSnap.isLeafNode()){// Make sure we have a children node with the correct index, not a leaf node;
newSnap=ChildrenNode.EMPTY_NODE;}var filtered=newSnap.withIndex(this.index_);// Don't support priorities on queries
filtered=filtered.updatePriority(ChildrenNode.EMPTY_NODE);var self=this;newSnap.forEachChild(PRIORITY_INDEX,function(key,childNode){if(!self.matches(new NamedNode(key,childNode))){filtered=filtered.updateImmediateChild(key,ChildrenNode.EMPTY_NODE);}});return this.indexedFilter_.updateFullNode(oldSnap,filtered,optChangeAccumulator);};/**
     * @inheritDoc
     */RangedFilter.prototype.updatePriority=function(oldSnap,newPriority){// Don't support priorities on queries
return oldSnap;};/**
     * @inheritDoc
     */RangedFilter.prototype.filtersNodes=function(){return true;};/**
     * @inheritDoc
     */RangedFilter.prototype.getIndexedFilter=function(){return this.indexedFilter_;};/**
     * @inheritDoc
     */RangedFilter.prototype.getIndex=function(){return this.index_;};/**
     * @param {!QueryParams} params
     * @return {!NamedNode}
     * @private
     */RangedFilter.getStartPost_=function(params){if(params.hasStart()){var startName=params.getIndexStartName();return params.getIndex().makePost(params.getIndexStartValue(),startName);}else{return params.getIndex().minPost();}};/**
     * @param {!QueryParams} params
     * @return {!NamedNode}
     * @private
     */RangedFilter.getEndPost_=function(params){if(params.hasEnd()){var endName=params.getIndexEndName();return params.getIndex().makePost(params.getIndexEndValue(),endName);}else{return params.getIndex().maxPost();}};return RangedFilter;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 *
 * @constructor
 * @implements {NodeFilter}
 */var LimitedFilter=/** @class */function(){/**
     * @param {!QueryParams} params
     */function LimitedFilter(params){this.rangedFilter_=new RangedFilter(params);this.index_=params.getIndex();this.limit_=params.getLimit();this.reverse_=!params.isViewFromLeft();}/**
     * @inheritDoc
     */LimitedFilter.prototype.updateChild=function(snap,key,newChild,affectedPath,source,optChangeAccumulator){if(!this.rangedFilter_.matches(new NamedNode(key,newChild))){newChild=ChildrenNode.EMPTY_NODE;}if(snap.getImmediateChild(key).equals(newChild)){// No change
return snap;}else if(snap.numChildren()<this.limit_){return this.rangedFilter_.getIndexedFilter().updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator);}else{return this.fullLimitUpdateChild_(snap,key,newChild,source,optChangeAccumulator);}};/**
     * @inheritDoc
     */LimitedFilter.prototype.updateFullNode=function(oldSnap,newSnap,optChangeAccumulator){var filtered;if(newSnap.isLeafNode()||newSnap.isEmpty()){// Make sure we have a children node with the correct index, not a leaf node;
filtered=ChildrenNode.EMPTY_NODE.withIndex(this.index_);}else{if(this.limit_*2<newSnap.numChildren()&&newSnap.isIndexed(this.index_)){// Easier to build up a snapshot, since what we're given has more than twice the elements we want
filtered=ChildrenNode.EMPTY_NODE.withIndex(this.index_);// anchor to the startPost, endPost, or last element as appropriate
var iterator=void 0;if(this.reverse_){iterator=newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(),this.index_);}else{iterator=newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(),this.index_);}var count=0;while(iterator.hasNext()&&count<this.limit_){var next=iterator.getNext();var inRange=void 0;if(this.reverse_){inRange=this.index_.compare(this.rangedFilter_.getStartPost(),next)<=0;}else{inRange=this.index_.compare(next,this.rangedFilter_.getEndPost())<=0;}if(inRange){filtered=filtered.updateImmediateChild(next.name,next.node);count++;}else{// if we have reached the end post, we cannot keep adding elemments
break;}}}else{// The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
filtered=newSnap.withIndex(this.index_);// Don't support priorities on queries
filtered=filtered.updatePriority(ChildrenNode.EMPTY_NODE);var startPost=void 0;var endPost=void 0;var cmp=void 0;var iterator=void 0;if(this.reverse_){iterator=filtered.getReverseIterator(this.index_);startPost=this.rangedFilter_.getEndPost();endPost=this.rangedFilter_.getStartPost();var indexCompare_1=this.index_.getCompare();cmp=function(a,b){return indexCompare_1(b,a);};}else{iterator=filtered.getIterator(this.index_);startPost=this.rangedFilter_.getStartPost();endPost=this.rangedFilter_.getEndPost();cmp=this.index_.getCompare();}var count=0;var foundStartPost=false;while(iterator.hasNext()){var next=iterator.getNext();if(!foundStartPost&&cmp(startPost,next)<=0){// start adding
foundStartPost=true;}var inRange=foundStartPost&&count<this.limit_&&cmp(next,endPost)<=0;if(inRange){count++;}else{filtered=filtered.updateImmediateChild(next.name,ChildrenNode.EMPTY_NODE);}}}}return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap,filtered,optChangeAccumulator);};/**
     * @inheritDoc
     */LimitedFilter.prototype.updatePriority=function(oldSnap,newPriority){// Don't support priorities on queries
return oldSnap;};/**
     * @inheritDoc
     */LimitedFilter.prototype.filtersNodes=function(){return true;};/**
     * @inheritDoc
     */LimitedFilter.prototype.getIndexedFilter=function(){return this.rangedFilter_.getIndexedFilter();};/**
     * @inheritDoc
     */LimitedFilter.prototype.getIndex=function(){return this.index_;};/**
     * @param {!Node} snap
     * @param {string} childKey
     * @param {!Node} childSnap
     * @param {!CompleteChildSource} source
     * @param {?ChildChangeAccumulator} changeAccumulator
     * @return {!Node}
     * @private
     */LimitedFilter.prototype.fullLimitUpdateChild_=function(snap,childKey,childSnap,source,changeAccumulator){// TODO: rename all cache stuff etc to general snap terminology
var cmp;if(this.reverse_){var indexCmp_1=this.index_.getCompare();cmp=function(a,b){return indexCmp_1(b,a);};}else{cmp=this.index_.getCompare();}var oldEventCache=snap;util.assert(oldEventCache.numChildren()==this.limit_,'');var newChildNamedNode=new NamedNode(childKey,childSnap);var windowBoundary=this.reverse_?oldEventCache.getFirstChild(this.index_):oldEventCache.getLastChild(this.index_);var inRange=this.rangedFilter_.matches(newChildNamedNode);if(oldEventCache.hasChild(childKey)){var oldChildSnap=oldEventCache.getImmediateChild(childKey);var nextChild=source.getChildAfterChild(this.index_,windowBoundary,this.reverse_);while(nextChild!=null&&(nextChild.name==childKey||oldEventCache.hasChild(nextChild.name))){// There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
// been applied to the limited filter yet. Ignore this next child which will be updated later in
// the limited filter...
nextChild=source.getChildAfterChild(this.index_,nextChild,this.reverse_);}var compareNext=nextChild==null?1:cmp(nextChild,newChildNamedNode);var remainsInWindow=inRange&&!childSnap.isEmpty()&&compareNext>=0;if(remainsInWindow){if(changeAccumulator!=null){changeAccumulator.trackChildChange(Change.childChangedChange(childKey,childSnap,oldChildSnap));}return oldEventCache.updateImmediateChild(childKey,childSnap);}else{if(changeAccumulator!=null){changeAccumulator.trackChildChange(Change.childRemovedChange(childKey,oldChildSnap));}var newEventCache=oldEventCache.updateImmediateChild(childKey,ChildrenNode.EMPTY_NODE);var nextChildInRange=nextChild!=null&&this.rangedFilter_.matches(nextChild);if(nextChildInRange){if(changeAccumulator!=null){changeAccumulator.trackChildChange(Change.childAddedChange(nextChild.name,nextChild.node));}return newEventCache.updateImmediateChild(nextChild.name,nextChild.node);}else{return newEventCache;}}}else if(childSnap.isEmpty()){// we're deleting a node, but it was not in the window, so ignore it
return snap;}else if(inRange){if(cmp(windowBoundary,newChildNamedNode)>=0){if(changeAccumulator!=null){changeAccumulator.trackChildChange(Change.childRemovedChange(windowBoundary.name,windowBoundary.node));changeAccumulator.trackChildChange(Change.childAddedChange(childKey,childSnap));}return oldEventCache.updateImmediateChild(childKey,childSnap).updateImmediateChild(windowBoundary.name,ChildrenNode.EMPTY_NODE);}else{return snap;}}else{return snap;}};return LimitedFilter;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a
 * range to be returned for a particular location. It is assumed that validation of parameters is done at the
 * user-facing API level, so it is not done here.
 * @constructor
 */var QueryParams=/** @class */function(){function QueryParams(){this.limitSet_=false;this.startSet_=false;this.startNameSet_=false;this.endSet_=false;this.endNameSet_=false;this.limit_=0;this.viewFrom_='';this.indexStartValue_=null;this.indexStartName_='';this.indexEndValue_=null;this.indexEndName_='';this.index_=PRIORITY_INDEX;}/**
     * @return {boolean}
     */QueryParams.prototype.hasStart=function(){return this.startSet_;};/**
     * @return {boolean} True if it would return from left.
     */QueryParams.prototype.isViewFromLeft=function(){if(this.viewFrom_===''){// limit(), rather than limitToFirst or limitToLast was called.
// This means that only one of startSet_ and endSet_ is true. Use them
// to calculate which side of the view to anchor to. If neither is set,
// anchor to the end.
return this.startSet_;}else{return this.viewFrom_===QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT;}};/**
     * Only valid to call if hasStart() returns true
     * @return {*}
     */QueryParams.prototype.getIndexStartValue=function(){util.assert(this.startSet_,'Only valid if start has been set');return this.indexStartValue_;};/**
     * Only valid to call if hasStart() returns true.
     * Returns the starting key name for the range defined by these query parameters
     * @return {!string}
     */QueryParams.prototype.getIndexStartName=function(){util.assert(this.startSet_,'Only valid if start has been set');if(this.startNameSet_){return this.indexStartName_;}else{return MIN_NAME;}};/**
     * @return {boolean}
     */QueryParams.prototype.hasEnd=function(){return this.endSet_;};/**
     * Only valid to call if hasEnd() returns true.
     * @return {*}
     */QueryParams.prototype.getIndexEndValue=function(){util.assert(this.endSet_,'Only valid if end has been set');return this.indexEndValue_;};/**
     * Only valid to call if hasEnd() returns true.
     * Returns the end key name for the range defined by these query parameters
     * @return {!string}
     */QueryParams.prototype.getIndexEndName=function(){util.assert(this.endSet_,'Only valid if end has been set');if(this.endNameSet_){return this.indexEndName_;}else{return MAX_NAME;}};/**
     * @return {boolean}
     */QueryParams.prototype.hasLimit=function(){return this.limitSet_;};/**
     * @return {boolean} True if a limit has been set and it has been explicitly anchored
     */QueryParams.prototype.hasAnchoredLimit=function(){return this.limitSet_&&this.viewFrom_!=='';};/**
     * Only valid to call if hasLimit() returns true
     * @return {!number}
     */QueryParams.prototype.getLimit=function(){util.assert(this.limitSet_,'Only valid if limit has been set');return this.limit_;};/**
     * @return {!Index}
     */QueryParams.prototype.getIndex=function(){return this.index_;};/**
     * @return {!QueryParams}
     * @private
     */QueryParams.prototype.copy_=function(){var copy=new QueryParams();copy.limitSet_=this.limitSet_;copy.limit_=this.limit_;copy.startSet_=this.startSet_;copy.indexStartValue_=this.indexStartValue_;copy.startNameSet_=this.startNameSet_;copy.indexStartName_=this.indexStartName_;copy.endSet_=this.endSet_;copy.indexEndValue_=this.indexEndValue_;copy.endNameSet_=this.endNameSet_;copy.indexEndName_=this.indexEndName_;copy.index_=this.index_;copy.viewFrom_=this.viewFrom_;return copy;};/**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */QueryParams.prototype.limit=function(newLimit){var newParams=this.copy_();newParams.limitSet_=true;newParams.limit_=newLimit;newParams.viewFrom_='';return newParams;};/**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */QueryParams.prototype.limitToFirst=function(newLimit){var newParams=this.copy_();newParams.limitSet_=true;newParams.limit_=newLimit;newParams.viewFrom_=QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT;return newParams;};/**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */QueryParams.prototype.limitToLast=function(newLimit){var newParams=this.copy_();newParams.limitSet_=true;newParams.limit_=newLimit;newParams.viewFrom_=QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_RIGHT;return newParams;};/**
     * @param {*} indexValue
     * @param {?string=} key
     * @return {!QueryParams}
     */QueryParams.prototype.startAt=function(indexValue,key){var newParams=this.copy_();newParams.startSet_=true;if(indexValue===undefined){indexValue=null;}newParams.indexStartValue_=indexValue;if(key!=null){newParams.startNameSet_=true;newParams.indexStartName_=key;}else{newParams.startNameSet_=false;newParams.indexStartName_='';}return newParams;};/**
     * @param {*} indexValue
     * @param {?string=} key
     * @return {!QueryParams}
     */QueryParams.prototype.endAt=function(indexValue,key){var newParams=this.copy_();newParams.endSet_=true;if(indexValue===undefined){indexValue=null;}newParams.indexEndValue_=indexValue;if(key!==undefined){newParams.endNameSet_=true;newParams.indexEndName_=key;}else{newParams.endNameSet_=false;newParams.indexEndName_='';}return newParams;};/**
     * @param {!Index} index
     * @return {!QueryParams}
     */QueryParams.prototype.orderBy=function(index){var newParams=this.copy_();newParams.index_=index;return newParams;};/**
     * @return {!Object}
     */QueryParams.prototype.getQueryObject=function(){var WIRE_PROTOCOL_CONSTANTS=QueryParams.WIRE_PROTOCOL_CONSTANTS_;var obj={};if(this.startSet_){obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE]=this.indexStartValue_;if(this.startNameSet_){obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME]=this.indexStartName_;}}if(this.endSet_){obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE]=this.indexEndValue_;if(this.endNameSet_){obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME]=this.indexEndName_;}}if(this.limitSet_){obj[WIRE_PROTOCOL_CONSTANTS.LIMIT]=this.limit_;var viewFrom=this.viewFrom_;if(viewFrom===''){if(this.isViewFromLeft()){viewFrom=WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT;}else{viewFrom=WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT;}}obj[WIRE_PROTOCOL_CONSTANTS.VIEW_FROM]=viewFrom;}// For now, priority index is the default, so we only specify if it's some other index
if(this.index_!==PRIORITY_INDEX){obj[WIRE_PROTOCOL_CONSTANTS.INDEX]=this.index_.toString();}return obj;};/**
     * @return {boolean}
     */QueryParams.prototype.loadsAllData=function(){return!(this.startSet_||this.endSet_||this.limitSet_);};/**
     * @return {boolean}
     */QueryParams.prototype.isDefault=function(){return this.loadsAllData()&&this.index_==PRIORITY_INDEX;};/**
     * @return {!NodeFilter}
     */QueryParams.prototype.getNodeFilter=function(){if(this.loadsAllData()){return new IndexedFilter(this.getIndex());}else if(this.hasLimit()){return new LimitedFilter(this);}else{return new RangedFilter(this);}};/**
     * Returns a set of REST query string parameters representing this query.
     *
     * @return {!Object.<string,*>} query string parameters
     */QueryParams.prototype.toRestQueryStringParameters=function(){var REST_CONSTANTS=QueryParams.REST_QUERY_CONSTANTS_;var qs={};if(this.isDefault()){return qs;}var orderBy;if(this.index_===PRIORITY_INDEX){orderBy=REST_CONSTANTS.PRIORITY_INDEX;}else if(this.index_===VALUE_INDEX){orderBy=REST_CONSTANTS.VALUE_INDEX;}else if(this.index_===KEY_INDEX){orderBy=REST_CONSTANTS.KEY_INDEX;}else{util.assert(this.index_ instanceof PathIndex,'Unrecognized index type!');orderBy=this.index_.toString();}qs[REST_CONSTANTS.ORDER_BY]=util.stringify(orderBy);if(this.startSet_){qs[REST_CONSTANTS.START_AT]=util.stringify(this.indexStartValue_);if(this.startNameSet_){qs[REST_CONSTANTS.START_AT]+=','+util.stringify(this.indexStartName_);}}if(this.endSet_){qs[REST_CONSTANTS.END_AT]=util.stringify(this.indexEndValue_);if(this.endNameSet_){qs[REST_CONSTANTS.END_AT]+=','+util.stringify(this.indexEndName_);}}if(this.limitSet_){if(this.isViewFromLeft()){qs[REST_CONSTANTS.LIMIT_TO_FIRST]=this.limit_;}else{qs[REST_CONSTANTS.LIMIT_TO_LAST]=this.limit_;}}return qs;};/**
     * Wire Protocol Constants
     * @const
     * @enum {string}
     * @private
     */QueryParams.WIRE_PROTOCOL_CONSTANTS_={INDEX_START_VALUE:'sp',INDEX_START_NAME:'sn',INDEX_END_VALUE:'ep',INDEX_END_NAME:'en',LIMIT:'l',VIEW_FROM:'vf',VIEW_FROM_LEFT:'l',VIEW_FROM_RIGHT:'r',INDEX:'i'};/**
     * REST Query Constants
     * @const
     * @enum {string}
     * @private
     */QueryParams.REST_QUERY_CONSTANTS_={ORDER_BY:'orderBy',PRIORITY_INDEX:'$priority',VALUE_INDEX:'$value',KEY_INDEX:'$key',START_AT:'startAt',END_AT:'endAt',LIMIT_TO_FIRST:'limitToFirst',LIMIT_TO_LAST:'limitToLast'};/**
     * Default, empty query parameters
     * @type {!QueryParams}
     * @const
     */QueryParams.DEFAULT=new QueryParams();return QueryParams;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Reference=/** @class */function(_super){tslib_1.__extends(Reference,_super);/**
     * Call options:
     *   new Reference(Repo, Path) or
     *   new Reference(url: string, string|RepoManager)
     *
     * Externally - this is the firebase.database.Reference type.
     *
     * @param {!Repo} repo
     * @param {(!Path)} path
     * @extends {Query}
     */function Reference(repo,path){var _this=this;if(!(repo instanceof Repo)){throw new Error('new Reference() no longer supported - use app.database().');}// call Query's constructor, passing in the repo and path.
_this=_super.call(this,repo,path,QueryParams.DEFAULT,false)||this;return _this;}/** @return {?string} */Reference.prototype.getKey=function(){util.validateArgCount('Reference.key',0,0,arguments.length);if(this.path.isEmpty())return null;else return this.path.getBack();};/**
     * @param {!(string|Path)} pathString
     * @return {!Reference}
     */Reference.prototype.child=function(pathString){util.validateArgCount('Reference.child',1,1,arguments.length);if(typeof pathString==='number'){pathString=String(pathString);}else if(!(pathString instanceof Path)){if(this.path.getFront()===null)validateRootPathString('Reference.child',1,pathString,false);else validatePathString('Reference.child',1,pathString,false);}return new Reference(this.repo,this.path.child(pathString));};/** @return {?Reference} */Reference.prototype.getParent=function(){util.validateArgCount('Reference.parent',0,0,arguments.length);var parentPath=this.path.parent();return parentPath===null?null:new Reference(this.repo,parentPath);};/** @return {!Reference} */Reference.prototype.getRoot=function(){util.validateArgCount('Reference.root',0,0,arguments.length);var ref=this;while(ref.getParent()!==null){ref=ref.getParent();}return ref;};/** @return {!Database} */Reference.prototype.databaseProp=function(){return this.repo.database;};/**
     * @param {*} newVal
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */Reference.prototype.set=function(newVal,onComplete){util.validateArgCount('Reference.set',1,2,arguments.length);validateWritablePath('Reference.set',this.path);validateFirebaseDataArg('Reference.set',1,newVal,this.path,false);util.validateCallback('Reference.set',2,onComplete,true);var deferred=new util.Deferred();this.repo.setWithPriority(this.path,newVal,/*priority=*/null,deferred.wrapCallback(onComplete));return deferred.promise;};/**
     * @param {!Object} objectToMerge
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */Reference.prototype.update=function(objectToMerge,onComplete){util.validateArgCount('Reference.update',1,2,arguments.length);validateWritablePath('Reference.update',this.path);if(Array.isArray(objectToMerge)){var newObjectToMerge={};for(var i=0;i<objectToMerge.length;++i){newObjectToMerge[''+i]=objectToMerge[i];}objectToMerge=newObjectToMerge;warn('Passing an Array to Firebase.update() is deprecated. '+'Use set() if you want to overwrite the existing data, or '+'an Object with integer keys if you really do want to '+'only update some of the children.');}validateFirebaseMergeDataArg('Reference.update',1,objectToMerge,this.path,false);util.validateCallback('Reference.update',2,onComplete,true);var deferred=new util.Deferred();this.repo.update(this.path,objectToMerge,deferred.wrapCallback(onComplete));return deferred.promise;};/**
     * @param {*} newVal
     * @param {string|number|null} newPriority
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */Reference.prototype.setWithPriority=function(newVal,newPriority,onComplete){util.validateArgCount('Reference.setWithPriority',2,3,arguments.length);validateWritablePath('Reference.setWithPriority',this.path);validateFirebaseDataArg('Reference.setWithPriority',1,newVal,this.path,false);validatePriority('Reference.setWithPriority',2,newPriority,false);util.validateCallback('Reference.setWithPriority',3,onComplete,true);if(this.getKey()==='.length'||this.getKey()==='.keys')throw'Reference.setWithPriority failed: '+this.getKey()+' is a read-only object.';var deferred=new util.Deferred();this.repo.setWithPriority(this.path,newVal,newPriority,deferred.wrapCallback(onComplete));return deferred.promise;};/**
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */Reference.prototype.remove=function(onComplete){util.validateArgCount('Reference.remove',0,1,arguments.length);validateWritablePath('Reference.remove',this.path);util.validateCallback('Reference.remove',1,onComplete,true);return this.set(null,onComplete);};/**
     * @param {function(*):*} transactionUpdate
     * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete
     * @param {boolean=} applyLocally
     * @return {!Promise}
     */Reference.prototype.transaction=function(transactionUpdate,onComplete,applyLocally){util.validateArgCount('Reference.transaction',1,3,arguments.length);validateWritablePath('Reference.transaction',this.path);util.validateCallback('Reference.transaction',1,transactionUpdate,false);util.validateCallback('Reference.transaction',2,onComplete,true);// NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how
// to expose it.
validateBoolean('Reference.transaction',3,applyLocally,true);if(this.getKey()==='.length'||this.getKey()==='.keys')throw'Reference.transaction failed: '+this.getKey()+' is a read-only object.';if(applyLocally===undefined)applyLocally=true;var deferred=new util.Deferred();if(typeof onComplete==='function'){deferred.promise.catch(function(){});}var promiseComplete=function(error,committed,snapshot){if(error){deferred.reject(error);}else{deferred.resolve(new TransactionResult(committed,snapshot));}if(typeof onComplete==='function'){onComplete(error,committed,snapshot);}};this.repo.startTransaction(this.path,transactionUpdate,promiseComplete,applyLocally);return deferred.promise;};/**
     * @param {string|number|null} priority
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */Reference.prototype.setPriority=function(priority,onComplete){util.validateArgCount('Reference.setPriority',1,2,arguments.length);validateWritablePath('Reference.setPriority',this.path);validatePriority('Reference.setPriority',1,priority,false);util.validateCallback('Reference.setPriority',2,onComplete,true);var deferred=new util.Deferred();this.repo.setWithPriority(this.path.child('.priority'),priority,null,deferred.wrapCallback(onComplete));return deferred.promise;};/**
     * @param {*=} value
     * @param {function(?Error)=} onComplete
     * @return {!Reference}
     */Reference.prototype.push=function(value,onComplete){util.validateArgCount('Reference.push',0,2,arguments.length);validateWritablePath('Reference.push',this.path);validateFirebaseDataArg('Reference.push',1,value,this.path,true);util.validateCallback('Reference.push',2,onComplete,true);var now=this.repo.serverTime();var name=nextPushId(now);// push() returns a ThennableReference whose promise is fulfilled with a regular Reference.
// We use child() to create handles to two different references. The first is turned into a
// ThennableReference below by adding then() and catch() methods and is used as the
// return value of push(). The second remains a regular Reference and is used as the fulfilled
// value of the first ThennableReference.
var thennablePushRef=this.child(name);var pushRef=this.child(name);var promise;if(value!=null){promise=thennablePushRef.set(value,onComplete).then(function(){return pushRef;});}else{promise=Promise.resolve(pushRef);}thennablePushRef.then=promise.then.bind(promise);thennablePushRef.catch=promise.then.bind(promise,undefined);if(typeof onComplete==='function'){promise.catch(function(){});}return thennablePushRef;};/**
     * @return {!OnDisconnect}
     */Reference.prototype.onDisconnect=function(){validateWritablePath('Reference.onDisconnect',this.path);return new OnDisconnect(this.repo,this.path);};Object.defineProperty(Reference.prototype,"database",{get:function(){return this.databaseProp();},enumerable:true,configurable:true});Object.defineProperty(Reference.prototype,"key",{get:function(){return this.getKey();},enumerable:true,configurable:true});Object.defineProperty(Reference.prototype,"parent",{get:function(){return this.getParent();},enumerable:true,configurable:true});Object.defineProperty(Reference.prototype,"root",{get:function(){return this.getRoot();},enumerable:true,configurable:true});return Reference;}(Query);/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */Query.__referenceConstructor=Reference;SyncPoint.__referenceConstructor=Reference;/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Node in a Tree.
 */var TreeNode=/** @class */function(){function TreeNode(){// TODO: Consider making accessors that create children and value lazily or
// separate Internal / Leaf 'types'.
this.children={};this.childCount=0;this.value=null;}return TreeNode;}();/**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */var Tree=/** @class */function(){/**
     * @template T
     * @param {string=} name_ Optional name of the node.
     * @param {Tree=} parent_ Optional parent node.
     * @param {TreeNode=} node_ Optional node to wrap.
     */function Tree(name_,parent_,node_){if(name_===void 0){name_='';}if(parent_===void 0){parent_=null;}if(node_===void 0){node_=new TreeNode();}this.name_=name_;this.parent_=parent_;this.node_=node_;}/**
     * Returns a sub-Tree for the given path.
     *
     * @param {!(string|Path)} pathObj Path to look up.
     * @return {!Tree.<T>} Tree for path.
     */Tree.prototype.subTree=function(pathObj){// TODO: Require pathObj to be Path?
var path=pathObj instanceof Path?pathObj:new Path(pathObj);var child=this,next;while((next=path.getFront())!==null){var childNode=util.safeGet(child.node_.children,next)||new TreeNode();child=new Tree(next,child,childNode);path=path.popFront();}return child;};/**
     * Returns the data associated with this tree node.
     *
     * @return {?T} The data or null if no data exists.
     */Tree.prototype.getValue=function(){return this.node_.value;};/**
     * Sets data to this tree node.
     *
     * @param {!T} value Value to set.
     */Tree.prototype.setValue=function(value){util.assert(typeof value!=='undefined','Cannot set value to undefined');this.node_.value=value;this.updateParents_();};/**
     * Clears the contents of the tree node (its value and all children).
     */Tree.prototype.clear=function(){this.node_.value=null;this.node_.children={};this.node_.childCount=0;this.updateParents_();};/**
     * @return {boolean} Whether the tree has any children.
     */Tree.prototype.hasChildren=function(){return this.node_.childCount>0;};/**
     * @return {boolean} Whether the tree is empty (no value or children).
     */Tree.prototype.isEmpty=function(){return this.getValue()===null&&!this.hasChildren();};/**
     * Calls action for each child of this tree node.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     */Tree.prototype.forEachChild=function(action){var _this=this;util.forEach(this.node_.children,function(child,childTree){action(new Tree(child,_this,childTree));});};/**
     * Does a depth-first traversal of this node's descendants, calling action for each one.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to
     *   false.
     * @param {boolean=} childrenFirst Whether to call action on children before calling it on
     *   parent.
     */Tree.prototype.forEachDescendant=function(action,includeSelf,childrenFirst){if(includeSelf&&!childrenFirst)action(this);this.forEachChild(function(child){child.forEachDescendant(action,/*includeSelf=*/true,childrenFirst);});if(includeSelf&&childrenFirst)action(this);};/**
     * Calls action on each ancestor node.
     *
     * @param {function(!Tree.<T>)} action Action to be called on each parent; return
     *   true to abort.
     * @param {boolean=} includeSelf Whether to call action on this node as well.
     * @return {boolean} true if the action callback returned true.
     */Tree.prototype.forEachAncestor=function(action,includeSelf){var node=includeSelf?this:this.parent();while(node!==null){if(action(node)){return true;}node=node.parent();}return false;};/**
     * Does a depth-first traversal of this node's descendants.  When a descendant with a value
     * is found, action is called on it and traversal does not continue inside the node.
     * Action is *not* called on this node.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     */Tree.prototype.forEachImmediateDescendantWithValue=function(action){this.forEachChild(function(child){if(child.getValue()!==null)action(child);else child.forEachImmediateDescendantWithValue(action);});};/**
     * @return {!Path} The path of this tree node, as a Path.
     */Tree.prototype.path=function(){return new Path(this.parent_===null?this.name_:this.parent_.path()+'/'+this.name_);};/**
     * @return {string} The name of the tree node.
     */Tree.prototype.name=function(){return this.name_;};/**
     * @return {?Tree} The parent tree node, or null if this is the root of the tree.
     */Tree.prototype.parent=function(){return this.parent_;};/**
     * Adds or removes this child from its parent based on whether it's empty or not.
     *
     * @private
     */Tree.prototype.updateParents_=function(){if(this.parent_!==null)this.parent_.updateChild_(this.name_,this);};/**
     * Adds or removes the passed child to this tree node, depending on whether it's empty.
     *
     * @param {string} childName The name of the child to update.
     * @param {!Tree.<T>} child The child to update.
     * @private
     */Tree.prototype.updateChild_=function(childName,child){var childEmpty=child.isEmpty();var childExists=util.contains(this.node_.children,childName);if(childEmpty&&childExists){delete this.node_.children[childName];this.node_.childCount--;this.updateParents_();}else if(!childEmpty&&!childExists){this.node_.children[childName]=child.node_;this.node_.childCount++;this.updateParents_();}};return Tree;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific
// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well
// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.
// For now it's part of Repo, but in its own file.
/**
 * @enum {number}
 */var TransactionStatus;(function(TransactionStatus){// We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the
// server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to
// mismatched hash.
TransactionStatus[TransactionStatus["RUN"]=0]="RUN";// We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted
// or rejected yet).
TransactionStatus[TransactionStatus["SENT"]=1]="SENT";// Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be
// removed when we get a chance to prune completed ones.
TransactionStatus[TransactionStatus["COMPLETED"]=2]="COMPLETED";// Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).
// If it comes back as unsuccessful, we'll abort it.
TransactionStatus[TransactionStatus["SENT_NEEDS_ABORT"]=3]="SENT_NEEDS_ABORT";// Temporary state used to mark transactions that need to be aborted.
TransactionStatus[TransactionStatus["NEEDS_ABORT"]=4]="NEEDS_ABORT";})(TransactionStatus||(TransactionStatus={}));/**
 * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's
 * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.
 * @type {number}
 * @const
 * @private
 */Repo.MAX_TRANSACTION_RETRIES_=25;/**
 * Setup the transaction data structures
 * @private
 */Repo.prototype.transactions_init_=function(){/**
     * Stores queues of outstanding transactions for Firebase locations.
     *
     * @type {!Tree.<Array.<!Transaction>>}
     * @private
     */this.transactionQueueTree_=new Tree();};/**
 * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.
 *
 * @param {!Path} path Path at which to do transaction.
 * @param {function(*):*} transactionUpdate Update callback.
 * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.
 * @param {boolean} applyLocally Whether or not to make intermediate results visible
 */Repo.prototype.startTransaction=function(path,transactionUpdate,onComplete,applyLocally){this.log_('transaction on '+path);// Add a watch to make sure we get server updates.
var valueCallback=function(){};var watchRef=new Reference(this,path);watchRef.on('value',valueCallback);var unwatcher=function(){watchRef.off('value',valueCallback);};// Initialize transaction.
var transaction={path:path,update:transactionUpdate,onComplete:onComplete,// One of TransactionStatus enums.
status:null,// Used when combining transactions at different locations to figure out which one goes first.
order:LUIDGenerator(),// Whether to raise local events for this transaction.
applyLocally:applyLocally,// Count of how many times we've retried the transaction.
retryCount:0,// Function to call to clean up our .on() listener.
unwatcher:unwatcher,// Stores why a transaction was aborted.
abortReason:null,currentWriteId:null,currentInputSnapshot:null,currentOutputSnapshotRaw:null,currentOutputSnapshotResolved:null};// Run transaction initially.
var currentState=this.getLatestState_(path);transaction.currentInputSnapshot=currentState;var newVal=transaction.update(currentState.val());if(newVal===undefined){// Abort transaction.
transaction.unwatcher();transaction.currentOutputSnapshotRaw=null;transaction.currentOutputSnapshotResolved=null;if(transaction.onComplete){// We just set the input snapshot, so this cast should be safe
var snapshot=new DataSnapshot(transaction.currentInputSnapshot,new Reference(this,transaction.path),PRIORITY_INDEX);transaction.onComplete(null,false,snapshot);}}else{validateFirebaseData('transaction failed: Data returned ',newVal,transaction.path);// Mark as run and add to our queue.
transaction.status=TransactionStatus.RUN;var queueNode=this.transactionQueueTree_.subTree(path);var nodeQueue=queueNode.getValue()||[];nodeQueue.push(transaction);queueNode.setValue(nodeQueue);// Update visibleData and raise events
// Note: We intentionally raise events after updating all of our transaction state, since the user could
// start new transactions from the event callbacks.
var priorityForNode=void 0;if(typeof newVal==='object'&&newVal!==null&&util.contains(newVal,'.priority')){priorityForNode=util.safeGet(newVal,'.priority');util.assert(isValidPriority(priorityForNode),'Invalid priority returned by transaction. '+'Priority must be a valid string, finite number, server value, or null.');}else{var currentNode=this.serverSyncTree_.calcCompleteEventCache(path)||ChildrenNode.EMPTY_NODE;priorityForNode=currentNode.getPriority().val();}priorityForNode/** @type {null|number|string} */=priorityForNode;var serverValues=this.generateServerValues();var newNodeUnresolved=nodeFromJSON$1(newVal,priorityForNode);var newNode=resolveDeferredValueSnapshot(newNodeUnresolved,serverValues);transaction.currentOutputSnapshotRaw=newNodeUnresolved;transaction.currentOutputSnapshotResolved=newNode;transaction.currentWriteId=this.getNextWriteId_();var events=this.serverSyncTree_.applyUserOverwrite(path,newNode,transaction.currentWriteId,transaction.applyLocally);this.eventQueue_.raiseEventsForChangedPath(path,events);this.sendReadyTransactions_();}};/**
 * @param {!Path} path
 * @param {Array.<number>=} excludeSets A specific set to exclude
 * @return {Node}
 * @private
 */Repo.prototype.getLatestState_=function(path,excludeSets){return this.serverSyncTree_.calcCompleteEventCache(path,excludeSets)||ChildrenNode.EMPTY_NODE;};/**
 * Sends any already-run transactions that aren't waiting for outstanding transactions to
 * complete.
 *
 * Externally it's called with no arguments, but it calls itself recursively with a particular
 * transactionQueueTree node to recurse through the tree.
 *
 * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.
 * @private
 */Repo.prototype.sendReadyTransactions_=function(node){var _this=this;if(node===void 0){node=this.transactionQueueTree_;}// Before recursing, make sure any completed transactions are removed.
if(!node){this.pruneCompletedTransactionsBelowNode_(node);}if(node.getValue()!==null){var queue=this.buildTransactionQueue_(node);util.assert(queue.length>0,'Sending zero length transaction queue');var allRun=queue.every(function(transaction){return transaction.status===TransactionStatus.RUN;});// If they're all run (and not sent), we can send them.  Else, we must wait.
if(allRun){this.sendTransactionQueue_(node.path(),queue);}}else if(node.hasChildren()){node.forEachChild(function(childNode){_this.sendReadyTransactions_(childNode);});}};/**
 * Given a list of run transactions, send them to the server and then handle the result (success or failure).
 *
 * @param {!Path} path The location of the queue.
 * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.
 * @private
 */Repo.prototype.sendTransactionQueue_=function(path,queue){var _this=this;// Mark transactions as sent and increment retry count!
var setsToIgnore=queue.map(function(txn){return txn.currentWriteId;});var latestState=this.getLatestState_(path,setsToIgnore);var snapToSend=latestState;var latestHash=latestState.hash();for(var i=0;i<queue.length;i++){var txn=queue[i];util.assert(txn.status===TransactionStatus.RUN,'tryToSendTransactionQueue_: items in queue should all be run.');txn.status=TransactionStatus.SENT;txn.retryCount++;var relativePath=Path.relativePath(path,txn.path);// If we've gotten to this point, the output snapshot must be defined.
snapToSend=snapToSend.updateChild(relativePath/**@type {!Node} */,txn.currentOutputSnapshotRaw);}var dataToSend=snapToSend.val(true);var pathToSend=path;// Send the put.
this.server_.put(pathToSend.toString(),dataToSend,function(status){_this.log_('transaction put response',{path:pathToSend.toString(),status:status});var events=[];if(status==='ok'){// Queue up the callbacks and fire them after cleaning up all of our transaction state, since
// the callback could trigger more transactions or sets.
var callbacks=[];for(var i=0;i<queue.length;i++){queue[i].status=TransactionStatus.COMPLETED;events=events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));if(queue[i].onComplete){// We never unset the output snapshot, and given that this transaction is complete, it should be set
var node=queue[i].currentOutputSnapshotResolved;var ref=new Reference(_this,queue[i].path);var snapshot=new DataSnapshot(node,ref,PRIORITY_INDEX);callbacks.push(queue[i].onComplete.bind(null,null,true,snapshot));}queue[i].unwatcher();}// Now remove the completed transactions.
_this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path));// There may be pending transactions that we can now send.
_this.sendReadyTransactions_();_this.eventQueue_.raiseEventsForChangedPath(path,events);// Finally, trigger onComplete callbacks.
for(var i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i]);}}else{// transactions are no longer sent.  Update their status appropriately.
if(status==='datastale'){for(var i=0;i<queue.length;i++){if(queue[i].status===TransactionStatus.SENT_NEEDS_ABORT)queue[i].status=TransactionStatus.NEEDS_ABORT;else queue[i].status=TransactionStatus.RUN;}}else{warn('transaction at '+pathToSend.toString()+' failed: '+status);for(var i=0;i<queue.length;i++){queue[i].status=TransactionStatus.NEEDS_ABORT;queue[i].abortReason=status;}}_this.rerunTransactions_(path);}},latestHash);};/**
 * Finds all transactions dependent on the data at changedPath and reruns them.
 *
 * Should be called any time cached data changes.
 *
 * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to
 * be raised for.
 *
 * @param {!Path} changedPath The path in mergedData that changed.
 * @return {!Path} The rootmost path that was affected by rerunning transactions.
 * @private
 */Repo.prototype.rerunTransactions_=function(changedPath){var rootMostTransactionNode=this.getAncestorTransactionNode_(changedPath);var path=rootMostTransactionNode.path();var queue=this.buildTransactionQueue_(rootMostTransactionNode);this.rerunTransactionQueue_(queue,path);return path;};/**
 * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).
 *
 * @param {Array.<Transaction>} queue The queue of transactions to run.
 * @param {!Path} path The path the queue is for.
 * @private
 */Repo.prototype.rerunTransactionQueue_=function(queue,path){if(queue.length===0){return;// Nothing to do!
}// Queue up the callbacks and fire them after cleaning up all of our transaction state, since
// the callback could trigger more transactions or sets.
var callbacks=[];var events=[];// Ignore all of the sets we're going to re-run.
var txnsToRerun=queue.filter(function(q){return q.status===TransactionStatus.RUN;});var setsToIgnore=txnsToRerun.map(function(q){return q.currentWriteId;});for(var i=0;i<queue.length;i++){var transaction=queue[i];var relativePath=Path.relativePath(path,transaction.path);var abortTransaction=false,abortReason=void 0;util.assert(relativePath!==null,'rerunTransactionsUnderNode_: relativePath should not be null.');if(transaction.status===TransactionStatus.NEEDS_ABORT){abortTransaction=true;abortReason=transaction.abortReason;events=events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId,true));}else if(transaction.status===TransactionStatus.RUN){if(transaction.retryCount>=Repo.MAX_TRANSACTION_RETRIES_){abortTransaction=true;abortReason='maxretry';events=events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId,true));}else{// This code reruns a transaction
var currentNode=this.getLatestState_(transaction.path,setsToIgnore);transaction.currentInputSnapshot=currentNode;var newData=queue[i].update(currentNode.val());if(newData!==undefined){validateFirebaseData('transaction failed: Data returned ',newData,transaction.path);var newDataNode=nodeFromJSON$1(newData);var hasExplicitPriority=typeof newData==='object'&&newData!=null&&util.contains(newData,'.priority');if(!hasExplicitPriority){// Keep the old priority if there wasn't a priority explicitly specified.
newDataNode=newDataNode.updatePriority(currentNode.getPriority());}var oldWriteId=transaction.currentWriteId;var serverValues=this.generateServerValues();var newNodeResolved=resolveDeferredValueSnapshot(newDataNode,serverValues);transaction.currentOutputSnapshotRaw=newDataNode;transaction.currentOutputSnapshotResolved=newNodeResolved;transaction.currentWriteId=this.getNextWriteId_();// Mutates setsToIgnore in place
setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId),1);events=events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path,newNodeResolved,transaction.currentWriteId,transaction.applyLocally));events=events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId,true));}else{abortTransaction=true;abortReason='nodata';events=events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId,true));}}}this.eventQueue_.raiseEventsForChangedPath(path,events);events=[];if(abortTransaction){// Abort.
queue[i].status=TransactionStatus.COMPLETED;// Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).
// So defer the unwatcher until we're done.
(function(unwatcher){setTimeout(unwatcher,Math.floor(0));})(queue[i].unwatcher);if(queue[i].onComplete){if(abortReason==='nodata'){var ref=new Reference(this,queue[i].path);// We set this field immediately, so it's safe to cast to an actual snapshot
var lastInput/** @type {!Node} */=queue[i].currentInputSnapshot;var snapshot=new DataSnapshot(lastInput,ref,PRIORITY_INDEX);callbacks.push(queue[i].onComplete.bind(null,null,false,snapshot));}else{callbacks.push(queue[i].onComplete.bind(null,new Error(abortReason),false,null));}}}}// Clean up completed transactions.
this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);// Now fire callbacks, now that we're in a good, known state.
for(var i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i]);}// Try to send the transaction result to the server.
this.sendReadyTransactions_();};/**
 * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns
 * the node for the given path if there are no pending transactions on any ancestor.
 *
 * @param {!Path} path The location to start at.
 * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.
 * @private
 */Repo.prototype.getAncestorTransactionNode_=function(path){var front;// Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.
var transactionNode=this.transactionQueueTree_;while((front=path.getFront())!==null&&transactionNode.getValue()===null){transactionNode=transactionNode.subTree(front);path=path.popFront();}return transactionNode;};/**
 * Builds the queue of all transactions at or below the specified transactionNode.
 *
 * @param {!Tree.<Array.<Transaction>>} transactionNode
 * @return {Array.<Transaction>} The generated queue.
 * @private
 */Repo.prototype.buildTransactionQueue_=function(transactionNode){// Walk any child transaction queues and aggregate them into a single queue.
var transactionQueue=[];this.aggregateTransactionQueuesForNode_(transactionNode,transactionQueue);// Sort them by the order the transactions were created.
transactionQueue.sort(function(a,b){return a.order-b.order;});return transactionQueue;};/**
 * @param {!Tree.<Array.<Transaction>>} node
 * @param {Array.<Transaction>} queue
 * @private
 */Repo.prototype.aggregateTransactionQueuesForNode_=function(node,queue){var _this=this;var nodeQueue=node.getValue();if(nodeQueue!==null){for(var i=0;i<nodeQueue.length;i++){queue.push(nodeQueue[i]);}}node.forEachChild(function(child){_this.aggregateTransactionQueuesForNode_(child,queue);});};/**
 * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
 *
 * @param {!Tree.<Array.<!Transaction>>} node
 * @private
 */Repo.prototype.pruneCompletedTransactionsBelowNode_=function(node){var _this=this;var queue=node.getValue();if(queue){var to=0;for(var from=0;from<queue.length;from++){if(queue[from].status!==TransactionStatus.COMPLETED){queue[to]=queue[from];to++;}}queue.length=to;node.setValue(queue.length>0?queue:null);}node.forEachChild(function(childNode){_this.pruneCompletedTransactionsBelowNode_(childNode);});};/**
 * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()
 * since we consider them incompatible with transactions.
 *
 * @param {!Path} path Path for which we want to abort related transactions.
 * @return {!Path}
 * @private
 */Repo.prototype.abortTransactions_=function(path){var _this=this;var affectedPath=this.getAncestorTransactionNode_(path).path();var transactionNode=this.transactionQueueTree_.subTree(path);transactionNode.forEachAncestor(function(node){_this.abortTransactionsOnNode_(node);});this.abortTransactionsOnNode_(transactionNode);transactionNode.forEachDescendant(function(node){_this.abortTransactionsOnNode_(node);});return affectedPath;};/**
 * Abort transactions stored in this transaction queue node.
 *
 * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.
 * @private
 */Repo.prototype.abortTransactionsOnNode_=function(node){var queue=node.getValue();if(queue!==null){// Queue up the callbacks and fire them after cleaning up all of our transaction state, since
// the callback could trigger more transactions or sets.
var callbacks=[];// Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones
// can be immediately aborted and removed.
var events=[];var lastSent=-1;for(var i=0;i<queue.length;i++){if(queue[i].status===TransactionStatus.SENT_NEEDS_ABORT);else if(queue[i].status===TransactionStatus.SENT){util.assert(lastSent===i-1,'All SENT items should be at beginning of queue.');lastSent=i;// Mark transaction for abort when it comes back.
queue[i].status=TransactionStatus.SENT_NEEDS_ABORT;queue[i].abortReason='set';}else{util.assert(queue[i].status===TransactionStatus.RUN,'Unexpected transaction status in abort');// We can abort it immediately.
queue[i].unwatcher();events=events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId,true));if(queue[i].onComplete){var snapshot=null;callbacks.push(queue[i].onComplete.bind(null,new Error('set'),false,snapshot));}}}if(lastSent===-1){// We're not waiting for any sent transactions.  We can clear the queue.
node.setValue(null);}else{// Remove the transactions we aborted.
queue.length=lastSent+1;}// Now fire the callbacks.
this.eventQueue_.raiseEventsForChangedPath(node.path(),events);for(var i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i]);}}};/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** @const {string} */var DATABASE_URL_OPTION='databaseURL';var _staticInstance;/**
 * Creates and caches Repo instances.
 */var RepoManager=/** @class */function(){function RepoManager(){/**
         * @private {!Object.<string, Object<string, !fb.core.Repo>>}
         */this.repos_={};/**
         * If true, new Repos will be created to use ReadonlyRestClient (for testing purposes).
         * @private {boolean}
         */this.useRestClient_=false;}RepoManager.getInstance=function(){if(!_staticInstance){_staticInstance=new RepoManager();}return _staticInstance;};// TODO(koss): Remove these functions unless used in tests?
RepoManager.prototype.interrupt=function(){for(var appName in this.repos_){for(var dbUrl in this.repos_[appName]){this.repos_[appName][dbUrl].interrupt();}}};RepoManager.prototype.resume=function(){for(var appName in this.repos_){for(var dbUrl in this.repos_[appName]){this.repos_[appName][dbUrl].resume();}}};/**
     * This function should only ever be called to CREATE a new database instance.
     *
     * @param {!FirebaseApp} app
     * @return {!Database}
     */RepoManager.prototype.databaseFromApp=function(app,url){var dbUrl=url||app.options[DATABASE_URL_OPTION];if(dbUrl===undefined){fatal("Can't determine Firebase Database URL.  Be sure to include "+DATABASE_URL_OPTION+' option when calling firebase.initializeApp().');}var parsedUrl=parseRepoInfo(dbUrl);var repoInfo=parsedUrl.repoInfo;validateUrl('Invalid Firebase Database URL',1,parsedUrl);if(!parsedUrl.path.isEmpty()){fatal('Database URL must point to the root of a Firebase Database '+'(not including a child path).');}var repo=this.createRepo(repoInfo,app);return repo.database;};/**
     * Remove the repo and make sure it is disconnected.
     *
     * @param {!Repo} repo
     */RepoManager.prototype.deleteRepo=function(repo){var appRepos=util.safeGet(this.repos_,repo.app.name);// This should never happen...
if(!appRepos||util.safeGet(appRepos,repo.repoInfo_.toURLString())!==repo){fatal("Database "+repo.app.name+"("+repo.repoInfo_+") has already been deleted.");}repo.interrupt();delete appRepos[repo.repoInfo_.toURLString()];};/**
     * Ensures a repo doesn't already exist and then creates one using the
     * provided app.
     *
     * @param {!RepoInfo} repoInfo The metadata about the Repo
     * @param {!FirebaseApp} app
     * @return {!Repo} The Repo object for the specified server / repoName.
     */RepoManager.prototype.createRepo=function(repoInfo,app){var appRepos=util.safeGet(this.repos_,app.name);if(!appRepos){appRepos={};this.repos_[app.name]=appRepos;}var repo=util.safeGet(appRepos,repoInfo.toURLString());if(repo){fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');}repo=new Repo(repoInfo,this.useRestClient_,app);appRepos[repoInfo.toURLString()]=repo;return repo;};/**
     * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.
     * @param {boolean} forceRestClient
     */RepoManager.prototype.forceRestClient=function(forceRestClient){this.useRestClient_=forceRestClient;};return RepoManager;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Class representing a firebase database.
 * @implements {FirebaseService}
 */var Database=/** @class */function(){/**
     * The constructor should not be called by users of our public API.
     * @param {!Repo} repo_
     */function Database(repo_){this.repo_=repo_;if(!(repo_ instanceof Repo)){fatal("Don't call new Database() directly - please use firebase.database().");}/** @type {Reference} */this.root_=new Reference(repo_,Path.Empty);this.INTERNAL=new DatabaseInternals(this);}Object.defineProperty(Database.prototype,"app",{get:function(){return this.repo_.app;},enumerable:true,configurable:true});Database.prototype.ref=function(path){this.checkDeleted_('ref');util.validateArgCount('database.ref',0,1,arguments.length);if(path instanceof Reference){return this.refFromURL(path.toString());}return path!==undefined?this.root_.child(path):this.root_;};/**
     * Returns a reference to the root or the path specified in url.
     * We throw a exception if the url is not in the same domain as the
     * current repo.
     * @param {string} url
     * @return {!Reference} Firebase reference.
     */Database.prototype.refFromURL=function(url){/** @const {string} */var apiName='database.refFromURL';this.checkDeleted_(apiName);util.validateArgCount(apiName,1,1,arguments.length);var parsedURL=parseRepoInfo(url);validateUrl(apiName,1,parsedURL);var repoInfo=parsedURL.repoInfo;if(repoInfo.host!==this.repo_.repoInfo_.host){fatal(apiName+': Host name does not match the current database: '+'(found '+repoInfo.host+' but expected '+this.repo_.repoInfo_.host+')');}return this.ref(parsedURL.path.toString());};/**
     * @param {string} apiName
     */Database.prototype.checkDeleted_=function(apiName){if(this.repo_===null){fatal('Cannot call '+apiName+' on a deleted database.');}};// Make individual repo go offline.
Database.prototype.goOffline=function(){util.validateArgCount('database.goOffline',0,0,arguments.length);this.checkDeleted_('goOffline');this.repo_.interrupt();};Database.prototype.goOnline=function(){util.validateArgCount('database.goOnline',0,0,arguments.length);this.checkDeleted_('goOnline');this.repo_.resume();};Database.ServerValue={TIMESTAMP:{'.sv':'timestamp'}};return Database;}();var DatabaseInternals=/** @class */function(){/** @param {!Database} database */function DatabaseInternals(database){this.database=database;}/** @return {Promise<void>} */DatabaseInternals.prototype.delete=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){this.database.checkDeleted_('delete');RepoManager.getInstance().deleteRepo(this.database.repo_);this.database.repo_=null;this.database.root_=null;this.database.INTERNAL=null;this.database=null;return[2/*return*/];});});};return DatabaseInternals;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * INTERNAL methods for internal-use only (tests, etc.).
 *
 * Customers shouldn't use these or else should be aware that they could break at any time.
 *
 * @const
 */var forceLongPolling=function(){WebSocketConnection.forceDisallow();BrowserPollConnection.forceAllow();};var forceWebSockets=function(){BrowserPollConnection.forceDisallow();};/* Used by App Manager */var isWebSocketsAvailable=function(){return WebSocketConnection['isAvailable']();};var setSecurityDebugCallback=function(ref,callback){ref.repo.persistentConnection_.securityDebugCallback_=callback;};var stats=function(ref,showDelta){ref.repo.stats(showDelta);};var statsIncrementCounter=function(ref,metric){ref.repo.statsIncrementCounter(metric);};var dataUpdateCount=function(ref){return ref.repo.dataUpdateCount;};var interceptServerData=function(ref,callback){return ref.repo.interceptServerData_(callback);};var INTERNAL=/*#__PURE__*/Object.freeze({forceLongPolling:forceLongPolling,forceWebSockets:forceWebSockets,isWebSocketsAvailable:isWebSocketsAvailable,setSecurityDebugCallback:setSecurityDebugCallback,stats:stats,statsIncrementCounter:statsIncrementCounter,dataUpdateCount:dataUpdateCount,interceptServerData:interceptServerData});/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DataConnection=PersistentConnection;/**
 * @param {!string} pathString
 * @param {function(*)} onComplete
 */PersistentConnection.prototype.simpleListen=function(pathString,onComplete){this.sendRequest('q',{p:pathString},onComplete);};/**
 * @param {*} data
 * @param {function(*)} onEcho
 */PersistentConnection.prototype.echo=function(data,onEcho){this.sendRequest('echo',{d:data},onEcho);};// RealTimeConnection properties that we use in tests.
var RealTimeConnection=Connection;/**
 * @param {function(): string} newHash
 * @return {function()}
 */var hijackHash=function(newHash){var oldPut=PersistentConnection.prototype.put;PersistentConnection.prototype.put=function(pathString,data,opt_onComplete,opt_hash){if(opt_hash!==undefined){opt_hash=newHash();}oldPut.call(this,pathString,data,opt_onComplete,opt_hash);};return function(){PersistentConnection.prototype.put=oldPut;};};/**
 * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}
 */var ConnectionTarget=RepoInfo;/**
 * @param {!Query} query
 * @return {!string}
 */var queryIdentifier=function(query){return query.queryIdentifier();};/**
 * @param {!Query} firebaseRef
 * @return {!Object}
 */var listens=function(firebaseRef){return firebaseRef.repo.persistentConnection_.listens_;};/**
 * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.
 *
 * @param {boolean} forceRestClient
 */var forceRestClient=function(forceRestClient){RepoManager.getInstance().forceRestClient(forceRestClient);};var TEST_ACCESS=/*#__PURE__*/Object.freeze({DataConnection:DataConnection,RealTimeConnection:RealTimeConnection,hijackHash:hijackHash,ConnectionTarget:ConnectionTarget,queryIdentifier:queryIdentifier,listens:listens,forceRestClient:forceRestClient});/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var ServerValue=Database.ServerValue;function registerDatabase(instance){// Register the Database Service with the 'firebase' namespace.
var namespace=instance.INTERNAL.registerService('database',function(app,unused,url){return RepoManager.getInstance().databaseFromApp(app,url);},// firebase.database namespace properties
{Reference:Reference,Query:Query,Database:Database,DataSnapshot:DataSnapshot,enableLogging:enableLogging,INTERNAL:INTERNAL,ServerValue:ServerValue,TEST_ACCESS:TEST_ACCESS},null,true);if(util.isNodeSdk()){module.exports=namespace;}}registerDatabase(firebase);exports.DataSnapshot=DataSnapshot;exports.Database=Database;exports.OnDisconnect=OnDisconnect;exports.Query=Query;exports.Reference=Reference;exports.ServerValue=ServerValue;exports.enableLogging=enableLogging;exports.registerDatabase=registerDatabase;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "../node_modules/process/browser.js")))

/***/ }),

/***/ "../node_modules/@firebase/logger/dist/index.esm.js":
/*!**********************************************************!*\
  !*** ../node_modules/@firebase/logger/dist/index.esm.js ***!
  \**********************************************************/
/*! exports provided: LogLevel, Logger, setLogLevel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLevel", function() { return LogLevel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLogLevel", function() { return setLogLevel; });
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A container for all of the Logger instances
 */
var instances = [];
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */

var LogLevel;

(function (LogLevel) {
  LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
  LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
  LogLevel[LogLevel["INFO"] = 2] = "INFO";
  LogLevel[LogLevel["WARN"] = 3] = "WARN";
  LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
  LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
/**
 * The default log level
 */


var defaultLogLevel = LogLevel.INFO;
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */

var defaultLogHandler = function (instance, logType) {
  var args = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }

  if (logType < instance.logLevel) {
    return;
  }

  var now = new Date().toISOString();

  switch (logType) {
    /**
     * By default, `console.debug` is not displayed in the developer console (in
     * chrome). To avoid forcing users to have to opt-in to these logs twice
     * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
     * logs to the `console.log` function.
     */
    case LogLevel.DEBUG:
      console.log.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
      break;

    case LogLevel.VERBOSE:
      console.log.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
      break;

    case LogLevel.INFO:
      console.info.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
      break;

    case LogLevel.WARN:
      console.warn.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
      break;

    case LogLevel.ERROR:
      console.error.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
      break;

    default:
      throw new Error("Attempted to log a message with an invalid logType (value: " + logType + ")");
  }
};

var Logger =
/** @class */
function () {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  function Logger(name) {
    this.name = name;
    /**
     * The log level of the given Logger instance.
     */

    this._logLevel = defaultLogLevel;
    /**
     * The log handler for the Logger instance.
     */

    this._logHandler = defaultLogHandler;
    /**
     * Capture the current instance for later use
     */

    instances.push(this);
  }

  Object.defineProperty(Logger.prototype, "logLevel", {
    get: function () {
      return this._logLevel;
    },
    set: function (val) {
      if (!(val in LogLevel)) {
        throw new TypeError('Invalid value assigned to `logLevel`');
      }

      this._logLevel = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Logger.prototype, "logHandler", {
    get: function () {
      return this._logHandler;
    },
    set: function (val) {
      if (typeof val !== 'function') {
        throw new TypeError('Value assigned to `logHandler` must be a function');
      }

      this._logHandler = val;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * The functions below are all based on the `console` interface
   */

  Logger.prototype.debug = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    this._logHandler.apply(this, [this, LogLevel.DEBUG].concat(args));
  };

  Logger.prototype.log = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    this._logHandler.apply(this, [this, LogLevel.VERBOSE].concat(args));
  };

  Logger.prototype.info = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    this._logHandler.apply(this, [this, LogLevel.INFO].concat(args));
  };

  Logger.prototype.warn = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    this._logHandler.apply(this, [this, LogLevel.WARN].concat(args));
  };

  Logger.prototype.error = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    this._logHandler.apply(this, [this, LogLevel.ERROR].concat(args));
  };

  return Logger;
}();
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function setLogLevel(level) {
  instances.forEach(function (inst) {
    inst.logLevel = level;
  });
}



/***/ }),

/***/ "../node_modules/@firebase/util/dist/index.cjs.js":
/*!********************************************************!*\
  !*** ../node_modules/@firebase/util/dist/index.cjs.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, '__esModule', {
  value: true
});

var tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.js");
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */


var CONSTANTS = {
  /**
   * @define {boolean} Whether this is the client Node.js SDK.
   */
  NODE_CLIENT: false,

  /**
   * @define {boolean} Whether this is the Admin Node.js SDK.
   */
  NODE_ADMIN: false,

  /**
   * Firebase SDK Version
   */
  SDK_VERSION: '${JSCORE_VERSION}'
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Throws an error if the provided assertion is falsy
 */

var assert = function (assertion, message) {
  if (!assertion) {
    throw assertionError(message);
  }
};
/**
 * Returns an Error object suitable for throwing.
 */


var assertionError = function (message) {
  return new Error('Firebase Database (' + CONSTANTS.SDK_VERSION + ') INTERNAL ASSERT FAILED: ' + message);
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var stringToByteArray = function (str) {
  // TODO(user): Use native implementations if/when available
  var out = [];
  var p = 0;

  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);

    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
      // Surrogate Pair
      c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }

  return out;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param bytes Array of numbers representing characters.
 * @return Stringification of the array.
 */


var byteArrayToString = function (bytes) {
  // TODO(user): Use native implementations if/when available
  var out = [];
  var pos = 0,
      c = 0;

  while (pos < bytes.length) {
    var c1 = bytes[pos++];

    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      var c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else if (c1 > 239 && c1 < 365) {
      // Surrogate Pair
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      var c4 = bytes[pos++];
      var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;
      out[c++] = String.fromCharCode(0xd800 + (u >> 10));
      out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
    } else {
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }

  return out.join('');
}; // Static lookup maps, lazily populated by init_()


var base64 = {
  /**
   * Maps bytes to characters.
   * @type {Object}
   * @private
   */
  byteToCharMap_: null,

  /**
   * Maps characters to bytes.
   * @type {Object}
   * @private
   */
  charToByteMap_: null,

  /**
   * Maps bytes to websafe characters.
   * @type {Object}
   * @private
   */
  byteToCharMapWebSafe_: null,

  /**
   * Maps websafe characters to bytes.
   * @type {Object}
   * @private
   */
  charToByteMapWebSafe_: null,

  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   * @type {string}
   */
  ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',

  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   * @type {string}
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + '+/=';
  },

  /**
   * Our websafe alphabet.
   * @type {string}
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + '-_.';
  },

  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   * @type {boolean}
   */
  HAS_NATIVE_SUPPORT: typeof atob === 'function',

  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray: function (input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error('encodeByteArray takes an array as a parameter');
    }

    this.init_();
    var byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    var output = [];

    for (var i = 0; i < input.length; i += 3) {
      var byte1 = input[i];
      var haveByte2 = i + 1 < input.length;
      var byte2 = haveByte2 ? input[i + 1] : 0;
      var haveByte3 = i + 2 < input.length;
      var byte3 = haveByte3 ? input[i + 2] : 0;
      var outByte1 = byte1 >> 2;
      var outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;
      var outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;
      var outByte4 = byte3 & 0x3f;

      if (!haveByte3) {
        outByte4 = 64;

        if (!haveByte2) {
          outByte3 = 64;
        }
      }

      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }

    return output.join('');
  },

  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString: function (input, webSafe) {
    // Shortcut for Mozilla browsers that implement
    // a native base64 encoder in the form of "btoa/atob"
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }

    return this.encodeByteArray(stringToByteArray(input), webSafe);
  },

  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString: function (input, webSafe) {
    // Shortcut for Mozilla browsers that implement
    // a native base64 encoder in the form of "btoa/atob"
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }

    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },

  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray: function (input, webSafe) {
    this.init_();
    var charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    var output = [];

    for (var i = 0; i < input.length;) {
      var byte1 = charToByteMap[input.charAt(i++)];
      var haveByte2 = i < input.length;
      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
      ++i;
      var haveByte3 = i < input.length;
      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      var haveByte4 = i < input.length;
      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
      ++i;

      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw Error();
      }

      var outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);

      if (byte3 !== 64) {
        var outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;
        output.push(outByte2);

        if (byte4 !== 64) {
          var outByte3 = byte3 << 6 & 0xc0 | byte4;
          output.push(outByte3);
        }
      }
    }

    return output;
  },

  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_: function () {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {}; // We want quick mappings back and forth, so we precompute two maps.

      for (var i = 0; i < this.ENCODED_VALS.length; i++) {
        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
        this.charToByteMap_[this.byteToCharMap_[i]] = i;
        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i; // Be forgiving when decoding and correctly decode both encodings.

        if (i >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
        }
      }
    }
  }
};
/**
 * URL-safe base64 encoding
 */

var base64Encode = function (str) {
  var utf8Bytes = stringToByteArray(str);
  return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param str To be decoded
 * @return Decoded result, if possible
 */


var base64Decode = function (str) {
  try {
    return base64.decodeString(str, true);
  } catch (e) {
    console.error('base64Decode failed: ', e);
  }

  return null;
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */


function deepCopy(value) {
  return deepExtend(undefined, value);
}
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 */


function deepExtend(target, source) {
  if (!(source instanceof Object)) {
    return source;
  }

  switch (source.constructor) {
    case Date:
      // Treat Dates like scalars; if the target date object had any child
      // properties - they will be lost!
      var dateValue = source;
      return new Date(dateValue.getTime());

    case Object:
      if (target === undefined) {
        target = {};
      }

      break;

    case Array:
      // Always copy the array source and overwrite the target.
      target = [];
      break;

    default:
      // Not a plain Object - treat it as a scalar.
      return source;
  }

  for (var prop in source) {
    if (!source.hasOwnProperty(prop)) {
      continue;
    }

    target[prop] = deepExtend(target[prop], source[prop]);
  }

  return target;
}
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Deferred =
/** @class */
function () {
  function Deferred() {
    var _this = this;

    this.promise = new Promise(function (resolve, reject) {
      _this.resolve = resolve;
      _this.reject = reject;
    });
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */


  Deferred.prototype.wrapCallback = function (callback) {
    var _this = this;

    return function (error, value) {
      if (error) {
        _this.reject(error);
      } else {
        _this.resolve(value);
      }

      if (typeof callback === 'function') {
        // Attaching noop handler just in case developer wasn't expecting
        // promises
        _this.promise.catch(function () {}); // Some of our callbacks don't expect a value and our own tests
        // assert that the parameter length is 1


        if (callback.length === 1) {
          callback(error);
        } else {
          callback(error, value);
        }
      }
    };
  };

  return Deferred;
}();
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return user agent string
 */


function getUA() {
  if (typeof navigator !== 'undefined' && typeof navigator['userAgent'] === 'string') {
    return navigator['userAgent'];
  } else {
    return '';
  }
}
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap
 * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally
 * wait for a callback.
 */


function isMobileCordova() {
  return typeof window !== 'undefined' && // @ts-ignore Setting up an broadly applicable index signature for Window
  // just to deal with this case would probably be a bad idea.
  !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
}
/**
 * Detect Node.js.
 *
 * @return true if Node.js environment is detected.
 */
// Node detection logic from: https://github.com/iliakan/detect-node/


function isNode() {
  try {
    return Object.prototype.toString.call(global.process) === '[object process]';
  } catch (e) {
    return false;
  }
}
/**
 * Detect Browser Environment
 */


function isBrowser() {
  return typeof self === 'object' && self.self === self;
}
/**
 * Detect React Native.
 *
 * @return true if ReactNative environment is detected.
 */


function isReactNative() {
  return typeof navigator === 'object' && navigator['product'] === 'ReactNative';
}
/**
 * Detect whether the current SDK build is the Node version.
 *
 * @return true if it's the Node SDK build.
 */


function isNodeSdk() {
  return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
}
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var ERROR_NAME = 'FirebaseError'; // Based on code from:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types

var FirebaseError =
/** @class */
function (_super) {
  tslib_1.__extends(FirebaseError, _super);

  function FirebaseError(code, message) {
    var _this = _super.call(this, message) || this;

    _this.code = code;
    _this.name = ERROR_NAME; // Fix For ES5
    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work

    Object.setPrototypeOf(_this, FirebaseError.prototype); // Maintains proper stack trace for where our error was thrown.
    // Only available on V8.

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this, ErrorFactory.prototype.create);
    }

    return _this;
  }

  return FirebaseError;
}(Error);

var ErrorFactory =
/** @class */
function () {
  function ErrorFactory(service, serviceName, errors) {
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }

  ErrorFactory.prototype.create = function (code) {
    var data = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      data[_i - 1] = arguments[_i];
    }

    var customData = data[0] || {};
    var fullCode = this.service + "/" + code;
    var template = this.errors[code];
    var message = template ? replaceTemplate(template, customData) : 'Error'; // Service Name: Error message (service/code).

    var fullMessage = this.serviceName + ": " + message + " (" + fullCode + ").";
    var error = new FirebaseError(fullCode, fullMessage); // Keys with an underscore at the end of their name are not included in
    // error.data for some reason.
    // TODO: Replace with Object.entries when lib is updated to es2017.

    for (var _a = 0, _b = Object.keys(customData); _a < _b.length; _a++) {
      var key = _b[_a];

      if (key.slice(-1) !== '_') {
        if (key in error) {
          console.warn("Overwriting FirebaseError base field \"" + key + "\" can cause unexpected behavior.");
        }

        error[key] = customData[key];
      }
    }

    return error;
  };

  return ErrorFactory;
}();

function replaceTemplate(template, data) {
  return template.replace(PATTERN, function (_, key) {
    var value = data[key];
    return value != null ? value.toString() : "<" + key + "?>";
  });
}

var PATTERN = /\{\$([^}]+)}/g;
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */

function jsonEval(str) {
  return JSON.parse(str);
}
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */


function stringify(data) {
  return JSON.stringify(data);
}
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */


var decode = function (token) {
  var header = {},
      claims = {},
      data = {},
      signature = '';

  try {
    var parts = token.split('.');
    header = jsonEval(base64Decode(parts[0]) || '');
    claims = jsonEval(base64Decode(parts[1]) || '');
    signature = parts[2];
    data = claims['d'] || {};
    delete claims['d'];
  } catch (e) {}

  return {
    header: header,
    claims: claims,
    data: data,
    signature: signature
  };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */


var isValidTimestamp = function (token) {
  var claims = decode(token).claims;
  var now = Math.floor(new Date().getTime() / 1000);
  var validSince = 0,
      validUntil = 0;

  if (typeof claims === 'object') {
    if (claims.hasOwnProperty('nbf')) {
      validSince = claims['nbf'];
    } else if (claims.hasOwnProperty('iat')) {
      validSince = claims['iat'];
    }

    if (claims.hasOwnProperty('exp')) {
      validUntil = claims['exp'];
    } else {
      // token will expire after 24h by default
      validUntil = validSince + 86400;
    }
  }

  return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */


var issuedAtTime = function (token) {
  var claims = decode(token).claims;

  if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
    return claims['iat'];
  }

  return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */


var isValidFormat = function (token) {
  var decoded = decode(token),
      claims = decoded.claims;
  return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */


var isAdmin = function (token) {
  var claims = decode(token).claims;
  return typeof claims === 'object' && claims['admin'] === true;
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// See http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/


var contains = function (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var safeGet = function (obj, key) {
  if (Object.prototype.hasOwnProperty.call(obj, key)) return obj[key]; // else return undefined.
};
/**
 * Enumerates the keys/values in an object, excluding keys defined on the prototype.
 *
 * @param {?Object.<K,V>} obj Object to enumerate.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */


var forEach = function (obj, fn) {
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      fn(key, obj[key]);
    }
  }
};
/**
 * Copies all the (own) properties from one object to another.
 * @param {!Object} objTo
 * @param {!Object} objFrom
 * @return {!Object} objTo
 */


var extend = function (objTo, objFrom) {
  forEach(objFrom, function (key, value) {
    objTo[key] = value;
  });
  return objTo;
};
/**
 * Returns a clone of the specified object.
 * @param {!Object} obj
 * @return {!Object} cloned obj.
 */


var clone = function (obj) {
  return extend({}, obj);
};
/**
 * Returns true if obj has typeof "object" and is not null.  Unlike goog.isObject(), does not return true
 * for functions.
 */


var isNonNullObject = function (obj) {
  return typeof obj === 'object' && obj !== null;
};

var isEmpty = function (obj) {
  for (var key in obj) {
    return false;
  }

  return true;
};

var getCount = function (obj) {
  var rv = 0;

  for (var key in obj) {
    rv++;
  }

  return rv;
};

var map = function (obj, fn, context) {
  var res = {};

  for (var key in obj) {
    res[key] = fn.call(context, obj[key], key, obj);
  }

  return res;
};

var findKey = function (obj, fn, context) {
  for (var key in obj) {
    if (fn.call(context, obj[key], key, obj)) {
      return key;
    }
  }

  return undefined;
};

var findValue = function (obj, fn, context) {
  var key = findKey(obj, fn, context);
  return key && obj[key];
};

var getAnyKey = function (obj) {
  for (var key in obj) {
    return key;
  }
};

var getValues = function (obj) {
  var res = [];
  var i = 0;

  for (var key in obj) {
    res[i++] = obj[key];
  }

  return res;
};
/**
 * Tests whether every key/value pair in an object pass the test implemented
 * by the provided function
 *
 * @param {?Object.<K,V>} obj Object to test.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */


var every = function (obj, fn) {
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!fn(key, obj[key])) {
        return false;
      }
    }
  }

  return true;
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a params
 * object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 */


var querystring = function (querystringParams) {
  var params = [];
  forEach(querystringParams, function (key, value) {
    if (Array.isArray(value)) {
      value.forEach(function (arrayVal) {
        params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
      });
    } else {
      params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
    }
  });
  return params.length ? '&' + params.join('&') : '';
};
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object (e.g. {arg: 'val', arg2: 'val2'})
 *
 * @param {string} querystring
 * @return {!Object}
 */


var querystringDecode = function (querystring) {
  var obj = {};
  var tokens = querystring.replace(/^\?/, '').split('&');
  tokens.forEach(function (token) {
    if (token) {
      var key = token.split('=');
      obj[key[0]] = key[1];
    }
  });
  return obj;
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */

/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @final
 * @struct
 */


var Sha1 =
/** @class */
function () {
  function Sha1() {
    /**
     * Holds the previous values of accumulated variables a-e in the compress_
     * function.
     * @private
     */
    this.chain_ = [];
    /**
     * A buffer holding the partially computed hash result.
     * @private
     */

    this.buf_ = [];
    /**
     * An array of 80 bytes, each a part of the message to be hashed.  Referred to
     * as the message schedule in the docs.
     * @private
     */

    this.W_ = [];
    /**
     * Contains data needed to pad messages less than 64 bytes.
     * @private
     */

    this.pad_ = [];
    /**
     * @private {number}
     */

    this.inbuf_ = 0;
    /**
     * @private {number}
     */

    this.total_ = 0;
    this.blockSize = 512 / 8;
    this.pad_[0] = 128;

    for (var i = 1; i < this.blockSize; ++i) {
      this.pad_[i] = 0;
    }

    this.reset();
  }

  Sha1.prototype.reset = function () {
    this.chain_[0] = 0x67452301;
    this.chain_[1] = 0xefcdab89;
    this.chain_[2] = 0x98badcfe;
    this.chain_[3] = 0x10325476;
    this.chain_[4] = 0xc3d2e1f0;
    this.inbuf_ = 0;
    this.total_ = 0;
  };
  /**
   * Internal compress helper function.
   * @param buf Block to compress.
   * @param offset Offset of the block in the buffer.
   * @private
   */


  Sha1.prototype.compress_ = function (buf, offset) {
    if (!offset) {
      offset = 0;
    }

    var W = this.W_; // get 16 big endian words

    if (typeof buf === 'string') {
      for (var i = 0; i < 16; i++) {
        // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
        // have a bug that turns the post-increment ++ operator into pre-increment
        // during JIT compilation.  We have code that depends heavily on SHA-1 for
        // correctness and which is affected by this bug, so I've removed all uses
        // of post-increment ++ in which the result value is used.  We can revert
        // this change once the Safari bug
        // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
        // most clients have been updated.
        W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
        offset += 4;
      }
    } else {
      for (var i = 0; i < 16; i++) {
        W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
        offset += 4;
      }
    } // expand to 80 words


    for (var i = 16; i < 80; i++) {
      var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
      W[i] = (t << 1 | t >>> 31) & 0xffffffff;
    }

    var a = this.chain_[0];
    var b = this.chain_[1];
    var c = this.chain_[2];
    var d = this.chain_[3];
    var e = this.chain_[4];
    var f, k; // TODO(user): Try to unroll this loop to speed up the computation.

    for (var i = 0; i < 80; i++) {
      if (i < 40) {
        if (i < 20) {
          f = d ^ b & (c ^ d);
          k = 0x5a827999;
        } else {
          f = b ^ c ^ d;
          k = 0x6ed9eba1;
        }
      } else {
        if (i < 60) {
          f = b & c | d & (b | c);
          k = 0x8f1bbcdc;
        } else {
          f = b ^ c ^ d;
          k = 0xca62c1d6;
        }
      }

      var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;
      e = d;
      d = c;
      c = (b << 30 | b >>> 2) & 0xffffffff;
      b = a;
      a = t;
    }

    this.chain_[0] = this.chain_[0] + a & 0xffffffff;
    this.chain_[1] = this.chain_[1] + b & 0xffffffff;
    this.chain_[2] = this.chain_[2] + c & 0xffffffff;
    this.chain_[3] = this.chain_[3] + d & 0xffffffff;
    this.chain_[4] = this.chain_[4] + e & 0xffffffff;
  };

  Sha1.prototype.update = function (bytes, length) {
    // TODO(johnlenz): tighten the function signature and remove this check
    if (bytes == null) {
      return;
    }

    if (length === undefined) {
      length = bytes.length;
    }

    var lengthMinusBlock = length - this.blockSize;
    var n = 0; // Using local instead of member variables gives ~5% speedup on Firefox 16.

    var buf = this.buf_;
    var inbuf = this.inbuf_; // The outer while loop should execute at most twice.

    while (n < length) {
      // When we have no data in the block to top up, we can directly process the
      // input buffer (assuming it contains sufficient data). This gives ~25%
      // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
      // the data is provided in large chunks (or in multiples of 64 bytes).
      if (inbuf === 0) {
        while (n <= lengthMinusBlock) {
          this.compress_(bytes, n);
          n += this.blockSize;
        }
      }

      if (typeof bytes === 'string') {
        while (n < length) {
          buf[inbuf] = bytes.charCodeAt(n);
          ++inbuf;
          ++n;

          if (inbuf === this.blockSize) {
            this.compress_(buf);
            inbuf = 0; // Jump to the outer loop so we use the full-block optimization.

            break;
          }
        }
      } else {
        while (n < length) {
          buf[inbuf] = bytes[n];
          ++inbuf;
          ++n;

          if (inbuf === this.blockSize) {
            this.compress_(buf);
            inbuf = 0; // Jump to the outer loop so we use the full-block optimization.

            break;
          }
        }
      }
    }

    this.inbuf_ = inbuf;
    this.total_ += length;
  };
  /** @override */


  Sha1.prototype.digest = function () {
    var digest = [];
    var totalBits = this.total_ * 8; // Add pad 0x80 0x00*.

    if (this.inbuf_ < 56) {
      this.update(this.pad_, 56 - this.inbuf_);
    } else {
      this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
    } // Add # bits.


    for (var i = this.blockSize - 1; i >= 56; i--) {
      this.buf_[i] = totalBits & 255;
      totalBits /= 256; // Don't use bit-shifting here!
    }

    this.compress_(this.buf_);
    var n = 0;

    for (var i = 0; i < 5; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        digest[n] = this.chain_[i] >> j & 255;
        ++n;
      }
    }

    return digest;
  };

  return Sha1;
}();
/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */


function createSubscribe(executor, onNoObservers) {
  var proxy = new ObserverProxy(executor, onNoObservers);
  return proxy.subscribe.bind(proxy);
}
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */


var ObserverProxy =
/** @class */
function () {
  /**
   * @param executor Function which can make calls to a single Observer
   *     as a proxy.
   * @param onNoObservers Callback when count of Observers goes to zero.
   */
  function ObserverProxy(executor, onNoObservers) {
    var _this = this;

    this.observers = [];
    this.unsubscribes = [];
    this.observerCount = 0; // Micro-task scheduling by calling task.then().

    this.task = Promise.resolve();
    this.finalized = false;
    this.onNoObservers = onNoObservers; // Call the executor asynchronously so subscribers that are called
    // synchronously after the creation of the subscribe function
    // can still receive the very first value generated in the executor.

    this.task.then(function () {
      executor(_this);
    }).catch(function (e) {
      _this.error(e);
    });
  }

  ObserverProxy.prototype.next = function (value) {
    this.forEachObserver(function (observer) {
      observer.next(value);
    });
  };

  ObserverProxy.prototype.error = function (error) {
    this.forEachObserver(function (observer) {
      observer.error(error);
    });
    this.close(error);
  };

  ObserverProxy.prototype.complete = function () {
    this.forEachObserver(function (observer) {
      observer.complete();
    });
    this.close();
  };
  /**
   * Subscribe function that can be used to add an Observer to the fan-out list.
   *
   * - We require that no event is sent to a subscriber sychronously to their
   *   call to subscribe().
   */


  ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {
    var _this = this;

    var observer;

    if (nextOrObserver === undefined && error === undefined && complete === undefined) {
      throw new Error('Missing Observer.');
    } // Assemble an Observer object when passed as callback functions.


    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {
      observer = nextOrObserver;
    } else {
      observer = {
        next: nextOrObserver,
        error: error,
        complete: complete
      };
    }

    if (observer.next === undefined) {
      observer.next = noop;
    }

    if (observer.error === undefined) {
      observer.error = noop;
    }

    if (observer.complete === undefined) {
      observer.complete = noop;
    }

    var unsub = this.unsubscribeOne.bind(this, this.observers.length); // Attempt to subscribe to a terminated Observable - we
    // just respond to the Observer with the final error or complete
    // event.

    if (this.finalized) {
      // tslint:disable-next-line:no-floating-promises
      this.task.then(function () {
        try {
          if (_this.finalError) {
            observer.error(_this.finalError);
          } else {
            observer.complete();
          }
        } catch (e) {// nothing
        }

        return;
      });
    }

    this.observers.push(observer);
    return unsub;
  }; // Unsubscribe is synchronous - we guarantee that no events are sent to
  // any unsubscribed Observer.


  ObserverProxy.prototype.unsubscribeOne = function (i) {
    if (this.observers === undefined || this.observers[i] === undefined) {
      return;
    }

    delete this.observers[i];
    this.observerCount -= 1;

    if (this.observerCount === 0 && this.onNoObservers !== undefined) {
      this.onNoObservers(this);
    }
  };

  ObserverProxy.prototype.forEachObserver = function (fn) {
    if (this.finalized) {
      // Already closed by previous event....just eat the additional values.
      return;
    } // Since sendOne calls asynchronously - there is no chance that
    // this.observers will become undefined.


    for (var i = 0; i < this.observers.length; i++) {
      this.sendOne(i, fn);
    }
  }; // Call the Observer via one of it's callback function. We are careful to
  // confirm that the observe has not been unsubscribed since this asynchronous
  // function had been queued.


  ObserverProxy.prototype.sendOne = function (i, fn) {
    var _this = this; // Execute the callback asynchronously
    // tslint:disable-next-line:no-floating-promises


    this.task.then(function () {
      if (_this.observers !== undefined && _this.observers[i] !== undefined) {
        try {
          fn(_this.observers[i]);
        } catch (e) {
          // Ignore exceptions raised in Observers or missing methods of an
          // Observer.
          // Log error to console. b/31404806
          if (typeof console !== 'undefined' && console.error) {
            console.error(e);
          }
        }
      }
    });
  };

  ObserverProxy.prototype.close = function (err) {
    var _this = this;

    if (this.finalized) {
      return;
    }

    this.finalized = true;

    if (err !== undefined) {
      this.finalError = err;
    } // Proxy is no longer needed - garbage collect references
    // tslint:disable-next-line:no-floating-promises


    this.task.then(function () {
      _this.observers = undefined;
      _this.onNoObservers = undefined;
    });
  };

  return ObserverProxy;
}();
/** Turn synchronous function into one called asynchronously. */


function async(fn, onError) {
  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    Promise.resolve(true).then(function () {
      fn.apply(void 0, args);
    }).catch(function (error) {
      if (onError) {
        onError(error);
      }
    });
  };
}
/**
 * Return true if the object passed in implements any of the named methods.
 */


function implementsAnyMethods(obj, methods) {
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }

  for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
    var method = methods_1[_i];

    if (method in obj && typeof obj[method] === 'function') {
      return true;
    }
  }

  return false;
}

function noop() {} // do nothing

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param fnName The function name
 * @param minCount The minimum number of arguments to allow for the function call
 * @param maxCount The maximum number of argument to allow for the function call
 * @param argCount The actual number of arguments provided.
 */


var validateArgCount = function (fnName, minCount, maxCount, argCount) {
  var argError;

  if (argCount < minCount) {
    argError = 'at least ' + minCount;
  } else if (argCount > maxCount) {
    argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
  }

  if (argError) {
    var error = fnName + ' failed: Was called with ' + argCount + (argCount === 1 ? ' argument.' : ' arguments.') + ' Expects ' + argError + '.';
    throw new Error(error);
  }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param fnName The function name
 * @param argumentNumber The index of the argument
 * @param optional Whether or not the argument is optional
 * @return The prefix to add to the error thrown for validation.
 */


function errorPrefix(fnName, argumentNumber, optional) {
  var argName = '';

  switch (argumentNumber) {
    case 1:
      argName = optional ? 'first' : 'First';
      break;

    case 2:
      argName = optional ? 'second' : 'Second';
      break;

    case 3:
      argName = optional ? 'third' : 'Third';
      break;

    case 4:
      argName = optional ? 'fourth' : 'Fourth';
      break;

    default:
      throw new Error('errorPrefix called with argumentNumber > 4.  Need to update it?');
  }

  var error = fnName + ' failed: ';
  error += argName + ' argument ';
  return error;
}
/**
 * @param fnName
 * @param argumentNumber
 * @param namespace
 * @param optional
 */


function validateNamespace(fnName, argumentNumber, namespace, optional) {
  if (optional && !namespace) {
    return;
  }

  if (typeof namespace !== 'string') {
    //TODO: I should do more validation here. We only allow certain chars in namespaces.
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid firebase namespace.');
  }
}

function validateCallback(fnName, argumentNumber, callback, optional) {
  if (optional && !callback) {
    return;
  }

  if (typeof callback !== 'function') {
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid function.');
  }
}

function validateContextObject(fnName, argumentNumber, context, optional) {
  if (optional && !context) {
    return;
  }

  if (typeof context !== 'object' || context === null) {
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid context object.');
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3

/**
 * @param {string} str
 * @return {Array}
 */


var stringToByteArray$1 = function (str) {
  var out = [];
  var p = 0;

  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i); // Is this the lead surrogate in a surrogate pair?

    if (c >= 0xd800 && c <= 0xdbff) {
      var high = c - 0xd800; // the high 10 bits.

      i++;
      assert(i < str.length, 'Surrogate pair missing trail surrogate.');
      var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.

      c = 0x10000 + (high << 10) + low;
    }

    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if (c < 65536) {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }

  return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */


var stringLength = function (str) {
  var p = 0;

  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);

    if (c < 128) {
      p++;
    } else if (c < 2048) {
      p += 2;
    } else if (c >= 0xd800 && c <= 0xdbff) {
      // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
      p += 4;
      i++; // skip trail surrogate.
    } else {
      p += 3;
    }
  }

  return p;
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


exports.CONSTANTS = CONSTANTS;
exports.Deferred = Deferred;
exports.ErrorFactory = ErrorFactory;
exports.FirebaseError = FirebaseError;
exports.Sha1 = Sha1;
exports.assert = assert;
exports.assertionError = assertionError;
exports.async = async;
exports.base64 = base64;
exports.base64Decode = base64Decode;
exports.base64Encode = base64Encode;
exports.clone = clone;
exports.contains = contains;
exports.createSubscribe = createSubscribe;
exports.decode = decode;
exports.deepCopy = deepCopy;
exports.deepExtend = deepExtend;
exports.errorPrefix = errorPrefix;
exports.every = every;
exports.extend = extend;
exports.findKey = findKey;
exports.findValue = findValue;
exports.forEach = forEach;
exports.getAnyKey = getAnyKey;
exports.getCount = getCount;
exports.getUA = getUA;
exports.getValues = getValues;
exports.isAdmin = isAdmin;
exports.isBrowser = isBrowser;
exports.isEmpty = isEmpty;
exports.isMobileCordova = isMobileCordova;
exports.isNode = isNode;
exports.isNodeSdk = isNodeSdk;
exports.isNonNullObject = isNonNullObject;
exports.isReactNative = isReactNative;
exports.isValidFormat = isValidFormat;
exports.isValidTimestamp = isValidTimestamp;
exports.issuedAtTime = issuedAtTime;
exports.jsonEval = jsonEval;
exports.map = map;
exports.querystring = querystring;
exports.querystringDecode = querystringDecode;
exports.safeGet = safeGet;
exports.stringLength = stringLength;
exports.stringToByteArray = stringToByteArray$1;
exports.stringify = stringify;
exports.validateArgCount = validateArgCount;
exports.validateCallback = validateCallback;
exports.validateContextObject = validateContextObject;
exports.validateNamespace = validateNamespace;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/babel-polyfill/lib/index.js":
/*!***************************************************!*\
  !*** ../node_modules/babel-polyfill/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(/*! core-js/shim */ "../node_modules/core-js/shim.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "../node_modules/regenerator-runtime/runtime.js");

__webpack_require__(/*! core-js/fn/regexp/escape */ "../node_modules/core-js/fn/regexp/escape.js");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}

global._babelPolyfill = true;
var DEFINE_PROPERTY = "defineProperty";

function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);
"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/core-js/fn/regexp/escape.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/fn/regexp/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/core.regexp.escape */ "../node_modules/core-js/modules/core.regexp.escape.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").RegExp.escape;

/***/ }),

/***/ "../node_modules/core-js/modules/_a-function.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_a-function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_a-number-value.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/_a-number-value.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/_add-to-unscopables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_advance-string-index.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/_advance-string-index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var at = __webpack_require__(/*! ./_string-at */ "../node_modules/core-js/modules/_string-at.js")(true); // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_an-instance.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_an-instance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_an-object.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_an-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-copy-within.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_array-copy-within.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-fill.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_array-fill.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-from-iterable.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/_array-from-iterable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-includes.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/_array-includes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-methods.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_array-methods.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var IObject = __webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var asc = __webpack_require__(/*! ./_array-species-create */ "../node_modules/core-js/modules/_array-species-create.js");

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);

      if (TYPE) {
        if (IS_MAP) result[index] = res; // map
        else if (res) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return val;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              result.push(val);
            // filter
          } else if (IS_EVERY) return false; // every
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-reduce.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/_array-reduce.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }

    index += i;

    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }

  for (; isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }

  return memo;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-species-constructor.js":
/*!*********************************************************************!*\
  !*** ../node_modules/core-js/modules/_array-species-constructor.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var isArray = __webpack_require__(/*! ./_is-array */ "../node_modules/core-js/modules/_is-array.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-species-create.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/_array-species-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "../node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_bind.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var invoke = __webpack_require__(/*! ./_invoke */ "../node_modules/core-js/modules/_invoke.js");

var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function ()
  /* args... */
  {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };

  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_classof.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_classof.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

var TAG = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('toStringTag'); // ES3 wrong here


var ARG = cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? cof(O) // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_cof.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_cof.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_collection-strong.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_collection-strong.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

var $iterDefine = __webpack_require__(/*! ./_iter-define */ "../node_modules/core-js/modules/_iter-define.js");

var step = __webpack_require__(/*! ./_iter-step */ "../node_modules/core-js/modules/_iter-step.js");

var setSpecies = __webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var fastKey = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").fastKey;

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = create(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed

      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) entry = entry.p; // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      } // return step by kind


      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(NAME);
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_collection-to-json.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/_collection-to-json.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

var from = __webpack_require__(/*! ./_array-from-iterable */ "../node_modules/core-js/modules/_array-from-iterable.js");

module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_collection-weak.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_collection-weak.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

var getWeak = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").getWeak;

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js");

var $has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.a = [];
};

var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = id++; // collection id

      that._l = undefined; // leak store for uncaught frozen objects

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),

/***/ "../node_modules/core-js/modules/_collection.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_collection.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "../node_modules/core-js/modules/_iter-detect.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "../node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) $instance[ADDER](index, index);

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_core.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_core.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.6.4'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "../node_modules/core-js/modules/_create-property.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_create-property.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_ctx.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_ctx.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_date-to-iso-string.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/_date-to-iso-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
}; // PhantomJS / old WebKit has a broken implementations


module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),

/***/ "../node_modules/core-js/modules/_date-to-primitive.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_date-to-primitive.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_defined.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_defined.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_descriptors.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_descriptors.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "../node_modules/core-js/modules/_dom-create.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_dom-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var document = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "../node_modules/core-js/modules/_enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_enum-bug-keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),

/***/ "../node_modules/core-js/modules/_enum-keys.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_enum-keys.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "../node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js");

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  }

  return result;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_export.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_export.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

    if (target) redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "../node_modules/core-js/modules/_fails-is-regexp.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_fails-is-regexp.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_fails.js":
/*!*************************************************!*\
  !*** ../node_modules/core-js/modules/_fails.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_fix-re-wks.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_fix-re-wks.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.exec */ "../node_modules/core-js/modules/es6.regexp.exec.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

var wks = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "../node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var strfn = fns[0];
    var rxfn = fns[1];
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_flags.js":
/*!*************************************************!*\
  !*** ../node_modules/core-js/modules/_flags.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_flatten-into-array.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/_flatten-into-array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var isArray = __webpack_require__(/*! ./_is-array */ "../node_modules/core-js/modules/_is-array.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      spreadable = false;

      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
}

module.exports = flattenIntoArray;

/***/ }),

/***/ "../node_modules/core-js/modules/_for-of.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_for-of.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var call = __webpack_require__(/*! ./_iter-call */ "../node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "../node_modules/core-js/modules/_is-array-iter.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "../node_modules/core-js/modules/core.get-iterator-method.js");

var BREAK = {};
var RETURN = {};

var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),

/***/ "../node_modules/core-js/modules/_function-to-string.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/_function-to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_shared */ "../node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);

/***/ }),

/***/ "../node_modules/core-js/modules/_global.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_global.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "../node_modules/core-js/modules/_has.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_has.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_hide.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_hide.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_html.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").document;

module.exports = document && document.documentElement;

/***/ }),

/***/ "../node_modules/core-js/modules/_ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/_ie8-dom-define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "../node_modules/core-js/modules/_dom-create.js")('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "../node_modules/core-js/modules/_inherit-if-required.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/_inherit-if-required.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "../node_modules/core-js/modules/_set-proto.js").set;

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_invoke.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_invoke.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iobject.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_iobject.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js"); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-array-iter.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_is-array-iter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-array.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_is-array.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-integer.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_is-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-object.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_is-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-regexp.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_is-regexp.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

var MATCH = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-call.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-call.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-create.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-create.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

var descriptor = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-define.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-define.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

var $iterCreate = __webpack_require__(/*! ./_iter-create */ "../node_modules/core-js/modules/_iter-create.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-detect.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-detect.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-step.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-step.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iterators.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_iterators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "../node_modules/core-js/modules/_library.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_library.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "../node_modules/core-js/modules/_math-expm1.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_math-expm1.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 // Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),

/***/ "../node_modules/core-js/modules/_math-fround.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_math-fround.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(/*! ./_math-sign */ "../node_modules/core-js/modules/_math-sign.js");

var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_math-log1p.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_math-log1p.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_math-scale.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_math-scale.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (arguments.length === 0 // eslint-disable-next-line no-self-compare
  || x != x // eslint-disable-next-line no-self-compare
  || inLow != inLow // eslint-disable-next-line no-self-compare
  || inHigh != inHigh // eslint-disable-next-line no-self-compare
  || outLow != outLow // eslint-disable-next-line no-self-compare
  || outHigh != outHigh) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_math-sign.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_math-sign.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_meta.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_meta.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js")('meta');

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var setDesc = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function (it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "../node_modules/core-js/modules/_metadata.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_metadata.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(/*! ./es6.map */ "../node_modules/core-js/modules/es6.map.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var shared = __webpack_require__(/*! ./_shared */ "../node_modules/core-js/modules/_shared.js")('metadata');

var store = shared.store || (shared.store = new (__webpack_require__(/*! ./es6.weak-map */ "../node_modules/core-js/modules/es6.weak-map.js"))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);

  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }

  var keyMetadata = targetMetadata.get(targetKey);

  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  }

  return keyMetadata;
};

var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};

var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};

var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};

var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) {
    keys.push(key);
  });
  return keys;
};

var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};

var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),

/***/ "../node_modules/core-js/modules/_microtask.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_microtask.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var macrotask = __webpack_require__(/*! ./_task */ "../node_modules/core-js/modules/_task.js").set;

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    }); // eslint-disable-line no-new

    notify = function () {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);

    notify = function () {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_new-promise-capability.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/_new-promise-capability.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-assign.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_object-assign.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.2.1 Object.assign(target, source, ...)

var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "../node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js");

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  }

  return T;
} : $assign;

/***/ }),

/***/ "../node_modules/core-js/modules/_object-create.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_object-create.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var dPs = __webpack_require__(/*! ./_object-dps */ "../node_modules/core-js/modules/_object-dps.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "../node_modules/core-js/modules/_enum-bug-keys.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "../node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var Empty = function () {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "../node_modules/core-js/modules/_dom-create.js")('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __webpack_require__(/*! ./_html */ "../node_modules/core-js/modules/_html.js").appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;

  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];

  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-dp.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_object-dp.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "../node_modules/core-js/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-dps.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-dps.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) dP.f(O, P = keys[i++], Properties[P]);

  return O;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-forced-pam.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_object-forced-pam.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Forced replacement prototype accessors methods

module.exports = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js") || !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  var K = Math.random(); // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call

  __defineSetter__.call(null, K, function () {
    /* empty */
  });

  delete __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js")[K];
});

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gopd.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gopd.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "../node_modules/core-js/modules/_ie8-dom-define.js");

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gopn-ext.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gopn-ext.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

var toString = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gopn.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gopn.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "../node_modules/core-js/modules/_object-keys-internal.js");

var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "../node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gops.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gops.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gpo.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gpo.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "../node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-keys-internal.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/_object-keys-internal.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "../node_modules/core-js/modules/_array-includes.js")(false);

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "../node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }

  return result;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-keys.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "../node_modules/core-js/modules/_object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "../node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-pie.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-pie.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "../node_modules/core-js/modules/_object-sap.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-sap.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-to-array.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_object-to-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var isEnum = __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js").f;

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    }

    return result;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_own-keys.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_own-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "../node_modules/core-js/modules/_object-gops.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var Reflect = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").Reflect;

module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_parse-float.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_parse-float.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").parseFloat;

var $trim = __webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js").trim;

module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ "../node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),

/***/ "../node_modules/core-js/modules/_parse-int.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_parse-int.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").parseInt;

var $trim = __webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js").trim;

var ws = __webpack_require__(/*! ./_string-ws */ "../node_modules/core-js/modules/_string-ws.js");

var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ "../node_modules/core-js/modules/_perform.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_perform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_promise-resolve.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_promise-resolve.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "../node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_property-desc.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_property-desc.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_redefine-all.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/_redefine-all.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);

  return target;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_redefine.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_redefine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var SRC = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js")('src');

var $toString = __webpack_require__(/*! ./_function-to-string */ "../node_modules/core-js/modules/_function-to-string.js");

var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),

/***/ "../node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec

module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }

  return builtinExec.call(R, S);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_regexp-exec.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_regexp-exec.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./_flags */ "../node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

/***/ }),

/***/ "../node_modules/core-js/modules/_replacer.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_replacer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_same-value.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_same-value.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_set-collection-from.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/_set-collection-from.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    from: function from(source
    /* , mapFn, thisArg */
    ) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];

      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }

      return new this(A);
    }
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_set-collection-of.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_set-collection-of.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    of: function of() {
      var length = arguments.length;
      var A = new Array(length);

      while (length--) A[length] = arguments[length];

      return new this(A);
    }
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_set-proto.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_set-proto.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "../node_modules/core-js/modules/_set-species.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_set-species.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () {
      return this;
    }
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_set-to-string-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var TAG = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_shared-key.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_shared-key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "../node_modules/core-js/modules/_shared.js")('keys');

var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_shared.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_shared.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "../node_modules/core-js/modules/_species-constructor.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/_species-constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_strict-method.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_strict-method.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-at.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_string-at.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js"); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-context.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/_string-context.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "../node_modules/core-js/modules/_is-regexp.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-html.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_string-html.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-pad.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_string-pad.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "../node_modules/core-js/modules/_string-repeat.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-repeat.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_string-repeat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;

  return res;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-trim.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_string-trim.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var spaces = __webpack_require__(/*! ./_string-ws */ "../node_modules/core-js/modules/_string-ws.js");

var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),

/***/ "../node_modules/core-js/modules/_string-ws.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_string-ws.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),

/***/ "../node_modules/core-js/modules/_task.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_task.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var invoke = __webpack_require__(/*! ./_invoke */ "../node_modules/core-js/modules/_invoke.js");

var html = __webpack_require__(/*! ./_html */ "../node_modules/core-js/modules/_html.js");

var cel = __webpack_require__(/*! ./_dom-create */ "../node_modules/core-js/modules/_dom-create.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function () {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function (event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) args.push(arguments[i++]);

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-absolute-index.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_to-absolute-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-index.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_to-index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-integer.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_to-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-iobject.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_to-iobject.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-length.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_to-length.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-object.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_to-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-primitive.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/_to-primitive.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "../node_modules/core-js/modules/_typed-array.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_typed-array.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

  var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

  var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

  var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

  var $typed = __webpack_require__(/*! ./_typed */ "../node_modules/core-js/modules/_typed.js");

  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "../node_modules/core-js/modules/_typed-buffer.js");

  var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

  var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

  var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

  var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

  var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

  var toIndex = __webpack_require__(/*! ./_to-index */ "../node_modules/core-js/modules/_to-index.js");

  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

  var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

  var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

  var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

  var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "../node_modules/core-js/modules/_is-array-iter.js");

  var create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

  var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "../node_modules/core-js/modules/core.get-iterator-method.js");

  var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

  var wks = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js");

  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "../node_modules/core-js/modules/_array-includes.js");

  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "../node_modules/core-js/modules/es6.array.iterator.js");

  var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "../node_modules/core-js/modules/_iter-detect.js");

  var setSpecies = __webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js");

  var arrayFill = __webpack_require__(/*! ./_array-fill */ "../node_modules/core-js/modules/_array-fill.js");

  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "../node_modules/core-js/modules/_array-copy-within.js");

  var $DP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';
  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });
  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });
  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }

    return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);

    while (length > index) result[index] = list[index++];

    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, {
      get: function () {
        return this._d[internal];
      }
    });
  };

  var $from = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;

    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }

      O = values;
    }

    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var $of = function of()
  /* ...items */
  {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);

    while (length > index) result[index] = arguments[index++];

    return result;
  }; // iOS Safari 6.x fails here


  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start
    /* , end */
    ) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value
    /* , start, end */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate
    /* , thisArg */
    ) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate
    /* , thisArg */
    ) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement
    /* , fromIndex */
    ) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement
    /* , fromIndex */
    ) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn
    /* , thisArg */
    ) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;

      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }

      return that;
    },
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike
  /* , offset */
  ) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);

    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };

  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };

  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }

    return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () {
      /* noop */
    },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () {
      return this[TYPED_ARRAY];
    }
  }); // eslint-disable-next-line max-statements

  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };

    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };

    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }

        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });

        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new

      new TypedArray(null); // eslint-disable-line no-new

      new TypedArray(1.5); // eslint-disable-line no-new

      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645

        if (!isObject(data)) return new Base(toIndex(data));

        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }

        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }

    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;
    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });
    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });
    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
    $export($export.P, NAME, proto);
    setSpecies(NAME);
    $export($export.P + $export.F * FORCED_SET, NAME, {
      set: $set
    });
    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, {
      slice: $slice
    });
    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {
      toLocaleString: $toLocaleString
    });
    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {
  /* empty */
};

/***/ }),

/***/ "../node_modules/core-js/modules/_typed-buffer.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/_typed-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

var $typed = __webpack_require__(/*! ./_typed */ "../node_modules/core-js/modules/_typed.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var toIndex = __webpack_require__(/*! ./_to-index */ "../node_modules/core-js/modules/_to-index.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var arrayFill = __webpack_require__(/*! ./_array-fill */ "../node_modules/core-js/modules/_array-fill.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value); // eslint-disable-next-line no-self-compare

  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);

    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);

  buffer[--i] |= s * 128;
  return buffer;
}

function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;

  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}

function packI8(it) {
  return [it & 0xff];
}

function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}

function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}

function packF64(it) {
  return packIEEE754(it, 52, 8);
}

function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, {
    get: function () {
      return this[internal];
    }
  });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}

function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);

  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new

    new $ArrayBuffer(1.5); // eslint-disable-line no-new

    new $ArrayBuffer(NaN); // eslint-disable-line no-new

    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };

    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }

    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  } // iOS Safari 7.x bug


  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),

/***/ "../node_modules/core-js/modules/_typed.js":
/*!*************************************************!*\
  !*** ../node_modules/core-js/modules/_typed.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),

/***/ "../node_modules/core-js/modules/_uid.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_uid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_user-agent.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_user-agent.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

/***/ }),

/***/ "../node_modules/core-js/modules/_validate-collection.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/_validate-collection.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_wks-define.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_wks-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "../node_modules/core-js/modules/_wks-ext.js");

var defineProperty = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_wks-ext.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_wks-ext.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

/***/ }),

/***/ "../node_modules/core-js/modules/_wks.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_wks.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "../node_modules/core-js/modules/_shared.js")('wks');

var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

var Symbol = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").Symbol;

var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "../node_modules/core-js/modules/core.get-iterator-method.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/core.get-iterator-method.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator');

var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

module.exports = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "../node_modules/core-js/modules/core.regexp.escape.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/core.regexp.escape.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $re = __webpack_require__(/*! ./_replacer */ "../node_modules/core-js/modules/_replacer.js")(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {
  escape: function escape(it) {
    return $re(it);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.copy-within.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.copy-within.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  copyWithin: __webpack_require__(/*! ./_array-copy-within */ "../node_modules/core-js/modules/_array-copy-within.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.every.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.every.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $every = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.fill.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.fill.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  fill: __webpack_require__(/*! ./_array-fill */ "../node_modules/core-js/modules/_array-fill.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")('fill');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.filter.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.filter.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $filter = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.find-index.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.find-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(6);

var KEY = 'findIndex';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.find.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.find.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(5);

var KEY = 'find';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.for-each.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.for-each.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $forEach = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(0);

var STRICT = __webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.from.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.from.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var call = __webpack_require__(/*! ./_iter-call */ "../node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "../node_modules/core-js/modules/_is-array-iter.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "../node_modules/core-js/modules/_create-property.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "../node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "../node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.index-of.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.index-of.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $indexOf = __webpack_require__(/*! ./_array-includes */ "../node_modules/core-js/modules/_array-includes.js")(false);

var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.is-array.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.is-array.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', {
  isArray: __webpack_require__(/*! ./_is-array */ "../node_modules/core-js/modules/_is-array.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.iterator.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.iterator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js");

var step = __webpack_require__(/*! ./_iter-step */ "../node_modules/core-js/modules/_iter-step.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js"); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__(/*! ./_iter-define */ "../node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.join.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.join.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var arrayJoin = [].join; // fallback for not array-like strings

$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.last-index-of.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.last-index-of.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;

    return -1;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.map.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.map.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $map = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.of.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.of.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "../node_modules/core-js/modules/_create-property.js"); // WebKit Array.of isn't generic


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of()
  /* ...args */
  {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);

    while (aLen > index) createProperty(result, index, arguments[index++]);

    result.length = aLen;
    return result;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.reduce-right.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.reduce-right.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "../node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.reduce.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.reduce.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "../node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.slice.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.slice.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var html = __webpack_require__(/*! ./_html */ "../node_modules/core-js/modules/_html.js");

var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;

    for (; i < size; i++) cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];

    return cloned;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.some.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.some.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $some = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.sort.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.sort.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var $sort = [].sort;
var test = [1, 2, 3];
$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.species.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.species.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js")('Array');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.now.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.now.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', {
  now: function () {
    return new Date().getTime();
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.to-iso-string.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.to-iso-string.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toISOString = __webpack_require__(/*! ./_date-to-iso-string */ "../node_modules/core-js/modules/_date-to-iso-string.js"); // PhantomJS / old WebKit has a broken implementations


$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.to-json.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.to-json.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function () {
      return 1;
    }
  }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.to-primitive.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.to-primitive.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('toPrimitive');

var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ "../node_modules/core-js/modules/_date-to-primitive.js"));

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.to-string.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;

if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.function.bind.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.function.bind.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', {
  bind: __webpack_require__(/*! ./_bind */ "../node_modules/core-js/modules/_bind.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.function.has-instance.js":
/*!********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.function.has-instance.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('hasInstance');

var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, {
  value: function (O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;

    return false;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.function.name.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.function.name.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // 19.2.4.2 name

NAME in FProto || __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.map.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/es6.map.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "../node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var MAP = 'Map'; // 23.1 Map Objects

module.exports = __webpack_require__(/*! ./_collection */ "../node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.acosh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.acosh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var log1p = __webpack_require__(/*! ./_math-log1p */ "../node_modules/core-js/modules/_math-log1p.js");

var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.asinh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.asinh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
} // Tor Browser bug: Math.asinh(0) -> -0


$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
  asinh: asinh
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.atanh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.atanh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.cbrt.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.cbrt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var sign = __webpack_require__(/*! ./_math-sign */ "../node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.clz32.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.clz32.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.cosh.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.cosh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.expm1.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.expm1.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $expm1 = __webpack_require__(/*! ./_math-expm1 */ "../node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
  expm1: $expm1
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.fround.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.fround.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  fround: __webpack_require__(/*! ./_math-fround */ "../node_modules/core-js/modules/_math-fround.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.hypot.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.hypot.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var abs = Math.abs;
$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.imul.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.imul.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.log10.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.log10.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.log1p.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.log1p.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log1p: __webpack_require__(/*! ./_math-log1p */ "../node_modules/core-js/modules/_math-log1p.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.log2.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.log2.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.sign.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.sign.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  sign: __webpack_require__(/*! ./_math-sign */ "../node_modules/core-js/modules/_math-sign.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.sinh.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.sinh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "../node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.tanh.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.tanh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "../node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.trunc.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.trunc.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.constructor.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.constructor.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "../node_modules/core-js/modules/_inherit-if-required.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var $trim = __webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js").trim;

var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype; // Opera ~12 has broken Object#toString

var BROKEN_COF = cof(__webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument)

var toNumber = function (argument) {
  var it = toPrimitive(argument, false);

  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal /^0o[0-7]+$/i

        default:
          return +it;
      }

      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };

  for (var keys = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }

  $Number.prototype = proto;
  proto.constructor = $Number;

  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.epsilon.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.epsilon.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  EPSILON: Math.pow(2, -52)
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.is-finite.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.is-finite.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var _isFinite = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.is-integer.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.is-integer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isInteger: __webpack_require__(/*! ./_is-integer */ "../node_modules/core-js/modules/_is-integer.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.is-nan.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.is-nan.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.is-safe-integer.js":
/*!*********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.is-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var isInteger = __webpack_require__(/*! ./_is-integer */ "../node_modules/core-js/modules/_is-integer.js");

var abs = Math.abs;
$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.max-safe-integer.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.max-safe-integer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MAX_SAFE_INTEGER: 0x1fffffffffffff
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.min-safe-integer.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.min-safe-integer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MIN_SAFE_INTEGER: -0x1fffffffffffff
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.parse-float.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.parse-float.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "../node_modules/core-js/modules/_parse-float.js"); // 20.1.2.12 Number.parseFloat(string)


$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.parse-int.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.parse-int.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "../node_modules/core-js/modules/_parse-int.js"); // 20.1.2.13 Number.parseInt(string, radix)


$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
  parseInt: $parseInt
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.to-fixed.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.to-fixed.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "../node_modules/core-js/modules/_a-number-value.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "../node_modules/core-js/modules/_string-repeat.js");

var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;

  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (n) {
  var i = 6;
  var c = 0;

  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};

var numToString = function () {
  var i = 6;
  var s = '';

  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }

  return s;
};

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = f;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }

    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }

    return m;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.to-precision.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.to-precision.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "../node_modules/core-js/modules/_a-number-value.js");

var $toPrecision = 1.0.toPrecision;
$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.assign.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.assign.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__(/*! ./_object-assign */ "../node_modules/core-js/modules/_object-assign.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.create.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.create.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js"); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


$export($export.S, 'Object', {
  create: __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.define-properties.js":
/*!***********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.define-properties.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js"); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperties: __webpack_require__(/*! ./_object-dps */ "../node_modules/core-js/modules/_object-dps.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.define-property.js":
/*!*********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.define-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js"); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperty: __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.freeze.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.freeze.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.get-own-property-names.js":
/*!****************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.get-own-property-names.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "../node_modules/core-js/modules/_object-gopn-ext.js").f;
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.get-prototype-of.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.get-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.is-extensible.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.is-extensible.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.is-frozen.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.is-frozen.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.is-sealed.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.is-sealed.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.is.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.is.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  is: __webpack_require__(/*! ./_same-value */ "../node_modules/core-js/modules/_same-value.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.keys.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.keys.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.prevent-extensions.js":
/*!************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.prevent-extensions.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.seal.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.seal.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.set-prototype-of.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.set-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "../node_modules/core-js/modules/_set-proto.js").set
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.to-string.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.to-string.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

var test = {};
test[__webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.parse-float.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.parse-float.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "../node_modules/core-js/modules/_parse-float.js"); // 18.2.4 parseFloat(string)


$export($export.G + $export.F * (parseFloat != $parseFloat), {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.parse-int.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.parse-int.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "../node_modules/core-js/modules/_parse-int.js"); // 18.2.5 parseInt(string, radix)


$export($export.G + $export.F * (parseInt != $parseInt), {
  parseInt: $parseInt
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.promise.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

var task = __webpack_require__(/*! ./_task */ "../node_modules/core-js/modules/_task.js").set;

var microtask = __webpack_require__(/*! ./_microtask */ "../node_modules/core-js/modules/_microtask.js")();

var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "../node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "../node_modules/core-js/modules/_perform.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "../node_modules/core-js/modules/_user-agent.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "../node_modules/core-js/modules/_promise-resolve.js");

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function () {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        }; // wrap

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);

__webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js")(PROMISE);

Wrapper = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js")[PROMISE]; // statics

$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "../node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.apply.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.apply.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var rApply = (__webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").Reflect || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.construct.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.construct.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var bind = __webpack_require__(/*! ./_bind */ "../node_modules/core-js/modules/_bind.js");

var rConstruct = (__webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.define-property.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.define-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js"); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.delete-property.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.delete-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f;

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.enumerate.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.enumerate.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target

  this._i = 0; // next index

  var keys = this._k = []; // keys

  var key;

  for (key in iterated) keys.push(key);
};

__webpack_require__(/*! ./_iter-create */ "../node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;

  do {
    if (that._i >= keys.length) return {
      value: undefined,
      done: true
    };
  } while (!((key = keys[that._i++]) in that._t));

  return {
    value: key,
    done: false
  };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/*!***********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var getProto = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.get.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.get.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {
  get: get
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.has.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.has.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.is-extensible.js":
/*!********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.is-extensible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.own-keys.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.own-keys.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  ownKeys: __webpack_require__(/*! ./_own-keys */ "../node_modules/core-js/modules/_own-keys.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/*!*************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/*!***********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var setProto = __webpack_require__(/*! ./_set-proto */ "../node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);

    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.set.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.set.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = createDesc(0);
  }

  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;

    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));

    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {
  set: set
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.constructor.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "../node_modules/core-js/modules/_inherit-if-required.js");

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "../node_modules/core-js/modules/_is-regexp.js");

var $flags = __webpack_require__(/*! ./_flags */ "../node_modules/core-js/modules/_flags.js");

var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };

  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () {
        return Base[key];
      },
      set: function (it) {
        Base[key] = it;
      }
    });
  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);

  proto.constructor = $RegExp;
  $RegExp.prototype = proto;

  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js")('RegExp');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.exec.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.exec.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "../node_modules/core-js/modules/_regexp-exec.js");

__webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.flags.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.flags.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "../node_modules/core-js/modules/_flags.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.match.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.match.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "../node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "../node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@match logic


__webpack_require__(/*! ./_fix-re-wks */ "../node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative($match, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.replace.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.replace.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "../node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "../node_modules/core-js/modules/_regexp-exec-abstract.js");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


__webpack_require__(/*! ./_fix-re-wks */ "../node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative($replace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.search.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.search.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var sameValue = __webpack_require__(/*! ./_same-value */ "../node_modules/core-js/modules/_same-value.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "../node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@search logic


__webpack_require__(/*! ./_fix-re-wks */ "../node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative($search, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.split.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.split.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ./_is-regexp */ "../node_modules/core-js/modules/_is-regexp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "../node_modules/core-js/modules/_advance-string-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "../node_modules/core-js/modules/_regexp-exec-abstract.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "../node_modules/core-js/modules/_regexp-exec.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  RegExp(MAX_UINT32, 'y');
}); // @@split logic

__webpack_require__(/*! ./_fix-re-wks */ "../node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = defined(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.to-string.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.flags */ "../node_modules/core-js/modules/es6.regexp.flags.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var $flags = __webpack_require__(/*! ./_flags */ "../node_modules/core-js/modules/_flags.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return $toString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.set.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/es6.set.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "../node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var SET = 'Set'; // 23.2 Set Objects

module.exports = __webpack_require__(/*! ./_collection */ "../node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.anchor.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.anchor.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.2 String.prototype.anchor(name)

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.big.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.big.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.3 String.prototype.big()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.blink.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.blink.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.4 String.prototype.blink()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.bold.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.bold.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.5 String.prototype.bold()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.code-point-at.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.code-point-at.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "../node_modules/core-js/modules/_string-at.js")(false);

$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.ends-with.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.ends-with.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "../node_modules/core-js/modules/_string-context.js");

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "../node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.fixed.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.fixed.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.6 String.prototype.fixed()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.fontcolor.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.fontcolor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.fontsize.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.fontsize.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.from-code-point.js":
/*!*********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.from-code-point.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.includes.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.includes.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var context = __webpack_require__(/*! ./_string-context */ "../node_modules/core-js/modules/_string-context.js");

var INCLUDES = 'includes';
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "../node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.italics.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.italics.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.9 String.prototype.italics()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.iterator.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.iterator.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(/*! ./_string-at */ "../node_modules/core-js/modules/_string-at.js")(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__(/*! ./_iter-define */ "../node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.link.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.link.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.10 String.prototype.link(url)

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.raw.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.raw.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;

    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.repeat.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.repeat.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(/*! ./_string-repeat */ "../node_modules/core-js/modules/_string-repeat.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.small.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.small.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.11 String.prototype.small()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.starts-with.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.starts-with.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "../node_modules/core-js/modules/_string-context.js");

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "../node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.strike.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.strike.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.12 String.prototype.strike()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.sub.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.sub.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.13 String.prototype.sub()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.sup.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.sup.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.14 String.prototype.sup()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.trim.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.trim.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.1.3.25 String.prototype.trim()

__webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.symbol.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/es6.symbol.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ECMAScript 6 symbols shim

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var META = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").KEY;

var $fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var shared = __webpack_require__(/*! ./_shared */ "../node_modules/core-js/modules/_shared.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

var wks = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "../node_modules/core-js/modules/_wks-ext.js");

var wksDefine = __webpack_require__(/*! ./_wks-define */ "../node_modules/core-js/modules/_wks-define.js");

var enumKeys = __webpack_require__(/*! ./_enum-keys */ "../node_modules/core-js/modules/_enum-keys.js");

var isArray = __webpack_require__(/*! ./_is-array */ "../node_modules/core-js/modules/_is-array.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

var _create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "../node_modules/core-js/modules/_object-gopn-ext.js");

var $GOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var $DP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) $defineProperty(it, key = keys[i++], P[key]);

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__(/*! ./_object-gops */ "../node_modules/core-js/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () {
    setter = true;
  },
  useSimple: function () {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) args.push(arguments[i++]);

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.array-buffer.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.array-buffer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $typed = __webpack_require__(/*! ./_typed */ "../node_modules/core-js/modules/_typed.js");

var buffer = __webpack_require__(/*! ./_typed-buffer */ "../node_modules/core-js/modules/_typed-buffer.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var ArrayBuffer = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").ArrayBuffer;

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});
$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  }
});

__webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.data-view.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.data-view.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "../node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "../node_modules/core-js/modules/_typed-buffer.js").DataView
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.float32-array.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.float32-array.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.float64-array.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.float64-array.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.int16-array.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.int16-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.int32-array.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.int32-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.int8-array.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.int8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/*!************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.weak-map.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.weak-map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var each = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(0);

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js");

var assign = __webpack_require__(/*! ./_object-assign */ "../node_modules/core-js/modules/_object-assign.js");

var weak = __webpack_require__(/*! ./_collection-weak */ "../node_modules/core-js/modules/_collection-weak.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
}; // 23.3 WeakMap Objects

var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "../node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result; // store all the rest on native weakmap
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.weak-set.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.weak-set.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(/*! ./_collection-weak */ "../node_modules/core-js/modules/_collection-weak.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

__webpack_require__(/*! ./_collection */ "../node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),

/***/ "../node_modules/core-js/modules/es7.array.flat-map.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.array.flat-map.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "../node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "../node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")('flatMap');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.array.flatten.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.array.flatten.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "../node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "../node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatten: function flatten()
  /* depthArg = 1 */
  {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")('flatten');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.array.includes.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.array.includes.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $includes = __webpack_require__(/*! ./_array-includes */ "../node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")('includes');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.asap.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/es7.asap.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var microtask = __webpack_require__(/*! ./_microtask */ "../node_modules/core-js/modules/_microtask.js")();

var process = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").process;

var isNode = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js")(process) == 'process';
$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.error.is-error.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.error.is-error.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.global.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/es7.global.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.G, {
  global: __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.map.from.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es7.map.from.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(/*! ./_set-collection-from */ "../node_modules/core-js/modules/_set-collection-from.js")('Map');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.map.of.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/es7.map.of.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(/*! ./_set-collection-of */ "../node_modules/core-js/modules/_set-collection-of.js")('Map');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.map.to-json.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.map.to-json.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Map', {
  toJSON: __webpack_require__(/*! ./_collection-to-json */ "../node_modules/core-js/modules/_collection-to-json.js")('Map')
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.clamp.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.clamp.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.deg-per-rad.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.deg-per-rad.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  DEG_PER_RAD: Math.PI / 180
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.degrees.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.degrees.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var RAD_PER_DEG = 180 / Math.PI;
$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.fscale.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.fscale.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var scale = __webpack_require__(/*! ./_math-scale */ "../node_modules/core-js/modules/_math-scale.js");

var fround = __webpack_require__(/*! ./_math-fround */ "../node_modules/core-js/modules/_math-fround.js");

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.iaddh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.iaddh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.imulh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.imulh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.isubh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.isubh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.rad-per-deg.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.rad-per-deg.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  RAD_PER_DEG: 180 / Math.PI
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.radians.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.radians.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var DEG_PER_RAD = Math.PI / 180;
$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.scale.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.scale.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  scale: __webpack_require__(/*! ./_math-scale */ "../node_modules/core-js/modules/_math-scale.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.signbit.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.signbit.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  signbit: function signbit(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.math.umulh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.math.umulh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.define-getter.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.define-getter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js"); // B.2.2.2 Object.prototype.__defineGetter__(P, getter)


__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "../node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, {
      get: aFunction(getter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.define-setter.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.define-setter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js"); // B.2.2.3 Object.prototype.__defineSetter__(P, setter)


__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "../node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, {
      set: aFunction(setter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.entries.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.entries.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $entries = __webpack_require__(/*! ./_object-to-array */ "../node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var ownKeys = __webpack_require__(/*! ./_own-keys */ "../node_modules/core-js/modules/_own-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "../node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }

    return result;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.lookup-getter.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.lookup-getter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.4 Object.prototype.__lookupGetter__(P)


__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "../node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.lookup-setter.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.lookup-setter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.5 Object.prototype.__lookupSetter__(P)


__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "../node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.values.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.values.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $values = __webpack_require__(/*! ./_object-to-array */ "../node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.observable.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.observable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/zenparsing/es-observable

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var microtask = __webpack_require__(/*! ./_microtask */ "../node_modules/core-js/modules/_microtask.js")();

var OBSERVABLE = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('observable');

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;

  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);

  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;

    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () {
        subscription.unsubscribe();
      };else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  }

  if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() {
    closeSubscription(this);
  }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;

      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;

    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    }

    cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;

      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      }

      cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});
redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);

    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }

    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];

    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  }
});
hide($Observable.prototype, OBSERVABLE, function () {
  return this;
});
$export($export.G, {
  Observable: $Observable
});

__webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js")('Observable');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.promise.finally.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.promise.finally.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "../node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.promise.try.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.promise.try.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-promise-try

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "../node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "../node_modules/core-js/modules/_perform.js");

$export($export.S, 'Promise', {
  'try': function (callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.reflect.define-metadata.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.reflect.define-metadata.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "../node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;
metadata.exp({
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.reflect.delete-metadata.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.reflect.delete-metadata.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "../node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;
metadata.exp({
  deleteMetadata: function deleteMetadata(metadataKey, target
  /* , targetKey */
  ) {
    var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.reflect.get-metadata-keys.js":
/*!************************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.reflect.get-metadata-keys.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(/*! ./es6.set */ "../node_modules/core-js/modules/es6.set.js");

var from = __webpack_require__(/*! ./_array-from-iterable */ "../node_modules/core-js/modules/_array-from-iterable.js");

var metadata = __webpack_require__(/*! ./_metadata */ "../node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({
  getMetadataKeys: function getMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.reflect.get-metadata.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.reflect.get-metadata.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "../node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({
  getMetadata: function getMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js":
/*!****************************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "../node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadataKeys: function getOwnMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.reflect.get-own-metadata.js":
/*!***********************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.reflect.get-own-metadata.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "../node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadata: function getOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.reflect.has-metadata.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.reflect.has-metadata.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "../node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({
  hasMetadata: function hasMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.reflect.has-own-metadata.js":
/*!***********************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.reflect.has-own-metadata.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "../node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;
metadata.exp({
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.reflect.metadata.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.reflect.metadata.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(/*! ./_metadata */ "../node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;
$metadata.exp({
  metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, targetKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
    };
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.set.from.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es7.set.from.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(/*! ./_set-collection-from */ "../node_modules/core-js/modules/_set-collection-from.js")('Set');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.set.of.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/es7.set.of.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(/*! ./_set-collection-of */ "../node_modules/core-js/modules/_set-collection-of.js")('Set');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.set.to-json.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.set.to-json.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Set', {
  toJSON: __webpack_require__(/*! ./_collection-to-json */ "../node_modules/core-js/modules/_collection-to-json.js")('Set')
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.at.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.at.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/mathiasbynens/String.prototype.at

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "../node_modules/core-js/modules/_string-at.js")(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.match-all.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.match-all.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/String.prototype.matchAll/

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "../node_modules/core-js/modules/_is-regexp.js");

var getFlags = __webpack_require__(/*! ./_flags */ "../node_modules/core-js/modules/_flags.js");

var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(/*! ./_iter-create */ "../node_modules/core-js/modules/_iter-create.js")($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);

  return {
    value: match,
    done: match === null
  };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.pad-end.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.pad-end.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "../node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "../node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.pad-start.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.pad-start.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "../node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "../node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.trim-left.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.trim-left.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js")('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.trim-right.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.trim-right.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js")('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!********************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "../node_modules/core-js/modules/_wks-define.js")('asyncIterator');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.symbol.observable.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.symbol.observable.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "../node_modules/core-js/modules/_wks-define.js")('observable');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.system.global.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.system.global.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'System', {
  global: __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.weak-map.from.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.weak-map.from.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(/*! ./_set-collection-from */ "../node_modules/core-js/modules/_set-collection-from.js")('WeakMap');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.weak-map.of.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.weak-map.of.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(/*! ./_set-collection-of */ "../node_modules/core-js/modules/_set-collection-of.js")('WeakMap');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.weak-set.from.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.weak-set.from.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(/*! ./_set-collection-from */ "../node_modules/core-js/modules/_set-collection-from.js")('WeakSet');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.weak-set.of.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es7.weak-set.of.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(/*! ./_set-collection-of */ "../node_modules/core-js/modules/_set-collection-of.js")('WeakSet');

/***/ }),

/***/ "../node_modules/core-js/modules/web.dom.iterable.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/web.dom.iterable.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "../node_modules/core-js/modules/es6.array.iterator.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

var wks = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),

/***/ "../node_modules/core-js/modules/web.immediate.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/web.immediate.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $task = __webpack_require__(/*! ./_task */ "../node_modules/core-js/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "../node_modules/core-js/modules/web.timers.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/web.timers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "../node_modules/core-js/modules/_user-agent.js");

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function (set) {
  return function (fn, time
  /* , ...args */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),

/***/ "../node_modules/core-js/shim.js":
/*!***************************************!*\
  !*** ../node_modules/core-js/shim.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./modules/es6.symbol */ "../node_modules/core-js/modules/es6.symbol.js");

__webpack_require__(/*! ./modules/es6.object.create */ "../node_modules/core-js/modules/es6.object.create.js");

__webpack_require__(/*! ./modules/es6.object.define-property */ "../node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! ./modules/es6.object.define-properties */ "../node_modules/core-js/modules/es6.object.define-properties.js");

__webpack_require__(/*! ./modules/es6.object.get-own-property-descriptor */ "../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");

__webpack_require__(/*! ./modules/es6.object.get-prototype-of */ "../node_modules/core-js/modules/es6.object.get-prototype-of.js");

__webpack_require__(/*! ./modules/es6.object.keys */ "../node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! ./modules/es6.object.get-own-property-names */ "../node_modules/core-js/modules/es6.object.get-own-property-names.js");

__webpack_require__(/*! ./modules/es6.object.freeze */ "../node_modules/core-js/modules/es6.object.freeze.js");

__webpack_require__(/*! ./modules/es6.object.seal */ "../node_modules/core-js/modules/es6.object.seal.js");

__webpack_require__(/*! ./modules/es6.object.prevent-extensions */ "../node_modules/core-js/modules/es6.object.prevent-extensions.js");

__webpack_require__(/*! ./modules/es6.object.is-frozen */ "../node_modules/core-js/modules/es6.object.is-frozen.js");

__webpack_require__(/*! ./modules/es6.object.is-sealed */ "../node_modules/core-js/modules/es6.object.is-sealed.js");

__webpack_require__(/*! ./modules/es6.object.is-extensible */ "../node_modules/core-js/modules/es6.object.is-extensible.js");

__webpack_require__(/*! ./modules/es6.object.assign */ "../node_modules/core-js/modules/es6.object.assign.js");

__webpack_require__(/*! ./modules/es6.object.is */ "../node_modules/core-js/modules/es6.object.is.js");

__webpack_require__(/*! ./modules/es6.object.set-prototype-of */ "../node_modules/core-js/modules/es6.object.set-prototype-of.js");

__webpack_require__(/*! ./modules/es6.object.to-string */ "../node_modules/core-js/modules/es6.object.to-string.js");

__webpack_require__(/*! ./modules/es6.function.bind */ "../node_modules/core-js/modules/es6.function.bind.js");

__webpack_require__(/*! ./modules/es6.function.name */ "../node_modules/core-js/modules/es6.function.name.js");

__webpack_require__(/*! ./modules/es6.function.has-instance */ "../node_modules/core-js/modules/es6.function.has-instance.js");

__webpack_require__(/*! ./modules/es6.parse-int */ "../node_modules/core-js/modules/es6.parse-int.js");

__webpack_require__(/*! ./modules/es6.parse-float */ "../node_modules/core-js/modules/es6.parse-float.js");

__webpack_require__(/*! ./modules/es6.number.constructor */ "../node_modules/core-js/modules/es6.number.constructor.js");

__webpack_require__(/*! ./modules/es6.number.to-fixed */ "../node_modules/core-js/modules/es6.number.to-fixed.js");

__webpack_require__(/*! ./modules/es6.number.to-precision */ "../node_modules/core-js/modules/es6.number.to-precision.js");

__webpack_require__(/*! ./modules/es6.number.epsilon */ "../node_modules/core-js/modules/es6.number.epsilon.js");

__webpack_require__(/*! ./modules/es6.number.is-finite */ "../node_modules/core-js/modules/es6.number.is-finite.js");

__webpack_require__(/*! ./modules/es6.number.is-integer */ "../node_modules/core-js/modules/es6.number.is-integer.js");

__webpack_require__(/*! ./modules/es6.number.is-nan */ "../node_modules/core-js/modules/es6.number.is-nan.js");

__webpack_require__(/*! ./modules/es6.number.is-safe-integer */ "../node_modules/core-js/modules/es6.number.is-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.max-safe-integer */ "../node_modules/core-js/modules/es6.number.max-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.min-safe-integer */ "../node_modules/core-js/modules/es6.number.min-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.parse-float */ "../node_modules/core-js/modules/es6.number.parse-float.js");

__webpack_require__(/*! ./modules/es6.number.parse-int */ "../node_modules/core-js/modules/es6.number.parse-int.js");

__webpack_require__(/*! ./modules/es6.math.acosh */ "../node_modules/core-js/modules/es6.math.acosh.js");

__webpack_require__(/*! ./modules/es6.math.asinh */ "../node_modules/core-js/modules/es6.math.asinh.js");

__webpack_require__(/*! ./modules/es6.math.atanh */ "../node_modules/core-js/modules/es6.math.atanh.js");

__webpack_require__(/*! ./modules/es6.math.cbrt */ "../node_modules/core-js/modules/es6.math.cbrt.js");

__webpack_require__(/*! ./modules/es6.math.clz32 */ "../node_modules/core-js/modules/es6.math.clz32.js");

__webpack_require__(/*! ./modules/es6.math.cosh */ "../node_modules/core-js/modules/es6.math.cosh.js");

__webpack_require__(/*! ./modules/es6.math.expm1 */ "../node_modules/core-js/modules/es6.math.expm1.js");

__webpack_require__(/*! ./modules/es6.math.fround */ "../node_modules/core-js/modules/es6.math.fround.js");

__webpack_require__(/*! ./modules/es6.math.hypot */ "../node_modules/core-js/modules/es6.math.hypot.js");

__webpack_require__(/*! ./modules/es6.math.imul */ "../node_modules/core-js/modules/es6.math.imul.js");

__webpack_require__(/*! ./modules/es6.math.log10 */ "../node_modules/core-js/modules/es6.math.log10.js");

__webpack_require__(/*! ./modules/es6.math.log1p */ "../node_modules/core-js/modules/es6.math.log1p.js");

__webpack_require__(/*! ./modules/es6.math.log2 */ "../node_modules/core-js/modules/es6.math.log2.js");

__webpack_require__(/*! ./modules/es6.math.sign */ "../node_modules/core-js/modules/es6.math.sign.js");

__webpack_require__(/*! ./modules/es6.math.sinh */ "../node_modules/core-js/modules/es6.math.sinh.js");

__webpack_require__(/*! ./modules/es6.math.tanh */ "../node_modules/core-js/modules/es6.math.tanh.js");

__webpack_require__(/*! ./modules/es6.math.trunc */ "../node_modules/core-js/modules/es6.math.trunc.js");

__webpack_require__(/*! ./modules/es6.string.from-code-point */ "../node_modules/core-js/modules/es6.string.from-code-point.js");

__webpack_require__(/*! ./modules/es6.string.raw */ "../node_modules/core-js/modules/es6.string.raw.js");

__webpack_require__(/*! ./modules/es6.string.trim */ "../node_modules/core-js/modules/es6.string.trim.js");

__webpack_require__(/*! ./modules/es6.string.iterator */ "../node_modules/core-js/modules/es6.string.iterator.js");

__webpack_require__(/*! ./modules/es6.string.code-point-at */ "../node_modules/core-js/modules/es6.string.code-point-at.js");

__webpack_require__(/*! ./modules/es6.string.ends-with */ "../node_modules/core-js/modules/es6.string.ends-with.js");

__webpack_require__(/*! ./modules/es6.string.includes */ "../node_modules/core-js/modules/es6.string.includes.js");

__webpack_require__(/*! ./modules/es6.string.repeat */ "../node_modules/core-js/modules/es6.string.repeat.js");

__webpack_require__(/*! ./modules/es6.string.starts-with */ "../node_modules/core-js/modules/es6.string.starts-with.js");

__webpack_require__(/*! ./modules/es6.string.anchor */ "../node_modules/core-js/modules/es6.string.anchor.js");

__webpack_require__(/*! ./modules/es6.string.big */ "../node_modules/core-js/modules/es6.string.big.js");

__webpack_require__(/*! ./modules/es6.string.blink */ "../node_modules/core-js/modules/es6.string.blink.js");

__webpack_require__(/*! ./modules/es6.string.bold */ "../node_modules/core-js/modules/es6.string.bold.js");

__webpack_require__(/*! ./modules/es6.string.fixed */ "../node_modules/core-js/modules/es6.string.fixed.js");

__webpack_require__(/*! ./modules/es6.string.fontcolor */ "../node_modules/core-js/modules/es6.string.fontcolor.js");

__webpack_require__(/*! ./modules/es6.string.fontsize */ "../node_modules/core-js/modules/es6.string.fontsize.js");

__webpack_require__(/*! ./modules/es6.string.italics */ "../node_modules/core-js/modules/es6.string.italics.js");

__webpack_require__(/*! ./modules/es6.string.link */ "../node_modules/core-js/modules/es6.string.link.js");

__webpack_require__(/*! ./modules/es6.string.small */ "../node_modules/core-js/modules/es6.string.small.js");

__webpack_require__(/*! ./modules/es6.string.strike */ "../node_modules/core-js/modules/es6.string.strike.js");

__webpack_require__(/*! ./modules/es6.string.sub */ "../node_modules/core-js/modules/es6.string.sub.js");

__webpack_require__(/*! ./modules/es6.string.sup */ "../node_modules/core-js/modules/es6.string.sup.js");

__webpack_require__(/*! ./modules/es6.date.now */ "../node_modules/core-js/modules/es6.date.now.js");

__webpack_require__(/*! ./modules/es6.date.to-json */ "../node_modules/core-js/modules/es6.date.to-json.js");

__webpack_require__(/*! ./modules/es6.date.to-iso-string */ "../node_modules/core-js/modules/es6.date.to-iso-string.js");

__webpack_require__(/*! ./modules/es6.date.to-string */ "../node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__(/*! ./modules/es6.date.to-primitive */ "../node_modules/core-js/modules/es6.date.to-primitive.js");

__webpack_require__(/*! ./modules/es6.array.is-array */ "../node_modules/core-js/modules/es6.array.is-array.js");

__webpack_require__(/*! ./modules/es6.array.from */ "../node_modules/core-js/modules/es6.array.from.js");

__webpack_require__(/*! ./modules/es6.array.of */ "../node_modules/core-js/modules/es6.array.of.js");

__webpack_require__(/*! ./modules/es6.array.join */ "../node_modules/core-js/modules/es6.array.join.js");

__webpack_require__(/*! ./modules/es6.array.slice */ "../node_modules/core-js/modules/es6.array.slice.js");

__webpack_require__(/*! ./modules/es6.array.sort */ "../node_modules/core-js/modules/es6.array.sort.js");

__webpack_require__(/*! ./modules/es6.array.for-each */ "../node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__(/*! ./modules/es6.array.map */ "../node_modules/core-js/modules/es6.array.map.js");

__webpack_require__(/*! ./modules/es6.array.filter */ "../node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! ./modules/es6.array.some */ "../node_modules/core-js/modules/es6.array.some.js");

__webpack_require__(/*! ./modules/es6.array.every */ "../node_modules/core-js/modules/es6.array.every.js");

__webpack_require__(/*! ./modules/es6.array.reduce */ "../node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__(/*! ./modules/es6.array.reduce-right */ "../node_modules/core-js/modules/es6.array.reduce-right.js");

__webpack_require__(/*! ./modules/es6.array.index-of */ "../node_modules/core-js/modules/es6.array.index-of.js");

__webpack_require__(/*! ./modules/es6.array.last-index-of */ "../node_modules/core-js/modules/es6.array.last-index-of.js");

__webpack_require__(/*! ./modules/es6.array.copy-within */ "../node_modules/core-js/modules/es6.array.copy-within.js");

__webpack_require__(/*! ./modules/es6.array.fill */ "../node_modules/core-js/modules/es6.array.fill.js");

__webpack_require__(/*! ./modules/es6.array.find */ "../node_modules/core-js/modules/es6.array.find.js");

__webpack_require__(/*! ./modules/es6.array.find-index */ "../node_modules/core-js/modules/es6.array.find-index.js");

__webpack_require__(/*! ./modules/es6.array.species */ "../node_modules/core-js/modules/es6.array.species.js");

__webpack_require__(/*! ./modules/es6.array.iterator */ "../node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! ./modules/es6.regexp.constructor */ "../node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__(/*! ./modules/es6.regexp.exec */ "../node_modules/core-js/modules/es6.regexp.exec.js");

__webpack_require__(/*! ./modules/es6.regexp.to-string */ "../node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__(/*! ./modules/es6.regexp.flags */ "../node_modules/core-js/modules/es6.regexp.flags.js");

__webpack_require__(/*! ./modules/es6.regexp.match */ "../node_modules/core-js/modules/es6.regexp.match.js");

__webpack_require__(/*! ./modules/es6.regexp.replace */ "../node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! ./modules/es6.regexp.search */ "../node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__(/*! ./modules/es6.regexp.split */ "../node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! ./modules/es6.promise */ "../node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ./modules/es6.map */ "../node_modules/core-js/modules/es6.map.js");

__webpack_require__(/*! ./modules/es6.set */ "../node_modules/core-js/modules/es6.set.js");

__webpack_require__(/*! ./modules/es6.weak-map */ "../node_modules/core-js/modules/es6.weak-map.js");

__webpack_require__(/*! ./modules/es6.weak-set */ "../node_modules/core-js/modules/es6.weak-set.js");

__webpack_require__(/*! ./modules/es6.typed.array-buffer */ "../node_modules/core-js/modules/es6.typed.array-buffer.js");

__webpack_require__(/*! ./modules/es6.typed.data-view */ "../node_modules/core-js/modules/es6.typed.data-view.js");

__webpack_require__(/*! ./modules/es6.typed.int8-array */ "../node_modules/core-js/modules/es6.typed.int8-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint8-array */ "../node_modules/core-js/modules/es6.typed.uint8-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint8-clamped-array */ "../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");

__webpack_require__(/*! ./modules/es6.typed.int16-array */ "../node_modules/core-js/modules/es6.typed.int16-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint16-array */ "../node_modules/core-js/modules/es6.typed.uint16-array.js");

__webpack_require__(/*! ./modules/es6.typed.int32-array */ "../node_modules/core-js/modules/es6.typed.int32-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint32-array */ "../node_modules/core-js/modules/es6.typed.uint32-array.js");

__webpack_require__(/*! ./modules/es6.typed.float32-array */ "../node_modules/core-js/modules/es6.typed.float32-array.js");

__webpack_require__(/*! ./modules/es6.typed.float64-array */ "../node_modules/core-js/modules/es6.typed.float64-array.js");

__webpack_require__(/*! ./modules/es6.reflect.apply */ "../node_modules/core-js/modules/es6.reflect.apply.js");

__webpack_require__(/*! ./modules/es6.reflect.construct */ "../node_modules/core-js/modules/es6.reflect.construct.js");

__webpack_require__(/*! ./modules/es6.reflect.define-property */ "../node_modules/core-js/modules/es6.reflect.define-property.js");

__webpack_require__(/*! ./modules/es6.reflect.delete-property */ "../node_modules/core-js/modules/es6.reflect.delete-property.js");

__webpack_require__(/*! ./modules/es6.reflect.enumerate */ "../node_modules/core-js/modules/es6.reflect.enumerate.js");

__webpack_require__(/*! ./modules/es6.reflect.get */ "../node_modules/core-js/modules/es6.reflect.get.js");

__webpack_require__(/*! ./modules/es6.reflect.get-own-property-descriptor */ "../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");

__webpack_require__(/*! ./modules/es6.reflect.get-prototype-of */ "../node_modules/core-js/modules/es6.reflect.get-prototype-of.js");

__webpack_require__(/*! ./modules/es6.reflect.has */ "../node_modules/core-js/modules/es6.reflect.has.js");

__webpack_require__(/*! ./modules/es6.reflect.is-extensible */ "../node_modules/core-js/modules/es6.reflect.is-extensible.js");

__webpack_require__(/*! ./modules/es6.reflect.own-keys */ "../node_modules/core-js/modules/es6.reflect.own-keys.js");

__webpack_require__(/*! ./modules/es6.reflect.prevent-extensions */ "../node_modules/core-js/modules/es6.reflect.prevent-extensions.js");

__webpack_require__(/*! ./modules/es6.reflect.set */ "../node_modules/core-js/modules/es6.reflect.set.js");

__webpack_require__(/*! ./modules/es6.reflect.set-prototype-of */ "../node_modules/core-js/modules/es6.reflect.set-prototype-of.js");

__webpack_require__(/*! ./modules/es7.array.includes */ "../node_modules/core-js/modules/es7.array.includes.js");

__webpack_require__(/*! ./modules/es7.array.flat-map */ "../node_modules/core-js/modules/es7.array.flat-map.js");

__webpack_require__(/*! ./modules/es7.array.flatten */ "../node_modules/core-js/modules/es7.array.flatten.js");

__webpack_require__(/*! ./modules/es7.string.at */ "../node_modules/core-js/modules/es7.string.at.js");

__webpack_require__(/*! ./modules/es7.string.pad-start */ "../node_modules/core-js/modules/es7.string.pad-start.js");

__webpack_require__(/*! ./modules/es7.string.pad-end */ "../node_modules/core-js/modules/es7.string.pad-end.js");

__webpack_require__(/*! ./modules/es7.string.trim-left */ "../node_modules/core-js/modules/es7.string.trim-left.js");

__webpack_require__(/*! ./modules/es7.string.trim-right */ "../node_modules/core-js/modules/es7.string.trim-right.js");

__webpack_require__(/*! ./modules/es7.string.match-all */ "../node_modules/core-js/modules/es7.string.match-all.js");

__webpack_require__(/*! ./modules/es7.symbol.async-iterator */ "../node_modules/core-js/modules/es7.symbol.async-iterator.js");

__webpack_require__(/*! ./modules/es7.symbol.observable */ "../node_modules/core-js/modules/es7.symbol.observable.js");

__webpack_require__(/*! ./modules/es7.object.get-own-property-descriptors */ "../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");

__webpack_require__(/*! ./modules/es7.object.values */ "../node_modules/core-js/modules/es7.object.values.js");

__webpack_require__(/*! ./modules/es7.object.entries */ "../node_modules/core-js/modules/es7.object.entries.js");

__webpack_require__(/*! ./modules/es7.object.define-getter */ "../node_modules/core-js/modules/es7.object.define-getter.js");

__webpack_require__(/*! ./modules/es7.object.define-setter */ "../node_modules/core-js/modules/es7.object.define-setter.js");

__webpack_require__(/*! ./modules/es7.object.lookup-getter */ "../node_modules/core-js/modules/es7.object.lookup-getter.js");

__webpack_require__(/*! ./modules/es7.object.lookup-setter */ "../node_modules/core-js/modules/es7.object.lookup-setter.js");

__webpack_require__(/*! ./modules/es7.map.to-json */ "../node_modules/core-js/modules/es7.map.to-json.js");

__webpack_require__(/*! ./modules/es7.set.to-json */ "../node_modules/core-js/modules/es7.set.to-json.js");

__webpack_require__(/*! ./modules/es7.map.of */ "../node_modules/core-js/modules/es7.map.of.js");

__webpack_require__(/*! ./modules/es7.set.of */ "../node_modules/core-js/modules/es7.set.of.js");

__webpack_require__(/*! ./modules/es7.weak-map.of */ "../node_modules/core-js/modules/es7.weak-map.of.js");

__webpack_require__(/*! ./modules/es7.weak-set.of */ "../node_modules/core-js/modules/es7.weak-set.of.js");

__webpack_require__(/*! ./modules/es7.map.from */ "../node_modules/core-js/modules/es7.map.from.js");

__webpack_require__(/*! ./modules/es7.set.from */ "../node_modules/core-js/modules/es7.set.from.js");

__webpack_require__(/*! ./modules/es7.weak-map.from */ "../node_modules/core-js/modules/es7.weak-map.from.js");

__webpack_require__(/*! ./modules/es7.weak-set.from */ "../node_modules/core-js/modules/es7.weak-set.from.js");

__webpack_require__(/*! ./modules/es7.global */ "../node_modules/core-js/modules/es7.global.js");

__webpack_require__(/*! ./modules/es7.system.global */ "../node_modules/core-js/modules/es7.system.global.js");

__webpack_require__(/*! ./modules/es7.error.is-error */ "../node_modules/core-js/modules/es7.error.is-error.js");

__webpack_require__(/*! ./modules/es7.math.clamp */ "../node_modules/core-js/modules/es7.math.clamp.js");

__webpack_require__(/*! ./modules/es7.math.deg-per-rad */ "../node_modules/core-js/modules/es7.math.deg-per-rad.js");

__webpack_require__(/*! ./modules/es7.math.degrees */ "../node_modules/core-js/modules/es7.math.degrees.js");

__webpack_require__(/*! ./modules/es7.math.fscale */ "../node_modules/core-js/modules/es7.math.fscale.js");

__webpack_require__(/*! ./modules/es7.math.iaddh */ "../node_modules/core-js/modules/es7.math.iaddh.js");

__webpack_require__(/*! ./modules/es7.math.isubh */ "../node_modules/core-js/modules/es7.math.isubh.js");

__webpack_require__(/*! ./modules/es7.math.imulh */ "../node_modules/core-js/modules/es7.math.imulh.js");

__webpack_require__(/*! ./modules/es7.math.rad-per-deg */ "../node_modules/core-js/modules/es7.math.rad-per-deg.js");

__webpack_require__(/*! ./modules/es7.math.radians */ "../node_modules/core-js/modules/es7.math.radians.js");

__webpack_require__(/*! ./modules/es7.math.scale */ "../node_modules/core-js/modules/es7.math.scale.js");

__webpack_require__(/*! ./modules/es7.math.umulh */ "../node_modules/core-js/modules/es7.math.umulh.js");

__webpack_require__(/*! ./modules/es7.math.signbit */ "../node_modules/core-js/modules/es7.math.signbit.js");

__webpack_require__(/*! ./modules/es7.promise.finally */ "../node_modules/core-js/modules/es7.promise.finally.js");

__webpack_require__(/*! ./modules/es7.promise.try */ "../node_modules/core-js/modules/es7.promise.try.js");

__webpack_require__(/*! ./modules/es7.reflect.define-metadata */ "../node_modules/core-js/modules/es7.reflect.define-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.delete-metadata */ "../node_modules/core-js/modules/es7.reflect.delete-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-metadata */ "../node_modules/core-js/modules/es7.reflect.get-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-metadata-keys */ "../node_modules/core-js/modules/es7.reflect.get-metadata-keys.js");

__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata */ "../node_modules/core-js/modules/es7.reflect.get-own-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata-keys */ "../node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js");

__webpack_require__(/*! ./modules/es7.reflect.has-metadata */ "../node_modules/core-js/modules/es7.reflect.has-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.has-own-metadata */ "../node_modules/core-js/modules/es7.reflect.has-own-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.metadata */ "../node_modules/core-js/modules/es7.reflect.metadata.js");

__webpack_require__(/*! ./modules/es7.asap */ "../node_modules/core-js/modules/es7.asap.js");

__webpack_require__(/*! ./modules/es7.observable */ "../node_modules/core-js/modules/es7.observable.js");

__webpack_require__(/*! ./modules/web.timers */ "../node_modules/core-js/modules/web.timers.js");

__webpack_require__(/*! ./modules/web.immediate */ "../node_modules/core-js/modules/web.immediate.js");

__webpack_require__(/*! ./modules/web.dom.iterable */ "../node_modules/core-js/modules/web.dom.iterable.js");

module.exports = __webpack_require__(/*! ./modules/_core */ "../node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "../node_modules/firebase/app/dist/index.cjs.js":
/*!******************************************************!*\
  !*** ../node_modules/firebase/app/dist/index.cjs.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var firebase = _interopDefault(__webpack_require__(/*! @firebase/app */ "../node_modules/@firebase/app/dist/index.cjs.js"));
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


module.exports = firebase;

/***/ }),

/***/ "../node_modules/firebase/database/dist/index.esm.js":
/*!***********************************************************!*\
  !*** ../node_modules/firebase/database/dist/index.esm.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/database */ "../node_modules/@firebase/database/dist/index.cjs.js");
/* harmony import */ var _firebase_database__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_firebase_database__WEBPACK_IMPORTED_MODULE_0__);

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/***/ }),

/***/ "../node_modules/lodash/_DataView.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_DataView.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;

/***/ }),

/***/ "../node_modules/lodash/_Hash.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/_Hash.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "../node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "../node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "../node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "../node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "../node_modules/lodash/_hashSet.js");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),

/***/ "../node_modules/lodash/_ListCache.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_ListCache.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "../node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "../node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "../node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "../node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "../node_modules/lodash/_listCacheSet.js");
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),

/***/ "../node_modules/lodash/_Map.js":
/*!**************************************!*\
  !*** ../node_modules/lodash/_Map.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),

/***/ "../node_modules/lodash/_MapCache.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_MapCache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "../node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "../node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "../node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "../node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "../node_modules/lodash/_mapCacheSet.js");
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),

/***/ "../node_modules/lodash/_Promise.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_Promise.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;

/***/ }),

/***/ "../node_modules/lodash/_Set.js":
/*!**************************************!*\
  !*** ../node_modules/lodash/_Set.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;

/***/ }),

/***/ "../node_modules/lodash/_Stack.js":
/*!****************************************!*\
  !*** ../node_modules/lodash/_Stack.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "../node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "../node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "../node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "../node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "../node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "../node_modules/lodash/_stackSet.js");
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),

/***/ "../node_modules/lodash/_Symbol.js":
/*!*****************************************!*\
  !*** ../node_modules/lodash/_Symbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");
/** Built-in value references. */


var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),

/***/ "../node_modules/lodash/_Uint8Array.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_Uint8Array.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),

/***/ "../node_modules/lodash/_WeakMap.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_WeakMap.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;

/***/ }),

/***/ "../node_modules/lodash/_arrayEach.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_arrayEach.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

/***/ }),

/***/ "../node_modules/lodash/_arrayFilter.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_arrayFilter.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;

/***/ }),

/***/ "../node_modules/lodash/_arrayLikeKeys.js":
/*!************************************************!*\
  !*** ../node_modules/lodash/_arrayLikeKeys.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "../node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "../node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "../node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "../node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "../node_modules/lodash/isTypedArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),

/***/ "../node_modules/lodash/_arrayPush.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_arrayPush.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),

/***/ "../node_modules/lodash/_assignValue.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_assignValue.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "../node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "../node_modules/lodash/eq.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),

/***/ "../node_modules/lodash/_assocIndexOf.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_assocIndexOf.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "../node_modules/lodash/eq.js");
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),

/***/ "../node_modules/lodash/_baseAssign.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_baseAssign.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "../node_modules/lodash/keys.js");
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

/***/ }),

/***/ "../node_modules/lodash/_baseAssignIn.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_baseAssignIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "../node_modules/lodash/keysIn.js");
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

/***/ }),

/***/ "../node_modules/lodash/_baseAssignValue.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/_baseAssignValue.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "../node_modules/lodash/_defineProperty.js");
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),

/***/ "../node_modules/lodash/_baseClone.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_baseClone.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "../node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "../node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "../node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "../node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "../node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "../node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "../node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "../node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "../node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "../node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "../node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "../node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "../node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "../node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "../node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "../node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "../node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "../node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "../node_modules/lodash/keys.js");
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
    return result;
  }

  if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

/***/ }),

/***/ "../node_modules/lodash/_baseCreate.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_baseCreate.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js");
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),

/***/ "../node_modules/lodash/_baseGetAllKeys.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_baseGetAllKeys.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "../node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../node_modules/lodash/isArray.js");
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),

/***/ "../node_modules/lodash/_baseGetTag.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_baseGetTag.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "../node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "../node_modules/lodash/_objectToString.js");
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ "../node_modules/lodash/_baseIsArguments.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/_baseIsArguments.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),

/***/ "../node_modules/lodash/_baseIsMap.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_baseIsMap.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "../node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

/***/ }),

/***/ "../node_modules/lodash/_baseIsNative.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_baseIsNative.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "../node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "../node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "../node_modules/lodash/_toSource.js");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),

/***/ "../node_modules/lodash/_baseIsSet.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_baseIsSet.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "../node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

/***/ }),

/***/ "../node_modules/lodash/_baseIsTypedArray.js":
/*!***************************************************!*\
  !*** ../node_modules/lodash/_baseIsTypedArray.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "../node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),

/***/ "../node_modules/lodash/_baseKeys.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_baseKeys.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "../node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "../node_modules/lodash/_nativeKeys.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),

/***/ "../node_modules/lodash/_baseKeysIn.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_baseKeysIn.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "../node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "../node_modules/lodash/_nativeKeysIn.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),

/***/ "../node_modules/lodash/_baseTimes.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_baseTimes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),

/***/ "../node_modules/lodash/_baseUnary.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_baseUnary.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),

/***/ "../node_modules/lodash/_cloneArrayBuffer.js":
/*!***************************************************!*\
  !*** ../node_modules/lodash/_cloneArrayBuffer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "../node_modules/lodash/_Uint8Array.js");
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),

/***/ "../node_modules/lodash/_cloneBuffer.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_cloneBuffer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../node_modules/lodash/_cloneDataView.js":
/*!************************************************!*\
  !*** ../node_modules/lodash/_cloneDataView.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "../node_modules/lodash/_cloneArrayBuffer.js");
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

/***/ }),

/***/ "../node_modules/lodash/_cloneRegExp.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_cloneRegExp.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

/***/ }),

/***/ "../node_modules/lodash/_cloneSymbol.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_cloneSymbol.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../node_modules/lodash/_Symbol.js");
/** Used to convert symbols to primitives and strings. */


var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

/***/ }),

/***/ "../node_modules/lodash/_cloneTypedArray.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/_cloneTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "../node_modules/lodash/_cloneArrayBuffer.js");
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),

/***/ "../node_modules/lodash/_copyArray.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_copyArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),

/***/ "../node_modules/lodash/_copyObject.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_copyObject.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "../node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "../node_modules/lodash/_baseAssignValue.js");
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),

/***/ "../node_modules/lodash/_copySymbols.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_copySymbols.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "../node_modules/lodash/_getSymbols.js");
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

/***/ }),

/***/ "../node_modules/lodash/_copySymbolsIn.js":
/*!************************************************!*\
  !*** ../node_modules/lodash/_copySymbolsIn.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "../node_modules/lodash/_getSymbolsIn.js");
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

/***/ }),

/***/ "../node_modules/lodash/_coreJsData.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_coreJsData.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),

/***/ "../node_modules/lodash/_defineProperty.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_defineProperty.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "../node_modules/lodash/_getNative.js");

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),

/***/ "../node_modules/lodash/_freeGlobal.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_freeGlobal.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/lodash/_getAllKeys.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_getAllKeys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "../node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "../node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "../node_modules/lodash/keys.js");
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),

/***/ "../node_modules/lodash/_getAllKeysIn.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_getAllKeysIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "../node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "../node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "../node_modules/lodash/keysIn.js");
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

/***/ }),

/***/ "../node_modules/lodash/_getMapData.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_getMapData.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "../node_modules/lodash/_isKeyable.js");
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),

/***/ "../node_modules/lodash/_getNative.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_getNative.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "../node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "../node_modules/lodash/_getValue.js");
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),

/***/ "../node_modules/lodash/_getPrototype.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_getPrototype.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "../node_modules/lodash/_overArg.js");
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),

/***/ "../node_modules/lodash/_getRawTag.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_getRawTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../node_modules/lodash/_Symbol.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ "../node_modules/lodash/_getSymbols.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_getSymbols.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "../node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "../node_modules/lodash/stubArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;

/***/ }),

/***/ "../node_modules/lodash/_getSymbolsIn.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_getSymbolsIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "../node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "../node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "../node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "../node_modules/lodash/stubArray.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
module.exports = getSymbolsIn;

/***/ }),

/***/ "../node_modules/lodash/_getTag.js":
/*!*****************************************!*\
  !*** ../node_modules/lodash/_getTag.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "../node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "../node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "../node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "../node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "../node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "../node_modules/lodash/_toSource.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;

/***/ }),

/***/ "../node_modules/lodash/_getValue.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_getValue.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),

/***/ "../node_modules/lodash/_hashClear.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_hashClear.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../node_modules/lodash/_nativeCreate.js");
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),

/***/ "../node_modules/lodash/_hashDelete.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_hashDelete.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),

/***/ "../node_modules/lodash/_hashGet.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_hashGet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),

/***/ "../node_modules/lodash/_hashHas.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_hashHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../node_modules/lodash/_nativeCreate.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),

/***/ "../node_modules/lodash/_hashSet.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_hashSet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),

/***/ "../node_modules/lodash/_initCloneArray.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_initCloneArray.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

module.exports = initCloneArray;

/***/ }),

/***/ "../node_modules/lodash/_initCloneByTag.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_initCloneByTag.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "../node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "../node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "../node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "../node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "../node_modules/lodash/_cloneTypedArray.js");
/** `Object#toString` result references. */


var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

/***/ }),

/***/ "../node_modules/lodash/_initCloneObject.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/_initCloneObject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "../node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "../node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "../node_modules/lodash/_isPrototype.js");
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),

/***/ "../node_modules/lodash/_isIndex.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_isIndex.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),

/***/ "../node_modules/lodash/_isKeyable.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_isKeyable.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),

/***/ "../node_modules/lodash/_isMasked.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_isMasked.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "../node_modules/lodash/_coreJsData.js");
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),

/***/ "../node_modules/lodash/_isPrototype.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_isPrototype.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),

/***/ "../node_modules/lodash/_listCacheClear.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_listCacheClear.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),

/***/ "../node_modules/lodash/_listCacheDelete.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/_listCacheDelete.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../node_modules/lodash/_assocIndexOf.js");
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),

/***/ "../node_modules/lodash/_listCacheGet.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_listCacheGet.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../node_modules/lodash/_assocIndexOf.js");
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),

/***/ "../node_modules/lodash/_listCacheHas.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_listCacheHas.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../node_modules/lodash/_assocIndexOf.js");
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),

/***/ "../node_modules/lodash/_listCacheSet.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_listCacheSet.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../node_modules/lodash/_assocIndexOf.js");
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),

/***/ "../node_modules/lodash/_mapCacheClear.js":
/*!************************************************!*\
  !*** ../node_modules/lodash/_mapCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "../node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "../node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "../node_modules/lodash/_Map.js");
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),

/***/ "../node_modules/lodash/_mapCacheDelete.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_mapCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../node_modules/lodash/_getMapData.js");
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),

/***/ "../node_modules/lodash/_mapCacheGet.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_mapCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../node_modules/lodash/_getMapData.js");
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),

/***/ "../node_modules/lodash/_mapCacheHas.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_mapCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../node_modules/lodash/_getMapData.js");
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),

/***/ "../node_modules/lodash/_mapCacheSet.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_mapCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../node_modules/lodash/_getMapData.js");
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),

/***/ "../node_modules/lodash/_nativeCreate.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_nativeCreate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "../node_modules/lodash/_getNative.js");
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),

/***/ "../node_modules/lodash/_nativeKeys.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_nativeKeys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "../node_modules/lodash/_overArg.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),

/***/ "../node_modules/lodash/_nativeKeysIn.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_nativeKeysIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),

/***/ "../node_modules/lodash/_nodeUtil.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_nodeUtil.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "../node_modules/lodash/_freeGlobal.js");
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../node_modules/lodash/_objectToString.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_objectToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ "../node_modules/lodash/_overArg.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_overArg.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),

/***/ "../node_modules/lodash/_root.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/_root.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "../node_modules/lodash/_freeGlobal.js");
/** Detect free variable `self`. */


var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ "../node_modules/lodash/_stackClear.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_stackClear.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "../node_modules/lodash/_ListCache.js");
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),

/***/ "../node_modules/lodash/_stackDelete.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_stackDelete.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),

/***/ "../node_modules/lodash/_stackGet.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_stackGet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),

/***/ "../node_modules/lodash/_stackHas.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_stackHas.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),

/***/ "../node_modules/lodash/_stackSet.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_stackSet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "../node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "../node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "../node_modules/lodash/_MapCache.js");
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),

/***/ "../node_modules/lodash/_toSource.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_toSource.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),

/***/ "../node_modules/lodash/cloneDeep.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/cloneDeep.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(/*! ./_baseClone */ "../node_modules/lodash/_baseClone.js");
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */

function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

/***/ }),

/***/ "../node_modules/lodash/eq.js":
/*!************************************!*\
  !*** ../node_modules/lodash/eq.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),

/***/ "../node_modules/lodash/isArguments.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/isArguments.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "../node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../node_modules/lodash/isObjectLike.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),

/***/ "../node_modules/lodash/isArray.js":
/*!*****************************************!*\
  !*** ../node_modules/lodash/isArray.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),

/***/ "../node_modules/lodash/isArrayLike.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/isArrayLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "../node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "../node_modules/lodash/isLength.js");
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),

/***/ "../node_modules/lodash/isBuffer.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isBuffer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "../node_modules/lodash/stubFalse.js");
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../node_modules/lodash/isFunction.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/isFunction.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js");
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),

/***/ "../node_modules/lodash/isLength.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isLength.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),

/***/ "../node_modules/lodash/isMap.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/isMap.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "../node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "../node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "../node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;

/***/ }),

/***/ "../node_modules/lodash/isObject.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isObject.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ "../node_modules/lodash/isObjectLike.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/isObjectLike.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ "../node_modules/lodash/isSet.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/isSet.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "../node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "../node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "../node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;

/***/ }),

/***/ "../node_modules/lodash/isTypedArray.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/isTypedArray.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "../node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "../node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "../node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),

/***/ "../node_modules/lodash/keys.js":
/*!**************************************!*\
  !*** ../node_modules/lodash/keys.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "../node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "../node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "../node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),

/***/ "../node_modules/lodash/keysIn.js":
/*!****************************************!*\
  !*** ../node_modules/lodash/keysIn.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "../node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "../node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "../node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),

/***/ "../node_modules/lodash/stubArray.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/stubArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),

/***/ "../node_modules/lodash/stubFalse.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/stubFalse.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),

/***/ "../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../node_modules/sass-loader/lib/loader.js?!../node_modules/normalize.css/normalize.css":
/*!************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/dist/cjs.js??ref--5-2!../node_modules/postcss-loader/src??ref--5-3!../node_modules/sass-loader/lib/loader.js??ref--5-4!../node_modules/normalize.css/normalize.css ***!
  \************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../node_modules/sass-loader/lib/loader.js?!./js/components/users/scss/index.scss":
/*!******************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/dist/cjs.js??ref--7-2!../node_modules/postcss-loader/src??ref--7-3!../node_modules/sass-loader/lib/loader.js??ref--7-4!./js/components/users/scss/index.scss ***!
  \******************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "../node_modules/normalize.css/normalize.css":
/*!***************************************************!*\
  !*** ../node_modules/normalize.css/normalize.css ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../mini-css-extract-plugin/dist/loader.js!../css-loader/dist/cjs.js??ref--5-2!../postcss-loader/src??ref--5-3!../sass-loader/lib/loader.js??ref--5-4!./normalize.css */ "../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../node_modules/sass-loader/lib/loader.js?!../node_modules/normalize.css/normalize.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../style-loader/lib/addStyles.js */ "../node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "../node_modules/popper.js/dist/esm/popper.js":
/*!****************************************************!*\
  !*** ../node_modules/popper.js/dist/esm/popper.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.15.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;

for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }

    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/

var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */

function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */


function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  } // NOTE: 1 DOM access here


  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */


function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }

  return element.parentNode || element.host;
}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */


function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;

    case '#document':
      return element.body;
  } // Firefox want us to check `-x` and `-y` variations as well


  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */

function isIE(version) {
  if (version === 11) {
    return isIE11;
  }

  if (version === 10) {
    return isIE10;
  }

  return isIE11 || isIE10;
}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */


function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  } // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...


  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }

  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */


function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */


function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  } // Here we make sure to give as "start" the element that comes first in the DOM


  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1; // Get common ancestor container

  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  } // one of the nodes is inside shadowDOM, find which one


  var element1root = getRoot(element1);

  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */


function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */


function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */


function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */


function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */


function getBoundingClientRect(element) {
  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11

  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  }; // subtract scrollbar size from sizes

  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons

  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.

  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };
  return getClientRect(offset);
}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */


function isFixed(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }

  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }

  var parentNode = getParentNode(element);

  if (!parentNode) {
    return false;
  }

  return isFixed(parentNode);
}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */


function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }

  var el = element.parentElement;

  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }

  return el || document.documentElement;
}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */


function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

  var boundaries = {
    top: 0,
    left: 0
  };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference); // Handle viewport case

  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;

    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));

      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  } // Add paddings


  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;
  return width * height;
}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split('-')[1];
  return computedPlacement + (variation ? '-' + variation : '');
}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */


function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */


function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */


function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */


function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0]; // Get popper node sizes

  var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  }; // depending by the popper placement we have to compute its offsets slightly differently

  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  } // use `filter` to obtain the same behavior of `find`


  return arr.filter(check)[0];
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  } // use `find` + `indexOf` if `findIndex` isn't supported


  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */


function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }

    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */


function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  }; // compute reference element offsets

  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed; // compute the popper offsets

  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

  data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback

  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */


function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */


function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;

    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }

  return null;
}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */


function destroy() {
  this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners(); // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it

  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }

  return this;
}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */


function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, {
    passive: true
  });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }

  scrollParents.push(target);
}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, {
    passive: true
  }); // Scroll event listener on scroll parents

  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */


function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  }); // Reset state

  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */


function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */


function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = ''; // add unit if the value is numeric and is one of the following

    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }

    element.style[prop] = styles[prop] + unit;
  });
}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];

    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */


function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element

  setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */


function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations

  setStyles(popper, {
    position: options.positionFixed ? 'fixed' : 'absolute'
  });
  return options;
}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */


function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;

  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }

  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed

  var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.

  var left = void 0,
      top = void 0;

  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }

  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }

  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  } // Attributes


  var attributes = {
    'x-placement': data.placement
  }; // Update `data` attributes, styles and arrowStyles

  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */


function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';

    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }

  return isRequired;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function arrow(data, options) {
  var _data$offsets$arrow; // arrow depends on keepTogether in order to work


  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len]; //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //
  // top/left side

  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  } // bottom/right side


  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available

  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
  return data;
}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */


function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }

  return variation;
}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */


var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

var validPlacements = placements.slice(3);
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */

function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;

    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;

    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;

    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future

      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }

  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */


function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2]; // If it's not a number it's an operator, I guess

  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;

    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;

      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;

    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }

    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */


function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one

  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  }); // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space

  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  } // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.


  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []) // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  }); // Loop trough the offsets arrays and execute the operations

  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */


function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var basePlacement = placement.split('-')[0];
  var offsets = void 0;

  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken

  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  } // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself


  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification

  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];
  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed

  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];

      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }

      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];

      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }

      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;
    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */


var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: offset,

    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: preventOverflow,

    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],

    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: arrow,

    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: flip,

    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',

    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',

    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,

    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,

    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,

    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: computeStyle,

    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,

    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',

    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: applyStyle,

    /** @prop {Function} */
    onLoad: applyStyleOnLoad,

    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */

var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};
/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */
// Utils
// Methods

var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    }; // make update() debounced, so that it only runs at most once-per-tick


    this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it

    this.options = _extends({}, Popper.Defaults, options); // init state

    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    }; // get reference and popper elements (allow jQuery wrappers)

    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    }); // Refactoring modifiers' list (Object => Array)

    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    }) // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    }); // fire the first update to position the popper in the right place

    this.update();
    var eventsEnabled = this.options.eventsEnabled;

    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  } // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */

    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
/* harmony default export */ __webpack_exports__["default"] = (Popper);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "../node_modules/regenerator-runtime/runtime.js":
/*!******************************************************!*\
  !*** ../node_modules/regenerator-runtime/runtime.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */
!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    } // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.


    return;
  } // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.


  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}( // Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/style-loader/lib/addStyles.js":
/*!*****************************************************!*\
  !*** ../node_modules/style-loader/lib/addStyles.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "../node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "../node_modules/style-loader/lib/urls.js":
/*!************************************************!*\
  !*** ../node_modules/style-loader/lib/urls.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),

/***/ "../node_modules/tippy.js/esm/index.all.js":
/*!*************************************************!*\
  !*** ../node_modules/tippy.js/esm/index.all.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! popper.js */ "../node_modules/popper.js/dist/esm/popper.js");
/**!
* tippy.js v4.3.4
* (c) 2017-2019 atomiks
* MIT License
*/

var css = ".tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px) rotateX(0);transform:perspective(700px) translateY(-10px) rotateX(0)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateY(0) rotateX(60deg);transform:perspective(700px) translateY(0) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px) scale(1);transform:translateY(-10px) scale(1)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(0);transform:rotate(0)}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px) rotateX(0);transform:perspective(700px) translateY(10px) rotateX(0)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateY(0) rotateX(-60deg);transform:perspective(700px) translateY(0) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px) scale(1);transform:translateY(10px) scale(1)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px) rotateY(0);transform:perspective(700px) translateX(-10px) rotateY(0)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateX(0) rotateY(-60deg);transform:perspective(700px) translateX(0) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px) scale(1);transform:translateX(-10px) scale(1)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px) rotateY(0);transform:perspective(700px) translateX(10px) rotateY(0)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateX(0) rotateY(60deg);transform:perspective(700px) translateX(0) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px) scale(1);transform:translateX(10px) scale(1)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:transparent}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] .tippy-roundarrow path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:\"\";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=visible]{opacity:1}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}";

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var version = "4.3.4";
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var ua = isBrowser ? navigator.userAgent : '';
var isIE = /MSIE |Trident\//.test(ua);
var isUCBrowser = /UCBrowser\//.test(ua);
var isIOS = isBrowser && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;
var defaultProps = {
  a11y: true,
  allowHTML: true,
  animateFill: true,
  animation: 'shift-away',
  appendTo: function appendTo() {
    return document.body;
  },
  aria: 'describedby',
  arrow: false,
  arrowType: 'sharp',
  boundary: 'scrollParent',
  content: '',
  delay: 0,
  distance: 10,
  duration: [325, 275],
  flip: true,
  flipBehavior: 'flip',
  flipOnUpdate: false,
  followCursor: false,
  hideOnClick: true,
  ignoreAttributes: false,
  inertia: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  lazy: true,
  maxWidth: 350,
  multiple: false,
  offset: 0,
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  placement: 'top',
  popperOptions: {},
  role: 'tooltip',
  showOnInit: false,
  size: 'regular',
  sticky: false,
  target: '',
  theme: 'dark',
  touch: true,
  touchHold: false,
  trigger: 'mouseenter focus',
  triggerTarget: null,
  updateDuration: 0,
  wait: null,
  zIndex: 9999
  /**
   * If the set() method encounters one of these, the popperInstance must be
   * recreated
   */

};
var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'arrowType', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];
var elementProto = isBrowser ? Element.prototype : {};
var matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;
/**
 * Ponyfill for Array.from - converts iterable values to an array
 */

function arrayFrom(value) {
  return [].slice.call(value);
}
/**
 * Ponyfill for Element.prototype.closest
 */


function closest(element, selector) {
  return closestCallback(element, function (el) {
    return matches.call(el, selector);
  });
}
/**
 * Works like Element.prototype.closest, but uses a callback instead
 */


function closestCallback(element, callback) {
  while (element) {
    if (callback(element)) {
      return element;
    }

    element = element.parentElement;
  }

  return null;
} // Passive event listener config


var PASSIVE = {
  passive: true // Popper `preventOverflow` padding

};
var PADDING = 4; // Popper attributes
// In Popper v2 these will be `data-*` instead of `x-*` to adhere to HTML5 spec

var PLACEMENT_ATTRIBUTE = 'x-placement';
var OUT_OF_BOUNDARIES_ATTRIBUTE = 'x-out-of-boundaries'; // Classes

var IOS_CLASS = "tippy-iOS";
var ACTIVE_CLASS = "tippy-active";
var POPPER_CLASS = "tippy-popper";
var TOOLTIP_CLASS = "tippy-tooltip";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var ROUND_ARROW_CLASS = "tippy-roundarrow"; // Selectors

var POPPER_SELECTOR = ".".concat(POPPER_CLASS);
var TOOLTIP_SELECTOR = ".".concat(TOOLTIP_CLASS);
var CONTENT_SELECTOR = ".".concat(CONTENT_CLASS);
var BACKDROP_SELECTOR = ".".concat(BACKDROP_CLASS);
var ARROW_SELECTOR = ".".concat(ARROW_CLASS);
var ROUND_ARROW_SELECTOR = ".".concat(ROUND_ARROW_CLASS);
var isUsingTouch = false;

function onDocumentTouch() {
  if (isUsingTouch) {
    return;
  }

  isUsingTouch = true;

  if (isIOS) {
    document.body.classList.add(IOS_CLASS);
  }

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}

var lastMouseMoveTime = 0;

function onDocumentMouseMove() {
  var now = performance.now(); // Chrome 60+ is 1 mousemove per animation frame, use 20ms time difference

  if (now - lastMouseMoveTime < 20) {
    isUsingTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);

    if (!isIOS) {
      document.body.classList.remove(IOS_CLASS);
    }
  }

  lastMouseMoveTime = now;
}

function onWindowBlur() {
  var _document = document,
      activeElement = _document.activeElement;

  if (activeElement && activeElement.blur && activeElement._tippy) {
    activeElement.blur();
  }
}
/**
 * Adds the needed global event listeners
 */


function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouch, PASSIVE);
  window.addEventListener('blur', onWindowBlur);
}

var keys = Object.keys(defaultProps);
/**
 * Returns an object of optional props from data-tippy-* attributes
 */

function getDataAttributeOptions(reference) {
  return keys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
}
/**
 * Polyfills the virtual reference (plain object) with Element.prototype props
 * Mutating because DOM elements are mutated, adds `_tippy` property
 */


function polyfillElementPrototypeProperties(virtualReference) {
  var polyfills = {
    isVirtual: true,
    attributes: virtualReference.attributes || {},
    contains: function contains() {},
    setAttribute: function setAttribute(key, value) {
      virtualReference.attributes[key] = value;
    },
    getAttribute: function getAttribute(key) {
      return virtualReference.attributes[key];
    },
    removeAttribute: function removeAttribute(key) {
      delete virtualReference.attributes[key];
    },
    hasAttribute: function hasAttribute(key) {
      return key in virtualReference.attributes;
    },
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    classList: {
      classNames: {},
      add: function add(key) {
        virtualReference.classList.classNames[key] = true;
      },
      remove: function remove(key) {
        delete virtualReference.classList.classNames[key];
      },
      contains: function contains(key) {
        return key in virtualReference.classList.classNames;
      }
    }
  };

  for (var key in polyfills) {
    virtualReference[key] = polyfills[key];
  }
}
/**
 * Determines if a value is a "bare" virtual element (before mutations done
 * by `polyfillElementPrototypeProperties()`). JSDOM elements show up as
 * [object Object], we can check if the value is "element-like" if it has
 * `addEventListener`
 */


function isBareVirtualElement(value) {
  return {}.toString.call(value) === '[object Object]' && !value.addEventListener;
}
/**
 * Determines if the value is a reference element
 */


function isReferenceElement(value) {
  return !!value._tippy && !matches.call(value, POPPER_SELECTOR);
}
/**
 * Safe .hasOwnProperty check, for prototype-less objects
 */


function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
/**
 * Returns an array of elements based on the value
 */


function getArrayOfElements(value) {
  if (isSingular(value)) {
    // TODO: VirtualReference is not compatible to type Element
    return [value];
  }

  if (value instanceof NodeList) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  try {
    return arrayFrom(document.querySelectorAll(value));
  } catch (e) {
    return [];
  }
}
/**
 * Returns a value at a given index depending on if it's an array or number
 */


function getValue(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? defaultValue : v;
  }

  return value;
}
/**
 * Debounce utility. To avoid bloating bundle size, we're only passing 1
 * argument here, a more generic function would pass all arguments. Only
 * `onMouseMove` uses this which takes the event object for now.
 */


function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }

  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
/**
 * Prevents errors from being thrown while accessing nested modifier objects
 * in `popperOptions`
 */


function getModifier(obj, key) {
  return obj && obj.modifiers && obj.modifiers[key];
}
/**
 * Determines if an array or string includes a value
 */


function includes(a, b) {
  return a.indexOf(b) > -1;
}
/**
 * Determines if the value is a real element
 */


function isRealElement(value) {
  return value instanceof Element;
}
/**
 * Determines if the value is singular-like
 */


function isSingular(value) {
  return !!(value && hasOwnProperty(value, 'isVirtual')) || isRealElement(value);
}
/**
 * Firefox extensions don't allow setting .innerHTML directly, this will trick it
 */


function innerHTML() {
  return 'innerHTML';
}
/**
 * Evaluates a function if one, or returns the value
 */


function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(null, args) : value;
}
/**
 * Sets a popperInstance `flip` modifier's enabled state
 */


function setFlipModifierEnabled(modifiers, value) {
  modifiers.filter(function (m) {
    return m.name === 'flip';
  })[0].enabled = value;
}
/**
 * Determines if an element can receive focus
 * Always returns true for virtual objects
 */


function canReceiveFocus(element) {
  return isRealElement(element) ? matches.call(element, 'a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]') && !element.hasAttribute('disabled') : true;
}
/**
 * Returns a new `div` element
 */


function div() {
  return document.createElement('div');
}
/**
 * Applies a transition duration to a list of elements
 */


function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = "".concat(value, "ms");
    }
  });
}
/**
 * Sets the visibility state to elements so they can begin to transition
 */


function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
/**
 * Evaluates the props object by merging data attributes and
 * disabling conflicting options where necessary
 */


function evaluateProps(reference, props) {
  var out = _extends({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));

  if (out.arrow || isUCBrowser) {
    out.animateFill = false;
  }

  return out;
}
/**
 * Validates an object of options with the valid default props object
 */


function validateOptions(options, defaultProps) {
  Object.keys(options).forEach(function (option) {
    if (!hasOwnProperty(defaultProps, option)) {
      throw new Error("[tippy]: `".concat(option, "` is not a valid option"));
    }
  });
}
/**
 * Sets the innerHTML of an element
 */


function setInnerHTML(element, html) {
  element[innerHTML()] = isRealElement(html) ? html[innerHTML()] : html;
}
/**
 * Sets the content of a tooltip
 */


function setContent(contentEl, props) {
  if (isRealElement(props.content)) {
    setInnerHTML(contentEl, '');
    contentEl.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    var key = props.allowHTML ? 'innerHTML' : 'textContent';
    contentEl[key] = props.content;
  }
}
/**
 * Returns the child elements of a popper element
 */


function getChildren(popper) {
  return {
    tooltip: popper.querySelector(TOOLTIP_SELECTOR),
    backdrop: popper.querySelector(BACKDROP_SELECTOR),
    content: popper.querySelector(CONTENT_SELECTOR),
    arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(ROUND_ARROW_SELECTOR)
  };
}
/**
 * Adds `data-inertia` attribute
 */


function addInertia(tooltip) {
  tooltip.setAttribute('data-inertia', '');
}
/**
 * Removes `data-inertia` attribute
 */


function removeInertia(tooltip) {
  tooltip.removeAttribute('data-inertia');
}
/**
 * Creates an arrow element and returns it
 */


function createArrowElement(arrowType) {
  var arrow = div();

  if (arrowType === 'round') {
    arrow.className = ROUND_ARROW_CLASS;
    setInnerHTML(arrow, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>');
  } else {
    arrow.className = ARROW_CLASS;
  }

  return arrow;
}
/**
 * Creates a backdrop element and returns it
 */


function createBackdropElement() {
  var backdrop = div();
  backdrop.className = BACKDROP_CLASS;
  backdrop.setAttribute('data-state', 'hidden');
  return backdrop;
}
/**
 * Adds interactive-related attributes
 */


function addInteractive(popper, tooltip) {
  popper.setAttribute('tabindex', '-1');
  tooltip.setAttribute('data-interactive', '');
}
/**
 * Removes interactive-related attributes
 */


function removeInteractive(popper, tooltip) {
  popper.removeAttribute('tabindex');
  tooltip.removeAttribute('data-interactive');
}
/**
 * Add/remove transitionend listener from tooltip
 */


function updateTransitionEndListener(tooltip, action, listener) {
  // UC Browser hasn't adopted the `transitionend` event despite supporting
  // unprefixed transitions...
  var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
  tooltip[action + 'EventListener'](eventName, listener);
}
/**
 * Returns the popper's placement, ignoring shifting (top-start, etc)
 */


function getBasicPlacement(popper) {
  var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
  return fullPlacement ? fullPlacement.split('-')[0] : '';
}
/**
 * Triggers reflow
 */


function reflow(popper) {
  void popper.offsetHeight;
}
/**
 * Adds/removes theme from tooltip's classList
 */


function updateTheme(tooltip, action, theme) {
  theme.split(' ').forEach(function (themeName) {
    tooltip.classList[action](themeName + '-theme');
  });
}
/**
 * Constructs the popper element and returns it
 */


function createPopperElement(id, props) {
  var popper = div();
  popper.className = POPPER_CLASS;
  popper.id = "tippy-".concat(id);
  popper.style.zIndex = '' + props.zIndex;
  popper.style.position = 'absolute';
  popper.style.top = '0';
  popper.style.left = '0';

  if (props.role) {
    popper.setAttribute('role', props.role);
  }

  var tooltip = div();
  tooltip.className = TOOLTIP_CLASS;
  tooltip.style.maxWidth = props.maxWidth + (typeof props.maxWidth === 'number' ? 'px' : '');
  tooltip.setAttribute('data-size', props.size);
  tooltip.setAttribute('data-animation', props.animation);
  tooltip.setAttribute('data-state', 'hidden');
  updateTheme(tooltip, 'add', props.theme);
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');

  if (props.interactive) {
    addInteractive(popper, tooltip);
  }

  if (props.arrow) {
    tooltip.appendChild(createArrowElement(props.arrowType));
  }

  if (props.animateFill) {
    tooltip.appendChild(createBackdropElement());
    tooltip.setAttribute('data-animatefill', '');
  }

  if (props.inertia) {
    addInertia(tooltip);
  }

  setContent(content, props);
  tooltip.appendChild(content);
  popper.appendChild(tooltip);
  return popper;
}
/**
 * Updates the popper element based on the new props
 */


function updatePopperElement(popper, prevProps, nextProps) {
  var _getChildren = getChildren(popper),
      tooltip = _getChildren.tooltip,
      content = _getChildren.content,
      backdrop = _getChildren.backdrop,
      arrow = _getChildren.arrow;

  popper.style.zIndex = '' + nextProps.zIndex;
  tooltip.setAttribute('data-size', nextProps.size);
  tooltip.setAttribute('data-animation', nextProps.animation);
  tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === 'number' ? 'px' : '');

  if (nextProps.role) {
    popper.setAttribute('role', nextProps.role);
  } else {
    popper.removeAttribute('role');
  }

  if (prevProps.content !== nextProps.content) {
    setContent(content, nextProps);
  } // animateFill


  if (!prevProps.animateFill && nextProps.animateFill) {
    tooltip.appendChild(createBackdropElement());
    tooltip.setAttribute('data-animatefill', '');
  } else if (prevProps.animateFill && !nextProps.animateFill) {
    tooltip.removeChild(backdrop);
    tooltip.removeAttribute('data-animatefill');
  } // arrow


  if (!prevProps.arrow && nextProps.arrow) {
    tooltip.appendChild(createArrowElement(nextProps.arrowType));
  } else if (prevProps.arrow && !nextProps.arrow) {
    tooltip.removeChild(arrow);
  } // arrowType


  if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {
    tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow);
  } // interactive


  if (!prevProps.interactive && nextProps.interactive) {
    addInteractive(popper, tooltip);
  } else if (prevProps.interactive && !nextProps.interactive) {
    removeInteractive(popper, tooltip);
  } // inertia


  if (!prevProps.inertia && nextProps.inertia) {
    addInertia(tooltip);
  } else if (prevProps.inertia && !nextProps.inertia) {
    removeInertia(tooltip);
  } // theme


  if (prevProps.theme !== nextProps.theme) {
    updateTheme(tooltip, 'remove', prevProps.theme);
    updateTheme(tooltip, 'add', nextProps.theme);
  }
}
/**
 * Hides all visible poppers on the document
 */


function hideAll() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      excludedReferenceOrInstance = _ref.exclude,
      duration = _ref.duration;

  arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach(function (popper) {
    var instance = popper._tippy;

    if (instance) {
      var isExcluded = false;

      if (excludedReferenceOrInstance) {
        isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;
      }

      if (!isExcluded) {
        instance.hide(duration);
      }
    }
  });
}
/**
 * Determines if the mouse cursor is outside of the popper's interactive border
 * region
 */


function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {
  if (!popperPlacement) {
    return true;
  }

  var x = event.clientX,
      y = event.clientY;
  var interactiveBorder = props.interactiveBorder,
      distance = props.distance;
  var exceedsTop = popperRect.top - y > (popperPlacement === 'top' ? interactiveBorder + distance : interactiveBorder);
  var exceedsBottom = y - popperRect.bottom > (popperPlacement === 'bottom' ? interactiveBorder + distance : interactiveBorder);
  var exceedsLeft = popperRect.left - x > (popperPlacement === 'left' ? interactiveBorder + distance : interactiveBorder);
  var exceedsRight = x - popperRect.right > (popperPlacement === 'right' ? interactiveBorder + distance : interactiveBorder);
  return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
}
/**
 * Returns the distance offset, taking into account the default offset due to
 * the transform: translate() rule (10px) in CSS
 */


function getOffsetDistanceInPx(distance) {
  return -(distance - 10) + 'px';
}

var idCounter = 1; // Workaround for IE11's lack of new MouseEvent constructor

var mouseMoveListeners = [];
/**
 * Creates and returns a Tippy object. We're using a closure pattern instead of
 * a class so that the exposed object API is clean without private members
 * prefixed with `_`.
 */

function createTippy(reference, collectionProps) {
  var props = evaluateProps(reference, collectionProps); // If the reference shouldn't have multiple tippys, return null early

  if (!props.multiple && reference._tippy) {
    return null;
  }
  /* =======================  Private members  ======================= */


  var lastTriggerEventType;
  var lastMouseMoveEvent;
  var showTimeoutId;
  var hideTimeoutId;
  var scheduleHideAnimationFrameId;
  var isScheduledToShow = false;
  var isBeingDestroyed = false;
  var previousPlacement;
  var wasVisibleDuringPreviousUpdate = false;
  var hasMountCallbackRun = false;
  var currentMountCallback;
  var currentTransitionEndListener;
  var listeners = [];
  var currentComputedPadding;
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  /* =======================  Public members  ======================= */

  var id = idCounter++;
  var popper = createPopperElement(id, props);
  var popperChildren = getChildren(popper);
  var popperInstance = null;
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: popper,
    popperChildren: popperChildren,
    popperInstance: popperInstance,
    props: props,
    state: state,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    set: set,
    setContent: setContent,
    show: show,
    hide: hide,
    enable: enable,
    disable: disable,
    destroy: destroy
    /* ==================== Initial instance mutations =================== */

  };
  reference._tippy = instance;
  popper._tippy = instance;
  addTriggersToReference();

  if (!props.lazy) {
    createPopperInstance();
  }

  if (props.showOnInit) {
    scheduleShow();
  } // Ensure the event listeners target can receive focus


  if (props.a11y && !props.target && !canReceiveFocus(getEventListenersTarget())) {
    getEventListenersTarget().setAttribute('tabindex', '0');
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function (event) {
    if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === 'mouseenter') {
      // We don't want props.onTrigger() to be called here, since the `event`
      // object is not related to the reference element
      scheduleShow(event, true);
    }
  });
  popper.addEventListener('mouseleave', function () {
    if (instance.props.interactive && lastTriggerEventType === 'mouseenter') {
      document.addEventListener('mousemove', debouncedOnMouseMove);
    }
  });
  return instance;
  /* =======================  Private methods  ======================= */

  /**
   * Removes the follow cursor listener
   */

  function removeFollowCursorListener() {
    document.removeEventListener('mousemove', positionVirtualReferenceNearCursor);
  }
  /**
   * Cleans up interactive mouse listeners
   */


  function cleanupInteractiveMouseListeners() {
    document.body.removeEventListener('mouseleave', scheduleHide);
    document.removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  /**
   * Returns correct target used for event listeners
   */


  function getEventListenersTarget() {
    return instance.props.triggerTarget || reference;
  }
  /**
   * Adds the document click event listener for the instance
   */


  function addDocumentClickListener() {
    document.addEventListener('click', onDocumentClick, true);
  }
  /**
   * Removes the document click event listener for the instance
   */


  function removeDocumentClickListener() {
    document.removeEventListener('click', onDocumentClick, true);
  }
  /**
   * Returns transitionable inner elements used in show/hide methods
   */


  function getTransitionableElements() {
    return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];
  }
  /**
   * Determines if the instance is in `followCursor` mode.
   * NOTE: in v5, touch devices will use `initial` behavior no matter the value.
   */


  function getIsInLooseFollowCursorMode() {
    var followCursor = instance.props.followCursor;
    return followCursor && lastTriggerEventType !== 'focus' || isUsingTouch && followCursor === 'initial';
  }
  /**
   * Updates the tooltip's position on each animation frame
   */


  function makeSticky() {
    setTransitionDuration([popper], isIE ? 0 : instance.props.updateDuration);

    function updatePosition() {
      instance.popperInstance.scheduleUpdate();

      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      } else {
        setTransitionDuration([popper], 0);
      }
    }

    updatePosition();
  }
  /**
   * Invokes a callback once the tooltip has fully transitioned out
   */


  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }
  /**
   * Invokes a callback once the tooltip has fully transitioned in
   */


  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  /**
   * Invokes a callback once the tooltip's CSS transition ends
   */


  function onTransitionEnd(duration, callback) {
    var tooltip = instance.popperChildren.tooltip;
    /**
     * Listener added as the `transitionend` handler
     */

    function listener(event) {
      if (event.target === tooltip) {
        updateTransitionEndListener(tooltip, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(tooltip, 'add', listener);
    currentTransitionEndListener = listener;
  }
  /**
   * Adds an event listener to the reference and stores it in `listeners`
   */


  function on(eventType, handler) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    getEventListenersTarget().addEventListener(eventType, handler, options);
    listeners.push({
      eventType: eventType,
      handler: handler,
      options: options
    });
  }
  /**
   * Adds event listeners to the reference based on the `trigger` prop
   */


  function addTriggersToReference() {
    if (instance.props.touchHold && !instance.props.target) {
      on('touchstart', onTrigger, PASSIVE);
      on('touchend', onMouseLeave, PASSIVE);
    }

    instance.props.trigger.trim().split(' ').forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      } // Non-delegates


      if (!instance.props.target) {
        on(eventType, onTrigger);

        switch (eventType) {
          case 'mouseenter':
            on('mouseleave', onMouseLeave);
            break;

          case 'focus':
            on(isIE ? 'focusout' : 'blur', onBlur);
            break;
        }
      } else {
        // Delegates
        switch (eventType) {
          case 'mouseenter':
            on('mouseover', onDelegateShow);
            on('mouseout', onDelegateHide);
            break;

          case 'focus':
            on('focusin', onDelegateShow);
            on('focusout', onDelegateHide);
            break;

          case 'click':
            on(eventType, onDelegateShow);
            break;
        }
      }
    });
  }
  /**
   * Removes event listeners from the reference
   */


  function removeTriggersFromReference() {
    listeners.forEach(function (_ref) {
      var eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      getEventListenersTarget().removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  /**
   * Positions the virtual reference near the cursor
   */


  function positionVirtualReferenceNearCursor(event) {
    var _lastMouseMoveEvent = lastMouseMoveEvent = event,
        x = _lastMouseMoveEvent.clientX,
        y = _lastMouseMoveEvent.clientY; // Gets set once popperInstance `onCreate` has been called


    if (!currentComputedPadding) {
      return;
    } // If the instance is interactive, avoid updating the position unless it's
    // over the reference element


    var isCursorOverReference = closestCallback(event.target, function (el) {
      return el === reference;
    });
    var rect = reference.getBoundingClientRect();
    var followCursor = instance.props.followCursor;
    var isHorizontal = followCursor === 'horizontal';
    var isVertical = followCursor === 'vertical'; // The virtual reference needs some size to prevent itself from overflowing

    var isVerticalPlacement = includes(['top', 'bottom'], getBasicPlacement(popper));
    var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
    var isVariation = fullPlacement ? !!fullPlacement.split('-')[1] : false;
    var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
    var halfSize = size / 2;
    var verticalIncrease = isVerticalPlacement ? 0 : isVariation ? size : halfSize;
    var horizontalIncrease = isVerticalPlacement ? isVariation ? size : halfSize : 0;

    if (isCursorOverReference || !instance.props.interactive) {
      instance.popperInstance.reference = _extends({}, instance.popperInstance.reference, {
        // These `client` values don't get used by Popper.js if they are 0
        clientWidth: 0,
        clientHeight: 0,
        getBoundingClientRect: function getBoundingClientRect() {
          return {
            width: isVerticalPlacement ? size : 0,
            height: isVerticalPlacement ? 0 : size,
            top: (isHorizontal ? rect.top : y) - verticalIncrease,
            bottom: (isHorizontal ? rect.bottom : y) + verticalIncrease,
            left: (isVertical ? rect.left : x) - horizontalIncrease,
            right: (isVertical ? rect.right : x) + horizontalIncrease
          };
        }
      });
      instance.popperInstance.update();
    }

    if (followCursor === 'initial' && instance.state.isVisible) {
      removeFollowCursorListener();
    }
  }
  /**
   * Creates the tippy instance for a delegate when it's been triggered
   */


  function createDelegateChildTippy(event) {
    if (event) {
      var targetEl = closest(event.target, instance.props.target);

      if (targetEl && !targetEl._tippy) {
        createTippy(targetEl, _extends({}, instance.props, {
          content: invokeWithArgsOrReturn(collectionProps.content, [targetEl]),
          appendTo: collectionProps.appendTo,
          target: '',
          showOnInit: true
        }));
      }
    }
  }
  /**
   * Event listener invoked upon trigger
   */


  function onTrigger(event) {
    if (!instance.state.isEnabled || isEventListenerStopped(event)) {
      return;
    }

    if (!instance.state.isVisible) {
      lastTriggerEventType = event.type;

      if (event instanceof MouseEvent) {
        lastMouseMoveEvent = event; // If scrolling, `mouseenter` events can be fired if the cursor lands
        // over a new target, but `mousemove` events don't get fired. This
        // causes interactive tooltips to get stuck open until the cursor is
        // moved

        mouseMoveListeners.forEach(function (listener) {
          return listener(event);
        });
      }
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && instance.props.hideOnClick !== false && instance.state.isVisible) {
      scheduleHide();
    } else {
      scheduleShow(event);
    }
  }
  /**
   * Event listener used for interactive tooltips to detect when they should
   * hide
   */


  function onMouseMove(event) {
    var isCursorOverPopper = closest(event.target, POPPER_SELECTOR) === popper;
    var isCursorOverReference = closestCallback(event.target, function (el) {
      return el === reference;
    });

    if (isCursorOverPopper || isCursorOverReference) {
      return;
    }

    if (isCursorOutsideInteractiveBorder(getBasicPlacement(popper), popper.getBoundingClientRect(), event, instance.props)) {
      cleanupInteractiveMouseListeners();
      scheduleHide();
    }
  }
  /**
   * Event listener invoked upon mouseleave
   */


  function onMouseLeave(event) {
    if (isEventListenerStopped(event)) {
      return;
    }

    if (instance.props.interactive) {
      document.body.addEventListener('mouseleave', scheduleHide);
      document.addEventListener('mousemove', debouncedOnMouseMove);
      mouseMoveListeners.push(debouncedOnMouseMove);
      return;
    }

    scheduleHide();
  }
  /**
   * Event listener invoked upon blur
   */


  function onBlur(event) {
    if (event.target !== getEventListenersTarget()) {
      return;
    }

    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide();
  }
  /**
   * Event listener invoked when a child target is triggered
   */


  function onDelegateShow(event) {
    if (closest(event.target, instance.props.target)) {
      scheduleShow(event);
    }
  }
  /**
   * Event listener invoked when a child target should hide
   */


  function onDelegateHide(event) {
    if (closest(event.target, instance.props.target)) {
      scheduleHide();
    }
  }
  /**
   * Determines if an event listener should stop further execution due to the
   * `touchHold` option
   */


  function isEventListenerStopped(event) {
    var supportsTouch = 'ontouchstart' in window;
    var isTouchEvent = includes(event.type, 'touch');
    var touchHold = instance.props.touchHold;
    return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;
  }
  /**
   * Runs the mount callback
   */


  function runMountCallback() {
    if (!hasMountCallbackRun && currentMountCallback) {
      hasMountCallbackRun = true;
      reflow(popper);
      currentMountCallback();
    }
  }
  /**
   * Creates the popper instance for the instance
   */


  function createPopperInstance() {
    var popperOptions = instance.props.popperOptions;
    var _instance$popperChild = instance.popperChildren,
        tooltip = _instance$popperChild.tooltip,
        arrow = _instance$popperChild.arrow;
    var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');

    function applyMutations(data) {
      if (instance.props.flip && !instance.props.flipOnUpdate) {
        if (data.flipped) {
          instance.popperInstance.options.placement = data.placement;
        }

        setFlipModifierEnabled(instance.popperInstance.modifiers, false);
      } // Apply all of the popper's attributes to the tootip node as well.
      // Allows users to avoid using the .tippy-popper selector for themes.


      tooltip.setAttribute(PLACEMENT_ATTRIBUTE, data.placement);

      if (data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE] !== false) {
        tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE, '');
      } else {
        tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE);
      } // Prevents a transition when changing placements (while tippy is visible)
      // for scroll/resize updates


      if (previousPlacement && previousPlacement !== data.placement && wasVisibleDuringPreviousUpdate) {
        tooltip.style.transition = 'none';
        requestAnimationFrame(function () {
          tooltip.style.transition = '';
        });
      }

      previousPlacement = data.placement;
      wasVisibleDuringPreviousUpdate = instance.state.isVisible;
      var basicPlacement = getBasicPlacement(popper);
      var styles = tooltip.style; // Account for the `distance` offset

      styles.top = styles.bottom = styles.left = styles.right = '';
      styles[basicPlacement] = getOffsetDistanceInPx(instance.props.distance);
      var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PADDING;
      var isPaddingNumber = typeof padding === 'number';

      var computedPadding = _extends({
        top: isPaddingNumber ? padding : padding.top,
        bottom: isPaddingNumber ? padding : padding.bottom,
        left: isPaddingNumber ? padding : padding.left,
        right: isPaddingNumber ? padding : padding.right
      }, !isPaddingNumber && padding);

      computedPadding[basicPlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basicPlacement] || 0) + instance.props.distance;
      instance.popperInstance.modifiers.filter(function (m) {
        return m.name === 'preventOverflow';
      })[0].padding = computedPadding;
      currentComputedPadding = computedPadding;
    }

    var config = _extends({
      eventsEnabled: false,
      placement: instance.props.placement
    }, popperOptions, {
      modifiers: _extends({}, popperOptions ? popperOptions.modifiers : {}, {
        preventOverflow: _extends({
          boundariesElement: instance.props.boundary,
          padding: PADDING
        }, preventOverflowModifier),
        arrow: _extends({
          element: arrow,
          enabled: !!arrow
        }, getModifier(popperOptions, 'arrow')),
        flip: _extends({
          enabled: instance.props.flip,
          // The tooltip is offset by 10px from the popper in CSS,
          // we need to account for its distance
          padding: instance.props.distance + PADDING,
          behavior: instance.props.flipBehavior
        }, getModifier(popperOptions, 'flip')),
        offset: _extends({
          offset: instance.props.offset
        }, getModifier(popperOptions, 'offset'))
      }),
      onCreate: function onCreate(data) {
        applyMutations(data);
        runMountCallback();

        if (popperOptions && popperOptions.onCreate) {
          popperOptions.onCreate(data);
        }
      },
      onUpdate: function onUpdate(data) {
        applyMutations(data);
        runMountCallback();

        if (popperOptions && popperOptions.onUpdate) {
          popperOptions.onUpdate(data);
        }
      }
    });

    instance.popperInstance = new popper_js__WEBPACK_IMPORTED_MODULE_0__["default"](reference, popper, config);
  }
  /**
   * Mounts the tooltip to the DOM
   */


  function mount() {
    hasMountCallbackRun = false;
    var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();

    if (instance.popperInstance) {
      setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);

      if (!isInLooseFollowCursorMode) {
        instance.popperInstance.reference = reference;
        instance.popperInstance.enableEventListeners();
      }

      instance.popperInstance.scheduleUpdate();
    } else {
      createPopperInstance();

      if (!isInLooseFollowCursorMode) {
        instance.popperInstance.enableEventListeners();
      }
    }

    var appendTo = instance.props.appendTo;
    var parentNode = appendTo === 'parent' ? reference.parentNode : invokeWithArgsOrReturn(appendTo, [reference]);

    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
      instance.props.onMount(instance);
      instance.state.isMounted = true;
    }
  }
  /**
   * Setup before show() is invoked (delays, etc.)
   */


  function scheduleShow(event, shouldAvoidCallingOnTrigger) {
    clearDelayTimeouts();

    if (instance.state.isVisible) {
      return;
    } // Is a delegate, create an instance for the child target


    if (instance.props.target) {
      return createDelegateChildTippy(event);
    }

    isScheduledToShow = true;

    if (event && !shouldAvoidCallingOnTrigger) {
      instance.props.onTrigger(instance, event);
    }

    if (instance.props.wait) {
      return instance.props.wait(instance, event);
    } // If the tooltip has a delay, we need to be listening to the mousemove as
    // soon as the trigger event is fired, so that it's in the correct position
    // upon mount.
    // Edge case: if the tooltip is still mounted, but then scheduleShow() is
    // called, it causes a jump.


    if (getIsInLooseFollowCursorMode() && !instance.state.isMounted) {
      if (!instance.popperInstance) {
        createPopperInstance();
      }

      document.addEventListener('mousemove', positionVirtualReferenceNearCursor);
    }

    addDocumentClickListener();
    var delay = getValue(instance.props.delay, 0, defaultProps.delay);

    if (delay) {
      showTimeoutId = setTimeout(function () {
        show();
      }, delay);
    } else {
      show();
    }
  }
  /**
   * Setup before hide() is invoked (delays, etc.)
   */


  function scheduleHide() {
    clearDelayTimeouts();

    if (!instance.state.isVisible) {
      return removeFollowCursorListener();
    }

    isScheduledToShow = false;
    var delay = getValue(instance.props.delay, 1, defaultProps.delay);

    if (delay) {
      hideTimeoutId = setTimeout(function () {
        if (instance.state.isVisible) {
          hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrameId = requestAnimationFrame(function () {
        hide();
      });
    }
  }
  /**
   * Listener to handle clicks on the document to determine if the
   * instance should hide
   */


  function onDocumentClick(event) {
    // Clicked on interactive popper
    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    } // Clicked on the event listeners target


    if (getEventListenersTarget().contains(event.target)) {
      if (isUsingTouch) {
        return;
      }

      if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {
        return;
      }
    }

    if (instance.props.hideOnClick === true) {
      clearDelayTimeouts();
      hide();
    }
  }
  /* =======================  Public methods  ======================= */

  /**
   * Enables the instance to allow it to show or hide
   */


  function enable() {
    instance.state.isEnabled = true;
  }
  /**
   * Disables the instance to disallow it to show or hide
   */


  function disable() {
    instance.state.isEnabled = false;
  }
  /**
   * Clears pending timeouts related to the `delay` prop if any
   */


  function clearDelayTimeouts() {
    clearTimeout(showTimeoutId);
    clearTimeout(hideTimeoutId);
    cancelAnimationFrame(scheduleHideAnimationFrameId);
  }
  /**
   * Sets new props for the instance and redraws the tooltip
   */


  function set(options) {
    // Backwards-compatible after TypeScript change
    options = options || {};
    validateOptions(options, defaultProps);
    removeTriggersFromReference();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, _extends({}, instance.props, options, {
      ignoreAttributes: true
    }));
    nextProps.ignoreAttributes = hasOwnProperty(options, 'ignoreAttributes') ? options.ignoreAttributes || false : prevProps.ignoreAttributes;
    instance.props = nextProps;
    addTriggersToReference();
    cleanupInteractiveMouseListeners();
    debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    updatePopperElement(popper, prevProps, nextProps);
    instance.popperChildren = getChildren(popper);

    if (instance.popperInstance) {
      if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
        return hasOwnProperty(options, prop) && options[prop] !== prevProps[prop];
      })) {
        instance.popperInstance.destroy();
        createPopperInstance();

        if (instance.state.isVisible) {
          instance.popperInstance.enableEventListeners();
        }

        if (instance.props.followCursor && lastMouseMoveEvent) {
          positionVirtualReferenceNearCursor(lastMouseMoveEvent);
        }
      } else {
        instance.popperInstance.update();
      }
    }
  }
  /**
   * Shortcut for .set({ content: newContent })
   */


  function setContent(content) {
    set({
      content: content
    });
  }
  /**
   * Shows the tooltip
   */


  function show() {
    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);

    if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {
      return;
    } // Standardize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.


    if (getEventListenersTarget().hasAttribute('disabled')) {
      return;
    }

    if (instance.props.onShow(instance) === false) {
      return;
    }

    addDocumentClickListener();
    popper.style.visibility = 'visible';
    instance.state.isVisible = true;

    if (instance.props.interactive) {
      getEventListenersTarget().classList.add(ACTIVE_CLASS);
    } // Prevent a transition if the popper is at the opposite placement


    var transitionableElements = getTransitionableElements();
    setTransitionDuration(transitionableElements.concat(popper), 0);

    currentMountCallback = function currentMountCallback() {
      if (!instance.state.isVisible) {
        return;
      }

      var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();

      if (isInLooseFollowCursorMode && lastMouseMoveEvent) {
        positionVirtualReferenceNearCursor(lastMouseMoveEvent);
      } else if (!isInLooseFollowCursorMode) {
        // Double update will apply correct mutations
        instance.popperInstance.update();
      }

      if (instance.popperChildren.backdrop) {
        instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + 'ms';
      }

      if (instance.props.sticky) {
        makeSticky();
      }

      setTransitionDuration([popper], instance.props.updateDuration);
      setTransitionDuration(transitionableElements, duration);
      setVisibilityState(transitionableElements, 'visible');
      onTransitionedIn(duration, function () {
        if (instance.props.aria) {
          getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria), popper.id);
        }

        instance.props.onShown(instance);
        instance.state.isShown = true;
      });
    };

    mount();
  }
  /**
   * Hides the tooltip
   */


  function hide() {
    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);

    if (instance.state.isDestroyed || !instance.state.isEnabled && !isBeingDestroyed) {
      return;
    }

    if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
      return;
    }

    removeDocumentClickListener();
    popper.style.visibility = 'hidden';
    instance.state.isVisible = false;
    instance.state.isShown = false;
    wasVisibleDuringPreviousUpdate = false;

    if (instance.props.interactive) {
      getEventListenersTarget().classList.remove(ACTIVE_CLASS);
    }

    var transitionableElements = getTransitionableElements();
    setTransitionDuration(transitionableElements, duration);
    setVisibilityState(transitionableElements, 'hidden');
    onTransitionedOut(duration, function () {
      if (!isScheduledToShow) {
        removeFollowCursorListener();
      }

      if (instance.props.aria) {
        getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria));
      }

      instance.popperInstance.disableEventListeners();
      instance.popperInstance.options.placement = instance.props.placement;
      popper.parentNode.removeChild(popper);
      instance.props.onHidden(instance);
      instance.state.isMounted = false;
    });
  }
  /**
   * Destroys the tooltip
   */


  function destroy(destroyTargetInstances) {
    if (instance.state.isDestroyed) {
      return;
    }

    isBeingDestroyed = true; // If the popper is currently mounted to the DOM, we want to ensure it gets
    // hidden and unmounted instantly upon destruction

    if (instance.state.isMounted) {
      hide(0);
    }

    removeTriggersFromReference();
    delete reference._tippy;
    var target = instance.props.target;

    if (target && destroyTargetInstances && isRealElement(reference)) {
      arrayFrom(reference.querySelectorAll(target)).forEach(function (child) {
        if (child._tippy) {
          child._tippy.destroy();
        }
      });
    }

    if (instance.popperInstance) {
      instance.popperInstance.destroy();
    }

    isBeingDestroyed = false;
    instance.state.isDestroyed = true;
  }
}
/**
 * Groups an array of instances by taking control of their props during
 * certain lifecycles.
 */


function group(instances) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay,
      _ref$duration = _ref.duration,
      duration = _ref$duration === void 0 ? 0 : _ref$duration;

  var isAnyTippyOpen = false;
  instances.forEach(function (instance) {
    if (instance._originalProps) {
      instance.set(instance._originalProps);
    } else {
      instance._originalProps = _extends({}, instance.props);
    }
  });

  function setIsAnyTippyOpen(value) {
    isAnyTippyOpen = value;
    updateInstances();
  }

  function onShow(instance) {
    instance._originalProps.onShow(instance);

    instances.forEach(function (instance) {
      instance.set({
        duration: duration
      });

      if (instance.state.isVisible) {
        instance.hide();
      }
    });
    setIsAnyTippyOpen(true);
  }

  function onHide(instance) {
    instance._originalProps.onHide(instance);

    setIsAnyTippyOpen(false);
  }

  function onShown(instance) {
    instance._originalProps.onShown(instance);

    instance.set({
      duration: instance._originalProps.duration
    });
  }

  function updateInstances() {
    instances.forEach(function (instance) {
      instance.set({
        onShow: onShow,
        onShown: onShown,
        onHide: onHide,
        delay: isAnyTippyOpen ? [0, Array.isArray(delay) ? delay[1] : delay] : delay,
        duration: isAnyTippyOpen ? duration : instance._originalProps.duration
      });
    });
  }

  updateInstances();
}

var globalEventListenersBound = false;
/**
 * Exported module
 */

function tippy(targets, options) {
  validateOptions(options || {}, defaultProps);

  if (!globalEventListenersBound) {
    bindGlobalEventListeners();
    globalEventListenersBound = true;
  }

  var props = _extends({}, defaultProps, options); // If they are specifying a virtual positioning reference, we need to polyfill
  // some native DOM props


  if (isBareVirtualElement(targets)) {
    polyfillElementPrototypeProperties(targets);
  }

  var instances = getArrayOfElements(targets).reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, props);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isSingular(targets) ? instances[0] : instances;
}
/**
 * Static props
 */


tippy.version = version;
tippy.defaults = defaultProps;
/**
 * Static methods
 */

tippy.setDefaults = function (partialDefaults) {
  Object.keys(partialDefaults).forEach(function (key) {
    // @ts-ignore
    defaultProps[key] = partialDefaults[key];
  });
};

tippy.hideAll = hideAll;
tippy.group = group;
/**
 * Auto-init tooltips for elements with a `data-tippy="..."` attribute
 */

function autoInit() {
  arrayFrom(document.querySelectorAll('[data-tippy]')).forEach(function (el) {
    var content = el.getAttribute('data-tippy');

    if (content) {
      tippy(el, {
        content: content
      });
    }
  });
}

if (isBrowser) {
  setTimeout(autoInit);
}
/**
 * Injects a string of CSS styles to a style node in <head>
 */


function injectCSS(css) {
  if (isBrowser) {
    var style = document.createElement('style');
    style.type = 'text/css';
    style.textContent = css;
    style.setAttribute('data-tippy-stylesheet', '');
    var head = document.head;
    var firstChild = head.firstChild;

    if (firstChild) {
      head.insertBefore(style, firstChild);
    } else {
      head.appendChild(style);
    }
  }
}

injectCSS(css);
/* harmony default export */ __webpack_exports__["default"] = (tippy);

/***/ }),

/***/ "../node_modules/tslib/tslib.es6.js":
/*!******************************************!*\
  !*** ../node_modules/tslib/tslib.es6.js ***!
  \******************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __exportStar(m, exports) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
function __values(o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}
;
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var normalize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! normalize.css */ "../node_modules/normalize.css/normalize.css");
/* harmony import */ var normalize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(normalize_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _js_components_users__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/components/users */ "./js/components/users/index.js");



/***/ }),

/***/ "./js/components/users/index.js":
/*!**************************************!*\
  !*** ./js/components/users/index.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _scss_index_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scss/index.scss */ "./js/components/users/scss/index.scss");
/* harmony import */ var _scss_index_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_scss_index_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _js_users_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/users.component */ "./js/components/users/js/users.component.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }




var users = _toConsumableArray(document.querySelectorAll('[data-component="users"]')).map(function (n) {
  return new _js_users_component__WEBPACK_IMPORTED_MODULE_1__["default"](n);
});

/***/ }),

/***/ "./js/components/users/js/templates.js":
/*!*********************************************!*\
  !*** ./js/components/users/js/templates.js ***!
  \*********************************************/
/*! exports provided: getUserTemplate, getUserEditTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUserTemplate", function() { return getUserTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUserEditTemplate", function() { return getUserEditTemplate; });
var getStringType = function getStringType(type) {
  var tooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (tooltip) {
    if (type === '1') {
      return " ";
    } else if (type === '2') {
      return " ";
    } else {
      return null;
    }
  }

  if (type === '1') {
    return "";
  } else if (type === '2') {
    return "";
  } else {
    return null;
  }
};

var getUserTemplate = function getUserTemplate(user) {
  return "\n      <tr class=\"users__row\">\n        <td class=\"users__cell users__cell--name\">\n            ".concat(user.firstName, "\n        </td>\n        <td class=\"users__cell\">\n          <button\n            class=\"users__button-tooltip\"\n            type=\"button\"\n            data-users-ref=\"tooltip\"\n            data-tippy-content=\"").concat(getStringType(user.type, true), "\"\n          >\n            ").concat(getStringType(user.type), "\n          </button>\n        </td>\n        <td class=\"users__cell\">\n            ").concat(user.userNumber, "\n        </td>\n        <td class=\"users__cell\">\n            <button\n                class=\"users__button-edit button\"\n                type=\"button\"\n                data-users-ref=\"edit\"\n                data-users-options=").concat(user.id, "\n            />\n                \u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C\n            </button>\n        </td>\n        <td class=\"users__cell\">\n            <button\n                class=\"users__button-delete button\"\n                type=\"button\"\n                data-users-ref=\"delete\"\n                data-users-options=").concat(user.id, "\n            >\n                \u0423\u0434\u0430\u043B\u0438\u0442\u044C\n            </button>\n        </td>\n      </tr>\n  ");
};
var getUserEditTemplate = function getUserEditTemplate(user) {
  return "\n      <tr class=\"users__row\">\n        <td class=\"users__cell users__cell--name\">\n            <div class=\"users__cell-element\">\n              <input\n                class=\"users__cell-input\"\n                type=\"text\"\n                value=\"".concat(user.firstName, "\"\n                data-users-ref=\"first-name-update\"\n              />\n              <div class=\"users__message\" data-users-ref=\"message\"></div>\n            </div>\n        </td>\n        <td class=\"users__cell\">\n          <select class=\"users__select-update\" data-users-ref=\"type-update\">\n            <option value=\"1\">\u0424\u0438\u0437\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u043B\u0438\u0446\u043E</option>\n            <option value=\"2\">\u042E\u0440\u0438\u0434\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u043B\u0438\u0446\u043E</option>\n          </select>\n        </td>\n        <td class=\"users__cell\">\n            <div class=\"users__cell-element\">\n              <input\n                  class=\"users__cell-input\"\n                  type=\"text\"\n                  value=\"").concat(user.userNumber, "\"\n                  data-users-ref=\"user-number-update\"\n              />\n              <div class=\"users__message\" data-users-ref=\"message\"></div>\n           </div>\n        </td>\n        <td class=\"users__cell\">\n            <button\n                class=\"users__button-edit button\"\n                type=\"button\"\n                data-users-ref=\"update\"\n                data-users-options=").concat(user.id, "\n            />\n                \u041E\u0431\u043D\u043E\u0432\u0438\u0442\u044C\n            </button>\n        </td>\n        <td class=\"users__cell\">\n            <button\n                class=\"users__button-delete button\"\n                type=\"button\"\n                data-users-ref=\"close\"\n                data-users-options=").concat(user.id, "\n            >\n                \u0417\u0430\u043A\u0440\u044B\u0442\u044C\n            </button>\n        </td>\n      </tr>\n  ");
};

/***/ }),

/***/ "./js/components/users/js/users.component.js":
/*!***************************************************!*\
  !*** ./js/components/users/js/users.component.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Users; });
/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tippy.js */ "../node_modules/tippy.js/esm/index.all.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/cloneDeep */ "../node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _general_js_data_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../general/js/data-service */ "./js/general/js/data-service.js");
/* harmony import */ var _general_js_validators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../general/js/validators */ "./js/general/js/validators.js");
/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./templates */ "./js/components/users/js/templates.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }







var Users =
/*#__PURE__*/
function () {
  function Users(el) {
    var _this = this;

    _classCallCheck(this, Users);

    this.selectFilterHandler = function (event) {
      if (event.target.value === '0') {
        _this.filterByZero();
      }

      if (event.target.value === '1') {
        _this.filterByOne();
      }

      if (event.target.value === '2') {
        _this.filterByTwo();
      }
    };

    this.filterByZero = function () {
      _this.filterState.filterByOneState = false;
      _this.filterState.filterByTwoState = false;

      _this.render(_this.data);
    };

    this.filterByOne = function () {
      _this.filterState.filterByOneState = true;
      _this.filterState.filterByTwoState = false;

      _this.render(_this.data);
    };

    this.filterByTwo = function () {
      _this.filterState.filterByOneState = false;
      _this.filterState.filterByTwoState = true;

      _this.render(_this.data);
    };

    this.fetchAds = function () {
      _general_js_data_service__WEBPACK_IMPORTED_MODULE_2__["default"].fetchAds().then(function (users) {
        _this.data = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default()(users);

        _this.render(_this.data);
      }).catch(function (error) {
        console.error(error);
      });
    };

    this.render = function (data) {
      var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var users = data;
      users = users.sort(function (a, b) {
        var nameA = a.firstName.toLowerCase();
        var nameB = b.firstName.toLowerCase();

        if (nameA < nameB) {
          return -1;
        }

        if (nameA > nameB) {
          return 1;
        }

        return 0;
      });

      if (_this.filterState.filterByOneState) {
        users = users.filter(function (user) {
          return user.type === '1';
        });
      }

      if (_this.filterState.filterByTwoState) {
        users = users.filter(function (user) {
          return user.type === '2';
        });
      }

      _this.usersTbody.innerHTML = '';

      if (mode === 'edit') {
        for (var i = 0; i < users.length; i++) {
          if (users[i].id === id) {
            _this.usersTbody.innerHTML += Object(_templates__WEBPACK_IMPORTED_MODULE_4__["getUserEditTemplate"])(users[i]);
          } else {
            _this.usersTbody.innerHTML += Object(_templates__WEBPACK_IMPORTED_MODULE_4__["getUserTemplate"])(users[i]);
          }
        }
      } else {
        for (var _i = 0; _i < users.length; _i++) {
          _this.usersTbody.innerHTML += Object(_templates__WEBPACK_IMPORTED_MODULE_4__["getUserTemplate"])(users[_i]);
        }
      }

      _this.tooltipInit();
    };

    this.tooltipInit = function () {
      _this.tooltipElements = _this.el.querySelectorAll('[data-users-ref="tooltip"]');
      _this.tooltip = Object(tippy_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.tooltipElements);
    };

    this.createAd = function (event) {
      event.preventDefault();
      var values = {
        name: _this.name.value,
        userNumber: _this.userNumber.value
      };
      var nodes = {
        name: _this.name,
        userNumber: _this.userNumber
      };
      var isValid = _general_js_validators__WEBPACK_IMPORTED_MODULE_3__["default"].required(_this.el, values, nodes);
      if (!isValid) return false;
      var payload = {
        firstName: _this.name.value,
        type: _this.type.value,
        userNumber: _this.userNumber.value
      };
      _general_js_data_service__WEBPACK_IMPORTED_MODULE_2__["default"].createAd(payload);
      _this.name.value = '';
      _this.userNumber.value = '';

      _this.fetchAds();
    };

    this.deleteAd = function (id) {
      _general_js_data_service__WEBPACK_IMPORTED_MODULE_2__["default"].deleteAd(id).then(function () {
        _this.fetchAds();
      }).catch(function (error) {
        console.error(error);
      });
    };

    this.updateAd = function (id) {
      var firstName = _this.el.querySelector('[data-users-ref="first-name-update"]');

      var type = _this.el.querySelector('[data-users-ref="type-update"]');

      var userNumber = _this.el.querySelector('[data-users-ref="user-number-update"]');

      var values = {
        name: firstName.value,
        userNumber: userNumber.value
      };
      var nodes = {
        name: firstName,
        userNumber: userNumber
      };
      var isValid = _general_js_validators__WEBPACK_IMPORTED_MODULE_3__["default"].required(_this.el, values, nodes);
      if (!isValid) return false;
      var payload = {
        firstName: firstName.value,
        type: type.value,
        userNumber: userNumber.value
      };
      _general_js_data_service__WEBPACK_IMPORTED_MODULE_2__["default"].updateAd(id, payload).then(function () {
        _this.fetchAds();
      }).catch(function (error) {
        console.error(error);
      });
    };

    this.editAd = function (id) {
      _this.render(_this.data, 'edit', id);
    };

    this.closeAd = function () {
      _this.render(_this.data);
    };

    this.userHandler = function (event) {
      var dataSet = event.target.getAttribute('data-users-ref');
      var id = event.target.getAttribute('data-users-options');

      if (dataSet === 'delete') {
        _this.deleteAd(id);
      }

      if (dataSet === 'edit') {
        _this.editAd(id);
      }

      if (dataSet === 'close') {
        _this.closeAd(id);
      }

      if (dataSet === 'update') {
        _this.updateAd(id);
      } // if (event.target.dataset.usersRef === 'edit') {
      //   this.editUser(event.target.dataset.usersOptions);
      // }
      //
      // if (event.target.dataset.usersRef === 'update') {
      //   this.updateUser(event.target.dataset.usersOptions);
      // }

    };

    this.el = el;
    this.filterState = {
      filterByZeroState: false,
      filterByOneState: false,
      filterByTwoState: false
    };
    this.form = this.el.querySelector('[data-users-ref="form"]');
    this.name = this.el.querySelector('[data-users-ref="name"]');
    this.type = this.el.querySelector('[data-users-ref="type"]');
    this.userNumber = this.el.querySelector('[data-users-ref="user-number"]');
    this.usersTbody = this.el.querySelector('[data-users-ref="users-tbody"]');
    this.selectFilter = this.el.querySelector('[data-users-ref="filter"]');
    this.init();
  }

  _createClass(Users, [{
    key: "init",
    value: function init() {
      this.el.addEventListener('click', this.userHandler);
      this.form.addEventListener('submit', this.createAd);
      this.selectFilter.addEventListener('change', this.selectFilterHandler);
      this.data = null;
      this.fetchAds();
    }
  }]);

  return Users;
}();



/***/ }),

/***/ "./js/components/users/scss/index.scss":
/*!*********************************************!*\
  !*** ./js/components/users/scss/index.scss ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../../node_modules/mini-css-extract-plugin/dist/loader.js!../../../../../node_modules/css-loader/dist/cjs.js??ref--7-2!../../../../../node_modules/postcss-loader/src??ref--7-3!../../../../../node_modules/sass-loader/lib/loader.js??ref--7-4!./index.scss */ "../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../node_modules/sass-loader/lib/loader.js?!./js/components/users/scss/index.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../../node_modules/style-loader/lib/addStyles.js */ "../node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./js/general/js/data-service.js":
/*!***************************************!*\
  !*** ./js/general/js/data-service.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ "../node_modules/firebase/app/dist/index.cjs.js");
/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(firebase_app__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/database */ "../node_modules/firebase/database/dist/index.esm.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://console.firebase.google.com/



var Ad = function Ad(firstName, type, userNumber) {
  var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  _classCallCheck(this, Ad);

  this.firstName = firstName;
  this.type = type;
  this.userNumber = userNumber;
  this.id = id;
};

var DataService =
/*#__PURE__*/
function () {
  function DataService() {
    _classCallCheck(this, DataService);

    this.data = null;
    this.init();
  }

  _createClass(DataService, [{
    key: "init",
    value: function init() {
      var config = {
        apiKey: 'AIzaSyBtvzZlxD_TLwsoE2kMZUMRPnFgz20RyjA',
        authDomain: 'javascript-app-8804a.firebaseapp.com',
        databaseURL: 'https://javascript-app-8804a.firebaseio.com',
        projectId: 'javascript-app-8804a',
        storageBucket: 'javascript-app-8804a.appspot.com',
        messagingSenderId: '916390243341',
        appId: '1:916390243341:web:d93322ea53d50bae'
      };
      firebase_app__WEBPACK_IMPORTED_MODULE_0___default.a.initializeApp(config);
    }
  }, {
    key: "fetchAds",
    value: function () {
      var _fetchAds = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var resultAds, fbVal, ads;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                resultAds = [];
                _context.prev = 1;
                _context.next = 4;
                return firebase_app__WEBPACK_IMPORTED_MODULE_0___default.a.database().ref('users').once('value');

              case 4:
                fbVal = _context.sent;
                ads = fbVal.val();

                if (ads) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", resultAds);

              case 8:
                Object.keys(ads).forEach(function (key) {
                  var ad = ads[key];
                  resultAds.push(new Ad(ad.firstName, ad.type, ad.userNumber, key));
                });
                this.data = resultAds;
                console.log('data', this.data);
                return _context.abrupt("return", this.data);

              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](1);
                throw _context.t0;

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 14]]);
      }));

      function fetchAds() {
        return _fetchAds.apply(this, arguments);
      }

      return fetchAds;
    }()
  }, {
    key: "createAd",
    value: function () {
      var _createAd = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(payload) {
        var newAd, ad;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                newAd = new Ad(payload.firstName, payload.type, payload.userNumber);
                _context2.prev = 1;
                _context2.next = 4;
                return firebase_app__WEBPACK_IMPORTED_MODULE_0___default.a.database().ref('users').push(newAd);

              case 4:
                ad = _context2.sent;
                _context2.next = 10;
                break;

              case 7:
                _context2.prev = 7;
                _context2.t0 = _context2["catch"](1);
                throw _context2.t0;

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 7]]);
      }));

      function createAd(_x) {
        return _createAd.apply(this, arguments);
      }

      return createAd;
    }()
  }, {
    key: "deleteAd",
    value: function () {
      var _deleteAd = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(id) {
        var ad;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return firebase_app__WEBPACK_IMPORTED_MODULE_0___default.a.database().ref('users').child(id).remove();

              case 3:
                ad = _context3.sent;
                _context3.next = 9;
                break;

              case 6:
                _context3.prev = 6;
                _context3.t0 = _context3["catch"](0);
                throw _context3.t0;

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 6]]);
      }));

      function deleteAd(_x2) {
        return _deleteAd.apply(this, arguments);
      }

      return deleteAd;
    }()
  }, {
    key: "updateAd",
    value: function () {
      var _updateAd = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(id, payload) {
        var ad;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return firebase_app__WEBPACK_IMPORTED_MODULE_0___default.a.database().ref('users').child(id).update(payload);

              case 3:
                ad = _context4.sent;
                _context4.next = 9;
                break;

              case 6:
                _context4.prev = 6;
                _context4.t0 = _context4["catch"](0);
                throw _context4.t0;

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 6]]);
      }));

      function updateAd(_x3, _x4) {
        return _updateAd.apply(this, arguments);
      }

      return updateAd;
    }()
  }]);

  return DataService;
}();

var instance = new DataService();
/* harmony default export */ __webpack_exports__["default"] = (instance);

/***/ }),

/***/ "./js/general/js/validators.js":
/*!*************************************!*\
  !*** ./js/general/js/validators.js ***!
  \*************************************/
/*! exports provided: Validators, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Validators", function() { return Validators; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Validators =
/*#__PURE__*/
function () {
  function Validators() {
    _classCallCheck(this, Validators);

    this.validationName = function (name) {
      if (name.length > 255) {
        return false;
      }

      return true;
    };

    this.validationUserNumber = function (number) {
      if (number.length !== 13) {
        return false;
      }

      return true;
    };

    this.getMessage = function (node, value) {
      var message = '';

      if (value === 'userNumber') {
        message = '  ';
      } else {
        message = ' .      255.';
      }

      node.nextElementSibling.innerHTML = message;
    };
  }

  _createClass(Validators, [{
    key: "required",
    value: function required(el, value, nodes) {
      var _this = this;

      var isValid = true;
      var nameLength = true;
      var userNumberState = true;
      Object.keys(nodes).forEach(function (n) {
        nodes[n].nextElementSibling.innerHTML = '';
      });
      Object.keys(value).forEach(function (v) {
        if (value[v] === '') {
          _this.getMessage(nodes[v], v);

          isValid = false;
        }

        if (v === 'name') {
          nameLength = _this.validationName(value[v]);

          if (!nameLength) {
            _this.getMessage(nodes[v], v);

            isValid = false;
          }
        }

        if (v === 'userNumber') {
          userNumberState = _this.validationUserNumber(value[v]);

          if (!userNumberState) {
            _this.getMessage(nodes[v], v);

            isValid = false;
          }
        }
      });
      return isValid;
    }
  }]);

  return Validators;
}();
var instance = new Validators();
/* harmony default export */ __webpack_exports__["default"] = (instance);

/***/ }),

/***/ 0:
/*!************************************!*\
  !*** multi babel-polyfill ./index ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! babel-polyfill */"../node_modules/babel-polyfill/lib/index.js");
module.exports = __webpack_require__(/*! ./index */"./index.js");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lcnJvcnMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9maXJlYmFzZUFwcC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2ZpcmViYXNlTmFtZXNwYWNlQ29yZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2ZpcmViYXNlTmFtZXNwYWNlLnRzIiwid2VicGFjazovLy8uLi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc3RvcmFnZS9ET01TdG9yYWdlV3JhcHBlci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc3RvcmFnZS9NZW1vcnlTdG9yYWdlLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9zdG9yYWdlL3N0b3JhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3V0aWwvdXRpbC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdXRpbC9QYXRoLnRzIiwid2VicGFjazovLy8uLi9zcmMvcmVhbHRpbWUvQ29uc3RhbnRzLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9SZXBvSW5mby50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdXRpbC9saWJzL3BhcnNlci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdXRpbC92YWxpZGF0aW9uLnRzIiwid2VicGFjazovLy8uLi9zcmMvYXBpL29uRGlzY29ubmVjdC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2FwaS9UcmFuc2FjdGlvblJlc3VsdC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdXRpbC9OZXh0UHVzaElkLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9zbmFwL05vZGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3NuYXAvaW5kZXhlcy9JbmRleC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc25hcC9pbmRleGVzL0tleUluZGV4LnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9zbmFwL3NuYXAudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3NuYXAvTGVhZk5vZGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4LnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS91dGlsL1NvcnRlZE1hcC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc25hcC9jaGlsZFNldC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc25hcC9JbmRleE1hcC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc25hcC9jb21wYXJhdG9ycy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc25hcC9DaGlsZHJlbk5vZGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3NuYXAvbm9kZUZyb21KU09OLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9zbmFwL2luZGV4ZXMvVmFsdWVJbmRleC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc25hcC9pbmRleGVzL1BhdGhJbmRleC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2FwaS9EYXRhU25hcHNob3QudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3ZpZXcvRXZlbnQudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3ZpZXcvRXZlbnRSZWdpc3RyYXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9hcGkvUXVlcnkudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3V0aWwvQ291bnRlZFNldC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvU3BhcnNlU25hcHNob3RUcmVlLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS91dGlsL1NlcnZlclZhbHVlcy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvb3BlcmF0aW9uL09wZXJhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvb3BlcmF0aW9uL0Fja1VzZXJXcml0ZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdXRpbC9JbW11dGFibGVUcmVlLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9vcGVyYXRpb24vTGlzdGVuQ29tcGxldGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL29wZXJhdGlvbi9PdmVyd3JpdGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL29wZXJhdGlvbi9NZXJnZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdmlldy9DYWNoZU5vZGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3ZpZXcvVmlld0NhY2hlLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS92aWV3L0NoYW5nZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdmlldy9maWx0ZXIvSW5kZXhlZEZpbHRlci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdmlldy9DaGlsZENoYW5nZUFjY3VtdWxhdG9yLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS92aWV3L0NvbXBsZXRlQ2hpbGRTb3VyY2UudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3ZpZXcvVmlld1Byb2Nlc3Nvci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdmlldy9FdmVudEdlbmVyYXRvci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdmlldy9WaWV3LnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9TeW5jUG9pbnQudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL0NvbXBvdW5kV3JpdGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL1dyaXRlVHJlZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvU3luY1RyZWUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL1NuYXBzaG90SG9sZGVyLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9BdXRoVG9rZW5Qcm92aWRlci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc3RhdHMvU3RhdHNDb2xsZWN0aW9uLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9zdGF0cy9TdGF0c01hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3N0YXRzL1N0YXRzTGlzdGVuZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3N0YXRzL1N0YXRzUmVwb3J0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3ZpZXcvRXZlbnRRdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdXRpbC9FdmVudEVtaXR0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3V0aWwvVmlzaWJpbGl0eU1vbml0b3IudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3V0aWwvT25saW5lTW9uaXRvci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3JlYWx0aW1lL3BvbGxpbmcvUGFja2V0UmVjZWl2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9yZWFsdGltZS9Ccm93c2VyUG9sbENvbm5lY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9yZWFsdGltZS9XZWJTb2NrZXRDb25uZWN0aW9uLnRzIiwid2VicGFjazovLy8uLi9zcmMvcmVhbHRpbWUvVHJhbnNwb3J0TWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3JlYWx0aW1lL0Nvbm5lY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL1NlcnZlckFjdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL1BlcnNpc3RlbnRDb25uZWN0aW9uLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9SZWFkb25seVJlc3RDbGllbnQudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL1JlcG8udHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3ZpZXcvZmlsdGVyL1JhbmdlZEZpbHRlci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdmlldy9maWx0ZXIvTGltaXRlZEZpbHRlci50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvdmlldy9RdWVyeVBhcmFtcy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2FwaS9SZWZlcmVuY2UudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL3V0aWwvVHJlZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvUmVwb190cmFuc2FjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvUmVwb01hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9hcGkvRGF0YWJhc2UudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9hcGkvaW50ZXJuYWwudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9hcGkvdGVzdF9hY2Nlc3MudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sb2dnZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9hc3NlcnQudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jcnlwdC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2RlZXBDb3B5LnRzIiwid2VicGFjazovLy8uLi9zcmMvZGVmZXJyZWQudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnZpcm9ubWVudC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2pzb24udHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9qd3QudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9vYmoudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9xdWVyeS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3NoYTEudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9zdWJzY3JpYmUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy92YWxpZGF0aW9uLnRzIiwid2VicGFjazovLy8uLi9zcmMvdXRmOC50cyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGF0dGVuLWludG8tYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZnVuY3Rpb24tdG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWZyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdXNlci1hZ2VudC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubWFwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVncmVlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5mc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkaWFucy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zaWduYml0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0Lm9mLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLm9mLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Nsb25lRGVlcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNNYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU2V0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvdXNlcnMvc2Nzcy9pbmRleC5zY3NzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzPzQyMDYiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9pc0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRQYXJlbnROb2RlLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvaXNJRS5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2lzT2Zmc2V0Q29udGFpbmVyLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZ2V0Um9vdC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2ZpbmRDb21tb25PZmZzZXRQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9pbmNsdWRlU2Nyb2xsLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZ2V0Qm9yZGVyc1NpemUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRXaW5kb3dTaXplcy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldENsaWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9pc0ZpeGVkLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldEJvdW5kYXJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldFJlZmVyZW5jZU9mZnNldHMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRPdXRlclNpemVzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRQb3BwZXJPZmZzZXRzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL3J1bk1vZGlmaWVycy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21ldGhvZHMvdXBkYXRlLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvaXNNb2RpZmllckVuYWJsZWQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tZXRob2RzL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRXaW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9zZXR1cEV2ZW50TGlzdGVuZXJzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbWV0aG9kcy9lbmFibGVFdmVudExpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL3JlbW92ZUV2ZW50TGlzdGVuZXJzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbWV0aG9kcy9kaXNhYmxlRXZlbnRMaXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9pc051bWVyaWMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9zZXRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9zZXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbW9kaWZpZXJzL2FwcGx5U3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRSb3VuZGVkT2Zmc2V0cy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21vZGlmaWVycy9jb21wdXRlU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9pc01vZGlmaWVyUmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tb2RpZmllcnMvYXJyb3cuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21ldGhvZHMvcGxhY2VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2Nsb2Nrd2lzZS5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21vZGlmaWVycy9mbGlwLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbW9kaWZpZXJzL2tlZXBUb2dldGhlci5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21vZGlmaWVycy9vZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbW9kaWZpZXJzL3NoaWZ0LmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbW9kaWZpZXJzL2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tb2RpZmllcnMvaW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tb2RpZmllcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tZXRob2RzL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL2Jyb3dzZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9wcm9wcy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3BvbnlmaWxscy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2JpbmRHbG9iYWxFdmVudExpc3RlbmVycy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3JlZmVyZW5jZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzLnRzIiwid2VicGFjazovLy8uLi9zcmMvcG9wcGVyLnRzIiwid2VicGFjazovLy8uLi9zcmMvY3JlYXRlVGlwcHkudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9ncm91cC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2luZGV4LnRzIiwid2VicGFjazovLy8uLi9zcmMvY3NzLnRzIiwid2VicGFjazovLy8uLi9idWlsZC9hbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3VzZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvdXNlcnMvanMvdGVtcGxhdGVzLmpzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvdXNlcnMvanMvdXNlcnMuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvdXNlcnMvc2Nzcy9pbmRleC5zY3NzPzYwZjYiLCJ3ZWJwYWNrOi8vLy4vanMvZ2VuZXJhbC9qcy9kYXRhLXNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvZ2VuZXJhbC9qcy92YWxpZGF0b3JzLmpzIl0sIm5hbWVzIjpbIkVycm9yRmFjdG9yeSIsImRlZXBDb3B5IiwiZGVlcEV4dGVuZCIsImNvbnRhaW5zIiwiTG9nZ2VyIiwiaXNCcm93c2VyIiwiaXNOb2RlIiwic3RyaW5naWZ5IiwianNvbkV2YWwiLCJzdHJpbmdUb0J5dGVBcnJheSIsIlNoYTEiLCJiYXNlNjQiLCJhc3NlcnQiLCJMb2dMZXZlbCIsImlzTm9kZVNkayIsImZvckVhY2giLCJzdHJpbmdMZW5ndGgiLCJlcnJvclByZWZpeEZ4biIsInZhbGlkYXRlQXJnQ291bnQiLCJ2YWxpZGF0ZUNhbGxiYWNrIiwiRGVmZXJyZWQiLCJhc3NlcnRpb25FcnJvciIsIk1BWF9OT0RFIiwic2V0TWF4Tm9kZSIsInNhZmVHZXQiLCJjbG9uZSIsIm1hcCIsInNldFByaW9yaXR5TWF4Tm9kZSIsIm5vZGVGcm9tSlNPTiIsImdldENvdW50IiwiZ2V0QW55S2V5IiwiZXZlcnkiLCJ2YWxpZGF0ZUNvbnRleHRPYmplY3QiLCJlcnJvclByZWZpeCIsImlzRW1wdHkiLCJnZXRWYWx1ZXMiLCJfX3JlZmVyZW5jZUNvbnN0cnVjdG9yIiwiZmluZFZhbHVlIiwiZmluZEtleSIsImlzTW9iaWxlQ29yZG92YSIsImJhc2U2NEVuY29kZSIsIkVOVl9DT05TVEFOVFMiLCJpc0FkbWluIiwiaXNWYWxpZEZvcm1hdCIsIkNPTlNUQU5UUyIsImlzUmVhY3ROYXRpdmUiLCJxdWVyeXN0cmluZyIsInJlcXVpcmUiLCJnbG9iYWwiLCJfYmFiZWxQb2x5ZmlsbCIsIkVycm9yIiwiREVGSU5FX1BST1BFUlRZIiwiZGVmaW5lIiwiTyIsImtleSIsInZhbHVlIiwiT2JqZWN0Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJTdHJpbmciLCJwcm90b3R5cGUiLCJwYWRTdGFydCIsInBhZEVuZCIsInNwbGl0IiwiQXJyYXkiLCJGdW5jdGlvbiIsImNhbGwiLCJiaW5kIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlZ0V4cCIsImVzY2FwZSIsIml0IiwiVHlwZUVycm9yIiwiY29mIiwibXNnIiwiVU5TQ09QQUJMRVMiLCJBcnJheVByb3RvIiwidW5kZWZpbmVkIiwiYXQiLCJTIiwiaW5kZXgiLCJ1bmljb2RlIiwibGVuZ3RoIiwiQ29uc3RydWN0b3IiLCJuYW1lIiwiZm9yYmlkZGVuRmllbGQiLCJpc09iamVjdCIsInRvT2JqZWN0IiwidG9BYnNvbHV0ZUluZGV4IiwidG9MZW5ndGgiLCJjb3B5V2l0aGluIiwidGFyZ2V0Iiwic3RhcnQiLCJsZW4iLCJ0byIsImZyb20iLCJlbmQiLCJhcmd1bWVudHMiLCJjb3VudCIsIk1hdGgiLCJtaW4iLCJpbmMiLCJmaWxsIiwiYUxlbiIsImVuZFBvcyIsImZvck9mIiwiaXRlciIsIklURVJBVE9SIiwicmVzdWx0IiwicHVzaCIsInRvSU9iamVjdCIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJlbCIsImZyb21JbmRleCIsImN0eCIsIklPYmplY3QiLCJhc2MiLCJUWVBFIiwiJGNyZWF0ZSIsIklTX01BUCIsIklTX0ZJTFRFUiIsIklTX1NPTUUiLCJJU19FVkVSWSIsIklTX0ZJTkRfSU5ERVgiLCJOT19IT0xFUyIsImNyZWF0ZSIsImNhbGxiYWNrZm4iLCJ0aGF0Iiwic2VsZiIsImYiLCJ2YWwiLCJyZXMiLCJhRnVuY3Rpb24iLCJtZW1vIiwiaXNSaWdodCIsImkiLCJpc0FycmF5IiwiU1BFQ0lFUyIsIm9yaWdpbmFsIiwiQyIsImNvbnN0cnVjdG9yIiwic3BlY2llc0NvbnN0cnVjdG9yIiwiaW52b2tlIiwiYXJyYXlTbGljZSIsInNsaWNlIiwiZmFjdG9yaWVzIiwiY29uc3RydWN0IiwiRiIsImFyZ3MiLCJuIiwiam9pbiIsImZuIiwicGFydEFyZ3MiLCJib3VuZCIsImNvbmNhdCIsIlRBRyIsIkFSRyIsInRyeUdldCIsImUiLCJUIiwiQiIsImNhbGxlZSIsInRvU3RyaW5nIiwiZFAiLCJyZWRlZmluZUFsbCIsImFuSW5zdGFuY2UiLCIkaXRlckRlZmluZSIsInN0ZXAiLCJzZXRTcGVjaWVzIiwiREVTQ1JJUFRPUlMiLCJmYXN0S2V5IiwidmFsaWRhdGUiLCJTSVpFIiwiZ2V0RW50cnkiLCJlbnRyeSIsIl9pIiwiX2YiLCJrIiwiZ2V0Q29uc3RydWN0b3IiLCJ3cmFwcGVyIiwiTkFNRSIsIkFEREVSIiwiaXRlcmFibGUiLCJfdCIsIl9sIiwiY2xlYXIiLCJkYXRhIiwiciIsInAiLCJuZXh0IiwicHJldiIsInYiLCJoYXMiLCJnZXQiLCJkZWYiLCJzZXRTdHJvbmciLCJpdGVyYXRlZCIsImtpbmQiLCJfayIsImNsYXNzb2YiLCJ0b0pTT04iLCJnZXRXZWFrIiwiYW5PYmplY3QiLCJjcmVhdGVBcnJheU1ldGhvZCIsIiRoYXMiLCJhcnJheUZpbmQiLCJhcnJheUZpbmRJbmRleCIsImlkIiwidW5jYXVnaHRGcm96ZW5TdG9yZSIsIlVuY2F1Z2h0RnJvemVuU3RvcmUiLCJhIiwiZmluZFVuY2F1Z2h0RnJvemVuIiwic3RvcmUiLCJzZXQiLCJzcGxpY2UiLCJ1ZnN0b3JlIiwiJGV4cG9ydCIsInJlZGVmaW5lIiwibWV0YSIsImZhaWxzIiwiJGl0ZXJEZXRlY3QiLCJzZXRUb1N0cmluZ1RhZyIsImluaGVyaXRJZlJlcXVpcmVkIiwibWV0aG9kcyIsImNvbW1vbiIsIklTX1dFQUsiLCJCYXNlIiwicHJvdG8iLCJmaXhNZXRob2QiLCJLRVkiLCJhZGQiLCJiIiwiZW50cmllcyIsIk5FRUQiLCJpbnN0YW5jZSIsIkhBU05UX0NIQUlOSU5HIiwiVEhST1dTX09OX1BSSU1JVElWRVMiLCJBQ0NFUFRfSVRFUkFCTEVTIiwiQlVHR1lfWkVSTyIsIiRpbnN0YW5jZSIsIkciLCJXIiwiY29yZSIsInZlcnNpb24iLCJfX2UiLCIkZGVmaW5lUHJvcGVydHkiLCJjcmVhdGVEZXNjIiwib2JqZWN0IiwiYyIsImFwcGx5IiwiZ2V0VGltZSIsIkRhdGUiLCIkdG9JU09TdHJpbmciLCJ0b0lTT1N0cmluZyIsImx6IiwibnVtIiwiTmFOIiwiaXNGaW5pdGUiLCJSYW5nZUVycm9yIiwiZCIsInkiLCJnZXRVVENGdWxsWWVhciIsIm0iLCJnZXRVVENNaWxsaXNlY29uZHMiLCJzIiwiYWJzIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsInRvUHJpbWl0aXZlIiwiTlVNQkVSIiwiaGludCIsImRlZmluZVByb3BlcnR5IiwiZG9jdW1lbnQiLCJpcyIsImNyZWF0ZUVsZW1lbnQiLCJnZXRLZXlzIiwiZ09QUyIsInBJRSIsImdldFN5bWJvbHMiLCJzeW1ib2xzIiwiaXNFbnVtIiwiaGlkZSIsIlBST1RPVFlQRSIsInR5cGUiLCJzb3VyY2UiLCJJU19GT1JDRUQiLCJJU19HTE9CQUwiLCJJU19TVEFUSUMiLCJJU19QUk9UTyIsIlAiLCJJU19CSU5EIiwiZXhwUHJvdG8iLCJvd24iLCJvdXQiLCJleHAiLCJVIiwiUiIsIk1BVENIIiwicmUiLCJleGVjIiwiZGVmaW5lZCIsIndrcyIsInJlZ2V4cEV4ZWMiLCJSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyIsImdyb3VwcyIsInJlcGxhY2UiLCJTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMiLCJvcmlnaW5hbEV4ZWMiLCJTWU1CT0wiLCJERUxFR0FURVNfVE9fU1lNQk9MIiwiREVMRUdBVEVTX1RPX0VYRUMiLCJleGVjQ2FsbGVkIiwibmF0aXZlUmVnRXhwTWV0aG9kIiwiZm5zIiwibWF5YmVDYWxsTmF0aXZlIiwibmF0aXZlTWV0aG9kIiwicmVnZXhwIiwic3RyIiwiYXJnMiIsImZvcmNlU3RyaW5nTWV0aG9kIiwiZG9uZSIsInN0cmZuIiwicnhmbiIsInN0cmluZyIsImFyZyIsImlnbm9yZUNhc2UiLCJtdWx0aWxpbmUiLCJzdGlja3kiLCJJU19DT05DQVRfU1BSRUFEQUJMRSIsImZsYXR0ZW5JbnRvQXJyYXkiLCJzb3VyY2VMZW4iLCJkZXB0aCIsIm1hcHBlciIsInRoaXNBcmciLCJ0YXJnZXRJbmRleCIsInNvdXJjZUluZGV4IiwibWFwRm4iLCJlbGVtZW50Iiwic3ByZWFkYWJsZSIsImlzQXJyYXlJdGVyIiwiZ2V0SXRlckZuIiwiQlJFQUsiLCJSRVRVUk4iLCJpdGVyRm4iLCJpdGVyYXRvciIsIndpbmRvdyIsIl9fZyIsImhhc093blByb3BlcnR5IiwiZG9jdW1lbnRFbGVtZW50Iiwic2V0UHJvdG90eXBlT2YiLCJ1biIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiSXRlcmF0b3JzIiwiZmxvb3IiLCJpc0ludGVnZXIiLCJpc1JlZ0V4cCIsInJldCIsImRlc2NyaXB0b3IiLCJJdGVyYXRvclByb3RvdHlwZSIsIkxJQlJBUlkiLCIkaXRlckNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwiQlVHR1kiLCJrZXlzIiwiRkZfSVRFUkFUT1IiLCJLRVlTIiwiVkFMVUVTIiwicmV0dXJuVGhpcyIsIkRFRkFVTFQiLCJJU19TRVQiLCJGT1JDRUQiLCJnZXRNZXRob2QiLCJ2YWx1ZXMiLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwic2tpcENsb3NpbmciLCJzYWZlIiwiYXJyIiwiJGV4cG0xIiwiZXhwbTEiLCJ4Iiwic2lnbiIsInBvdyIsIkVQU0lMT04iLCJFUFNJTE9OMzIiLCJNQVgzMiIsIk1JTjMyIiwicm91bmRUaWVzVG9FdmVuIiwiZnJvdW5kIiwiJGFicyIsIiRzaWduIiwiSW5maW5pdHkiLCJsb2cxcCIsImxvZyIsInNjYWxlIiwiaW5Mb3ciLCJpbkhpZ2giLCJvdXRMb3ciLCJvdXRIaWdoIiwiTUVUQSIsInNldERlc2MiLCJpc0V4dGVuc2libGUiLCJGUkVFWkUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNldE1ldGEiLCJ3Iiwib25GcmVlemUiLCJNYXAiLCJzaGFyZWQiLCJnZXRPckNyZWF0ZU1ldGFkYXRhTWFwIiwidGFyZ2V0S2V5IiwidGFyZ2V0TWV0YWRhdGEiLCJrZXlNZXRhZGF0YSIsIm9yZGluYXJ5SGFzT3duTWV0YWRhdGEiLCJNZXRhZGF0YUtleSIsIm1ldGFkYXRhTWFwIiwib3JkaW5hcnlHZXRPd25NZXRhZGF0YSIsIm9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEiLCJNZXRhZGF0YVZhbHVlIiwib3JkaW5hcnlPd25NZXRhZGF0YUtleXMiLCJfIiwidG9NZXRhS2V5IiwibWFjcm90YXNrIiwiT2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsInByb2Nlc3MiLCJQcm9taXNlIiwiaGVhZCIsImxhc3QiLCJub3RpZnkiLCJmbHVzaCIsInBhcmVudCIsImRvbWFpbiIsImV4aXQiLCJlbnRlciIsIm5leHRUaWNrIiwibmF2aWdhdG9yIiwic3RhbmRhbG9uZSIsInRvZ2dsZSIsIm5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwicmVzb2x2ZSIsInByb21pc2UiLCJ0aGVuIiwidGFzayIsIlByb21pc2VDYXBhYmlsaXR5IiwicmVqZWN0IiwiJCRyZXNvbHZlIiwiJCRyZWplY3QiLCIkYXNzaWduIiwiYXNzaWduIiwiQSIsIlN5bWJvbCIsIksiLCJqIiwiZFBzIiwiZW51bUJ1Z0tleXMiLCJJRV9QUk9UTyIsIkVtcHR5IiwiY3JlYXRlRGljdCIsImlmcmFtZSIsImx0IiwiZ3QiLCJpZnJhbWVEb2N1bWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwic3JjIiwiY29udGVudFdpbmRvdyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwiUHJvcGVydGllcyIsIklFOF9ET01fREVGSU5FIiwiQXR0cmlidXRlcyIsImRlZmluZVByb3BlcnRpZXMiLCJyYW5kb20iLCJfX2RlZmluZVNldHRlcl9fIiwiZ09QRCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdPUE4iLCJ3aW5kb3dOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRXaW5kb3dOYW1lcyIsIiRrZXlzIiwiaGlkZGVuS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIk9iamVjdFByb3RvIiwiYXJyYXlJbmRleE9mIiwibmFtZXMiLCJpc0VudHJpZXMiLCJSZWZsZWN0Iiwib3duS2V5cyIsIiRwYXJzZUZsb2F0IiwicGFyc2VGbG9hdCIsIiR0cmltIiwidHJpbSIsImNoYXJBdCIsIiRwYXJzZUludCIsInBhcnNlSW50Iiwid3MiLCJoZXgiLCJyYWRpeCIsInRlc3QiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eSIsInByb21pc2VDYXBhYmlsaXR5IiwiYml0bWFwIiwiZW51bWVyYWJsZSIsIlNSQyIsIiR0b1N0cmluZyIsIlRPX1NUUklORyIsIlRQTCIsImluc3BlY3RTb3VyY2UiLCJpc0Z1bmN0aW9uIiwiYnVpbHRpbkV4ZWMiLCJyZWdleHBGbGFncyIsIm5hdGl2ZUV4ZWMiLCJuYXRpdmVSZXBsYWNlIiwicGF0Y2hlZEV4ZWMiLCJMQVNUX0lOREVYIiwiVVBEQVRFU19MQVNUX0lOREVYX1dST05HIiwicmUxIiwicmUyIiwiTlBDR19JTkNMVURFRCIsIlBBVENIIiwibGFzdEluZGV4IiwicmVDb3B5IiwibWF0Y2giLCJyZWdFeHAiLCJyZXBsYWNlciIsInBhcnQiLCJDT0xMRUNUSU9OIiwibWFwcGluZyIsImNiIiwibmV4dEl0ZW0iLCJvZiIsImNoZWNrIiwiYnVnZ3kiLCJfX3Byb3RvX18iLCJ0YWciLCJzdGF0IiwidWlkIiwiU0hBUkVEIiwibW9kZSIsImNvcHlyaWdodCIsIkQiLCJtZXRob2QiLCJ0b0ludGVnZXIiLCJwb3MiLCJsIiwiY2hhckNvZGVBdCIsInNlYXJjaFN0cmluZyIsInF1b3QiLCJjcmVhdGVIVE1MIiwiYXR0cmlidXRlIiwicDEiLCJ0b0xvd2VyQ2FzZSIsInJlcGVhdCIsIm1heExlbmd0aCIsImZpbGxTdHJpbmciLCJsZWZ0IiwiZmlsbFN0ciIsImludE1heExlbmd0aCIsImZpbGxMZW4iLCJzdHJpbmdGaWxsZXIiLCJjZWlsIiwic3BhY2VzIiwic3BhY2UiLCJub24iLCJsdHJpbSIsInJ0cmltIiwiZXhwb3J0ZXIiLCJBTElBUyIsIkZPUkNFIiwiaHRtbCIsImNlbCIsInNldFRhc2siLCJzZXRJbW1lZGlhdGUiLCJjbGVhclRhc2siLCJjbGVhckltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiRGlzcGF0Y2giLCJjb3VudGVyIiwicXVldWUiLCJPTlJFQURZU1RBVEVDSEFOR0UiLCJkZWZlciIsImNoYW5uZWwiLCJwb3J0IiwicnVuIiwibGlzdGVuZXIiLCJldmVudCIsIm5vdyIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbXBvcnRTY3JpcHRzIiwicmVtb3ZlQ2hpbGQiLCJzZXRUaW1lb3V0IiwibWF4IiwibnVtYmVyIiwiaXNOYU4iLCJ2YWx1ZU9mIiwiJHR5cGVkIiwiJGJ1ZmZlciIsInByb3BlcnR5RGVzYyIsInRvSW5kZXgiLCJjcmVhdGVBcnJheUluY2x1ZGVzIiwiQXJyYXlJdGVyYXRvcnMiLCJhcnJheUZpbGwiLCJhcnJheUNvcHlXaXRoaW4iLCIkRFAiLCIkR09QRCIsIlVpbnQ4QXJyYXkiLCJBUlJBWV9CVUZGRVIiLCJTSEFSRURfQlVGRkVSIiwiQllURVNfUEVSX0VMRU1FTlQiLCIkQXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsIiREYXRhVmlldyIsIkRhdGFWaWV3IiwiYXJyYXlGb3JFYWNoIiwiYXJyYXlGaWx0ZXIiLCJhcnJheVNvbWUiLCJhcnJheUV2ZXJ5IiwiYXJyYXlJbmNsdWRlcyIsImFycmF5VmFsdWVzIiwiYXJyYXlLZXlzIiwiYXJyYXlFbnRyaWVzIiwiYXJyYXlMYXN0SW5kZXhPZiIsImxhc3RJbmRleE9mIiwiYXJyYXlSZWR1Y2UiLCJyZWR1Y2UiLCJhcnJheVJlZHVjZVJpZ2h0IiwicmVkdWNlUmlnaHQiLCJhcnJheUpvaW4iLCJhcnJheVNvcnQiLCJzb3J0IiwiYXJyYXlUb1N0cmluZyIsImFycmF5VG9Mb2NhbGVTdHJpbmciLCJ0b0xvY2FsZVN0cmluZyIsIlRZUEVEX0NPTlNUUlVDVE9SIiwiREVGX0NPTlNUUlVDVE9SIiwiQUxMX0NPTlNUUlVDVE9SUyIsIkNPTlNUUiIsIlRZUEVEX0FSUkFZIiwiVFlQRUQiLCJWSUVXIiwiV1JPTkdfTEVOR1RIIiwiJG1hcCIsImFsbG9jYXRlIiwiTElUVExFX0VORElBTiIsIlVpbnQxNkFycmF5IiwiYnVmZmVyIiwiRk9SQ0VEX1NFVCIsInRvT2Zmc2V0IiwiQllURVMiLCJvZmZzZXQiLCJzcGVjaWVzRnJvbUxpc3QiLCJsaXN0IiwiZnJvbUxpc3QiLCJhZGRHZXR0ZXIiLCJpbnRlcm5hbCIsIl9kIiwiJGZyb20iLCJtYXBmbiIsIiRvZiIsIlRPX0xPQ0FMRV9CVUciLCIkdG9Mb2NhbGVTdHJpbmciLCJmaWx0ZXIiLCJmaW5kIiwicHJlZGljYXRlIiwiZmluZEluZGV4IiwiaW5kZXhPZiIsInNlYXJjaEVsZW1lbnQiLCJpbmNsdWRlcyIsInNlcGFyYXRvciIsInJldmVyc2UiLCJtaWRkbGUiLCJzb21lIiwiY29tcGFyZWZuIiwic3ViYXJyYXkiLCJiZWdpbiIsIiRiZWdpbiIsImJ5dGVPZmZzZXQiLCIkc2xpY2UiLCIkc2V0IiwiYXJyYXlMaWtlIiwiJGl0ZXJhdG9ycyIsImlzVEFJbmRleCIsIiRnZXREZXNjIiwiJHNldERlc2MiLCJkZXNjIiwiJFR5cGVkQXJyYXlQcm90b3R5cGUkIiwiQ0xBTVBFRCIsIkdFVFRFUiIsIlNFVFRFUiIsIlR5cGVkQXJyYXkiLCJUQUMiLCJBQlYiLCJUeXBlZEFycmF5UHJvdG90eXBlIiwiZ2V0dGVyIiwibyIsInNldHRlciIsInJvdW5kIiwiYWRkRWxlbWVudCIsIiRvZmZzZXQiLCIkbGVuZ3RoIiwiYnl0ZUxlbmd0aCIsImtsYXNzIiwiJGxlbiIsIiRuYXRpdmVJdGVyYXRvciIsIkNPUlJFQ1RfSVRFUl9OQU1FIiwiJGl0ZXJhdG9yIiwiREFUQV9WSUVXIiwiV1JPTkdfSU5ERVgiLCJCYXNlQnVmZmVyIiwiTE4yIiwiQlVGRkVSIiwiQllURV9MRU5HVEgiLCJCWVRFX09GRlNFVCIsIiRCVUZGRVIiLCIkTEVOR1RIIiwiJE9GRlNFVCIsInBhY2tJRUVFNzU0IiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJydCIsInVucGFja0lFRUU3NTQiLCJuQml0cyIsInVucGFja0kzMiIsImJ5dGVzIiwicGFja0k4IiwicGFja0kxNiIsInBhY2tJMzIiLCJwYWNrRjY0IiwicGFja0YzMiIsInZpZXciLCJpc0xpdHRsZUVuZGlhbiIsIm51bUluZGV4IiwiaW50SW5kZXgiLCJfYiIsInBhY2siLCJjb252ZXJzaW9uIiwiYnVmZmVyTGVuZ3RoIiwiZ2V0SW50OCIsImdldFVpbnQ4IiwiZ2V0SW50MTYiLCJnZXRVaW50MTYiLCJnZXRJbnQzMiIsImdldFVpbnQzMiIsImdldEZsb2F0MzIiLCJnZXRGbG9hdDY0Iiwic2V0SW50OCIsInNldFVpbnQ4Iiwic2V0SW50MTYiLCJzZXRVaW50MTYiLCJzZXRJbnQzMiIsInNldFVpbnQzMiIsInNldEZsb2F0MzIiLCJzZXRGbG9hdDY0IiwiQXJyYXlCdWZmZXJQcm90byIsIiRzZXRJbnQ4IiwiVHlwZWQiLCJUeXBlZEFycmF5Q29uc3RydWN0b3JzIiwicHgiLCJ1c2VyQWdlbnQiLCJ3a3NFeHQiLCIkU3ltYm9sIiwiVVNFX1NZTUJPTCIsIiRleHBvcnRzIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCIkcmUiLCIkZXZlcnkiLCIkZmlsdGVyIiwiJGZpbmQiLCJmb3JjZWQiLCIkZm9yRWFjaCIsIlNUUklDVCIsImNyZWF0ZVByb3BlcnR5IiwiJGluZGV4T2YiLCJORUdBVElWRV9aRVJPIiwiYWRkVG9VbnNjb3BhYmxlcyIsIkFyZ3VtZW50cyIsIiRyZWR1Y2UiLCJ1cFRvIiwic2l6ZSIsImNsb25lZCIsIiRzb21lIiwiJHNvcnQiLCJwdiIsIlRPX1BSSU1JVElWRSIsIkRhdGVQcm90byIsIklOVkFMSURfREFURSIsIkhBU19JTlNUQU5DRSIsIkZ1bmN0aW9uUHJvdG8iLCJGUHJvdG8iLCJuYW1lUkUiLCJzdHJvbmciLCJNQVAiLCJzcXJ0IiwiJGFjb3NoIiwiYWNvc2giLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCIkYXNpbmgiLCJhc2luaCIsIiRhdGFuaCIsImF0YW5oIiwiY2JydCIsImNsejMyIiwiTE9HMkUiLCJjb3NoIiwiaHlwb3QiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJzdW0iLCJsYXJnIiwiZGl2IiwiJGltdWwiLCJpbXVsIiwiVUlOVDE2IiwieG4iLCJ5biIsInhsIiwieWwiLCJsb2cxMCIsIkxPRzEwRSIsImxvZzIiLCJzaW5oIiwiRSIsInRhbmgiLCJ0cnVuYyIsIiROdW1iZXIiLCJCUk9LRU5fQ09GIiwiVFJJTSIsInRvTnVtYmVyIiwiYXJndW1lbnQiLCJmaXJzdCIsInRoaXJkIiwibWF4Q29kZSIsImRpZ2l0cyIsImNvZGUiLCJfaXNGaW5pdGUiLCJpc1NhZmVJbnRlZ2VyIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJhTnVtYmVyVmFsdWUiLCIkdG9GaXhlZCIsInRvRml4ZWQiLCJFUlJPUiIsIlpFUk8iLCJtdWx0aXBseSIsImMyIiwiZGl2aWRlIiwibnVtVG9TdHJpbmciLCJ0IiwiYWNjIiwieDIiLCJmcmFjdGlvbkRpZ2l0cyIsInoiLCIkZmFpbHMiLCIkdG9QcmVjaXNpb24iLCJ0b1ByZWNpc2lvbiIsInByZWNpc2lvbiIsIiRmcmVlemUiLCJmcmVlemUiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiJGdldFByb3RvdHlwZU9mIiwiJGlzRXh0ZW5zaWJsZSIsIiRpc0Zyb3plbiIsImlzRnJvemVuIiwiJGlzU2VhbGVkIiwiaXNTZWFsZWQiLCIkcHJldmVudEV4dGVuc2lvbnMiLCIkc2VhbCIsInNlYWwiLCJtaWNyb3Rhc2siLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSIsInBlcmZvcm0iLCJwcm9taXNlUmVzb2x2ZSIsIlBST01JU0UiLCJ2ZXJzaW9ucyIsInY4IiwiJFByb21pc2UiLCJlbXB0eSIsIkludGVybmFsIiwibmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5IiwiT3duUHJvbWlzZUNhcGFiaWxpdHkiLCJXcmFwcGVyIiwiVVNFX05BVElWRSIsIkZha2VQcm9taXNlIiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50IiwiaXNUaGVuYWJsZSIsImlzUmVqZWN0IiwiX24iLCJjaGFpbiIsIl9jIiwiX3YiLCJvayIsIl9zIiwicmVhY3Rpb24iLCJoYW5kbGVyIiwiZmFpbCIsImV4aXRlZCIsIl9oIiwib25IYW5kbGVVbmhhbmRsZWQiLCJvblVuaGFuZGxlZCIsInVuaGFuZGxlZCIsImlzVW5oYW5kbGVkIiwiY29uc29sZSIsImVtaXQiLCJvbnVuaGFuZGxlZHJlamVjdGlvbiIsInJlYXNvbiIsImVycm9yIiwiX2EiLCJvbnJlamVjdGlvbmhhbmRsZWQiLCIkcmVqZWN0IiwiX3ciLCIkcmVzb2x2ZSIsImV4ZWN1dG9yIiwiZXJyIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiY2FwYWJpbGl0eSIsImFsbCIsInJlbWFpbmluZyIsIiRpbmRleCIsImFscmVhZHlDYWxsZWQiLCJyYWNlIiwickFwcGx5IiwiZkFwcGx5IiwidGhpc0FyZ3VtZW50IiwiYXJndW1lbnRzTGlzdCIsIkwiLCJyQ29uc3RydWN0IiwiTkVXX1RBUkdFVF9CVUciLCJBUkdTX0JVRyIsIlRhcmdldCIsIm5ld1RhcmdldCIsIiRhcmdzIiwicHJvcGVydHlLZXkiLCJhdHRyaWJ1dGVzIiwiZGVsZXRlUHJvcGVydHkiLCJFbnVtZXJhdGUiLCJlbnVtZXJhdGUiLCJnZXRQcm90byIsInJlY2VpdmVyIiwic2V0UHJvdG8iLCJWIiwib3duRGVzYyIsImV4aXN0aW5nRGVzY3JpcHRvciIsIiRmbGFncyIsIiRSZWdFeHAiLCJDT1JSRUNUX05FVyIsInRpUkUiLCJwaVJFIiwiZmlVIiwicHJveHkiLCJmbGFncyIsImFkdmFuY2VTdHJpbmdJbmRleCIsInJlZ0V4cEV4ZWMiLCIkbWF0Y2giLCJyeCIsImZ1bGxVbmljb2RlIiwibWF0Y2hTdHIiLCJTVUJTVElUVVRJT05fU1lNQk9MUyIsIlNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEIiwibWF5YmVUb1N0cmluZyIsIlJFUExBQ0UiLCIkcmVwbGFjZSIsInNlYXJjaFZhbHVlIiwicmVwbGFjZVZhbHVlIiwiZnVuY3Rpb25hbFJlcGxhY2UiLCJyZXN1bHRzIiwiYWNjdW11bGF0ZWRSZXN1bHQiLCJuZXh0U291cmNlUG9zaXRpb24iLCJtYXRjaGVkIiwicG9zaXRpb24iLCJjYXB0dXJlcyIsIm5hbWVkQ2FwdHVyZXMiLCJyZXBsYWNlckFyZ3MiLCJyZXBsYWNlbWVudCIsImdldFN1YnN0aXR1dGlvbiIsInRhaWxQb3MiLCJjaCIsImNhcHR1cmUiLCJzYW1lVmFsdWUiLCJTRUFSQ0giLCIkc2VhcmNoIiwic2VhcmNoIiwicHJldmlvdXNMYXN0SW5kZXgiLCJjYWxsUmVnRXhwRXhlYyIsIiRtaW4iLCIkcHVzaCIsIiRTUExJVCIsIkxFTkdUSCIsIk1BWF9VSU5UMzIiLCJTVVBQT1JUU19ZIiwiU1BMSVQiLCIkc3BsaXQiLCJpbnRlcm5hbFNwbGl0IiwibGltaXQiLCJvdXRwdXQiLCJsYXN0TGFzdEluZGV4Iiwic3BsaXRMaW1pdCIsInNlcGFyYXRvckNvcHkiLCJsYXN0TGVuZ3RoIiwic3BsaXR0ZXIiLCJ1bmljb2RlTWF0Y2hpbmciLCJsaW0iLCJxIiwiU0VUIiwiU2V0IiwiYW5jaG9yIiwiYmlnIiwiYmxpbmsiLCJib2xkIiwiJGF0IiwiY29kZVBvaW50QXQiLCJjb250ZXh0IiwiRU5EU19XSVRIIiwiJGVuZHNXaXRoIiwiZW5kc1dpdGgiLCJlbmRQb3NpdGlvbiIsImZpeGVkIiwiZm9udGNvbG9yIiwiY29sb3IiLCJmb250c2l6ZSIsImZyb21DaGFyQ29kZSIsIiRmcm9tQ29kZVBvaW50IiwiZnJvbUNvZGVQb2ludCIsIklOQ0xVREVTIiwiaXRhbGljcyIsInBvaW50IiwibGluayIsInVybCIsInJhdyIsImNhbGxTaXRlIiwidHBsIiwic21hbGwiLCJTVEFSVFNfV0lUSCIsIiRzdGFydHNXaXRoIiwic3RhcnRzV2l0aCIsInN0cmlrZSIsInN1YiIsInN1cCIsIndrc0RlZmluZSIsImVudW1LZXlzIiwiX2NyZWF0ZSIsImdPUE5FeHQiLCIkSlNPTiIsIkpTT04iLCJfc3RyaW5naWZ5IiwiSElEREVOIiwiU3ltYm9sUmVnaXN0cnkiLCJBbGxTeW1ib2xzIiwiT1BTeW1ib2xzIiwiUU9iamVjdCIsImZpbmRDaGlsZCIsInNldFN5bWJvbERlc2MiLCJwcm90b0Rlc2MiLCJ3cmFwIiwic3ltIiwiaXNTeW1ib2wiLCIkZGVmaW5lUHJvcGVydGllcyIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIiRnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiJGdldE93blByb3BlcnR5U3ltYm9scyIsIklTX09QIiwiZXM2U3ltYm9scyIsIndlbGxLbm93blN5bWJvbHMiLCJrZXlGb3IiLCJ1c2VTZXR0ZXIiLCJ1c2VTaW1wbGUiLCIkcmVwbGFjZXIiLCIkaXNWaWV3IiwiaXNWaWV3IiwiZmluIiwidmlld1MiLCJ2aWV3VCIsImluaXQiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkludDhBcnJheSIsIlVpbnQzMkFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJlYWNoIiwid2VhayIsIk5BVElWRV9XRUFLX01BUCIsIklTX0lFMTEiLCJBY3RpdmVYT2JqZWN0IiwiV0VBS19NQVAiLCJJbnRlcm5hbE1hcCIsIldlYWtNYXAiLCIkV2Vha01hcCIsIldFQUtfU0VUIiwiV2Vha1NldCIsImFycmF5U3BlY2llc0NyZWF0ZSIsImZsYXRNYXAiLCJmbGF0dGVuIiwiZGVwdGhBcmciLCIkaW5jbHVkZXMiLCJhc2FwIiwiaXNFcnJvciIsImNsYW1wIiwibG93ZXIiLCJ1cHBlciIsIkRFR19QRVJfUkFEIiwiUEkiLCJSQURfUEVSX0RFRyIsImRlZ3JlZXMiLCJyYWRpYW5zIiwiZnNjYWxlIiwiaWFkZGgiLCJ4MCIsIngxIiwieTAiLCJ5MSIsIiR4MCIsIiR4MSIsIiR5MCIsImltdWxoIiwidSIsIiR1IiwiJHYiLCJ1MCIsInYwIiwidTEiLCJ2MSIsImlzdWJoIiwic2lnbmJpdCIsInVtdWxoIiwiX19kZWZpbmVHZXR0ZXJfXyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJnZXREZXNjIiwiX19sb29rdXBHZXR0ZXJfXyIsIl9fbG9va3VwU2V0dGVyX18iLCIkdmFsdWVzIiwiT0JTRVJWQUJMRSIsImNsZWFudXBTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJjbGVhbnVwIiwic3Vic2NyaXB0aW9uQ2xvc2VkIiwiX28iLCJjbG9zZVN1YnNjcmlwdGlvbiIsIlN1YnNjcmlwdGlvbiIsIm9ic2VydmVyIiwic3Vic2NyaWJlciIsIlN1YnNjcmlwdGlvbk9ic2VydmVyIiwidW5zdWJzY3JpYmUiLCJjb21wbGV0ZSIsIiRPYnNlcnZhYmxlIiwiT2JzZXJ2YWJsZSIsInN1YnNjcmliZSIsIm9ic2VydmFibGUiLCJpdGVtcyIsIm9uRmluYWxseSIsIm1ldGFkYXRhIiwiZGVmaW5lTWV0YWRhdGEiLCJtZXRhZGF0YUtleSIsIm1ldGFkYXRhVmFsdWUiLCJkZWxldGVNZXRhZGF0YSIsIm9yZGluYXJ5TWV0YWRhdGFLZXlzIiwib0tleXMiLCJwS2V5cyIsImdldE1ldGFkYXRhS2V5cyIsIm9yZGluYXJ5R2V0TWV0YWRhdGEiLCJoYXNPd24iLCJnZXRNZXRhZGF0YSIsImdldE93bk1ldGFkYXRhS2V5cyIsImdldE93bk1ldGFkYXRhIiwib3JkaW5hcnlIYXNNZXRhZGF0YSIsImhhc01ldGFkYXRhIiwiaGFzT3duTWV0YWRhdGEiLCIkbWV0YWRhdGEiLCJkZWNvcmF0b3IiLCJnZXRGbGFncyIsIlJlZ0V4cFByb3RvIiwiJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yIiwiX3IiLCJtYXRjaEFsbCIsIiRwYWQiLCJ0cmltTGVmdCIsInRyaW1SaWdodCIsIlRPX1NUUklOR19UQUciLCJBcnJheVZhbHVlcyIsIkRPTUl0ZXJhYmxlcyIsIkNTU1J1bGVMaXN0IiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsIkNTU1ZhbHVlTGlzdCIsIkNsaWVudFJlY3RMaXN0IiwiRE9NUmVjdExpc3QiLCJET01TdHJpbmdMaXN0IiwiRE9NVG9rZW5MaXN0IiwiRGF0YVRyYW5zZmVySXRlbUxpc3QiLCJGaWxlTGlzdCIsIkhUTUxBbGxDb2xsZWN0aW9uIiwiSFRNTENvbGxlY3Rpb24iLCJIVE1MRm9ybUVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIk1lZGlhTGlzdCIsIk1pbWVUeXBlQXJyYXkiLCJOYW1lZE5vZGVNYXAiLCJOb2RlTGlzdCIsIlBhaW50UmVxdWVzdExpc3QiLCJQbHVnaW4iLCJQbHVnaW5BcnJheSIsIlNWR0xlbmd0aExpc3QiLCJTVkdOdW1iZXJMaXN0IiwiU1ZHUGF0aFNlZ0xpc3QiLCJTVkdQb2ludExpc3QiLCJTVkdTdHJpbmdMaXN0IiwiU1ZHVHJhbnNmb3JtTGlzdCIsIlNvdXJjZUJ1ZmZlckxpc3QiLCJTdHlsZVNoZWV0TGlzdCIsIlRleHRUcmFja0N1ZUxpc3QiLCJUZXh0VHJhY2tMaXN0IiwiVG91Y2hMaXN0IiwiY29sbGVjdGlvbnMiLCJleHBsaWNpdCIsIkNvbGxlY3Rpb24iLCIkdGFzayIsIk1TSUUiLCJ0aW1lIiwiYm91bmRBcmdzIiwic2V0SW50ZXJ2YWwiLCJnZXROYXRpdmUiLCJyb290IiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiU3RhY2siLCJfX2RhdGFfXyIsImFycmF5RWFjaCIsImFycmF5IiwiaXRlcmF0ZWUiLCJyZXNJbmRleCIsImJhc2VUaW1lcyIsImlzQXJndW1lbnRzIiwiaXNCdWZmZXIiLCJpc0luZGV4IiwiaXNUeXBlZEFycmF5Iiwib2JqZWN0UHJvdG8iLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiYXJyYXlQdXNoIiwiYmFzZUFzc2lnblZhbHVlIiwiZXEiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiYXNzb2NJbmRleE9mIiwiY29weU9iamVjdCIsImJhc2VBc3NpZ24iLCJrZXlzSW4iLCJiYXNlQXNzaWduSW4iLCJjbG9uZUJ1ZmZlciIsImNvcHlBcnJheSIsImNvcHlTeW1ib2xzIiwiY29weVN5bWJvbHNJbiIsImdldEFsbEtleXMiLCJnZXRBbGxLZXlzSW4iLCJnZXRUYWciLCJpbml0Q2xvbmVBcnJheSIsImluaXRDbG9uZUJ5VGFnIiwiaW5pdENsb25lT2JqZWN0IiwiaXNNYXAiLCJpc1NldCIsIkNMT05FX0RFRVBfRkxBRyIsIkNMT05FX0ZMQVRfRkxBRyIsIkNMT05FX1NZTUJPTFNfRkxBRyIsImFyZ3NUYWciLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwib2JqZWN0VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJjbG9uZWFibGVUYWdzIiwiYmFzZUNsb25lIiwiYml0bWFzayIsImN1c3RvbWl6ZXIiLCJzdGFjayIsImlzRGVlcCIsImlzRmxhdCIsImlzRnVsbCIsImlzRnVuYyIsInN0YWNrZWQiLCJzdWJWYWx1ZSIsImtleXNGdW5jIiwicHJvcHMiLCJvYmplY3RDcmVhdGUiLCJiYXNlQ3JlYXRlIiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3RMaWtlIiwiYmFzZUlzQXJndW1lbnRzIiwiYmFzZUlzTWFwIiwiaXNNYXNrZWQiLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJiYXNlSXNOYXRpdmUiLCJwYXR0ZXJuIiwiYmFzZUlzU2V0IiwiaXNMZW5ndGgiLCJ0eXBlZEFycmF5VGFncyIsImJhc2VJc1R5cGVkQXJyYXkiLCJpc1Byb3RvdHlwZSIsIm5hdGl2ZUtleXMiLCJiYXNlS2V5cyIsIm5hdGl2ZUtleXNJbiIsImJhc2VLZXlzSW4iLCJpc1Byb3RvIiwiYmFzZVVuYXJ5IiwiZnVuYyIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwiY29weSIsImNsb25lRGF0YVZpZXciLCJkYXRhVmlldyIsInJlRmxhZ3MiLCJjbG9uZVJlZ0V4cCIsInN5bWJvbFByb3RvIiwic3ltYm9sVmFsdWVPZiIsImNsb25lU3ltYm9sIiwic3ltYm9sIiwiY2xvbmVUeXBlZEFycmF5IiwidHlwZWRBcnJheSIsImlzTmV3IiwibmV3VmFsdWUiLCJnZXRTeW1ib2xzSW4iLCJjb3JlSnNEYXRhIiwiZnJlZUdsb2JhbCIsImlzS2V5YWJsZSIsImdldE1hcERhdGEiLCJnZXRWYWx1ZSIsIm92ZXJBcmciLCJnZXRQcm90b3R5cGUiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsImlzT3duIiwidW5tYXNrZWQiLCJzdHViQXJyYXkiLCJuYXRpdmVHZXRTeW1ib2xzIiwicHJvbWlzZVRhZyIsImRhdGFWaWV3Q3RvclN0cmluZyIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsIkN0b3IiLCJjdG9yU3RyaW5nIiwibmF0aXZlQ3JlYXRlIiwiSEFTSF9VTkRFRklORUQiLCJpbnB1dCIsInJlSXNVaW50IiwibWFza1NyY0tleSIsImFycmF5UHJvdG8iLCJwb3AiLCJmcmVlUHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJiaW5kaW5nIiwidHJhbnNmb3JtIiwiZnJlZVNlbGYiLCJMQVJHRV9BUlJBWV9TSVpFIiwicGFpcnMiLCJjbG9uZURlZXAiLCJvdGhlciIsImlzQXJyYXlMaWtlIiwic3R1YkZhbHNlIiwibmF0aXZlSXNCdWZmZXIiLCJhc3luY1RhZyIsInByb3h5VGFnIiwibm9kZUlzTWFwIiwibm9kZUlzU2V0Iiwibm9kZUlzVHlwZWRBcnJheSIsImxvbmdlclRpbWVvdXRCcm93c2VycyIsInRpbWVvdXREdXJhdGlvbiIsImNhbGxlZCIsInNjaGVkdWxlZCIsInN1cHBvcnRzTWljcm9UYXNrcyIsImdldFR5cGUiLCJmdW5jdGlvblRvQ2hlY2siLCJjc3MiLCJwcm9wZXJ0eSIsImdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZ2V0U2Nyb2xsUGFyZW50IiwiZ2V0UGFyZW50Tm9kZSIsImlzSUUxMSIsImlzSUUxMCIsIm5vT2Zmc2V0UGFyZW50IiwiaXNJRSIsIm9mZnNldFBhcmVudCIsIm5vZGVOYW1lIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZ2V0Um9vdCIsImVsZW1lbnQxIiwiZWxlbWVudDIiLCJvcmRlciIsIk5vZGUiLCJyYW5nZSIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwiaXNPZmZzZXRDb250YWluZXIiLCJlbGVtZW50MXJvb3QiLCJmaW5kQ29tbW9uT2Zmc2V0UGFyZW50Iiwic2lkZSIsInVwcGVyU2lkZSIsInNjcm9sbGluZ0VsZW1lbnQiLCJzdWJ0cmFjdCIsInNjcm9sbFRvcCIsImdldFNjcm9sbCIsInNjcm9sbExlZnQiLCJtb2RpZmllciIsInNpZGVBIiwiYXhpcyIsInNpZGVCIiwic3R5bGVzIiwiYm9keSIsImNvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0U2l6ZSIsIm9mZnNldHMiLCJoZWlnaHQiLCJyZWN0IiwidG9wIiwic2l6ZXMiLCJnZXRXaW5kb3dTaXplcyIsIndpZHRoIiwiaG9yaXpTY3JvbGxiYXIiLCJ2ZXJ0U2Nyb2xsYmFyIiwiZ2V0Qm9yZGVyc1NpemUiLCJnZXRDbGllbnRSZWN0IiwiZml4ZWRQb3NpdGlvbiIsInJ1bklzSUUiLCJpc0hUTUwiLCJjaGlsZHJlblJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYXJlbnRSZWN0Iiwic2Nyb2xsUGFyZW50IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJtYXJnaW5Ub3AiLCJtYXJnaW5MZWZ0IiwiaW5jbHVkZVNjcm9sbCIsImV4Y2x1ZGVTY3JvbGwiLCJyZWxhdGl2ZU9mZnNldCIsImdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSIsInBhcmVudE5vZGUiLCJpc0ZpeGVkIiwiYm91bmRhcmllcyIsImdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQiLCJib3VuZGFyaWVzRWxlbWVudCIsImdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZSIsImJvdW5kYXJpZXNOb2RlIiwicG9wcGVyIiwicGFkZGluZyIsImlzUGFkZGluZ051bWJlciIsInBsYWNlbWVudCIsImdldEJvdW5kYXJpZXMiLCJyZWN0cyIsInJlZlJlY3QiLCJib3R0b20iLCJzb3J0ZWRBcmVhcyIsImdldEFyZWEiLCJmaWx0ZXJlZEFyZWFzIiwiY29tcHV0ZWRQbGFjZW1lbnQiLCJ2YXJpYXRpb24iLCJjb21tb25PZmZzZXRQYXJlbnQiLCJoYXNoIiwicmlnaHQiLCJwb3BwZXJSZWN0IiwiZ2V0T3V0ZXJTaXplcyIsInBvcHBlck9mZnNldHMiLCJpc0hvcml6IiwibWFpblNpZGUiLCJzZWNvbmRhcnlTaWRlIiwibWVhc3VyZW1lbnQiLCJzZWNvbmRhcnlNZWFzdXJlbWVudCIsInJlZmVyZW5jZU9mZnNldHMiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImN1ciIsIm9iaiIsIm1vZGlmaWVyc1RvUnVuIiwiZW5kcyIsIm1vZGlmaWVycyIsImdldFJlZmVyZW5jZU9mZnNldHMiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsImdldFBvcHBlck9mZnNldHMiLCJydW5Nb2RpZmllcnMiLCJlbmFibGVkIiwicHJlZml4ZXMiLCJ1cHBlclByb3AiLCJwcmVmaXgiLCJ0b0NoZWNrIiwiaXNNb2RpZmllckVuYWJsZWQiLCJnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUiLCJvd25lckRvY3VtZW50IiwiaXNCb2R5IiwicGFzc2l2ZSIsInN0YXRlIiwic2Nyb2xsRWxlbWVudCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsInVuaXQiLCJpc051bWVyaWMiLCJvcHRpb25zIiwicmVmZXJlbmNlIiwibm9Sb3VuZCIsInJlZmVyZW5jZVdpZHRoIiwicG9wcGVyV2lkdGgiLCJpc1ZlcnRpY2FsIiwiaXNWYXJpYXRpb24iLCJzYW1lV2lkdGhQYXJpdHkiLCJib3RoT2RkV2lkdGgiLCJob3Jpem9udGFsVG9JbnRlZ2VyIiwidmVydGljYWxUb0ludGVnZXIiLCJpc0ZpcmVmb3giLCJsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24iLCJncHVBY2NlbGVyYXRpb24iLCJvZmZzZXRQYXJlbnRSZWN0IiwiZ2V0Um91bmRlZE9mZnNldHMiLCJwcmVmaXhlZFByb3BlcnR5IiwiaW52ZXJ0VG9wIiwiaW52ZXJ0TGVmdCIsInJlcXVlc3RpbmciLCJpc1JlcXVpcmVkIiwicmVxdWVzdGVkIiwiaXNNb2RpZmllclJlcXVpcmVkIiwiYXJyb3dFbGVtZW50Iiwic2lkZUNhcGl0YWxpemVkIiwiYWx0U2lkZSIsIm9wU2lkZSIsImFycm93RWxlbWVudFNpemUiLCJjZW50ZXIiLCJwb3BwZXJNYXJnaW5TaWRlIiwicG9wcGVyQm9yZGVyU2lkZSIsInNpZGVWYWx1ZSIsInZhbGlkUGxhY2VtZW50cyIsInBsYWNlbWVudHMiLCJCRUhBVklPUlMiLCJwbGFjZW1lbnRPcHBvc2l0ZSIsImZsaXBPcmRlciIsImNsb2Nrd2lzZSIsInJlZk9mZnNldHMiLCJvdmVybGFwc1JlZiIsIm92ZXJmbG93c0xlZnQiLCJvdmVyZmxvd3NSaWdodCIsIm92ZXJmbG93c1RvcCIsIm92ZXJmbG93c0JvdHRvbSIsIm92ZXJmbG93c0JvdW5kYXJpZXMiLCJmbGlwcGVkVmFyaWF0aW9uQnlSZWYiLCJmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50IiwiZmxpcHBlZFZhcmlhdGlvbiIsImdldE9wcG9zaXRlVmFyaWF0aW9uIiwidXNlSGVpZ2h0IiwiZnJhZ21lbnRzIiwiZnJhZyIsImRpdmlkZXIiLCJzcGxpdFJlZ2V4Iiwib3BzIiwibWVyZ2VXaXRoUHJldmlvdXMiLCJ0b1ZhbHVlIiwib3AiLCJpbmRleDIiLCJiYXNlUGxhY2VtZW50IiwicGFyc2VPZmZzZXQiLCJ0cmFuc2Zvcm1Qcm9wIiwicG9wcGVyU3R5bGVzIiwic2hpZnR2YXJpYXRpb24iLCJzaGlmdE9mZnNldHMiLCJzdWJ0cmFjdExlbmd0aCIsInNoaWZ0Iiwia2VlcFRvZ2V0aGVyIiwiaW5uZXIiLCJQb3BwZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkZWJvdW5jZSIsIm1vZGlmaWVyT3B0aW9ucyIsImV2ZW50c0VuYWJsZWQiLCJ1cGRhdGUiLCJkZXN0cm95IiwiZW5hYmxlRXZlbnRMaXN0ZW5lcnMiLCJkaXNhYmxlRXZlbnRMaXN0ZW5lcnMiLCJVdGlscyIsIlBvcHBlclV0aWxzIiwiRGVmYXVsdHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJJdGVtIiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJPcCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsImluTW9kdWxlIiwicnVudGltZSIsInJlZ2VuZXJhdG9yUnVudGltZSIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJOYXRpdmVJdGVyYXRvclByb3RvdHlwZSIsIkdwIiwiZGlzcGxheU5hbWUiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiY3RvciIsIm1hcmsiLCJhd3JhcCIsIl9fYXdhaXQiLCJBc3luY0l0ZXJhdG9yIiwicmVjb3JkIiwidW53cmFwcGVkIiwicHJldmlvdXNQcm9taXNlIiwiZW5xdWV1ZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiYXN5bmMiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJldHVybiIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXRlcmF0b3JNZXRob2QiLCJza2lwVGVtcFJlc2V0Iiwic3RvcCIsInJvb3RFbnRyeSIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsImxvY2F0aW9uIiwiYmFzZVVybCIsInByb3RvY29sIiwiaG9zdCIsImN1cnJlbnREaXIiLCJwYXRobmFtZSIsImZpeGVkQ3NzIiwiZnVsbE1hdGNoIiwib3JpZ1VybCIsInVucXVvdGVkT3JpZ1VybCIsIiQxIiwibmV3VXJsIiwidWEiLCJpc1VDQnJvd3NlciIsImlzSU9TIiwiZGVmYXVsdFByb3BzIiwiYTExeSIsImFsbG93SFRNTCIsImFuaW1hdGVGaWxsIiwiYW5pbWF0aW9uIiwiYXBwZW5kVG8iLCJhcmlhIiwiYXJyb3ciLCJhcnJvd1R5cGUiLCJib3VuZGFyeSIsImNvbnRlbnQiLCJkZWxheSIsImRpc3RhbmNlIiwiZHVyYXRpb24iLCJmbGlwIiwiZmxpcEJlaGF2aW9yIiwiZmxpcE9uVXBkYXRlIiwiZm9sbG93Q3Vyc29yIiwiaGlkZU9uQ2xpY2siLCJpZ25vcmVBdHRyaWJ1dGVzIiwiaW5lcnRpYSIsImludGVyYWN0aXZlIiwiaW50ZXJhY3RpdmVCb3JkZXIiLCJpbnRlcmFjdGl2ZURlYm91bmNlIiwibGF6eSIsIm1heFdpZHRoIiwibXVsdGlwbGUiLCJvbkhpZGRlbiIsIm9uSGlkZSIsIm9uTW91bnQiLCJvblNob3ciLCJvblNob3duIiwib25UcmlnZ2VyIiwicG9wcGVyT3B0aW9ucyIsInJvbGUiLCJzaG93T25Jbml0IiwidGhlbWUiLCJ0b3VjaCIsInRvdWNoSG9sZCIsInRyaWdnZXIiLCJ0cmlnZ2VyVGFyZ2V0IiwidXBkYXRlRHVyYXRpb24iLCJ3YWl0IiwiekluZGV4IiwiUE9QUEVSX0lOU1RBTkNFX0RFUEVOREVOQ0lFUyIsImVsZW1lbnRQcm90byIsIkVsZW1lbnQiLCJtYXRjaGVzIiwiY2xvc2VzdENhbGxiYWNrIiwiY2FsbGJhY2siLCJQQVNTSVZFIiwiUEFERElORyIsIlBMQUNFTUVOVF9BVFRSSUJVVEUiLCJPVVRfT0ZfQk9VTkRBUklFU19BVFRSSUJVVEUiLCJJT1NfQ0xBU1MiLCJBQ1RJVkVfQ0xBU1MiLCJQT1BQRVJfQ0xBU1MiLCJUT09MVElQX0NMQVNTIiwiQ09OVEVOVF9DTEFTUyIsIkJBQ0tEUk9QX0NMQVNTIiwiQVJST1dfQ0xBU1MiLCJST1VORF9BUlJPV19DTEFTUyIsIlBPUFBFUl9TRUxFQ1RPUiIsIlRPT0xUSVBfU0VMRUNUT1IiLCJDT05URU5UX1NFTEVDVE9SIiwiQkFDS0RST1BfU0VMRUNUT1IiLCJBUlJPV19TRUxFQ1RPUiIsIlJPVU5EX0FSUk9XX1NFTEVDVE9SIiwiaXNVc2luZ1RvdWNoIiwibGFzdE1vdXNlTW92ZVRpbWUiLCJwZXJmb3JtYW5jZSIsImFjdGl2ZUVsZW1lbnQiLCJ2YWx1ZUFzU3RyaW5nIiwicG9seWZpbGxzIiwiaXNWaXJ0dWFsIiwidmlydHVhbFJlZmVyZW5jZSIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGFzc0xpc3QiLCJjbGFzc05hbWVzIiwicmVtb3ZlIiwiaXNTaW5ndWxhciIsImFycmF5RnJvbSIsIm1zIiwiaXNSZWFsRWxlbWVudCIsImVscyIsImludm9rZVdpdGhBcmdzT3JSZXR1cm4iLCJnZXREYXRhQXR0cmlidXRlT3B0aW9ucyIsImlubmVySFRNTCIsInNldElubmVySFRNTCIsImNvbnRlbnRFbCIsInRvb2x0aXAiLCJiYWNrZHJvcCIsImV2ZW50TmFtZSIsImFjdGlvbiIsImZ1bGxQbGFjZW1lbnQiLCJ0aGVtZU5hbWUiLCJ1cGRhdGVUaGVtZSIsImFkZEludGVyYWN0aXZlIiwiY3JlYXRlQXJyb3dFbGVtZW50IiwiY3JlYXRlQmFja2Ryb3BFbGVtZW50IiwiYWRkSW5lcnRpYSIsInNldENvbnRlbnQiLCJnZXRDaGlsZHJlbiIsIm5leHRQcm9wcyIsInByZXZQcm9wcyIsInJlbW92ZUludGVyYWN0aXZlIiwicmVtb3ZlSW5lcnRpYSIsImV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSIsImV4Y2x1ZGUiLCJpc0V4Y2x1ZGVkIiwiaXNSZWZlcmVuY2VFbGVtZW50IiwiZXhjZWVkc1RvcCIsInBvcHBlclBsYWNlbWVudCIsImV4Y2VlZHNCb3R0b20iLCJleGNlZWRzTGVmdCIsImV4Y2VlZHNSaWdodCIsImlkQ291bnRlciIsIm1vdXNlTW92ZUxpc3RlbmVycyIsImV2YWx1YXRlUHJvcHMiLCJpc1NjaGVkdWxlZFRvU2hvdyIsImlzQmVpbmdEZXN0cm95ZWQiLCJ3YXNWaXNpYmxlRHVyaW5nUHJldmlvdXNVcGRhdGUiLCJoYXNNb3VudENhbGxiYWNrUnVuIiwiZGVib3VuY2VkT25Nb3VzZU1vdmUiLCJjcmVhdGVQb3BwZXJFbGVtZW50IiwicG9wcGVyQ2hpbGRyZW4iLCJwb3BwZXJJbnN0YW5jZSIsImlzRW5hYmxlZCIsImlzVmlzaWJsZSIsImlzRGVzdHJveWVkIiwiaXNNb3VudGVkIiwiaXNTaG93biIsImNsZWFyRGVsYXlUaW1lb3V0cyIsInNob3ciLCJlbmFibGUiLCJkaXNhYmxlIiwiYWRkVHJpZ2dlcnNUb1JlZmVyZW5jZSIsImNyZWF0ZVBvcHBlckluc3RhbmNlIiwic2NoZWR1bGVTaG93IiwiY2FuUmVjZWl2ZUZvY3VzIiwiZ2V0RXZlbnRMaXN0ZW5lcnNUYXJnZXQiLCJsYXN0VHJpZ2dlckV2ZW50VHlwZSIsInNldFRyYW5zaXRpb25EdXJhdGlvbiIsInVwZGF0ZVBvc2l0aW9uIiwib25UcmFuc2l0aW9uRW5kIiwidXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyIiwiY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lciIsImV2ZW50VHlwZSIsImxhc3RNb3VzZU1vdmVFdmVudCIsImlzQ3Vyc29yT3ZlclJlZmVyZW5jZSIsImlzSG9yaXpvbnRhbCIsImlzVmVydGljYWxQbGFjZW1lbnQiLCJnZXRCYXNpY1BsYWNlbWVudCIsImhhbGZTaXplIiwidmVydGljYWxJbmNyZWFzZSIsImhvcml6b250YWxJbmNyZWFzZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwicmVtb3ZlRm9sbG93Q3Vyc29yTGlzdGVuZXIiLCJ0YXJnZXRFbCIsImNsb3Nlc3QiLCJjcmVhdGVUaXBweSIsImNvbGxlY3Rpb25Qcm9wcyIsImlzRXZlbnRMaXN0ZW5lclN0b3BwZWQiLCJzY2hlZHVsZUhpZGUiLCJpc0N1cnNvck92ZXJQb3BwZXIiLCJpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlciIsImNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzIiwic3VwcG9ydHNUb3VjaCIsImlzVG91Y2hFdmVudCIsInJlZmxvdyIsImN1cnJlbnRNb3VudENhbGxiYWNrIiwicHJldmVudE92ZXJmbG93TW9kaWZpZXIiLCJnZXRNb2RpZmllciIsInNldEZsaXBNb2RpZmllckVuYWJsZWQiLCJwcmV2aW91c1BsYWNlbWVudCIsImJhc2ljUGxhY2VtZW50IiwiZ2V0T2Zmc2V0RGlzdGFuY2VJblB4IiwiY29tcHV0ZWRQYWRkaW5nIiwiY3VycmVudENvbXB1dGVkUGFkZGluZyIsImNvbmZpZyIsInByZXZlbnRPdmVyZmxvdyIsImJlaGF2aW9yIiwib25DcmVhdGUiLCJhcHBseU11dGF0aW9ucyIsInJ1bk1vdW50Q2FsbGJhY2siLCJvblVwZGF0ZSIsImlzSW5Mb29zZUZvbGxvd0N1cnNvck1vZGUiLCJnZXRJc0luTG9vc2VGb2xsb3dDdXJzb3JNb2RlIiwiY3JlYXRlRGVsZWdhdGVDaGlsZFRpcHB5IiwiYWRkRG9jdW1lbnRDbGlja0xpc3RlbmVyIiwic2hvd1RpbWVvdXRJZCIsImhpZGVUaW1lb3V0SWQiLCJzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZUlkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJyZW1vdmVUcmlnZ2Vyc0Zyb21SZWZlcmVuY2UiLCJ1cGRhdGVQb3BwZXJFbGVtZW50IiwicG9zaXRpb25WaXJ0dWFsUmVmZXJlbmNlTmVhckN1cnNvciIsInRyYW5zaXRpb25hYmxlRWxlbWVudHMiLCJnZXRUcmFuc2l0aW9uYWJsZUVsZW1lbnRzIiwibWFrZVN0aWNreSIsInNldFZpc2liaWxpdHlTdGF0ZSIsIm9uVHJhbnNpdGlvbmVkSW4iLCJtb3VudCIsInJlbW92ZURvY3VtZW50Q2xpY2tMaXN0ZW5lciIsIm9uVHJhbnNpdGlvbmVkT3V0IiwiY2hpbGQiLCJpbnN0YW5jZXMiLCJpc0FueVRpcHB5T3BlbiIsInVwZGF0ZUluc3RhbmNlcyIsInNldElzQW55VGlwcHlPcGVuIiwiZ2xvYmFsRXZlbnRMaXN0ZW5lcnNCb3VuZCIsImJpbmRHbG9iYWxFdmVudExpc3RlbmVycyIsImlzQmFyZVZpcnR1YWxFbGVtZW50IiwicG9seWZpbGxFbGVtZW50UHJvdG90eXBlUHJvcGVydGllcyIsInRpcHB5IiwicGFydGlhbERlZmF1bHRzIiwiZmlyc3RDaGlsZCIsImluamVjdENTUyIsImV4dGVuZFN0YXRpY3MiLCJfX2V4dGVuZHMiLCJfXyIsIl9fYXNzaWduIiwiX19yZXN0IiwiX19kZWNvcmF0ZSIsImRlY29yYXRvcnMiLCJkZWNvcmF0ZSIsIl9fcGFyYW0iLCJwYXJhbUluZGV4IiwiX19tZXRhZGF0YSIsIl9fYXdhaXRlciIsIl9hcmd1bWVudHMiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsIl9fZ2VuZXJhdG9yIiwibGFiZWwiLCJ0cnlzIiwiZyIsInZlcmIiLCJfX2V4cG9ydFN0YXIiLCJfX3ZhbHVlcyIsIl9fcmVhZCIsImFyIiwiX19zcHJlYWQiLCJfX2FzeW5jR2VuZXJhdG9yIiwicmVzdW1lIiwic2V0dGxlIiwiZnVsZmlsbCIsIl9fYXN5bmNEZWxlZ2F0b3IiLCJfX2FzeW5jVmFsdWVzIiwiX19tYWtlVGVtcGxhdGVPYmplY3QiLCJjb29rZWQiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsIl9faW1wb3J0RGVmYXVsdCIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJ1c2VycyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJVc2VycyIsImdldFN0cmluZ1R5cGUiLCJnZXRVc2VyVGVtcGxhdGUiLCJ1c2VyIiwiZmlyc3ROYW1lIiwidXNlck51bWJlciIsImdldFVzZXJFZGl0VGVtcGxhdGUiLCJzZWxlY3RGaWx0ZXJIYW5kbGVyIiwiZmlsdGVyQnlaZXJvIiwiZmlsdGVyQnlPbmUiLCJmaWx0ZXJCeVR3byIsImZpbHRlclN0YXRlIiwiZmlsdGVyQnlPbmVTdGF0ZSIsImZpbHRlckJ5VHdvU3RhdGUiLCJyZW5kZXIiLCJmZXRjaEFkcyIsImRhdGFTZXJ2aWNlIiwiY2F0Y2giLCJuYW1lQSIsIm5hbWVCIiwidXNlcnNUYm9keSIsInRvb2x0aXBJbml0IiwidG9vbHRpcEVsZW1lbnRzIiwiY3JlYXRlQWQiLCJwcmV2ZW50RGVmYXVsdCIsIm5vZGVzIiwiaXNWYWxpZCIsInZhbGlkYXRvcnMiLCJyZXF1aXJlZCIsInBheWxvYWQiLCJkZWxldGVBZCIsInVwZGF0ZUFkIiwicXVlcnlTZWxlY3RvciIsImVkaXRBZCIsImNsb3NlQWQiLCJ1c2VySGFuZGxlciIsImRhdGFTZXQiLCJmaWx0ZXJCeVplcm9TdGF0ZSIsImZvcm0iLCJzZWxlY3RGaWx0ZXIiLCJBZCIsIkRhdGFTZXJ2aWNlIiwiYXBpS2V5IiwiYXV0aERvbWFpbiIsImRhdGFiYXNlVVJMIiwicHJvamVjdElkIiwic3RvcmFnZUJ1Y2tldCIsIm1lc3NhZ2luZ1NlbmRlcklkIiwiYXBwSWQiLCJmYiIsImluaXRpYWxpemVBcHAiLCJyZXN1bHRBZHMiLCJkYXRhYmFzZSIsInJlZiIsImZiVmFsIiwiYWRzIiwiYWQiLCJuZXdBZCIsIlZhbGlkYXRvcnMiLCJ2YWxpZGF0aW9uTmFtZSIsInZhbGlkYXRpb25Vc2VyTnVtYmVyIiwiZ2V0TWVzc2FnZSIsIm1lc3NhZ2UiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJuYW1lTGVuZ3RoIiwidXNlck51bWJlclN0YXRlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVB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RCxlQUFMLEVBQXNCO0FBQ3BCLGlCQUFJLENBQUNKLFVBQUwsQ0FBZ0JwQyxLQUFLLENBQUMzMkQsQ0FBRCxDQUFyQixFQUEwQkEsQ0FBMUI7O0FBQ0E0MkQsbUJBQU8sR0FBRyxLQUFWO0FBQ0Q7QUFDRjtBQUNGLE9BekJIO0FBMkJBLGFBQU9BLE9BQVA7QUFDRDtBQXZDSDs7QUFBQTtBQUFBO0FBc0VBLElBQU1qMEQsUUFBUSxHQUFHLElBQUlpMkQsVUFBSixFQUFqQjtBQUNlajJELHVFQUFmLEUiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIuL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBTdGFuZGFyZGl6ZWQgRmlyZWJhc2UgRXJyb3IuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAvLyBUeXBlc2NyaXB0IHN0cmluZyBsaXRlcmFscyBmb3IgdHlwZS1zYWZlIGNvZGVzXG4gKiAgIHR5cGUgRXJyID1cbiAqICAgICAndW5rbm93bicgfFxuICogICAgICdvYmplY3Qtbm90LWZvdW5kJ1xuICogICAgIDtcbiAqXG4gKiAgIC8vIENsb3N1cmUgZW51bSBmb3IgdHlwZS1zYWZlIGVycm9yIGNvZGVzXG4gKiAgIC8vIGF0LWVudW0ge3N0cmluZ31cbiAqICAgdmFyIEVyciA9IHtcbiAqICAgICBVTktOT1dOOiAndW5rbm93bicsXG4gKiAgICAgT0JKRUNUX05PVF9GT1VORDogJ29iamVjdC1ub3QtZm91bmQnLFxuICogICB9XG4gKlxuICogICBsZXQgZXJyb3JzOiBNYXA8RXJyLCBzdHJpbmc+ID0ge1xuICogICAgICdnZW5lcmljLWVycm9yJzogXCJVbmtub3duIGVycm9yXCIsXG4gKiAgICAgJ2ZpbGUtbm90LWZvdW5kJzogXCJDb3VsZCBub3QgZmluZCBmaWxlOiB7JGZpbGV9XCIsXG4gKiAgIH07XG4gKlxuICogICAvLyBUeXBlLXNhZmUgZnVuY3Rpb24gLSBtdXN0IHBhc3MgYSB2YWxpZCBlcnJvciBjb2RlIGFzIHBhcmFtLlxuICogICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JGYWN0b3J5PEVycj4oJ3NlcnZpY2UnLCAnU2VydmljZScsIGVycm9ycyk7XG4gKlxuICogICAuLi5cbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5HRU5FUklDKTtcbiAqICAgLi4uXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuRklMRV9OT1RfRk9VTkQsIHsnZmlsZSc6IGZpbGVOYW1lfSk7XG4gKiAgIC4uLlxuICogICAvLyBTZXJ2aWNlOiBDb3VsZCBub3QgZmlsZSBmaWxlOiBmb28udHh0IChzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kKS5cbiAqXG4gKiAgIGNhdGNoIChlKSB7XG4gKiAgICAgYXNzZXJ0KGUubWVzc2FnZSA9PT0gXCJDb3VsZCBub3QgZmluZCBmaWxlOiBmb28udHh0LlwiKTtcbiAqICAgICBpZiAoZS5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xuICogICAgIH1cbiAqICAgfVxuICovXG5cbmV4cG9ydCB0eXBlIEVycm9yTWFwPEVycm9yQ29kZSBleHRlbmRzIHN0cmluZz4gPSB7XG4gIHJlYWRvbmx5IFtLIGluIEVycm9yQ29kZV06IHN0cmluZ1xufTtcblxuY29uc3QgRVJST1JfTkFNRSA9ICdGaXJlYmFzZUVycm9yJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHJpbmdMaWtlIHtcbiAgdG9TdHJpbmcoKTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yRGF0YSB7XG4gIFtrZXk6IHN0cmluZ106IFN0cmluZ0xpa2UgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlyZWJhc2VFcnJvciBleHRlbmRzIEVycm9yLCBFcnJvckRhdGEge1xuICAvLyBVbmlxdWUgY29kZSBmb3IgZXJyb3IgLSBmb3JtYXQgaXMgc2VydmljZS9lcnJvci1jb2RlLXN0cmluZy5cbiAgcmVhZG9ubHkgY29kZTogc3RyaW5nO1xuXG4gIC8vIERldmVsb3Blci1mcmllbmRseSBlcnJvciBtZXNzYWdlLlxuICByZWFkb25seSBtZXNzYWdlOiBzdHJpbmc7XG5cbiAgLy8gQWx3YXlzICdGaXJlYmFzZUVycm9yJy5cbiAgcmVhZG9ubHkgbmFtZTogdHlwZW9mIEVSUk9SX05BTUU7XG5cbiAgLy8gV2hlcmUgYXZhaWxhYmxlIC0gc3RhY2sgYmFja3RyYWNlIGluIGEgc3RyaW5nLlxuICByZWFkb25seSBzdGFjaz86IHN0cmluZztcbn1cblxuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXG5leHBvcnQgY2xhc3MgRmlyZWJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVhZG9ubHkgbmFtZSA9IEVSUk9SX05BTUU7XG5cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgY29kZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcblxuICAgIC8vIEZpeCBGb3IgRVM1XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRmlyZWJhc2VFcnJvci5wcm90b3R5cGUpO1xuXG4gICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24uXG4gICAgLy8gT25seSBhdmFpbGFibGUgb24gVjguXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFcnJvckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFcnJvckZhY3Rvcnk8XG4gIEVycm9yQ29kZSBleHRlbmRzIHN0cmluZyxcbiAgRXJyb3JQYXJhbXMgZXh0ZW5kcyB7IHJlYWRvbmx5IFtLIGluIEVycm9yQ29kZV0/OiBFcnJvckRhdGEgfSA9IHt9XG4+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXJ2aWNlOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXJ2aWNlTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXJyb3JzOiBFcnJvck1hcDxFcnJvckNvZGU+XG4gICkge31cblxuICBjcmVhdGU8SyBleHRlbmRzIEVycm9yQ29kZT4oXG4gICAgY29kZTogSyxcbiAgICAuLi5kYXRhOiBLIGV4dGVuZHMga2V5b2YgRXJyb3JQYXJhbXMgPyBbRXJyb3JQYXJhbXNbS11dIDogW11cbiAgKTogRmlyZWJhc2VFcnJvciB7XG4gICAgY29uc3QgY3VzdG9tRGF0YSA9IChkYXRhWzBdIGFzIEVycm9yRGF0YSkgfHwge307XG4gICAgY29uc3QgZnVsbENvZGUgPSBgJHt0aGlzLnNlcnZpY2V9LyR7Y29kZX1gO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5lcnJvcnNbY29kZV07XG5cbiAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcbiAgICAvLyBTZXJ2aWNlIE5hbWU6IEVycm9yIG1lc3NhZ2UgKHNlcnZpY2UvY29kZSkuXG4gICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgJHt0aGlzLnNlcnZpY2VOYW1lfTogJHttZXNzYWdlfSAoJHtmdWxsQ29kZX0pLmA7XG5cbiAgICBjb25zdCBlcnJvciA9IG5ldyBGaXJlYmFzZUVycm9yKGZ1bGxDb2RlLCBmdWxsTWVzc2FnZSk7XG5cbiAgICAvLyBLZXlzIHdpdGggYW4gdW5kZXJzY29yZSBhdCB0aGUgZW5kIG9mIHRoZWlyIG5hbWUgYXJlIG5vdCBpbmNsdWRlZCBpblxuICAgIC8vIGVycm9yLmRhdGEgZm9yIHNvbWUgcmVhc29uLlxuICAgIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBPYmplY3QuZW50cmllcyB3aGVuIGxpYiBpcyB1cGRhdGVkIHRvIGVzMjAxNy5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjdXN0b21EYXRhKSkge1xuICAgICAgaWYgKGtleS5zbGljZSgtMSkgIT09ICdfJykge1xuICAgICAgICBpZiAoa2V5IGluIGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYE92ZXJ3cml0aW5nIEZpcmViYXNlRXJyb3IgYmFzZSBmaWVsZCBcIiR7a2V5fVwiIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yW2tleV0gPSBjdXN0b21EYXRhW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZTogc3RyaW5nLCBkYXRhOiBFcnJvckRhdGEpOiBzdHJpbmcge1xuICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShQQVRURVJOLCAoXywga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS50b1N0cmluZygpIDogYDwke2tleX0/PmA7XG4gIH0pO1xufVxuXG5jb25zdCBQQVRURVJOID0gL1xce1xcJChbXn1dKyl9L2c7XG4iLCIvLyBQYXNzaXZlIGV2ZW50IGxpc3RlbmVyIGNvbmZpZ1xuZXhwb3J0IGNvbnN0IFBBU1NJVkUgPSB7IHBhc3NpdmU6IHRydWUgfVxuXG4vLyBQb3BwZXIgYHByZXZlbnRPdmVyZmxvd2AgcGFkZGluZ1xuZXhwb3J0IGNvbnN0IFBBRERJTkcgPSA0XG5cbi8vIFBvcHBlciBhdHRyaWJ1dGVzXG4vLyBJbiBQb3BwZXIgdjIgdGhlc2Ugd2lsbCBiZSBgZGF0YS0qYCBpbnN0ZWFkIG9mIGB4LSpgIHRvIGFkaGVyZSB0byBIVE1MNSBzcGVjXG5leHBvcnQgY29uc3QgUExBQ0VNRU5UX0FUVFJJQlVURSA9ICd4LXBsYWNlbWVudCdcbmV4cG9ydCBjb25zdCBPVVRfT0ZfQk9VTkRBUklFU19BVFRSSUJVVEUgPSAneC1vdXQtb2YtYm91bmRhcmllcydcblxuLy8gQ2xhc3Nlc1xuZXhwb3J0IGNvbnN0IElPU19DTEFTUyA9IGBfX05BTUVTUEFDRV9QUkVGSVhfXy1pT1NgXG5leHBvcnQgY29uc3QgQUNUSVZFX0NMQVNTID0gYF9fTkFNRVNQQUNFX1BSRUZJWF9fLWFjdGl2ZWBcbmV4cG9ydCBjb25zdCBQT1BQRVJfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tcG9wcGVyYFxuZXhwb3J0IGNvbnN0IFRPT0xUSVBfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tdG9vbHRpcGBcbmV4cG9ydCBjb25zdCBDT05URU5UX0NMQVNTID0gYF9fTkFNRVNQQUNFX1BSRUZJWF9fLWNvbnRlbnRgXG5leHBvcnQgY29uc3QgQkFDS0RST1BfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tYmFja2Ryb3BgXG5leHBvcnQgY29uc3QgQVJST1dfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tYXJyb3dgXG5leHBvcnQgY29uc3QgUk9VTkRfQVJST1dfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tcm91bmRhcnJvd2BcblxuLy8gU2VsZWN0b3JzXG5leHBvcnQgY29uc3QgUE9QUEVSX1NFTEVDVE9SID0gYC4ke1BPUFBFUl9DTEFTU31gXG5leHBvcnQgY29uc3QgVE9PTFRJUF9TRUxFQ1RPUiA9IGAuJHtUT09MVElQX0NMQVNTfWBcbmV4cG9ydCBjb25zdCBDT05URU5UX1NFTEVDVE9SID0gYC4ke0NPTlRFTlRfQ0xBU1N9YFxuZXhwb3J0IGNvbnN0IEJBQ0tEUk9QX1NFTEVDVE9SID0gYC4ke0JBQ0tEUk9QX0NMQVNTfWBcbmV4cG9ydCBjb25zdCBBUlJPV19TRUxFQ1RPUiA9IGAuJHtBUlJPV19DTEFTU31gXG5leHBvcnQgY29uc3QgUk9VTkRfQVJST1dfU0VMRUNUT1IgPSBgLiR7Uk9VTkRfQVJST1dfQ0xBU1N9YFxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEZpcmViYXNlQXBwLFxuICBGaXJlYmFzZU9wdGlvbnMsXG4gIEZpcmViYXNlQXBwQ29uZmlnXG59IGZyb20gJ0BmaXJlYmFzZS9hcHAtdHlwZXMnO1xuaW1wb3J0IHtcbiAgX0ZpcmViYXNlQXBwLFxuICBfRmlyZWJhc2VOYW1lc3BhY2UsXG4gIEZpcmViYXNlU2VydmljZSxcbiAgRmlyZWJhc2VBcHBJbnRlcm5hbHNcbn0gZnJvbSAnQGZpcmViYXNlL2FwcC10eXBlcy9wcml2YXRlJztcbmltcG9ydCB7IGRlZXBDb3B5LCBkZWVwRXh0ZW5kIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQXBwRXJyb3IsIEVSUk9SX0ZBQ1RPUlkgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBERUZBVUxUX0VOVFJZX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmludGVyZmFjZSBTZXJ2aWNlc0NhY2hlIHtcbiAgW25hbWU6IHN0cmluZ106IHtcbiAgICBbc2VydmljZU5hbWU6IHN0cmluZ106IEZpcmViYXNlU2VydmljZTtcbiAgfTtcbn1cblxuLy8gQW4gYXJyYXkgdG8gY2FwdHVyZSBsaXN0ZW5lcnMgYmVmb3JlIHRoZSB0cnVlIGF1dGggZnVuY3Rpb25zXG4vLyBleGlzdFxubGV0IHRva2VuTGlzdGVuZXJzOiBBcnJheTwodG9rZW46IHN0cmluZyB8IG51bGwpID0+IHZvaWQ+ID0gW107XG5cbi8qKlxuICogR2xvYmFsIGNvbnRleHQgb2JqZWN0IGZvciBhIGNvbGxlY3Rpb24gb2Ygc2VydmljZXMgdXNpbmdcbiAqIGEgc2hhcmVkIGF1dGhlbnRpY2F0aW9uIHN0YXRlLlxuICovXG5leHBvcnQgY2xhc3MgRmlyZWJhc2VBcHBJbXBsIGltcGxlbWVudHMgRmlyZWJhc2VBcHAge1xuICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnNfOiBGaXJlYmFzZU9wdGlvbnM7XG4gIHByaXZhdGUgcmVhZG9ubHkgbmFtZV86IHN0cmluZztcbiAgcHJpdmF0ZSBpc0RlbGV0ZWRfID0gZmFsc2U7XG4gIHByaXZhdGUgc2VydmljZXNfOiBTZXJ2aWNlc0NhY2hlID0ge307XG4gIHByaXZhdGUgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXzogYm9vbGVhbjtcblxuICBJTlRFUk5BTDogRmlyZWJhc2VBcHBJbnRlcm5hbHM7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgb3B0aW9uczogRmlyZWJhc2VPcHRpb25zLFxuICAgIGNvbmZpZzogRmlyZWJhc2VBcHBDb25maWcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmaXJlYmFzZV86IF9GaXJlYmFzZU5hbWVzcGFjZVxuICApIHtcbiAgICB0aGlzLm5hbWVfID0gY29uZmlnLm5hbWUhO1xuICAgIHRoaXMuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXyA9XG4gICAgICBjb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIHx8IGZhbHNlO1xuICAgIHRoaXMub3B0aW9uc18gPSBkZWVwQ29weTxGaXJlYmFzZU9wdGlvbnM+KG9wdGlvbnMpO1xuICAgIHRoaXMuSU5URVJOQUwgPSB7XG4gICAgICBnZXRVaWQ6ICgpID0+IG51bGwsXG4gICAgICBnZXRUb2tlbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG51bGwpLFxuICAgICAgYWRkQXV0aFRva2VuTGlzdGVuZXI6IChjYWxsYmFjazogKHRva2VuOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgIHRva2VuTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAvLyBNYWtlIHN1cmUgY2FsbGJhY2sgaXMgY2FsbGVkLCBhc3luY2hyb25vdXNseSwgaW4gdGhlIGFic2VuY2Ugb2YgdGhlIGF1dGggbW9kdWxlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2sobnVsbCksIDApO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyOiBjYWxsYmFjayA9PiB7XG4gICAgICAgIHRva2VuTGlzdGVuZXJzID0gdG9rZW5MaXN0ZW5lcnMuZmlsdGVyKFxuICAgICAgICAgIGxpc3RlbmVyID0+IGxpc3RlbmVyICE9PSBjYWxsYmFja1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHRoaXMuY2hlY2tEZXN0cm95ZWRfKCk7XG4gICAgcmV0dXJuIHRoaXMuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXztcbiAgfVxuXG4gIHNldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQodmFsKSB7XG4gICAgdGhpcy5jaGVja0Rlc3Ryb3llZF8oKTtcbiAgICB0aGlzLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZF8gPSB2YWw7XG4gIH1cblxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHRoaXMuY2hlY2tEZXN0cm95ZWRfKCk7XG4gICAgcmV0dXJuIHRoaXMubmFtZV87XG4gIH1cblxuICBnZXQgb3B0aW9ucygpOiBGaXJlYmFzZU9wdGlvbnMge1xuICAgIHRoaXMuY2hlY2tEZXN0cm95ZWRfKCk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gIH1cblxuICBkZWxldGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZF8oKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmZpcmViYXNlXy5JTlRFUk5BTC5yZW1vdmVBcHAodGhpcy5uYW1lXyk7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VzOiBGaXJlYmFzZVNlcnZpY2VbXSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3Qgc2VydmljZUtleSBvZiBPYmplY3Qua2V5cyh0aGlzLnNlcnZpY2VzXykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlS2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuc2VydmljZXNfW3NlcnZpY2VLZXldKSkge1xuICAgICAgICAgICAgc2VydmljZXMucHVzaCh0aGlzLnNlcnZpY2VzX1tzZXJ2aWNlS2V5XVtpbnN0YW5jZUtleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICBzZXJ2aWNlc1xuICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdJTlRFUk5BTCcgaW4gc2VydmljZSlcbiAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLklOVEVSTkFMIS5kZWxldGUoKSlcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihcbiAgICAgICAgKCk6IHZvaWQgPT4ge1xuICAgICAgICAgIHRoaXMuaXNEZWxldGVkXyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zZXJ2aWNlc18gPSB7fTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzZXJ2aWNlIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFwcCAoY3JlYXRpbmcgaXRcbiAgICogb24gZGVtYW5kKSwgaWRlbnRpZmllZCBieSB0aGUgcGFzc2VkIGluc3RhbmNlSWRlbnRpZmllci5cbiAgICpcbiAgICogTk9URTogQ3VycmVudGx5IHN0b3JhZ2UgaXMgdGhlIG9ubHkgb25lIHRoYXQgaXMgbGV2ZXJhZ2luZyB0aGlzXG4gICAqIGZ1bmN0aW9uYWxpdHkuIFRoZXkgaW52b2tlIGl0IGJ5IGNhbGxpbmc6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogZmlyZWJhc2UuYXBwKCkuc3RvcmFnZSgnU1RPUkFHRSBCVUNLRVQgSUQnKVxuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIHNlcnZpY2UgbmFtZSBpcyBwYXNzZWQgdG8gdGhpcyBhbHJlYWR5XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldFNlcnZpY2UoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIGluc3RhbmNlSWRlbnRpZmllcjogc3RyaW5nID0gREVGQVVMVF9FTlRSWV9OQU1FXG4gICk6IEZpcmViYXNlU2VydmljZSB7XG4gICAgdGhpcy5jaGVja0Rlc3Ryb3llZF8oKTtcblxuICAgIGlmICghdGhpcy5zZXJ2aWNlc19bbmFtZV0pIHtcbiAgICAgIHRoaXMuc2VydmljZXNfW25hbWVdID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzX1tuYW1lXVtpbnN0YW5jZUlkZW50aWZpZXJdKSB7XG4gICAgICAvKipcbiAgICAgICAqIElmIGEgY3VzdG9tIGluc3RhbmNlIGhhcyBiZWVuIGRlZmluZWQgKGkuZS4gbm90ICdbREVGQVVMVF0nKVxuICAgICAgICogdGhlbiB3ZSB3aWxsIHBhc3MgdGhhdCBpbnN0YW5jZSBvbiwgb3RoZXJ3aXNlIHdlIHBhc3MgYG51bGxgXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGluc3RhbmNlU3BlY2lmaWVyID1cbiAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyICE9PSBERUZBVUxUX0VOVFJZX05BTUVcbiAgICAgICAgICA/IGluc3RhbmNlSWRlbnRpZmllclxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3Qgc2VydmljZSA9IHRoaXMuZmlyZWJhc2VfLklOVEVSTkFMLmZhY3Rvcmllc1tuYW1lXShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5leHRlbmRBcHAuYmluZCh0aGlzKSxcbiAgICAgICAgaW5zdGFuY2VTcGVjaWZpZXJcbiAgICAgICk7XG4gICAgICB0aGlzLnNlcnZpY2VzX1tuYW1lXVtpbnN0YW5jZUlkZW50aWZpZXJdID0gc2VydmljZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlc19bbmFtZV1baW5zdGFuY2VJZGVudGlmaWVyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiB1c2VkIHRvIGV4dGVuZCBhbiBBcHAgaW5zdGFuY2UgYXQgdGhlIHRpbWVcbiAgICogb2Ygc2VydmljZSBpbnN0YW5jZSBjcmVhdGlvbi5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHByaXZhdGUgZXh0ZW5kQXBwKHByb3BzOiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfSk6IHZvaWQge1xuICAgIC8vIENvcHkgdGhlIG9iamVjdCBvbnRvIHRoZSBGaXJlYmFzZUFwcEltcGwgcHJvdG90eXBlXG4gICAgZGVlcEV4dGVuZCh0aGlzLCBwcm9wcyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYXBwIGhhcyBvdmVyd3JpdHRlbiB0aGUgYWRkQXV0aFRva2VuTGlzdGVuZXIgc3R1YiwgZm9yd2FyZFxuICAgICAqIHRoZSBhY3RpdmUgdG9rZW4gbGlzdGVuZXJzIG9uIHRvIHRoZSB0cnVlIGZ4bi5cbiAgICAgKlxuICAgICAqIFRPRE86IFRoaXMgZnVuY3Rpb24gaXMgcmVxdWlyZWQgZHVlIHRvIG91ciBjdXJyZW50IG1vZHVsZVxuICAgICAqIHN0cnVjdHVyZS4gT25jZSB3ZSBhcmUgYWJsZSB0byByZWx5IHN0cmljdGx5IHVwb24gYSBzaW5nbGUgbW9kdWxlXG4gICAgICogaW1wbGVtZW50YXRpb24sIHRoaXMgY29kZSBzaG91bGQgYmUgcmVmYWN0b3JlZCBhbmQgQXV0aCBzaG91bGRcbiAgICAgKiBwcm92aWRlIHRoZXNlIHN0dWJzIGFuZCB0aGUgdXBncmFkZSBsb2dpY1xuICAgICAqL1xuICAgIGlmIChwcm9wcy5JTlRFUk5BTCAmJiBwcm9wcy5JTlRFUk5BTC5hZGRBdXRoVG9rZW5MaXN0ZW5lcikge1xuICAgICAgdG9rZW5MaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgIHRoaXMuSU5URVJOQUwuYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICB0b2tlbkxpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxuICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cbiAgICovXG4gIHByaXZhdGUgY2hlY2tEZXN0cm95ZWRfKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVsZXRlZF8pIHtcbiAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLkFQUF9ERUxFVEVELCB7IG5hbWU6IHRoaXMubmFtZV8gfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFByZXZlbnQgZGVhZC1jb2RlIGVsaW1pbmF0aW9uIG9mIHRoZXNlIG1ldGhvZHMgdy9vIGludmFsaWQgcHJvcGVydHlcbi8vIGNvcHlpbmcuXG4oRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZS5uYW1lICYmIEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUub3B0aW9ucykgfHxcbiAgRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZS5kZWxldGUgfHxcbiAgY29uc29sZS5sb2coJ2RjJyk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRmlyZWJhc2VBcHAsXG4gIEZpcmViYXNlT3B0aW9ucyxcbiAgRmlyZWJhc2VOYW1lc3BhY2UsXG4gIEZpcmViYXNlQXBwQ29uZmlnXG59IGZyb20gJ0BmaXJlYmFzZS9hcHAtdHlwZXMnO1xuaW1wb3J0IHtcbiAgX0ZpcmViYXNlQXBwLFxuICBfRmlyZWJhc2VOYW1lc3BhY2UsXG4gIEZpcmViYXNlU2VydmljZSxcbiAgRmlyZWJhc2VTZXJ2aWNlRmFjdG9yeSxcbiAgRmlyZWJhc2VTZXJ2aWNlTmFtZXNwYWNlLFxuICBBcHBIb29rXG59IGZyb20gJ0BmaXJlYmFzZS9hcHAtdHlwZXMvcHJpdmF0ZSc7XG5pbXBvcnQgeyBkZWVwRXh0ZW5kLCBjb250YWlucyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IEZpcmViYXNlQXBwSW1wbCB9IGZyb20gJy4vZmlyZWJhc2VBcHAnO1xuaW1wb3J0IHsgRVJST1JfRkFDVE9SWSwgQXBwRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBGaXJlYmFzZUFwcExpdGVJbXBsIH0gZnJvbSAnLi9saXRlL2ZpcmViYXNlQXBwTGl0ZSc7XG5pbXBvcnQgeyBERUZBVUxUX0VOVFJZX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vLi4vZmlyZWJhc2UvcGFja2FnZS5qc29uJztcblxuLyoqXG4gKiBCZWNhdXNlIGF1dGggY2FuJ3Qgc2hhcmUgY29kZSB3aXRoIG90aGVyIGNvbXBvbmVudHMsIHdlIGF0dGFjaCB0aGUgdXRpbGl0eSBmdW5jdGlvbnNcbiAqIGluIGFuIGludGVybmFsIG5hbWVzcGFjZSB0byBzaGFyZSBjb2RlLlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm4gYSBmaXJlYmFzZSBuYW1lc3BhY2Ugb2JqZWN0IHdpdGhvdXRcbiAqIGFueSB1dGlsaXR5IGZ1bmN0aW9ucywgc28gaXQgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIHRoZSByZWd1bGFyIGZpcmViYXNlTmFtZXNwYWNlIGFuZFxuICogdGhlIGxpdGUgdmVyc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlQ29yZShcbiAgZmlyZWJhc2VBcHBJbXBsOiB0eXBlb2YgRmlyZWJhc2VBcHBJbXBsIHwgdHlwZW9mIEZpcmViYXNlQXBwTGl0ZUltcGxcbik6IEZpcmViYXNlTmFtZXNwYWNlIHtcbiAgY29uc3QgYXBwczogeyBbbmFtZTogc3RyaW5nXTogRmlyZWJhc2VBcHAgfSA9IHt9O1xuICBjb25zdCBmYWN0b3JpZXM6IHsgW3NlcnZpY2U6IHN0cmluZ106IEZpcmViYXNlU2VydmljZUZhY3RvcnkgfSA9IHt9O1xuICBjb25zdCBhcHBIb29rczogeyBbc2VydmljZTogc3RyaW5nXTogQXBwSG9vayB9ID0ge307XG5cbiAgLy8gQSBuYW1lc3BhY2UgaXMgYSBwbGFpbiBKYXZhU2NyaXB0IE9iamVjdC5cbiAgY29uc3QgbmFtZXNwYWNlOiBGaXJlYmFzZU5hbWVzcGFjZSA9IHtcbiAgICAvLyBIYWNrIHRvIHByZXZlbnQgQmFiZWwgZnJvbSBtb2RpZnlpbmcgdGhlIG9iamVjdCByZXR1cm5lZFxuICAgIC8vIGFzIHRoZSBmaXJlYmFzZSBuYW1lc3BhY2UuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9fZXNNb2R1bGU6IHRydWUsXG4gICAgaW5pdGlhbGl6ZUFwcCxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYXBwLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhcHBzOiBudWxsLFxuICAgIFNES19WRVJTSU9OOiB2ZXJzaW9uLFxuICAgIElOVEVSTkFMOiB7XG4gICAgICByZWdpc3RlclNlcnZpY2UsXG4gICAgICByZW1vdmVBcHAsXG4gICAgICBmYWN0b3JpZXMsXG4gICAgICB1c2VBc1NlcnZpY2VcbiAgICB9XG4gIH07XG5cbiAgLy8gSW5qZWN0IGEgY2lyY3VsYXIgZGVmYXVsdCBleHBvcnQgdG8gYWxsb3cgQmFiZWwgdXNlcnMgd2hvIHdlcmUgcHJldmlvdXNseVxuICAvLyB1c2luZzpcbiAgLy9cbiAgLy8gICBpbXBvcnQgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UnO1xuICAvLyAgIHdoaWNoIGJlY29tZXM6IHZhciBmaXJlYmFzZSA9IHJlcXVpcmUoJ2ZpcmViYXNlJykuZGVmYXVsdDtcbiAgLy9cbiAgLy8gaW5zdGVhZCBvZlxuICAvL1xuICAvLyAgIGltcG9ydCAqIGFzIGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlJztcbiAgLy8gICB3aGljaCBiZWNvbWVzOiB2YXIgZmlyZWJhc2UgPSByZXF1aXJlKCdmaXJlYmFzZScpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAobmFtZXNwYWNlIGFzIGFueSlbJ2RlZmF1bHQnXSA9IG5hbWVzcGFjZTtcblxuICAvLyBmaXJlYmFzZS5hcHBzIGlzIGEgcmVhZC1vbmx5IGdldHRlci5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hbWVzcGFjZSwgJ2FwcHMnLCB7XG4gICAgZ2V0OiBnZXRBcHBzXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgYnkgQXBwLmRlbGV0ZSgpIC0gYnV0IGJlZm9yZSBhbnkgc2VydmljZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBBcHBcbiAgICogYXJlIGRlbGV0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVBcHAobmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgYXBwID0gYXBwc1tuYW1lXTtcbiAgICBjYWxsQXBwSG9va3MoYXBwLCAnZGVsZXRlJyk7XG4gICAgZGVsZXRlIGFwcHNbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBBcHAgb2JqZWN0IGZvciBhIGdpdmVuIG5hbWUgKG9yIERFRkFVTFQpLlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwKG5hbWU/OiBzdHJpbmcpOiBGaXJlYmFzZUFwcCB7XG4gICAgbmFtZSA9IG5hbWUgfHwgREVGQVVMVF9FTlRSWV9OQU1FO1xuICAgIGlmICghY29udGFpbnMoYXBwcywgbmFtZSkpIHtcbiAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLk5PX0FQUCwgeyBuYW1lIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXBwc1tuYW1lXTtcbiAgfVxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgYXBwWydBcHAnXSA9IGZpcmViYXNlQXBwSW1wbDtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBcHAgaW5zdGFuY2UgKG5hbWUgbXVzdCBiZSB1bmlxdWUpLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChcbiAgICBvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsXG4gICAgY29uZmlnPzogRmlyZWJhc2VBcHBDb25maWdcbiAgKTogRmlyZWJhc2VBcHA7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemVBcHAob3B0aW9uczogRmlyZWJhc2VPcHRpb25zLCBuYW1lPzogc3RyaW5nKTogRmlyZWJhc2VBcHA7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemVBcHAoXG4gICAgb3B0aW9uczogRmlyZWJhc2VPcHRpb25zLFxuICAgIHJhd0NvbmZpZyA9IHt9XG4gICk6IEZpcmViYXNlQXBwIHtcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcgfHwgcmF3Q29uZmlnID09PSBudWxsKSB7XG4gICAgICBjb25zdCBuYW1lID0gcmF3Q29uZmlnO1xuICAgICAgcmF3Q29uZmlnID0geyBuYW1lIH07XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlnID0gcmF3Q29uZmlnIGFzIEZpcmViYXNlQXBwQ29uZmlnO1xuXG4gICAgaWYgKGNvbmZpZy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbmZpZy5uYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbmFtZSB9ID0gY29uZmlnO1xuXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xuICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuQkFEX0FQUF9OQU1FLCB7IG5hbWU6IFN0cmluZyhuYW1lKSB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnMoYXBwcywgbmFtZSkpIHtcbiAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLkRVUExJQ0FURV9BUFAsIHsgbmFtZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhcHAgPSBuZXcgZmlyZWJhc2VBcHBJbXBsKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG5hbWVzcGFjZSBhcyBfRmlyZWJhc2VOYW1lc3BhY2VcbiAgICApO1xuXG4gICAgYXBwc1tuYW1lXSA9IGFwcDtcbiAgICBjYWxsQXBwSG9va3MoYXBwLCAnY3JlYXRlJyk7XG5cbiAgICByZXR1cm4gYXBwO1xuICB9XG5cbiAgLypcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGFsbCB0aGUgbm9uLWRlbGV0ZWQgRmlyZWJhc2VBcHBzLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXBwcygpOiBGaXJlYmFzZUFwcFtdIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyBjYWxsZXIgY2Fubm90IG11dGF0ZSB0aGUgYXBwcyBsaXN0LlxuICAgIHJldHVybiBPYmplY3Qua2V5cyhhcHBzKS5tYXAobmFtZSA9PiBhcHBzW25hbWVdKTtcbiAgfVxuXG4gIC8qXG4gICAqIFJlZ2lzdGVyIGEgRmlyZWJhc2UgU2VydmljZS5cbiAgICpcbiAgICogZmlyZWJhc2UuSU5URVJOQUwucmVnaXN0ZXJTZXJ2aWNlKClcbiAgICpcbiAgICogVE9ETzogSW1wbGVtZW50IHNlcnZpY2VQcm9wZXJ0aWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVnaXN0ZXJTZXJ2aWNlKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBjcmVhdGVTZXJ2aWNlOiBGaXJlYmFzZVNlcnZpY2VGYWN0b3J5LFxuICAgIHNlcnZpY2VQcm9wZXJ0aWVzPzogeyBbcHJvcDogc3RyaW5nXTogdW5rbm93biB9LFxuICAgIGFwcEhvb2s/OiBBcHBIb29rLFxuICAgIGFsbG93TXVsdGlwbGVJbnN0YW5jZXMgPSBmYWxzZVxuICApOiBGaXJlYmFzZVNlcnZpY2VOYW1lc3BhY2U8RmlyZWJhc2VTZXJ2aWNlPiB7XG4gICAgLy8gQ2Fubm90IHJlLXJlZ2lzdGVyIGEgc2VydmljZSB0aGF0IGFscmVhZHkgZXhpc3RzXG4gICAgaWYgKGZhY3Rvcmllc1tuYW1lXSkge1xuICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuRFVQTElDQVRFX1NFUlZJQ0UsIHsgbmFtZSB9KTtcbiAgICB9XG5cbiAgICAvLyBDYXB0dXJlIHRoZSBzZXJ2aWNlIGZhY3RvcnkgZm9yIGxhdGVyIHNlcnZpY2UgaW5zdGFudGlhdGlvblxuICAgIGZhY3Rvcmllc1tuYW1lXSA9IGNyZWF0ZVNlcnZpY2U7XG5cbiAgICAvLyBDYXB0dXJlIHRoZSBhcHBIb29rLCBpZiBwYXNzZWRcbiAgICBpZiAoYXBwSG9vaykge1xuICAgICAgYXBwSG9va3NbbmFtZV0gPSBhcHBIb29rO1xuXG4gICAgICAvLyBSdW4gdGhlICoqbmV3KiogYXBwIGhvb2sgb24gYWxsIGV4aXN0aW5nIGFwcHNcbiAgICAgIGdldEFwcHMoKS5mb3JFYWNoKGFwcCA9PiB7XG4gICAgICAgIGFwcEhvb2soJ2NyZWF0ZScsIGFwcCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUaGUgU2VydmljZSBuYW1lc3BhY2UgaXMgYW4gYWNjZXNzb3IgZnVuY3Rpb24gLi4uXG4gICAgZnVuY3Rpb24gc2VydmljZU5hbWVzcGFjZShhcHBBcmc6IEZpcmViYXNlQXBwID0gYXBwKCkpOiBGaXJlYmFzZVNlcnZpY2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKHR5cGVvZiBhcHBBcmdbbmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSW52YWxpZCBhcmd1bWVudC5cbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHRoZSBmb2xsb3dpbmcgY2FzZTogZmlyZWJhc2Uuc3RvcmFnZSgnZ3M6LycpXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5ULCB7XG4gICAgICAgICAgbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yd2FyZCBzZXJ2aWNlIGluc3RhbmNlIGxvb2t1cCB0byB0aGUgRmlyZWJhc2VBcHAuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4gYXBwQXJnW25hbWVdKCk7XG4gICAgfVxuXG4gICAgLy8gLi4uIGFuZCBhIGNvbnRhaW5lciBmb3Igc2VydmljZS1sZXZlbCBwcm9wZXJ0aWVzLlxuICAgIGlmIChzZXJ2aWNlUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWVwRXh0ZW5kKHNlcnZpY2VOYW1lc3BhY2UsIHNlcnZpY2VQcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvLyBNb25rZXktcGF0Y2ggdGhlIHNlcnZpY2VOYW1lc3BhY2Ugb250byB0aGUgZmlyZWJhc2UgbmFtZXNwYWNlXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG5hbWVzcGFjZVtuYW1lXSA9IHNlcnZpY2VOYW1lc3BhY2U7XG5cbiAgICAvLyBQYXRjaCB0aGUgRmlyZWJhc2VBcHBJbXBsIHByb3RvdHlwZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmaXJlYmFzZUFwcEltcGwucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc3Qgc2VydmljZUZ4biA9IHRoaXMuX2dldFNlcnZpY2UuYmluZCh0aGlzLCBuYW1lKTtcbiAgICAgIHJldHVybiBzZXJ2aWNlRnhuLmFwcGx5KHRoaXMsIGFsbG93TXVsdGlwbGVJbnN0YW5jZXMgPyBhcmdzIDogW10pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2VydmljZU5hbWVzcGFjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxBcHBIb29rcyhhcHA6IEZpcmViYXNlQXBwLCBldmVudE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc2VydmljZU5hbWUgb2YgT2JqZWN0LmtleXMoZmFjdG9yaWVzKSkge1xuICAgICAgLy8gSWdub3JlIHZpcnR1YWwgc2VydmljZXNcbiAgICAgIGNvbnN0IGZhY3RvcnlOYW1lID0gdXNlQXNTZXJ2aWNlKGFwcCwgc2VydmljZU5hbWUpO1xuICAgICAgaWYgKGZhY3RvcnlOYW1lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFwcEhvb2tzW2ZhY3RvcnlOYW1lXSkge1xuICAgICAgICBhcHBIb29rc1tmYWN0b3J5TmFtZV0oZXZlbnROYW1lLCBhcHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE1hcCB0aGUgcmVxdWVzdGVkIHNlcnZpY2UgdG8gYSByZWdpc3RlcmVkIHNlcnZpY2UgbmFtZVxuICAvLyAodXNlZCB0byBtYXAgYXV0aCB0byBzZXJ2ZXJBdXRoIHNlcnZpY2Ugd2hlbiBuZWVkZWQpLlxuICBmdW5jdGlvbiB1c2VBc1NlcnZpY2UoYXBwOiBGaXJlYmFzZUFwcCwgbmFtZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKG5hbWUgPT09ICdzZXJ2ZXJBdXRoJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlU2VydmljZSA9IG5hbWU7XG5cbiAgICByZXR1cm4gdXNlU2VydmljZTtcbiAgfVxuXG4gIHJldHVybiBuYW1lc3BhY2U7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlyZWJhc2VOYW1lc3BhY2UgfSBmcm9tICdAZmlyZWJhc2UvYXBwLXR5cGVzJztcbmltcG9ydCB7IF9GaXJlYmFzZUFwcCwgX0ZpcmViYXNlTmFtZXNwYWNlIH0gZnJvbSAnQGZpcmViYXNlL2FwcC10eXBlcy9wcml2YXRlJztcbmltcG9ydCB7IGNyZWF0ZVN1YnNjcmliZSwgZGVlcEV4dGVuZCwgRXJyb3JGYWN0b3J5IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgRmlyZWJhc2VBcHBJbXBsIH0gZnJvbSAnLi9maXJlYmFzZUFwcCc7XG5pbXBvcnQgeyBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZUNvcmUgfSBmcm9tICcuL2ZpcmViYXNlTmFtZXNwYWNlQ29yZSc7XG5cbi8qKlxuICogUmV0dXJuIGEgZmlyZWJhc2UgbmFtZXNwYWNlIG9iamVjdC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGV4YWN0bHkgb25jZSBhbmQgdGhlIHJlc3VsdFxuICogYXNzaWduZWQgdG8gdGhlICdmaXJlYmFzZScgZ2xvYmFsLiAgSXQgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICogaW4gdW5pdCB0ZXN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlKCk6IEZpcmViYXNlTmFtZXNwYWNlIHtcbiAgY29uc3QgbmFtZXNwYWNlID0gY3JlYXRlRmlyZWJhc2VOYW1lc3BhY2VDb3JlKEZpcmViYXNlQXBwSW1wbCk7XG4gIChuYW1lc3BhY2UgYXMgX0ZpcmViYXNlTmFtZXNwYWNlKS5JTlRFUk5BTCA9IHtcbiAgICAuLi4obmFtZXNwYWNlIGFzIF9GaXJlYmFzZU5hbWVzcGFjZSkuSU5URVJOQUwsXG4gICAgY3JlYXRlRmlyZWJhc2VOYW1lc3BhY2UsXG4gICAgZXh0ZW5kTmFtZXNwYWNlLFxuICAgIGNyZWF0ZVN1YnNjcmliZSxcbiAgICBFcnJvckZhY3RvcnksXG4gICAgZGVlcEV4dGVuZFxuICB9O1xuXG4gIC8qKlxuICAgKiBQYXRjaCB0aGUgdG9wLWxldmVsIGZpcmViYXNlIG5hbWVzcGFjZSB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcy5cbiAgICpcbiAgICogZmlyZWJhc2UuSU5URVJOQUwuZXh0ZW5kTmFtZXNwYWNlKClcbiAgICovXG4gIGZ1bmN0aW9uIGV4dGVuZE5hbWVzcGFjZShwcm9wczogeyBbcHJvcDogc3RyaW5nXTogdW5rbm93biB9KTogdm9pZCB7XG4gICAgZGVlcEV4dGVuZChuYW1lc3BhY2UsIHByb3BzKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lc3BhY2U7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0ICdAZmlyZWJhc2UvZGF0YWJhc2UnO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGpzb25FdmFsLCBzdHJpbmdpZnkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qKlxuICogV3JhcHMgYSBET00gU3RvcmFnZSBvYmplY3QgYW5kOlxuICogLSBhdXRvbWF0aWNhbGx5IGVuY29kZSBvYmplY3RzIGFzIEpTT04gc3RyaW5ncyBiZWZvcmUgc3RvcmluZyB0aGVtIHRvIGFsbG93IHVzIHRvIHN0b3JlIGFyYml0cmFyeSB0eXBlcy5cbiAqIC0gcHJlZml4ZXMgbmFtZXMgd2l0aCBcImZpcmViYXNlOlwiIHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aCBhcHAgZGF0YS5cbiAqXG4gKiBXZSBhdXRvbWF0aWNhbGx5IChzZWUgc3RvcmFnZS5qcykgY3JlYXRlIHR3byBzdWNoIHdyYXBwZXJzLCBvbmUgZm9yIHNlc3Npb25TdG9yYWdlLFxuICogYW5kIG9uZSBmb3IgbG9jYWxTdG9yYWdlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgRE9NU3RvcmFnZVdyYXBwZXIge1xuICAvLyBVc2UgYSBwcmVmaXggdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIG90aGVyIHN0dWZmIHNhdmVkIGJ5IHRoZSBhcHAuXG4gIHByaXZhdGUgcHJlZml4XyA9ICdmaXJlYmFzZTonO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0b3JhZ2V9IGRvbVN0b3JhZ2VfIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2Ugb2JqZWN0IChlLmcuIGxvY2FsU3RvcmFnZSBvciBzZXNzaW9uU3RvcmFnZSlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZG9tU3RvcmFnZV86IFN0b3JhZ2UpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzYXZlIHRoZSB2YWx1ZSB1bmRlclxuICAgKiBAcGFyYW0gez9PYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSBiZWluZyBzdG9yZWQsIG9yIG51bGwgdG8gcmVtb3ZlIHRoZSBrZXkuXG4gICAqL1xuICBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkgfCBudWxsKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHRoaXMuZG9tU3RvcmFnZV8ucmVtb3ZlSXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9tU3RvcmFnZV8uc2V0SXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSwgc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIHRoYXQgd2FzIHN0b3JlZCB1bmRlciB0aGlzIGtleSwgb3IgbnVsbFxuICAgKi9cbiAgZ2V0KGtleTogc3RyaW5nKTogYW55IHtcbiAgICBjb25zdCBzdG9yZWRWYWwgPSB0aGlzLmRvbVN0b3JhZ2VfLmdldEl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xuICAgIGlmIChzdG9yZWRWYWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBqc29uRXZhbChzdG9yZWRWYWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICByZW1vdmUoa2V5OiBzdHJpbmcpIHtcbiAgICB0aGlzLmRvbVN0b3JhZ2VfLnJlbW92ZUl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xuICB9XG5cbiAgaXNJbk1lbW9yeVN0b3JhZ2U6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHByZWZpeGVkTmFtZV8obmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wcmVmaXhfICsgbmFtZTtcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZG9tU3RvcmFnZV8udG9TdHJpbmcoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGNvbnRhaW5zIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcbiAqIEFuIGluLW1lbW9yeSBzdG9yYWdlIGltcGxlbWVudGF0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgQVBJIG9mIERPTVN0b3JhZ2VXcmFwcGVyXG4gKiAoVE9ETzogY3JlYXRlIGludGVyZmFjZSBmb3IgYm90aCB0byBpbXBsZW1lbnQpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgTWVtb3J5U3RvcmFnZSB7XG4gIHByaXZhdGUgY2FjaGVfOiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuXG4gIHNldChrZXk6IHN0cmluZywgdmFsdWU6IGFueSB8IG51bGwpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FjaGVfW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBnZXQoa2V5OiBzdHJpbmcpOiBhbnkge1xuICAgIGlmIChjb250YWlucyh0aGlzLmNhY2hlXywga2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfW2tleV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVtb3ZlKGtleTogc3RyaW5nKSB7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XG4gIH1cblxuICBpc0luTWVtb3J5U3RvcmFnZSA9IHRydWU7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRE9NU3RvcmFnZVdyYXBwZXIgfSBmcm9tICcuL0RPTVN0b3JhZ2VXcmFwcGVyJztcbmltcG9ydCB7IE1lbW9yeVN0b3JhZ2UgfSBmcm9tICcuL01lbW9yeVN0b3JhZ2UnO1xuXG5kZWNsYXJlIGNvbnN0IHdpbmRvdzogYW55O1xuXG4vKipcbiAqIEhlbHBlciB0byBjcmVhdGUgYSBET01TdG9yYWdlV3JhcHBlciBvciBlbHNlIGZhbGwgYmFjayB0byBNZW1vcnlTdG9yYWdlLlxuICogVE9ETzogT25jZSBNZW1vcnlTdG9yYWdlIGFuZCBET01TdG9yYWdlV3JhcHBlciBoYXZlIGEgc2hhcmVkIGludGVyZmFjZSB0aGlzIG1ldGhvZCBhbm5vdGF0aW9uIHNob3VsZCBjaGFuZ2VcbiAqIHRvIHJlZmxlY3QgdGhpcyB0eXBlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRvbVN0b3JhZ2VOYW1lIE5hbWUgb2YgdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBvYmplY3RcbiAqICAgKGUuZy4gJ2xvY2FsU3RvcmFnZScgb3IgJ3Nlc3Npb25TdG9yYWdlJykuXG4gKiBAcmV0dXJuIHs/fSBUdXJuaW5nIG9mZiB0eXBlIGluZm9ybWF0aW9uIHVudGlsIGEgY29tbW9uIGludGVyZmFjZSBpcyBkZWZpbmVkLlxuICovXG5jb25zdCBjcmVhdGVTdG9yYWdlZm9yID0gZnVuY3Rpb24oXG4gIGRvbVN0b3JhZ2VOYW1lOiBzdHJpbmdcbik6IERPTVN0b3JhZ2VXcmFwcGVyIHwgTWVtb3J5U3RvcmFnZSB7XG4gIHRyeSB7XG4gICAgLy8gTk9URToganVzdCBhY2Nlc3NpbmcgXCJsb2NhbFN0b3JhZ2VcIiBvciBcIndpbmRvd1snbG9jYWxTdG9yYWdlJ11cIiBtYXkgdGhyb3cgYSBzZWN1cml0eSBleGNlcHRpb24sXG4gICAgLy8gc28gaXQgbXVzdCBiZSBpbnNpZGUgdGhlIHRyeS9jYXRjaC5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIHdpbmRvd1tkb21TdG9yYWdlTmFtZV0gIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICAvLyBOZWVkIHRvIHRlc3QgY2FjaGUuIEp1c3QgYmVjYXVzZSBpdCdzIGhlcmUgZG9lc24ndCBtZWFuIGl0IHdvcmtzXG4gICAgICBjb25zdCBkb21TdG9yYWdlID0gd2luZG93W2RvbVN0b3JhZ2VOYW1lXTtcbiAgICAgIGRvbVN0b3JhZ2Uuc2V0SXRlbSgnZmlyZWJhc2U6c2VudGluZWwnLCAnY2FjaGUnKTtcbiAgICAgIGRvbVN0b3JhZ2UucmVtb3ZlSXRlbSgnZmlyZWJhc2U6c2VudGluZWwnKTtcbiAgICAgIHJldHVybiBuZXcgRE9NU3RvcmFnZVdyYXBwZXIoZG9tU3RvcmFnZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIC8vIEZhaWxlZCB0byBjcmVhdGUgd3JhcHBlci4gIEp1c3QgcmV0dXJuIGluLW1lbW9yeSBzdG9yYWdlLlxuICAvLyBUT0RPOiBsb2c/XG4gIHJldHVybiBuZXcgTWVtb3J5U3RvcmFnZSgpO1xufTtcblxuLyoqIEEgc3RvcmFnZSBvYmplY3QgdGhhdCBsYXN0cyBhY3Jvc3Mgc2Vzc2lvbnMgKi9cbmV4cG9ydCBjb25zdCBQZXJzaXN0ZW50U3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2Vmb3IoJ2xvY2FsU3RvcmFnZScpO1xuXG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IG9ubHkgbGFzdHMgb25lIHNlc3Npb24gKi9cbmV4cG9ydCBjb25zdCBTZXNzaW9uU3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2Vmb3IoJ3Nlc3Npb25TdG9yYWdlJyk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuLi8uLi9hcGkvUXVlcnknO1xuXG5kZWNsYXJlIGNvbnN0IHdpbmRvdzogYW55O1xuZGVjbGFyZSBjb25zdCBXaW5kb3dzOiBhbnk7XG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGZvckVhY2ggfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBTaGExIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgc3RyaW5nVG9CeXRlQXJyYXkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBTZXNzaW9uU3RvcmFnZSB9IGZyb20gJy4uL3N0b3JhZ2Uvc3RvcmFnZSc7XG5pbXBvcnQgeyBpc05vZGVTZGsgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBMb2dnZXIsIExvZ0xldmVsIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5cbmNvbnN0IGxvZ0NsaWVudCA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9kYXRhYmFzZScpO1xuXG4vKipcbiAqIFJldHVybnMgYSBsb2NhbGx5LXVuaXF1ZSBJRCAoZ2VuZXJhdGVkIGJ5IGp1c3QgaW5jcmVtZW50aW5nIHVwIGZyb20gMCBlYWNoIHRpbWUgaXRzIGNhbGxlZCkuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKTogbnVtYmVyfSBHZW5lcmF0ZWQgSUQuXG4gKi9cbmV4cG9ydCBjb25zdCBMVUlER2VuZXJhdG9yOiAoKSA9PiBudW1iZXIgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9IDE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWQrKztcbiAgfTtcbn0pKCk7XG5cbi8qKlxuICogU2hhMSBoYXNoIG9mIHRoZSBpbnB1dCBzdHJpbmdcbiAqIEBwYXJhbSB7IXN0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gaGFzaFxuICogQHJldHVybiB7IXN0cmluZ30gVGhlIHJlc3VsdGluZyBoYXNoXG4gKi9cbmV4cG9ydCBjb25zdCBzaGExID0gZnVuY3Rpb24oc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCB1dGY4Qnl0ZXMgPSBzdHJpbmdUb0J5dGVBcnJheShzdHIpO1xuICBjb25zdCBzaGExID0gbmV3IFNoYTEoKTtcbiAgc2hhMS51cGRhdGUodXRmOEJ5dGVzKTtcbiAgY29uc3Qgc2hhMUJ5dGVzID0gc2hhMS5kaWdlc3QoKTtcbiAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkoc2hhMUJ5dGVzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJnc1xuICogQHJldHVybiB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYnVpbGRMb2dNZXNzYWdlXyA9IGZ1bmN0aW9uKC4uLnZhcl9hcmdzOiBhbnlbXSk6IHN0cmluZyB7XG4gIGxldCBtZXNzYWdlID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFyX2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KHZhcl9hcmdzW2ldKSB8fFxuICAgICAgKHZhcl9hcmdzW2ldICYmXG4gICAgICAgIHR5cGVvZiB2YXJfYXJnc1tpXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIHZhcl9hcmdzW2ldLmxlbmd0aCA9PT0gJ251bWJlcicpXG4gICAgKSB7XG4gICAgICBtZXNzYWdlICs9IGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkobnVsbCwgdmFyX2FyZ3NbaV0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhcl9hcmdzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWVzc2FnZSArPSBzdHJpbmdpZnkodmFyX2FyZ3NbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IHZhcl9hcmdzW2ldO1xuICAgIH1cbiAgICBtZXNzYWdlICs9ICcgJztcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlO1xufTtcblxuLyoqXG4gKiBVc2UgdGhpcyBmb3IgYWxsIGRlYnVnIG1lc3NhZ2VzIGluIEZpcmViYXNlLlxuICogQHR5cGUgez9mdW5jdGlvbihzdHJpbmcpfVxuICovXG5leHBvcnQgbGV0IGxvZ2dlcjogKChhOiBzdHJpbmcpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG5cbi8qKlxuICogRmxhZyB0byBjaGVjayBmb3IgbG9nIGF2YWlsYWJpbGl0eSBvbiBmaXJzdCBsb2cgbWVzc2FnZVxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5sZXQgZmlyc3RMb2dfID0gdHJ1ZTtcblxuLyoqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgRmlyZWJhc2UuZW5hYmxlTG9nZ2luZyAoZGVmaW5lZCBoZXJlIHRvIGJyZWFrIGRlcGVuZGVuY2llcylcbiAqIEBwYXJhbSB7Ym9vbGVhbnw/ZnVuY3Rpb24oc3RyaW5nKX0gbG9nZ2VyXyBBIGZsYWcgdG8gdHVybiBvbiBsb2dnaW5nLCBvciBhIGN1c3RvbSBsb2dnZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHBlcnNpc3RlbnQgV2hldGhlciBvciBub3QgdG8gcGVyc2lzdCBsb2dnaW5nIHNldHRpbmdzIGFjcm9zcyByZWZyZXNoZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGVuYWJsZUxvZ2dpbmcgPSBmdW5jdGlvbihcbiAgbG9nZ2VyXz86IGJvb2xlYW4gfCAoKGE6IHN0cmluZykgPT4gdm9pZCkgfCBudWxsLFxuICBwZXJzaXN0ZW50PzogYm9vbGVhblxuKSB7XG4gIGFzc2VydChcbiAgICAhcGVyc2lzdGVudCB8fCAobG9nZ2VyXyA9PT0gdHJ1ZSB8fCBsb2dnZXJfID09PSBmYWxzZSksXG4gICAgXCJDYW4ndCB0dXJuIG9uIGN1c3RvbSBsb2dnZXJzIHBlcnNpc3RlbnRseS5cIlxuICApO1xuICBpZiAobG9nZ2VyXyA9PT0gdHJ1ZSkge1xuICAgIGxvZ0NsaWVudC5sb2dMZXZlbCA9IExvZ0xldmVsLlZFUkJPU0U7XG4gICAgbG9nZ2VyID0gbG9nQ2xpZW50LmxvZy5iaW5kKGxvZ0NsaWVudCk7XG4gICAgaWYgKHBlcnNpc3RlbnQpIFNlc3Npb25TdG9yYWdlLnNldCgnbG9nZ2luZ19lbmFibGVkJywgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxvZ2dlcl8gPT09ICdmdW5jdGlvbicpIHtcbiAgICBsb2dnZXIgPSBsb2dnZXJfO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlciA9IG51bGw7XG4gICAgU2Vzc2lvblN0b3JhZ2UucmVtb3ZlKCdsb2dnaW5nX2VuYWJsZWQnKTtcbiAgfVxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfEFyZ3VtZW50cyl9IHZhcl9hcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBsb2cgPSBmdW5jdGlvbiguLi52YXJfYXJnczogc3RyaW5nW10pIHtcbiAgaWYgKGZpcnN0TG9nXyA9PT0gdHJ1ZSkge1xuICAgIGZpcnN0TG9nXyA9IGZhbHNlO1xuICAgIGlmIChsb2dnZXIgPT09IG51bGwgJiYgU2Vzc2lvblN0b3JhZ2UuZ2V0KCdsb2dnaW5nX2VuYWJsZWQnKSA9PT0gdHJ1ZSlcbiAgICAgIGVuYWJsZUxvZ2dpbmcodHJ1ZSk7XG4gIH1cblxuICBpZiAobG9nZ2VyKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkobnVsbCwgdmFyX2FyZ3MpO1xuICAgIGxvZ2dlcihtZXNzYWdlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHByZWZpeFxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uWypdKX1cbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ1dyYXBwZXIgPSBmdW5jdGlvbihcbiAgcHJlZml4OiBzdHJpbmdcbik6ICguLi52YXJfYXJnczogYW55W10pID0+IHZvaWQge1xuICByZXR1cm4gZnVuY3Rpb24oLi4udmFyX2FyZ3M6IGFueVtdKSB7XG4gICAgbG9nKHByZWZpeCwgLi4udmFyX2FyZ3MpO1xuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gdmFyX2FyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGVycm9yID0gZnVuY3Rpb24oLi4udmFyX2FyZ3M6IHN0cmluZ1tdKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSAnRklSRUJBU0UgSU5URVJOQUwgRVJST1I6ICcgKyBidWlsZExvZ01lc3NhZ2VfKC4uLnZhcl9hcmdzKTtcbiAgbG9nQ2xpZW50LmVycm9yKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gdmFyX2FyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGZhdGFsID0gZnVuY3Rpb24oLi4udmFyX2FyZ3M6IHN0cmluZ1tdKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBgRklSRUJBU0UgRkFUQUwgRVJST1I6ICR7YnVpbGRMb2dNZXNzYWdlXyguLi52YXJfYXJncyl9YDtcbiAgbG9nQ2xpZW50LmVycm9yKG1lc3NhZ2UpO1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHdhcm4gPSBmdW5jdGlvbiguLi52YXJfYXJnczogYW55W10pIHtcbiAgY29uc3QgbWVzc2FnZSA9ICdGSVJFQkFTRSBXQVJOSU5HOiAnICsgYnVpbGRMb2dNZXNzYWdlXyguLi52YXJfYXJncyk7XG4gIGxvZ0NsaWVudC53YXJuKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgY29udGFpbmluZyBwYWdlIHVzZXMgaHR0cHMuIENhbGxlZCB3aGVuIGEgY2FsbCB0byBuZXcgRmlyZWJhc2VcbiAqIGRvZXMgbm90IHVzZSBodHRwcy5cbiAqL1xuZXhwb3J0IGNvbnN0IHdhcm5JZlBhZ2VJc1NlY3VyZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBCZSB2ZXJ5IGNhcmVmdWwgYWNjZXNzaW5nIGJyb3dzZXIgZ2xvYmFscy4gV2hvIGtub3dzIHdoYXQgbWF5IG9yIG1heSBub3QgZXhpc3QuXG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHdpbmRvdy5sb2NhdGlvbiAmJlxuICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAmJlxuICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwczonKSAhPT0gLTFcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdJbnNlY3VyZSBGaXJlYmFzZSBhY2Nlc3MgZnJvbSBhIHNlY3VyZSBwYWdlLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgaHR0cHMgaW4gY2FsbHMgdG8gbmV3IEZpcmViYXNlKCkuJ1xuICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHshU3RyaW5nfSBtZXRob2ROYW1lXG4gKi9cbmV4cG9ydCBjb25zdCB3YXJuQWJvdXRVbnN1cHBvcnRlZE1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWU6IHN0cmluZykge1xuICB3YXJuKFxuICAgIG1ldGhvZE5hbWUgK1xuICAgICAgJyBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgY2hhbmdlIHNvb24uICAnICtcbiAgICAgICdQbGVhc2UgZG8gbm90IHVzZS4nXG4gICk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBkYXRhIGlzIE5hTiwgb3IgKy8tIEluZmluaXR5LlxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNJbnZhbGlkSlNPTk51bWJlciA9IGZ1bmN0aW9uKGRhdGE6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJlxuICAgIChkYXRhICE9IGRhdGEgfHwgLy8gTmFOXG4gICAgICBkYXRhID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxuICAgICAgZGF0YSA9PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpXG4gICk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4ZWN1dGVXaGVuRE9NUmVhZHkgPSBmdW5jdGlvbihmbjogKCkgPT4gdm9pZCkge1xuICBpZiAoaXNOb2RlU2RrKCkgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgIGZuKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTW9kZWxlZCBhZnRlciBqUXVlcnkuIFRyeSBET01Db250ZW50TG9hZGVkIGFuZCBvbnJlYWR5c3RhdGVjaGFuZ2UgKHdoaWNoXG4gICAgLy8gZmlyZSBiZWZvcmUgb25sb2FkKSwgYnV0IGZhbGwgYmFjayB0byBvbmxvYWQuXG5cbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgbGV0IHdyYXBwZWRGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHNldFRpbWVvdXQod3JhcHBlZEZuLCBNYXRoLmZsb29yKDEwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkRm4sIGZhbHNlKTtcbiAgICAgIC8vIGZhbGxiYWNrIHRvIG9ubG9hZC5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgd3JhcHBlZEZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmICgoZG9jdW1lbnQgYXMgYW55KS5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUuXG4gICAgICAoZG9jdW1lbnQgYXMgYW55KS5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB3cmFwcGVkRm4oKTtcbiAgICAgIH0pO1xuICAgICAgLy8gZmFsbGJhY2sgdG8gb25sb2FkLlxuICAgICAgKHdpbmRvdyBhcyBhbnkpLmF0dGFjaEV2ZW50KCdvbmxvYWQnLCB3cmFwcGVkRm4pO1xuXG4gICAgICAvLyBqUXVlcnkgaGFzIGFuIGV4dHJhIGhhY2sgZm9yIElFIHRoYXQgd2UgY291bGQgZW1wbG95IChiYXNlZCBvblxuICAgICAgLy8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC8pIEJ1dCBpdCBsb29rcyByZWFsbHkgb2xkLlxuICAgICAgLy8gSSdtIGhvcGluZyB3ZSBkb24ndCBuZWVkIGl0LlxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNaW5pbXVtIGtleSBuYW1lLiBJbnZhbGlkIGZvciBhY3R1YWwgZGF0YSwgdXNlZCBhcyBhIG1hcmtlciB0byBzb3J0IGJlZm9yZSBhbnkgdmFsaWQgbmFtZXNcbiAqIEB0eXBlIHshc3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgTUlOX05BTUUgPSAnW01JTl9OQU1FXSc7XG5cbi8qKlxuICogTWF4aW11bSBrZXkgbmFtZS4gSW52YWxpZCBmb3IgYWN0dWFsIGRhdGEsIHVzZWQgYXMgYSBtYXJrZXIgdG8gc29ydCBhYm92ZSBhbnkgdmFsaWQgbmFtZXNcbiAqIEB0eXBlIHshc3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgTUFYX05BTUUgPSAnW01BWF9OQU1FXSc7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsaWQgRmlyZWJhc2Uga2V5IG5hbWVzLCBwbHVzIG1pbiBhbmQgbWF4IG5hbWVcbiAqIEBwYXJhbSB7IXN0cmluZ30gYVxuICogQHBhcmFtIHshc3RyaW5nfSBiXG4gKiBAcmV0dXJuIHshbnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbmFtZUNvbXBhcmUgPSBmdW5jdGlvbihhOiBzdHJpbmcsIGI6IHN0cmluZyk6IG51bWJlciB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PT0gTUlOX05BTUUgfHwgYiA9PT0gTUFYX05BTUUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYiA9PT0gTUlOX05BTUUgfHwgYSA9PT0gTUFYX05BTUUpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhQXNJbnQgPSB0cnlQYXJzZUludChhKSxcbiAgICAgIGJBc0ludCA9IHRyeVBhcnNlSW50KGIpO1xuXG4gICAgaWYgKGFBc0ludCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJBc0ludCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYUFzSW50IC0gYkFzSW50ID09IDAgPyBhLmxlbmd0aCAtIGIubGVuZ3RoIDogYUFzSW50IC0gYkFzSW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYkFzSW50ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGFcbiAqIEBwYXJhbSB7IXN0cmluZ30gYlxuICogQHJldHVybiB7IW51bWJlcn0gY29tcGFyaXNvbiByZXN1bHQuXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdDb21wYXJlID0gZnVuY3Rpb24oYTogc3RyaW5nLCBiOiBzdHJpbmcpOiBudW1iZXIge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBjb25zdCByZXF1aXJlS2V5ID0gZnVuY3Rpb24oXG4gIGtleTogc3RyaW5nLFxuICBvYmo6IHsgW2s6IHN0cmluZ106IGFueSB9XG4pOiBhbnkge1xuICBpZiAob2JqICYmIGtleSBpbiBvYmopIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQga2V5ICgnICsga2V5ICsgJykgaW4gb2JqZWN0OiAnICsgc3RyaW5naWZ5KG9iailcbiAgICApO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBPYmplY3RUb1VuaXF1ZUtleSA9IGZ1bmN0aW9uKG9iajogYW55KTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIHN0cmluZ2lmeShvYmopO1xuXG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgZm9yIChsZXQgayBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goayk7XG4gIH1cblxuICAvLyBFeHBvcnQgYXMganNvbiwgYnV0IHdpdGggdGhlIGtleXMgc29ydGVkLlxuICBrZXlzLnNvcnQoKTtcbiAgbGV0IGtleSA9ICd7JztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgIT09IDApIGtleSArPSAnLCc7XG4gICAga2V5ICs9IHN0cmluZ2lmeShrZXlzW2ldKTtcbiAgICBrZXkgKz0gJzonO1xuICAgIGtleSArPSBPYmplY3RUb1VuaXF1ZUtleShvYmpba2V5c1tpXV0pO1xuICB9XG5cbiAga2V5ICs9ICd9JztcbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYSBudW1iZXIgb2Ygc21hbGxlciBzZWdtZW50cyBvZiBtYXhpbXVtIHNpemVcbiAqIEBwYXJhbSB7IXN0cmluZ30gc3RyIFRoZSBzdHJpbmdcbiAqIEBwYXJhbSB7IW51bWJlcn0gc2Vnc2l6ZSBUaGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcnMgaW4gdGhlIHN0cmluZy5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBUaGUgc3RyaW5nLCBzcGxpdCBpbnRvIGFwcHJvcHJpYXRlbHktc2l6ZWQgY2h1bmtzXG4gKi9cbmV4cG9ydCBjb25zdCBzcGxpdFN0cmluZ0J5U2l6ZSA9IGZ1bmN0aW9uKFxuICBzdHI6IHN0cmluZyxcbiAgc2Vnc2l6ZTogbnVtYmVyXG4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgaWYgKGxlbiA8PSBzZWdzaXplKSB7XG4gICAgcmV0dXJuIFtzdHJdO1xuICB9XG5cbiAgY29uc3QgZGF0YVNlZ3MgPSBbXTtcbiAgZm9yIChsZXQgYyA9IDA7IGMgPCBsZW47IGMgKz0gc2Vnc2l6ZSkge1xuICAgIGlmIChjICsgc2Vnc2l6ZSA+IGxlbikge1xuICAgICAgZGF0YVNlZ3MucHVzaChzdHIuc3Vic3RyaW5nKGMsIGxlbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhU2Vncy5wdXNoKHN0ci5zdWJzdHJpbmcoYywgYyArIHNlZ3NpemUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFTZWdzO1xufTtcblxuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggKGtleSwgdmFsdWUpIHBhaXIgaW4gYW4gb2JqZWN0IG9yXG4gKiBhcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggKGluZGV4LCB2YWx1ZSkgcGFpciBpbiBhbiBhcnJheVxuICogQHBhcmFtIHshKE9iamVjdHxBcnJheSl9IG9iaiBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtmdW5jdGlvbig/LCA/KX0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5XG4gKi9cbmV4cG9ydCBjb25zdCBlYWNoID0gZnVuY3Rpb24oXG4gIG9iajogT2JqZWN0IHwgQXJyYXk8YW55PixcbiAgZm46ICh2PzogYW55LCBrPzogYW55KSA9PiB2b2lkXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICBmbihpLCBvYmpbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBpbiB0aGUgY29udmVyc2lvbiBvZiBjb2RlIHdlIHJlbW92ZWQgdGhlIGdvb2cub2JqZWN0LmZvckVhY2hcbiAgICAgKiBmdW5jdGlvbiB3aGljaCBkaWQgYSB2YWx1ZSxrZXkgY2FsbGJhY2suIFdlIHN0YW5kYXJkaXplZCBvblxuICAgICAqIGEgc2luZ2xlIGltcGwgdGhhdCBkb2VzIGEga2V5LCB2YWx1ZSBjYWxsYmFjay4gU28gd2UgaW52ZXJ0XG4gICAgICogdG8gbm90IGhhdmUgdG8gdG91Y2ggdGhlIGBlYWNoYCBjb2RlIHBvaW50c1xuICAgICAqL1xuICAgIGZvckVhY2gob2JqLCAoa2V5OiBhbnksIHZhbDogYW55KSA9PiBmbih2YWwsIGtleSkpO1xuICB9XG59O1xuXG4vKipcbiAqIExpa2UgZ29vZy5iaW5kLCBidXQgZG9lc24ndCBib3RoZXIgdG8gY3JlYXRlIGEgY2xvc3VyZSBpZiBvcHRfY29udGV4dCBpcyBudWxsL3VuZGVmaW5lZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/T2JqZWN0PX0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigqKX1cbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmRDYWxsYmFjayA9IGZ1bmN0aW9uKFxuICBjYWxsYmFjazogKGE6IGFueSkgPT4gdm9pZCxcbiAgY29udGV4dD86IG9iamVjdCB8IG51bGxcbik6IEZ1bmN0aW9uIHtcbiAgcmV0dXJuIGNvbnRleHQgPyBjYWxsYmFjay5iaW5kKGNvbnRleHQpIDogY2FsbGJhY2s7XG59O1xuXG4vKipcbiAqIEJvcnJvd2VkIGZyb20gaHR0cDovL2hnLnNlY29uZGxpZmUuY29tL2xsc2Qvc3JjL3RpcC9qcy90eXBlZGFycmF5LmpzIChNSVQgTGljZW5zZSlcbiAqIEkgbWFkZSBvbmUgbW9kaWZpY2F0aW9uIGF0IHRoZSBlbmQgYW5kIHJlbW92ZWQgdGhlIE5hTiAvIEluZmluaXR5XG4gKiBoYW5kbGluZyAoc2luY2UgaXQgc2VlbWVkIGJyb2tlbiBbY2F1c2VkIGFuIG92ZXJmbG93XSBhbmQgd2UgZG9uJ3QgbmVlZCBpdCkuICBTZWUgTUpMIGNvbW1lbnRzLlxuICogQHBhcmFtIHshbnVtYmVyfSB2IEEgZG91YmxlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBkb3VibGVUb0lFRUU3NTRTdHJpbmcgPSBmdW5jdGlvbih2OiBudW1iZXIpOiBzdHJpbmcge1xuICBhc3NlcnQoIWlzSW52YWxpZEpTT05OdW1iZXIodiksICdJbnZhbGlkIEpTT04gbnVtYmVyJyk7IC8vIE1KTFxuXG4gIGNvbnN0IGViaXRzID0gMTEsXG4gICAgZmJpdHMgPSA1MjtcbiAgbGV0IGJpYXMgPSAoMSA8PCAoZWJpdHMgLSAxKSkgLSAxLFxuICAgIHMsXG4gICAgZSxcbiAgICBmLFxuICAgIGxuLFxuICAgIGksXG4gICAgYml0cyxcbiAgICBzdHI7XG5cbiAgLy8gQ29tcHV0ZSBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cbiAgLy8gU2tpcCBOYU4gLyBJbmZpbml0eSBoYW5kbGluZyAtLU1KTC5cbiAgaWYgKHYgPT09IDApIHtcbiAgICBlID0gMDtcbiAgICBmID0gMDtcbiAgICBzID0gMSAvIHYgPT09IC1JbmZpbml0eSA/IDEgOiAwO1xuICB9IGVsc2Uge1xuICAgIHMgPSB2IDwgMDtcbiAgICB2ID0gTWF0aC5hYnModik7XG5cbiAgICBpZiAodiA+PSBNYXRoLnBvdygyLCAxIC0gYmlhcykpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWRcbiAgICAgIGxuID0gTWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLmxvZyh2KSAvIE1hdGguTE4yKSwgYmlhcyk7XG4gICAgICBlID0gbG4gKyBiaWFzO1xuICAgICAgZiA9IE1hdGgucm91bmQodiAqIE1hdGgucG93KDIsIGZiaXRzIC0gbG4pIC0gTWF0aC5wb3coMiwgZmJpdHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVub3JtYWxpemVkXG4gICAgICBlID0gMDtcbiAgICAgIGYgPSBNYXRoLnJvdW5kKHYgLyBNYXRoLnBvdygyLCAxIC0gYmlhcyAtIGZiaXRzKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUGFjayBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cbiAgYml0cyA9IFtdO1xuICBmb3IgKGkgPSBmYml0czsgaTsgaSAtPSAxKSB7XG4gICAgYml0cy5wdXNoKGYgJSAyID8gMSA6IDApO1xuICAgIGYgPSBNYXRoLmZsb29yKGYgLyAyKTtcbiAgfVxuICBmb3IgKGkgPSBlYml0czsgaTsgaSAtPSAxKSB7XG4gICAgYml0cy5wdXNoKGUgJSAyID8gMSA6IDApO1xuICAgIGUgPSBNYXRoLmZsb29yKGUgLyAyKTtcbiAgfVxuICBiaXRzLnB1c2gocyA/IDEgOiAwKTtcbiAgYml0cy5yZXZlcnNlKCk7XG4gIHN0ciA9IGJpdHMuam9pbignJyk7XG5cbiAgLy8gUmV0dXJuIHRoZSBkYXRhIGFzIGEgaGV4IHN0cmluZy4gLS1NSkxcbiAgbGV0IGhleEJ5dGVTdHJpbmcgPSAnJztcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDgpIHtcbiAgICBsZXQgaGV4Qnl0ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSwgOCksIDIpLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Qnl0ZS5sZW5ndGggPT09IDEpIGhleEJ5dGUgPSAnMCcgKyBoZXhCeXRlO1xuICAgIGhleEJ5dGVTdHJpbmcgPSBoZXhCeXRlU3RyaW5nICsgaGV4Qnl0ZTtcbiAgfVxuICByZXR1cm4gaGV4Qnl0ZVN0cmluZy50b0xvd2VyQ2FzZSgpO1xufTtcblxuLyoqXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIENocm9tZSBjb250ZW50IHNjcmlwdCAod2hpY2ggZXhlY3V0ZXMgaW4gYW5cbiAqIGlzb2xhdGVkIGVudmlyb25tZW50IHdoZXJlIGxvbmctcG9sbGluZyBkb2Vzbid0IHdvcmspLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCA9IGZ1bmN0aW9uKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gISEoXG4gICAgdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcbiAgICB3aW5kb3dbJ2Nocm9tZSddICYmXG4gICAgd2luZG93WydjaHJvbWUnXVsnZXh0ZW5zaW9uJ10gJiZcbiAgICAhL15jaHJvbWUvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICk7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlJ3JlIGluIGEgV2luZG93cyA4IFN0b3JlIGFwcC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1dpbmRvd3NTdG9yZUFwcCA9IGZ1bmN0aW9uKCk6IGJvb2xlYW4ge1xuICAvLyBDaGVjayBmb3IgdGhlIHByZXNlbmNlIG9mIGEgY291cGxlIFdpblJUIGdsb2JhbHNcbiAgcmV0dXJuIHR5cGVvZiBXaW5kb3dzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgV2luZG93cy5VSSA9PT0gJ29iamVjdCc7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2VydmVyIGVycm9yIGNvZGUgdG8gYSBKYXZhc2NyaXB0IEVycm9yXG4gKiBAcGFyYW0geyFzdHJpbmd9IGNvZGVcbiAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICogQHJldHVybiB7RXJyb3J9XG4gKi9cbmV4cG9ydCBjb25zdCBlcnJvckZvclNlcnZlckNvZGUgPSBmdW5jdGlvbihjb2RlOiBzdHJpbmcsIHF1ZXJ5OiBRdWVyeSk6IEVycm9yIHtcbiAgbGV0IHJlYXNvbiA9ICdVbmtub3duIEVycm9yJztcbiAgaWYgKGNvZGUgPT09ICd0b29fYmlnJykge1xuICAgIHJlYXNvbiA9XG4gICAgICAnVGhlIGRhdGEgcmVxdWVzdGVkIGV4Y2VlZHMgdGhlIG1heGltdW0gc2l6ZSAnICtcbiAgICAgICd0aGF0IGNhbiBiZSBhY2Nlc3NlZCB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuJztcbiAgfSBlbHNlIGlmIChjb2RlID09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcbiAgICByZWFzb24gPSBcIkNsaWVudCBkb2Vzbid0IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhlIGRlc2lyZWQgZGF0YS5cIjtcbiAgfSBlbHNlIGlmIChjb2RlID09ICd1bmF2YWlsYWJsZScpIHtcbiAgICByZWFzb24gPSAnVGhlIHNlcnZpY2UgaXMgdW5hdmFpbGFibGUnO1xuICB9XG5cbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgY29kZSArICcgYXQgJyArIHF1ZXJ5LnBhdGgudG9TdHJpbmcoKSArICc6ICcgKyByZWFzb25cbiAgKTtcbiAgKGVycm9yIGFzIGFueSkuY29kZSA9IGNvZGUudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIGVycm9yO1xufTtcblxuLyoqXG4gKiBVc2VkIHRvIHRlc3QgZm9yIGludGVnZXItbG9va2luZyBzdHJpbmdzXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IElOVEVHRVJfUkVHRVhQXyA9IG5ldyBSZWdFeHAoJ14tP1xcXFxkezEsMTB9JCcpO1xuXG4vKipcbiAqIElmIHRoZSBzdHJpbmcgY29udGFpbnMgYSAzMi1iaXQgaW50ZWdlciwgcmV0dXJuIGl0LiAgRWxzZSByZXR1cm4gbnVsbC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHs/bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgdHJ5UGFyc2VJbnQgPSBmdW5jdGlvbihzdHI6IHN0cmluZyk6IG51bWJlciB8IG51bGwge1xuICBpZiAoSU5URUdFUl9SRUdFWFBfLnRlc3Qoc3RyKSkge1xuICAgIGNvbnN0IGludFZhbCA9IE51bWJlcihzdHIpO1xuICAgIGlmIChpbnRWYWwgPj0gLTIxNDc0ODM2NDggJiYgaW50VmFsIDw9IDIxNDc0ODM2NDcpIHtcbiAgICAgIHJldHVybiBpbnRWYWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcnVuIHNvbWUgY29kZSBidXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgYW5kIHJlLXRocm93IHRoZW0gbGF0ZXIuXG4gKiBVc2VmdWwgZm9yIHByZXZlbnRpbmcgdXNlciBjYWxsYmFja3MgZnJvbSBicmVha2luZyBpbnRlcm5hbCBjb2RlLlxuICpcbiAqIFJlLXRocm93aW5nIHRoZSBleGNlcHRpb24gZnJvbSBhIHNldFRpbWVvdXQgaXMgYSBsaXR0bGUgZXZpbCwgYnV0IGl0J3MgdmVyeVxuICogY29udmVuaWVudCAod2UgZG9uJ3QgaGF2ZSB0byB0cnkgdG8gZmlndXJlIG91dCB3aGVuIGlzIGEgc2FmZSBwb2ludCB0b1xuICogcmUtdGhyb3cgaXQpLCBhbmQgdGhlIGJlaGF2aW9yIHNlZW1zIHJlYXNvbmFibGU6XG4gKlxuICogKiBJZiB5b3UgYXJlbid0IHBhdXNpbmcgb24gZXhjZXB0aW9ucywgeW91IGdldCBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aXRoXG4gKiAgIHRoZSBjb3JyZWN0IHN0YWNrIHRyYWNlLlxuICogKiBJZiB5b3UncmUgcGF1c2luZyBvbiBhbGwgZXhjZXB0aW9ucywgdGhlIGRlYnVnZ2VyIHdpbGwgcGF1c2Ugb24geW91clxuICogICBleGNlcHRpb24gYW5kIHRoZW4gYWdhaW4gd2hlbiB3ZSByZXRocm93IGl0LlxuICogKiBJZiB5b3UncmUgb25seSBwYXVzaW5nIG9uIHVuY2F1Z2h0IGV4Y2VwdGlvbnMsIHRoZSBkZWJ1Z2dlciB3aWxsIG9ubHkgcGF1c2VcbiAqICAgb24gdXMgcmUtdGhyb3dpbmcgaXQuXG4gKlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm4gVGhlIGNvZGUgdG8gZ3VhcmQuXG4gKi9cbmV4cG9ydCBjb25zdCBleGNlcHRpb25HdWFyZCA9IGZ1bmN0aW9uKGZuOiAoKSA9PiB2b2lkKSB7XG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFJlLXRocm93IGV4Y2VwdGlvbiB3aGVuIGl0J3Mgc2FmZS5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSXQgdXNlZCB0byBiZSB0aGF0IFwidGhyb3cgZVwiIHdvdWxkIHJlc3VsdCBpbiBhIGdvb2QgY29uc29sZSBlcnJvciB3aXRoXG4gICAgICAvLyByZWxldmFudCBjb250ZXh0LCBidXQgYXMgb2YgQ2hyb21lIDM5LCB5b3UganVzdCBnZXQgdGhlIGZpcmViYXNlLmpzXG4gICAgICAvLyBmaWxlL2xpbmUgbnVtYmVyIHdoZXJlIHdlIHJlLXRocm93IGl0LCB3aGljaCBpcyB1c2VsZXNzLiBTbyB3ZSBsb2dcbiAgICAgIC8vIGUuc3RhY2sgZXhwbGljaXRseS5cbiAgICAgIGNvbnN0IHN0YWNrID0gZS5zdGFjayB8fCAnJztcbiAgICAgIHdhcm4oJ0V4Y2VwdGlvbiB3YXMgdGhyb3duIGJ5IHVzZXIgY2FsbGJhY2suJywgc3RhY2spO1xuICAgICAgdGhyb3cgZTtcbiAgICB9LCBNYXRoLmZsb29yKDApKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2FmZWx5IGNhbGwgb3B0X2NhbGxiYWNrIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuICBJdDpcbiAqIDEuIFR1cm5zIGludG8gYSBuby1vcCBpZiBvcHRfY2FsbGJhY2sgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiAyLiBXcmFwcyB0aGUgY2FsbCBpbnNpZGUgZXhjZXB0aW9uR3VhcmQgdG8gcHJldmVudCBleGNlcHRpb25zIGZyb20gYnJlYWtpbmcgb3VyIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7P0Z1bmN0aW9uPX0gY2FsbGJhY2sgT3B0aW9uYWwgb25Db21wbGV0ZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQXJiaXRyYXJ5IGFyZ3MgdG8gYmUgcGFzc2VkIHRvIG9wdF9vbkNvbXBsZXRlXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxsVXNlckNhbGxiYWNrID0gZnVuY3Rpb24oXG4gIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBudWxsLFxuICAuLi52YXJfYXJnczogYW55W11cbikge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXhjZXB0aW9uR3VhcmQoZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayguLi52YXJfYXJncyk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB3ZSB0aGluayB3ZSdyZSBjdXJyZW50bHkgYmVpbmcgY3Jhd2xlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGJlaW5nQ3Jhd2xlZCA9IGZ1bmN0aW9uKCk6IGJvb2xlYW4ge1xuICBjb25zdCB1c2VyQWdlbnQgPVxuICAgICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJlxuICAgICAgd2luZG93WyduYXZpZ2F0b3InXSAmJlxuICAgICAgd2luZG93WyduYXZpZ2F0b3InXVsndXNlckFnZW50J10pIHx8XG4gICAgJyc7XG5cbiAgLy8gRm9yIG5vdyB3ZSB3aGl0ZWxpc3QgdGhlIG1vc3QgcG9wdWxhciBjcmF3bGVycy4gIFdlIHNob3VsZCByZWZpbmUgdGhpcyB0byBiZSB0aGUgc2V0IG9mIGNyYXdsZXJzIHdlXG4gIC8vIGJlbGlldmUgdG8gc3VwcG9ydCBKYXZhU2NyaXB0L0FKQVggcmVuZGVyaW5nLlxuICAvLyBOT1RFOiBHb29nbGUgV2VibWFzdGVyIFRvb2xzIGRvZXNuJ3QgcmVhbGx5IGJlbG9uZywgYnV0IHRoZWlyIFwiVGhpcyBpcyBob3cgYSB2aXNpdG9yIHRvIHlvdXIgd2Vic2l0ZVxuICAvLyB3b3VsZCBoYXZlIHNlZW4gdGhlIHBhZ2VcIiBpcyBmbGFreSBpZiB3ZSBkb24ndCB0cmVhdCBpdCBhcyBhIGNyYXdsZXIuXG4gIHJldHVybiAoXG4gICAgdXNlckFnZW50LnNlYXJjaChcbiAgICAgIC9nb29nbGVib3R8Z29vZ2xlIHdlYm1hc3RlciB0b29sc3xiaW5nYm90fHlhaG9vISBzbHVycHxiYWlkdXNwaWRlcnx5YW5kZXhib3R8ZHVja2R1Y2tib3QvaVxuICAgICkgPj0gMFxuICApO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdXNpbmcgYSBnZXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpOiAqfSBmbkdldFxuICovXG5leHBvcnQgY29uc3QgZXhwb3J0UHJvcEdldHRlciA9IGZ1bmN0aW9uKFxuICBvYmplY3Q6IE9iamVjdCxcbiAgbmFtZTogc3RyaW5nLFxuICBmbkdldDogKCkgPT4gYW55XG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgeyBnZXQ6IGZuR2V0IH0pO1xufTtcblxuLyoqXG4gKiBTYW1lIGFzIHNldFRpbWVvdXQoKSBleGNlcHQgb24gTm9kZS5KUyBpdCB3aWxsIC9ub3QvIHByZXZlbnQgdGhlIHByb2Nlc3MgZnJvbSBleGl0aW5nLlxuICpcbiAqIEl0IGlzIHJlbW92ZWQgd2l0aCBjbGVhclRpbWVvdXQoKSBhcyBub3JtYWwuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gcnVuLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgTWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJ1bm5pbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ8T2JqZWN0fSBUaGUgc2V0VGltZW91dCgpIHJldHVybiB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFRpbWVvdXROb25CbG9ja2luZyA9IGZ1bmN0aW9uKFxuICBmbjogRnVuY3Rpb24sXG4gIHRpbWU6IG51bWJlclxuKTogbnVtYmVyIHwgT2JqZWN0IHtcbiAgY29uc3QgdGltZW91dDogbnVtYmVyIHwgT2JqZWN0ID0gc2V0VGltZW91dChmbiwgdGltZSk7XG4gIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ29iamVjdCcgJiYgKHRpbWVvdXQgYXMgYW55KVsndW5yZWYnXSkge1xuICAgICh0aW1lb3V0IGFzIGFueSlbJ3VucmVmJ10oKTtcbiAgfVxuICByZXR1cm4gdGltZW91dDtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgbmFtZUNvbXBhcmUgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgc3RyaW5nTGVuZ3RoIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIHBhcnNlZCBwYXRoLiAgSXQncyBpbW11dGFibGUgc28gdGhhdCB5b3VcbiAqIGNhbiBwYXNzIHRoZW0gYXJvdW5kIHRvIG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHRoZW0gY2hhbmdpbmdcbiAqIGl0LlxuICovXG5cbmV4cG9ydCBjbGFzcyBQYXRoIHtcbiAgcHJpdmF0ZSBwaWVjZXNfOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSBwaWVjZU51bV86IG51bWJlcjtcblxuICAvKipcbiAgICogU2luZ2xldG9uIHRvIHJlcHJlc2VudCBhbiBlbXB0eSBwYXRoXG4gICAqXG4gICAqIEBjb25zdFxuICAgKi9cbiAgc3RhdGljIGdldCBFbXB0eSgpIHtcbiAgICByZXR1cm4gbmV3IFBhdGgoJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBwYXRoT3JTdHJpbmcgUGF0aCBzdHJpbmcgdG8gcGFyc2UsXG4gICAqICAgICAgb3IgYW5vdGhlciBwYXRoLCBvciB0aGUgcmF3IHRva2VucyBhcnJheVxuICAgKiBAcGFyYW0ge251bWJlcj19IHBpZWNlTnVtXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXRoT3JTdHJpbmc6IHN0cmluZyB8IHN0cmluZ1tdLCBwaWVjZU51bT86IG51bWJlcikge1xuICAgIGlmIChwaWVjZU51bSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnBpZWNlc18gPSAocGF0aE9yU3RyaW5nIGFzIHN0cmluZykuc3BsaXQoJy8nKTtcblxuICAgICAgLy8gUmVtb3ZlIGVtcHR5IHBpZWNlcy5cbiAgICAgIGxldCBjb3B5VG8gPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5waWVjZXNfW2NvcHlUb10gPSB0aGlzLnBpZWNlc19baV07XG4gICAgICAgICAgY29weVRvKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGllY2VzXy5sZW5ndGggPSBjb3B5VG87XG5cbiAgICAgIHRoaXMucGllY2VOdW1fID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5waWVjZXNfID0gcGF0aE9yU3RyaW5nIGFzIHN0cmluZ1tdO1xuICAgICAgdGhpcy5waWVjZU51bV8gPSBwaWVjZU51bTtcbiAgICB9XG4gIH1cblxuICBnZXRGcm9udCgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAodGhpcy5waWVjZU51bV8gPj0gdGhpcy5waWVjZXNfLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdGhpcy5waWVjZXNfW3RoaXMucGllY2VOdW1fXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdGhpcyBwYXRoXG4gICAqL1xuICBnZXRMZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5waWVjZXNfLmxlbmd0aCAtIHRoaXMucGllY2VOdW1fO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFQYXRofVxuICAgKi9cbiAgcG9wRnJvbnQoKTogUGF0aCB7XG4gICAgbGV0IHBpZWNlTnVtID0gdGhpcy5waWVjZU51bV87XG4gICAgaWYgKHBpZWNlTnVtIDwgdGhpcy5waWVjZXNfLmxlbmd0aCkge1xuICAgICAgcGllY2VOdW0rKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXRoKHRoaXMucGllY2VzXywgcGllY2VOdW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBnZXRCYWNrKCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0aGlzLnBpZWNlTnVtXyA8IHRoaXMucGllY2VzXy5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5waWVjZXNfW3RoaXMucGllY2VzXy5sZW5ndGggLSAxXTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBsZXQgcGF0aFN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnBpZWNlTnVtXzsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMucGllY2VzX1tpXSAhPT0gJycpIHBhdGhTdHJpbmcgKz0gJy8nICsgdGhpcy5waWVjZXNfW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoU3RyaW5nIHx8ICcvJztcbiAgfVxuXG4gIHRvVXJsRW5jb2RlZFN0cmluZygpOiBzdHJpbmcge1xuICAgIGxldCBwYXRoU3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5waWVjZXNfW2ldICE9PSAnJylcbiAgICAgICAgcGF0aFN0cmluZyArPSAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHRoaXMucGllY2VzX1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoU3RyaW5nIHx8ICcvJztcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGFsbG93IGNvcHkgb2YgdGhlIHBhcnRzIG9mIHRoZSBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luXG4gICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fVxuICAgKi9cbiAgc2xpY2UoYmVnaW46IG51bWJlciA9IDApOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMucGllY2VzXy5zbGljZSh0aGlzLnBpZWNlTnVtXyArIGJlZ2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHs/UGF0aH1cbiAgICovXG4gIHBhcmVudCgpOiBQYXRoIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMucGllY2VOdW1fID49IHRoaXMucGllY2VzXy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgcGllY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgIHBpZWNlcy5wdXNoKHRoaXMucGllY2VzX1tpXSk7XG5cbiAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3whUGF0aH0gY2hpbGRQYXRoT2JqXG4gICAqIEByZXR1cm4geyFQYXRofVxuICAgKi9cbiAgY2hpbGQoY2hpbGRQYXRoT2JqOiBzdHJpbmcgfCBQYXRoKTogUGF0aCB7XG4gICAgY29uc3QgcGllY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKVxuICAgICAgcGllY2VzLnB1c2godGhpcy5waWVjZXNfW2ldKTtcblxuICAgIGlmIChjaGlsZFBhdGhPYmogaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgaSA9IGNoaWxkUGF0aE9iai5waWVjZU51bV87XG4gICAgICAgIGkgPCBjaGlsZFBhdGhPYmoucGllY2VzXy5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKSB7XG4gICAgICAgIHBpZWNlcy5wdXNoKGNoaWxkUGF0aE9iai5waWVjZXNfW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGRQaWVjZXMgPSBjaGlsZFBhdGhPYmouc3BsaXQoJy8nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRQaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkUGllY2VzW2ldLmxlbmd0aCA+IDApIHBpZWNlcy5wdXNoKGNoaWxkUGllY2VzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZXJlIGFyZSBubyBzZWdtZW50cyBpbiB0aGlzIHBhdGhcbiAgICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucGllY2VOdW1fID49IHRoaXMucGllY2VzXy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUGF0aH0gb3V0ZXJQYXRoXG4gICAqIEBwYXJhbSB7IVBhdGh9IGlubmVyUGF0aFxuICAgKiBAcmV0dXJuIHshUGF0aH0gVGhlIHBhdGggZnJvbSBvdXRlclBhdGggdG8gaW5uZXJQYXRoXG4gICAqL1xuICBzdGF0aWMgcmVsYXRpdmVQYXRoKG91dGVyUGF0aDogUGF0aCwgaW5uZXJQYXRoOiBQYXRoKTogUGF0aCB7XG4gICAgY29uc3Qgb3V0ZXIgPSBvdXRlclBhdGguZ2V0RnJvbnQoKSxcbiAgICAgIGlubmVyID0gaW5uZXJQYXRoLmdldEZyb250KCk7XG4gICAgaWYgKG91dGVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gaW5uZXJQYXRoO1xuICAgIH0gZWxzZSBpZiAob3V0ZXIgPT09IGlubmVyKSB7XG4gICAgICByZXR1cm4gUGF0aC5yZWxhdGl2ZVBhdGgob3V0ZXJQYXRoLnBvcEZyb250KCksIGlubmVyUGF0aC5wb3BGcm9udCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSU5URVJOQUwgRVJST1I6IGlubmVyUGF0aCAoJyArXG4gICAgICAgICAgaW5uZXJQYXRoICtcbiAgICAgICAgICAnKSBpcyBub3Qgd2l0aGluICcgK1xuICAgICAgICAgICdvdXRlclBhdGggKCcgK1xuICAgICAgICAgIG91dGVyUGF0aCArXG4gICAgICAgICAgJyknXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFQYXRofSBsZWZ0XG4gICAqIEBwYXJhbSB7IVBhdGh9IHJpZ2h0XG4gICAqIEByZXR1cm4ge251bWJlcn0gLTEsIDAsIDEgaWYgbGVmdCBpcyBsZXNzLCBlcXVhbCwgb3IgZ3JlYXRlciB0aGFuIHRoZSByaWdodC5cbiAgICovXG4gIHN0YXRpYyBjb21wYXJlUGF0aHMobGVmdDogUGF0aCwgcmlnaHQ6IFBhdGgpOiBudW1iZXIge1xuICAgIGNvbnN0IGxlZnRLZXlzID0gbGVmdC5zbGljZSgpO1xuICAgIGNvbnN0IHJpZ2h0S2V5cyA9IHJpZ2h0LnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0S2V5cy5sZW5ndGggJiYgaSA8IHJpZ2h0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY21wID0gbmFtZUNvbXBhcmUobGVmdEtleXNbaV0sIHJpZ2h0S2V5c1tpXSk7XG4gICAgICBpZiAoY21wICE9PSAwKSByZXR1cm4gY21wO1xuICAgIH1cbiAgICBpZiAobGVmdEtleXMubGVuZ3RoID09PSByaWdodEtleXMubGVuZ3RoKSByZXR1cm4gMDtcbiAgICByZXR1cm4gbGVmdEtleXMubGVuZ3RoIDwgcmlnaHRLZXlzLmxlbmd0aCA/IC0xIDogMTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1BhdGh9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcGF0aHMgYXJlIHRoZSBzYW1lLlxuICAgKi9cbiAgZXF1YWxzKG90aGVyOiBQYXRoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuZ2V0TGVuZ3RoKCkgIT09IG90aGVyLmdldExlbmd0aCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChcbiAgICAgIGxldCBpID0gdGhpcy5waWVjZU51bV8sIGogPSBvdGhlci5waWVjZU51bV87XG4gICAgICBpIDw9IHRoaXMucGllY2VzXy5sZW5ndGg7XG4gICAgICBpKyssIGorK1xuICAgICkge1xuICAgICAgaWYgKHRoaXMucGllY2VzX1tpXSAhPT0gb3RoZXIucGllY2VzX1tqXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHBhdGggaXMgYSBwYXJlbnQgKG9yIHRoZSBzYW1lIGFzKSBvdGhlclxuICAgKi9cbiAgY29udGFpbnMob3RoZXI6IFBhdGgpOiBib29sZWFuIHtcbiAgICBsZXQgaSA9IHRoaXMucGllY2VOdW1fO1xuICAgIGxldCBqID0gb3RoZXIucGllY2VOdW1fO1xuICAgIGlmICh0aGlzLmdldExlbmd0aCgpID4gb3RoZXIuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgd2hpbGUgKGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5waWVjZXNfW2ldICE9PSBvdGhlci5waWVjZXNfW2pdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgICsraTtcbiAgICAgICsrajtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0gLy8gZW5kIFBhdGhcblxuLyoqXG4gKiBEeW5hbWljIChtdXRhYmxlKSBwYXRoIHVzZWQgdG8gY291bnQgcGF0aCBsZW5ndGhzLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBlZmZpY2llbnRseSBjaGVjayBwYXRocyBmb3IgdmFsaWRcbiAqIGxlbmd0aCAoaW4gVVRGOCBieXRlcykgYW5kIGRlcHRoICh1c2VkIGluIHBhdGggdmFsaWRhdGlvbikuXG4gKlxuICogVGhyb3dzIEVycm9yIGV4Y2VwdGlvbiBpZiBwYXRoIGlzIGV2ZXIgaW52YWxpZC5cbiAqXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIHBhdGggYWx3YXlzIGJlZ2lucyB3aXRoICcvJy5cbiAqL1xuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25QYXRoIHtcbiAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgcHJpdmF0ZSBwYXJ0c186IHN0cmluZ1tdO1xuICAvKiogQHR5cGUge251bWJlcn0gSW5pdGlhbGl6ZSB0byBudW1iZXIgb2YgJy8nIGNoYXJzIG5lZWRlZCBpbiBwYXRoLiAqL1xuICBwcml2YXRlIGJ5dGVMZW5ndGhfOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggSW5pdGlhbCBQYXRoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JQcmVmaXhfIFByZWZpeCBmb3IgYW55IGVycm9yIG1lc3NhZ2VzLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGF0aDogUGF0aCwgcHJpdmF0ZSBlcnJvclByZWZpeF86IHN0cmluZykge1xuICAgIC8qKiBAdHlwZSB7IUFycmF5PHN0cmluZz59ICovXG4gICAgdGhpcy5wYXJ0c18gPSBwYXRoLnNsaWNlKCk7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9IEluaXRpYWxpemUgdG8gbnVtYmVyIG9mICcvJyBjaGFycyBuZWVkZWQgaW4gcGF0aC4gKi9cbiAgICB0aGlzLmJ5dGVMZW5ndGhfID0gTWF0aC5tYXgoMSwgdGhpcy5wYXJ0c18ubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gKz0gc3RyaW5nTGVuZ3RoKHRoaXMucGFydHNfW2ldKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1ZhbGlkXygpO1xuICB9XG5cbiAgLyoqIEBjb25zdCB7bnVtYmVyfSBNYXhpbXVtIGtleSBkZXB0aC4gKi9cbiAgc3RhdGljIGdldCBNQVhfUEFUSF9ERVBUSCgpIHtcbiAgICByZXR1cm4gMzI7XG4gIH1cblxuICAvKiogQGNvbnN0IHtudW1iZXJ9IE1heGltdW0gbnVtYmVyIG9mIChVVEY4KSBieXRlcyBpbiBhIEZpcmViYXNlIHBhdGguICovXG4gIHN0YXRpYyBnZXQgTUFYX1BBVEhfTEVOR1RIX0JZVEVTKCkge1xuICAgIHJldHVybiA3Njg7XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNoaWxkICovXG4gIHB1c2goY2hpbGQ6IHN0cmluZykge1xuICAgIC8vIENvdW50IHRoZSBuZWVkZWQgJy8nXG4gICAgaWYgKHRoaXMucGFydHNfLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gKz0gMTtcbiAgICB9XG4gICAgdGhpcy5wYXJ0c18ucHVzaChjaGlsZCk7XG4gICAgdGhpcy5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgoY2hpbGQpO1xuICAgIHRoaXMuY2hlY2tWYWxpZF8oKTtcbiAgfVxuXG4gIHBvcCgpIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJ0c18ucG9wKCk7XG4gICAgdGhpcy5ieXRlTGVuZ3RoXyAtPSBzdHJpbmdMZW5ndGgobGFzdCk7XG4gICAgLy8gVW4tY291bnQgdGhlIHByZXZpb3VzICcvJ1xuICAgIGlmICh0aGlzLnBhcnRzXy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmJ5dGVMZW5ndGhfIC09IDE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja1ZhbGlkXygpIHtcbiAgICBpZiAodGhpcy5ieXRlTGVuZ3RoXyA+IFZhbGlkYXRpb25QYXRoLk1BWF9QQVRIX0xFTkdUSF9CWVRFUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB0aGlzLmVycm9yUHJlZml4XyArXG4gICAgICAgICAgJ2hhcyBhIGtleSBwYXRoIGxvbmdlciB0aGFuICcgK1xuICAgICAgICAgIFZhbGlkYXRpb25QYXRoLk1BWF9QQVRIX0xFTkdUSF9CWVRFUyArXG4gICAgICAgICAgJyBieXRlcyAoJyArXG4gICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyArXG4gICAgICAgICAgJykuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFydHNfLmxlbmd0aCA+IFZhbGlkYXRpb25QYXRoLk1BWF9QQVRIX0RFUFRIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHRoaXMuZXJyb3JQcmVmaXhfICtcbiAgICAgICAgICAncGF0aCBzcGVjaWZpZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBkZXB0aCB0aGF0IGNhbiBiZSB3cml0dGVuICgnICtcbiAgICAgICAgICBWYWxpZGF0aW9uUGF0aC5NQVhfUEFUSF9ERVBUSCArXG4gICAgICAgICAgJykgb3Igb2JqZWN0IGNvbnRhaW5zIGEgY3ljbGUgJyArXG4gICAgICAgICAgdGhpcy50b0Vycm9yU3RyaW5nKClcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0cmluZyBmb3IgdXNlIGluIGVycm9yIG1lc3NhZ2VzIC0gdXNlcyAnLicgbm90YXRpb24gZm9yIHBhdGguXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRXJyb3JTdHJpbmcoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5wYXJ0c18ubGVuZ3RoID09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIFwiaW4gcHJvcGVydHkgJ1wiICsgdGhpcy5wYXJ0c18uam9pbignLicpICsgXCInXCI7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgUFJPVE9DT0xfVkVSU0lPTiA9ICc1JztcblxuZXhwb3J0IGNvbnN0IFZFUlNJT05fUEFSQU0gPSAndic7XG5cbmV4cG9ydCBjb25zdCBUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTSA9ICdzJztcblxuZXhwb3J0IGNvbnN0IFJFRkVSRVJfUEFSQU0gPSAncic7XG5cbmV4cG9ydCBjb25zdCBGT1JHRV9SRUYgPSAnZic7XG5cbmV4cG9ydCBjb25zdCBGT1JHRV9ET01BSU4gPSAnZmlyZWJhc2Vpby5jb20nO1xuXG5leHBvcnQgY29uc3QgTEFTVF9TRVNTSU9OX1BBUkFNID0gJ2xzJztcblxuZXhwb3J0IGNvbnN0IFdFQlNPQ0tFVCA9ICd3ZWJzb2NrZXQnO1xuXG5leHBvcnQgY29uc3QgTE9OR19QT0xMSU5HID0gJ2xvbmdfcG9sbGluZyc7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFBlcnNpc3RlbnRTdG9yYWdlIH0gZnJvbSAnLi9zdG9yYWdlL3N0b3JhZ2UnO1xuaW1wb3J0IHsgTE9OR19QT0xMSU5HLCBXRUJTT0NLRVQgfSBmcm9tICcuLi9yZWFsdGltZS9Db25zdGFudHMnO1xuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCBob2xkcyBtZXRhZGF0YSBhYm91dCBhIFJlcG8gb2JqZWN0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXBvSW5mbyB7XG4gIGhvc3Q6IHN0cmluZztcbiAgZG9tYWluOiBzdHJpbmc7XG4gIGludGVybmFsSG9zdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaG9zdCBIb3N0bmFtZSBwb3J0aW9uIG9mIHRoZSB1cmwgZm9yIHRoZSByZXBvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VjdXJlIFdoZXRoZXIgb3Igbm90IHRoaXMgcmVwbyBpcyBhY2Nlc3NlZCBvdmVyIHNzbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2UgcmVwcmVzZW50ZWQgYnkgdGhlIHJlcG9cbiAgICogQHBhcmFtIHtib29sZWFufSB3ZWJTb2NrZXRPbmx5IFdoZXRoZXIgdG8gcHJlZmVyIHdlYnNvY2tldHMgb3ZlciBhbGwgb3RoZXIgdHJhbnNwb3J0cyAodXNlZCBieSBOZXN0KS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBwZXJzaXN0ZW5jZUtleSBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZXNzaW9uIHBlcnNpc3RlbmNlIHN0b3JhZ2Uga2V5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBob3N0OiBzdHJpbmcsXG4gICAgcHVibGljIHNlY3VyZTogYm9vbGVhbixcbiAgICBwdWJsaWMgbmFtZXNwYWNlOiBzdHJpbmcsXG4gICAgcHVibGljIHdlYlNvY2tldE9ubHk6IGJvb2xlYW4sXG4gICAgcHVibGljIHBlcnNpc3RlbmNlS2V5OiBzdHJpbmcgPSAnJ1xuICApIHtcbiAgICB0aGlzLmhvc3QgPSBob3N0LnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5kb21haW4gPSB0aGlzLmhvc3Quc3Vic3RyKHRoaXMuaG9zdC5pbmRleE9mKCcuJykgKyAxKTtcbiAgICB0aGlzLmludGVybmFsSG9zdCA9IFBlcnNpc3RlbnRTdG9yYWdlLmdldCgnaG9zdDonICsgaG9zdCkgfHwgdGhpcy5ob3N0O1xuICB9XG5cbiAgbmVlZHNRdWVyeVBhcmFtKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmhvc3QgIT09IHRoaXMuaW50ZXJuYWxIb3N0IHx8IHRoaXMuaXNDdXN0b21Ib3N0KCk7XG4gIH1cblxuICBpc0NhY2hlYWJsZUhvc3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxIb3N0LnN1YnN0cigwLCAyKSA9PT0gJ3MtJztcbiAgfVxuXG4gIGlzRGVtb0hvc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluID09PSAnZmlyZWJhc2Vpby1kZW1vLmNvbSc7XG4gIH1cblxuICBpc0N1c3RvbUhvc3QoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZG9tYWluICE9PSAnZmlyZWJhc2Vpby5jb20nICYmIHRoaXMuZG9tYWluICE9PSAnZmlyZWJhc2Vpby1kZW1vLmNvbSdcbiAgICApO1xuICB9XG5cbiAgdXBkYXRlSG9zdChuZXdIb3N0OiBzdHJpbmcpIHtcbiAgICBpZiAobmV3SG9zdCAhPT0gdGhpcy5pbnRlcm5hbEhvc3QpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxIb3N0ID0gbmV3SG9zdDtcbiAgICAgIGlmICh0aGlzLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XG4gICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnNldCgnaG9zdDonICsgdGhpcy5ob3N0LCB0aGlzLmludGVybmFsSG9zdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdlYnNvY2tldCBVUkwgZm9yIHRoaXMgcmVwb1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBvZiBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgbGlzdFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgZm9yIHRoaXMgcmVwb1xuICAgKi9cbiAgY29ubmVjdGlvblVSTCh0eXBlOiBzdHJpbmcsIHBhcmFtczogeyBbazogc3RyaW5nXTogc3RyaW5nIH0pOiBzdHJpbmcge1xuICAgIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsICd0eXBlb2YgdHlwZSBtdXN0ID09IHN0cmluZycpO1xuICAgIGFzc2VydCh0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JywgJ3R5cGVvZiBwYXJhbXMgbXVzdCA9PSBvYmplY3QnKTtcblxuICAgIGxldCBjb25uVVJMOiBzdHJpbmc7XG4gICAgaWYgKHR5cGUgPT09IFdFQlNPQ0tFVCkge1xuICAgICAgY29ublVSTCA9XG4gICAgICAgICh0aGlzLnNlY3VyZSA/ICd3c3M6Ly8nIDogJ3dzOi8vJykgKyB0aGlzLmludGVybmFsSG9zdCArICcvLndzPyc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBMT05HX1BPTExJTkcpIHtcbiAgICAgIGNvbm5VUkwgPVxuICAgICAgICAodGhpcy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArIHRoaXMuaW50ZXJuYWxIb3N0ICsgJy8ubHA/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbm5lY3Rpb24gdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWVkc1F1ZXJ5UGFyYW0oKSkge1xuICAgICAgcGFyYW1zWyducyddID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGFpcnM6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3JFYWNoKHBhcmFtcywgKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICBwYWlycy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb25uVVJMICsgcGFpcnMuam9pbignJicpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge3N0cmluZ30gKi9cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBsZXQgc3RyID0gdGhpcy50b1VSTFN0cmluZygpO1xuICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlS2V5KSB7XG4gICAgICBzdHIgKz0gJzwnICsgdGhpcy5wZXJzaXN0ZW5jZUtleSArICc+JztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXG4gIHRvVVJMU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICh0aGlzLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICsgdGhpcy5ob3N0O1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL1BhdGgnO1xuaW1wb3J0IHsgUmVwb0luZm8gfSBmcm9tICcuLi8uLi9SZXBvSW5mbyc7XG5pbXBvcnQgeyB3YXJuSWZQYWdlSXNTZWN1cmUsIHdhcm4sIGZhdGFsIH0gZnJvbSAnLi4vdXRpbCc7XG5cbi8qKlxuICogQHBhcmFtIHshc3RyaW5nfSBwYXRoU3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aFN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHBhdGhTdHJpbmdEZWNvZGVkID0gJyc7XG4gIGNvbnN0IHBpZWNlcyA9IHBhdGhTdHJpbmcuc3BsaXQoJy8nKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGllY2VzW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBwaWVjZSA9IHBpZWNlc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBpZWNlID0gZGVjb2RlVVJJQ29tcG9uZW50KHBpZWNlLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICBwYXRoU3RyaW5nRGVjb2RlZCArPSAnLycgKyBwaWVjZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGhTdHJpbmdEZWNvZGVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IXN0cmluZ30gcXVlcnlTdHJpbmdcbiAqIEByZXR1cm4geyF7W2tleTpzdHJpbmddOnN0cmluZ319IGtleSB2YWx1ZSBoYXNoXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVF1ZXJ5KHF1ZXJ5U3RyaW5nOiBzdHJpbmcpOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHtcbiAgbGV0IHJlc3VsdHMgPSB7fTtcbiAgaWYgKHF1ZXJ5U3RyaW5nLmNoYXJBdCgwKSA9PT0gJz8nKSB7XG4gICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zdWJzdHJpbmcoMSk7XG4gIH1cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHF1ZXJ5U3RyaW5nLnNwbGl0KCcmJykpIHtcbiAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrdiA9IHNlZ21lbnQuc3BsaXQoJz0nKTtcbiAgICBpZiAoa3YubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXN1bHRzW2RlY29kZVVSSUNvbXBvbmVudChrdlswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KGt2WzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihgSW52YWxpZCBxdWVyeSBzZWdtZW50ICcke3NlZ21lbnR9JyBpbiBxdWVyeSAnJHtxdWVyeVN0cmluZ30nYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGRhdGFVUkxcbiAqIEByZXR1cm4ge3tyZXBvSW5mbzogIVJlcG9JbmZvLCBwYXRoOiAhUGF0aH19XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZVJlcG9JbmZvID0gZnVuY3Rpb24oXG4gIGRhdGFVUkw6IHN0cmluZ1xuKTogeyByZXBvSW5mbzogUmVwb0luZm87IHBhdGg6IFBhdGggfSB7XG4gIGNvbnN0IHBhcnNlZFVybCA9IHBhcnNlVVJMKGRhdGFVUkwpLFxuICAgIG5hbWVzcGFjZSA9IHBhcnNlZFVybC5zdWJkb21haW47XG5cbiAgaWYgKHBhcnNlZFVybC5kb21haW4gPT09ICdmaXJlYmFzZScpIHtcbiAgICBmYXRhbChcbiAgICAgIHBhcnNlZFVybC5ob3N0ICtcbiAgICAgICAgJyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tIGluc3RlYWQnXG4gICAgKTtcbiAgfVxuXG4gIC8vIENhdGNoIGNvbW1vbiBlcnJvciBvZiB1bmluaXRpYWxpemVkIG5hbWVzcGFjZSB2YWx1ZS5cbiAgaWYgKFxuICAgICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PSAndW5kZWZpbmVkJykgJiZcbiAgICBwYXJzZWRVcmwuZG9tYWluICE9PSAnbG9jYWxob3N0J1xuICApIHtcbiAgICBmYXRhbChcbiAgICAgICdDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tJ1xuICAgICk7XG4gIH1cblxuICBpZiAoIXBhcnNlZFVybC5zZWN1cmUpIHtcbiAgICB3YXJuSWZQYWdlSXNTZWN1cmUoKTtcbiAgfVxuXG4gIGNvbnN0IHdlYlNvY2tldE9ubHkgPSBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3MnIHx8IHBhcnNlZFVybC5zY2hlbWUgPT09ICd3c3MnO1xuXG4gIHJldHVybiB7XG4gICAgcmVwb0luZm86IG5ldyBSZXBvSW5mbyhcbiAgICAgIHBhcnNlZFVybC5ob3N0LFxuICAgICAgcGFyc2VkVXJsLnNlY3VyZSxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIHdlYlNvY2tldE9ubHlcbiAgICApLFxuICAgIHBhdGg6IG5ldyBQYXRoKHBhcnNlZFVybC5wYXRoU3RyaW5nKVxuICB9O1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBkYXRhVVJMXG4gKiBAcmV0dXJuIHt7aG9zdDogc3RyaW5nLCBwb3J0OiBudW1iZXIsIGRvbWFpbjogc3RyaW5nLCBzdWJkb21haW46IHN0cmluZywgc2VjdXJlOiBib29sZWFuLCBzY2hlbWU6IHN0cmluZywgcGF0aFN0cmluZzogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlVVJMID0gZnVuY3Rpb24oXG4gIGRhdGFVUkw6IHN0cmluZ1xuKToge1xuICBob3N0OiBzdHJpbmc7XG4gIHBvcnQ6IG51bWJlcjtcbiAgZG9tYWluOiBzdHJpbmc7XG4gIHN1YmRvbWFpbjogc3RyaW5nO1xuICBzZWN1cmU6IGJvb2xlYW47XG4gIHNjaGVtZTogc3RyaW5nO1xuICBwYXRoU3RyaW5nOiBzdHJpbmc7XG59IHtcbiAgLy8gRGVmYXVsdCB0byBlbXB0eSBzdHJpbmdzIGluIHRoZSBldmVudCBvZiBhIG1hbGZvcm1lZCBzdHJpbmcuXG4gIGxldCBob3N0ID0gJycsXG4gICAgZG9tYWluID0gJycsXG4gICAgc3ViZG9tYWluID0gJycsXG4gICAgcGF0aFN0cmluZyA9ICcnO1xuXG4gIC8vIEFsd2F5cyBkZWZhdWx0IHRvIFNTTCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gIGxldCBzZWN1cmUgPSB0cnVlLFxuICAgIHNjaGVtZSA9ICdodHRwcycsXG4gICAgcG9ydCA9IDQ0MztcblxuICAvLyBEb24ndCBkbyBhbnkgdmFsaWRhdGlvbiBoZXJlLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSByZXN1bHQgb2YgcGFyc2luZy5cbiAgaWYgKHR5cGVvZiBkYXRhVVJMID09PSAnc3RyaW5nJykge1xuICAgIC8vIFBhcnNlIHNjaGVtZS5cbiAgICBsZXQgY29sb25JbmQgPSBkYXRhVVJMLmluZGV4T2YoJy8vJyk7XG4gICAgaWYgKGNvbG9uSW5kID49IDApIHtcbiAgICAgIHNjaGVtZSA9IGRhdGFVUkwuc3Vic3RyaW5nKDAsIGNvbG9uSW5kIC0gMSk7XG4gICAgICBkYXRhVVJMID0gZGF0YVVSTC5zdWJzdHJpbmcoY29sb25JbmQgKyAyKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBob3N0LCBwYXRoLCBhbmQgcXVlcnkgc3RyaW5nLlxuICAgIGxldCBzbGFzaEluZCA9IGRhdGFVUkwuaW5kZXhPZignLycpO1xuICAgIGlmIChzbGFzaEluZCA9PT0gLTEpIHtcbiAgICAgIHNsYXNoSW5kID0gZGF0YVVSTC5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBxdWVzdGlvbk1hcmtJbmQgPSBkYXRhVVJMLmluZGV4T2YoJz8nKTtcbiAgICBpZiAocXVlc3Rpb25NYXJrSW5kID09PSAtMSkge1xuICAgICAgcXVlc3Rpb25NYXJrSW5kID0gZGF0YVVSTC5sZW5ndGg7XG4gICAgfVxuICAgIGhvc3QgPSBkYXRhVVJMLnN1YnN0cmluZygwLCBNYXRoLm1pbihzbGFzaEluZCwgcXVlc3Rpb25NYXJrSW5kKSk7XG4gICAgaWYgKHNsYXNoSW5kIDwgcXVlc3Rpb25NYXJrSW5kKSB7XG4gICAgICAvLyBGb3IgcGF0aFN0cmluZywgcXVlc3Rpb25NYXJrSW5kIHdpbGwgYWx3YXlzIGNvbWUgYWZ0ZXIgc2xhc2hJbmRcbiAgICAgIHBhdGhTdHJpbmcgPSBkZWNvZGVQYXRoKGRhdGFVUkwuc3Vic3RyaW5nKHNsYXNoSW5kLCBxdWVzdGlvbk1hcmtJbmQpKTtcbiAgICB9XG4gICAgbGV0IHF1ZXJ5UGFyYW1zID0gZGVjb2RlUXVlcnkoXG4gICAgICBkYXRhVVJMLnN1YnN0cmluZyhNYXRoLm1pbihkYXRhVVJMLmxlbmd0aCwgcXVlc3Rpb25NYXJrSW5kKSlcbiAgICApO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnQsIHVzZSBzY2hlbWUgZm9yIGRldGVybWluaW5nIGlmIGl0J3Mgc2VjdXJlLlxuICAgIGNvbG9uSW5kID0gaG9zdC5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGNvbG9uSW5kID49IDApIHtcbiAgICAgIHNlY3VyZSA9IHNjaGVtZSA9PT0gJ2h0dHBzJyB8fCBzY2hlbWUgPT09ICd3c3MnO1xuICAgICAgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKGNvbG9uSW5kICsgMSksIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb25JbmQgPSBkYXRhVVJMLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0cyA9IGhvc3Quc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAvLyBOb3JtYWxpemUgbmFtZXNwYWNlcyB0byBsb3dlcmNhc2UgdG8gc2hhcmUgc3RvcmFnZSAvIGNvbm5lY3Rpb24uXG4gICAgICBkb21haW4gPSBwYXJ0c1sxXTtcbiAgICAgIHN1YmRvbWFpbiA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGRvbWFpbiA9IHBhcnRzWzBdO1xuICAgIH0gZWxzZSBpZiAocGFydHNbMF0uc2xpY2UoMCwgY29sb25JbmQpLnRvTG93ZXJDYXNlKCkgPT09ICdsb2NhbGhvc3QnKSB7XG4gICAgICBkb21haW4gPSAnbG9jYWxob3N0JztcbiAgICB9XG4gICAgLy8gU3VwcG9ydCBgbnNgIHF1ZXJ5IHBhcmFtIGlmIHN1YmRvbWFpbiBub3QgYWxyZWFkeSBzZXRcbiAgICBpZiAoc3ViZG9tYWluID09PSAnJyAmJiAnbnMnIGluIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICBzdWJkb21haW4gPSBxdWVyeVBhcmFtc1snbnMnXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhvc3QsXG4gICAgcG9ydCxcbiAgICBkb21haW4sXG4gICAgc3ViZG9tYWluLFxuICAgIHNlY3VyZSxcbiAgICBzY2hlbWUsXG4gICAgcGF0aFN0cmluZ1xuICB9O1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQYXRoLCBWYWxpZGF0aW9uUGF0aCB9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgeyBmb3JFYWNoLCBjb250YWlucywgc2FmZUdldCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGlzSW52YWxpZEpTT05OdW1iZXIgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZXJyb3JQcmVmaXggYXMgZXJyb3JQcmVmaXhGeG4gfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBzdHJpbmdMZW5ndGggfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBSZXBvSW5mbyB9IGZyb20gJy4uL1JlcG9JbmZvJztcblxuLyoqXG4gKiBUcnVlIGZvciBpbnZhbGlkIEZpcmViYXNlIGtleXNcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgSU5WQUxJRF9LRVlfUkVHRVhfID0gL1tcXFtcXF0uIyRcXC9cXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XG5cbi8qKlxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBwYXRocy5cbiAqIEFsbG93cyAnLycgaW4gcGF0aHMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IElOVkFMSURfUEFUSF9SRUdFWF8gPSAvW1xcW1xcXS4jJFxcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztcblxuLyoqXG4gKiBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFsbG93IGluIGxlYWYgdmFsdWVcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgTUFYX0xFQUZfU0laRV8gPSAxMCAqIDEwMjQgKiAxMDI0O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEtleSA9IGZ1bmN0aW9uKGtleTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5Lmxlbmd0aCAhPT0gMCAmJiAhSU5WQUxJRF9LRVlfUkVHRVhfLnRlc3Qoa2V5KVxuICApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRQYXRoU3RyaW5nID0gZnVuY3Rpb24ocGF0aFN0cmluZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHBhdGhTdHJpbmcgPT09ICdzdHJpbmcnICYmXG4gICAgcGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiZcbiAgICAhSU5WQUxJRF9QQVRIX1JFR0VYXy50ZXN0KHBhdGhTdHJpbmcpXG4gICk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZFJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24ocGF0aFN0cmluZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChwYXRoU3RyaW5nKSB7XG4gICAgLy8gQWxsb3cgJy8uaW5mby8nIGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XG4gIH1cblxuICByZXR1cm4gaXNWYWxpZFBhdGhTdHJpbmcocGF0aFN0cmluZyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gcHJpb3JpdHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkUHJpb3JpdHkgPSBmdW5jdGlvbihwcmlvcml0eTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgcHJpb3JpdHkgPT09IG51bGwgfHxcbiAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XG4gICAgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicgJiYgIWlzSW52YWxpZEpTT05OdW1iZXIocHJpb3JpdHkpKSB8fFxuICAgIChwcmlvcml0eSAmJiB0eXBlb2YgcHJpb3JpdHkgPT09ICdvYmplY3QnICYmIGNvbnRhaW5zKHByaW9yaXR5LCAnLnN2JykpXG4gICk7XG59O1xuXG4vKipcbiAqIFByZS12YWxpZGF0ZSBhIGRhdHVtIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byBGaXJlYmFzZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25hbFxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcgPSBmdW5jdGlvbihcbiAgZm5OYW1lOiBzdHJpbmcsXG4gIGFyZ3VtZW50TnVtYmVyOiBudW1iZXIsXG4gIGRhdGE6IGFueSxcbiAgcGF0aDogUGF0aCxcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbikge1xuICBpZiAob3B0aW9uYWwgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgdmFsaWRhdGVGaXJlYmFzZURhdGEoXG4gICAgZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpLFxuICAgIGRhdGEsXG4gICAgcGF0aFxuICApO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBhIGRhdGEgb2JqZWN0IGNsaWVudC1zaWRlIGJlZm9yZSBzZW5kaW5nIHRvIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JQcmVmaXhcbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHBhcmFtIHshUGF0aHwhVmFsaWRhdGlvblBhdGh9IHBhdGhfXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUZpcmViYXNlRGF0YSA9IGZ1bmN0aW9uKFxuICBlcnJvclByZWZpeDogc3RyaW5nLFxuICBkYXRhOiBhbnksXG4gIHBhdGhfOiBQYXRoIHwgVmFsaWRhdGlvblBhdGhcbikge1xuICBjb25zdCBwYXRoID1cbiAgICBwYXRoXyBpbnN0YW5jZW9mIFBhdGggPyBuZXcgVmFsaWRhdGlvblBhdGgocGF0aF8sIGVycm9yUHJlZml4KSA6IHBhdGhfO1xuXG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggKyAnY29udGFpbnMgdW5kZWZpbmVkICcgKyBwYXRoLnRvRXJyb3JTdHJpbmcoKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JQcmVmaXggK1xuICAgICAgICAnY29udGFpbnMgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgcGF0aC50b0Vycm9yU3RyaW5nKCkgK1xuICAgICAgICAnIHdpdGggY29udGVudHMgPSAnICtcbiAgICAgICAgZGF0YS50b1N0cmluZygpXG4gICAgKTtcbiAgfVxuICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihkYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yUHJlZml4ICsgJ2NvbnRhaW5zICcgKyBkYXRhLnRvU3RyaW5nKCkgKyAnICcgKyBwYXRoLnRvRXJyb3JTdHJpbmcoKVxuICAgICk7XG4gIH1cblxuICAvLyBDaGVjayBtYXggbGVhZiBzaXplLCBidXQgdHJ5IHRvIGF2b2lkIHRoZSB1dGY4IGNvbnZlcnNpb24gaWYgd2UgY2FuLlxuICBpZiAoXG4gICAgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgZGF0YS5sZW5ndGggPiBNQVhfTEVBRl9TSVpFXyAvIDMgJiZcbiAgICBzdHJpbmdMZW5ndGgoZGF0YSkgPiBNQVhfTEVBRl9TSVpFX1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvclByZWZpeCArXG4gICAgICAgICdjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgIE1BWF9MRUFGX1NJWkVfICtcbiAgICAgICAgJyB1dGY4IGJ5dGVzICcgK1xuICAgICAgICBwYXRoLnRvRXJyb3JTdHJpbmcoKSArXG4gICAgICAgIFwiICgnXCIgK1xuICAgICAgICBkYXRhLnN1YnN0cmluZygwLCA1MCkgK1xuICAgICAgICBcIi4uLicpXCJcbiAgICApO1xuICB9XG5cbiAgLy8gVE9ETyA9IFBlcmYgPSBDb25zaWRlciBjb21iaW5pbmcgdGhlIHJlY3Vyc2l2ZSB2YWxpZGF0aW9uIG9mIGtleXMgaW50byBOb2RlRnJvbUpTT05cbiAgLy8gdG8gc2F2ZSBleHRyYSB3YWxraW5nIG9mIGxhcmdlIG9iamVjdHMuXG4gIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGxldCBoYXNEb3RWYWx1ZSA9IGZhbHNlLFxuICAgICAgaGFzQWN0dWFsQ2hpbGQgPSBmYWxzZTtcbiAgICBmb3JFYWNoKGRhdGEsIGZ1bmN0aW9uKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgICBpZiAoa2V5ID09PSAnLnZhbHVlJykge1xuICAgICAgICBoYXNEb3RWYWx1ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGtleSAhPT0gJy5wcmlvcml0eScgJiYga2V5ICE9PSAnLnN2Jykge1xuICAgICAgICBoYXNBY3R1YWxDaGlsZCA9IHRydWU7XG4gICAgICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgICAnIGNvbnRhaW5zIGFuIGludmFsaWQga2V5ICgnICtcbiAgICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICAgIHBhdGgudG9FcnJvclN0cmluZygpICtcbiAgICAgICAgICAgICAgJy4gIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyAnICtcbiAgICAgICAgICAgICAgJ2FuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgsIHZhbHVlLCBwYXRoKTtcbiAgICAgIHBhdGgucG9wKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzRG90VmFsdWUgJiYgaGFzQWN0dWFsQ2hpbGQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyb3JQcmVmaXggK1xuICAgICAgICAgICcgY29udGFpbnMgXCIudmFsdWVcIiBjaGlsZCAnICtcbiAgICAgICAgICBwYXRoLnRvRXJyb3JTdHJpbmcoKSArXG4gICAgICAgICAgJyBpbiBhZGRpdGlvbiB0byBhY3R1YWwgY2hpbGRyZW4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUHJlLXZhbGlkYXRlIHBhdGhzIHBhc3NlZCBpbiB0aGUgZmlyZWJhc2UgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yUHJlZml4XG4gKiBAcGFyYW0ge0FycmF5PCFQYXRoPn0gbWVyZ2VQYXRoc1xuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMgPSBmdW5jdGlvbihcbiAgZXJyb3JQcmVmaXg6IHN0cmluZyxcbiAgbWVyZ2VQYXRoczogUGF0aFtdXG4pIHtcbiAgbGV0IGksIGN1clBhdGg7XG4gIGZvciAoaSA9IDA7IGkgPCBtZXJnZVBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VyUGF0aCA9IG1lcmdlUGF0aHNbaV07XG4gICAgY29uc3Qga2V5cyA9IGN1clBhdGguc2xpY2UoKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChrZXlzW2pdID09PSAnLnByaW9yaXR5JyAmJiBqID09PSBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gLnByaW9yaXR5IGlzIE9LXG4gICAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkS2V5KGtleXNbal0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBlcnJvclByZWZpeCArXG4gICAgICAgICAgICAnY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKCcgK1xuICAgICAgICAgICAga2V5c1tqXSArXG4gICAgICAgICAgICAnKSBpbiBwYXRoICcgK1xuICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgICcuIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyAnICtcbiAgICAgICAgICAgICdhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgdGhhdCB1cGRhdGUga2V5cyBhcmUgbm90IGRlc2NlbmRhbnRzIG9mIGVhY2ggb3RoZXIuXG4gIC8vIFdlIHJlbHkgb24gdGhlIHByb3BlcnR5IHRoYXQgc29ydGluZyBndWFyYW50ZWVzIHRoYXQgYW5jZXN0b3JzIGNvbWVcbiAgLy8gcmlnaHQgYmVmb3JlIGRlc2NlbmRhbnRzLlxuICBtZXJnZVBhdGhzLnNvcnQoUGF0aC5jb21wYXJlUGF0aHMpO1xuICBsZXQgcHJldlBhdGg6IFBhdGggfCBudWxsID0gbnVsbDtcbiAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcbiAgICBpZiAocHJldlBhdGggIT09IG51bGwgJiYgcHJldlBhdGguY29udGFpbnMoY3VyUGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyb3JQcmVmaXggK1xuICAgICAgICAgICdjb250YWlucyBhIHBhdGggJyArXG4gICAgICAgICAgcHJldlBhdGgudG9TdHJpbmcoKSArXG4gICAgICAgICAgJyB0aGF0IGlzIGFuY2VzdG9yIG9mIGFub3RoZXIgcGF0aCAnICtcbiAgICAgICAgICBjdXJQYXRoLnRvU3RyaW5nKClcbiAgICAgICk7XG4gICAgfVxuICAgIHByZXZQYXRoID0gY3VyUGF0aDtcbiAgfVxufTtcblxuLyoqXG4gKiBwcmUtdmFsaWRhdGUgYW4gb2JqZWN0IHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byBmaXJlYmFzZSBmdW5jdGlvbiAoXG4gKiBtdXN0IGJlIGFuIG9iamVjdCAtIGUuZy4gZm9yIGZpcmViYXNlLnVwZGF0ZSgpKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25hbFxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZyA9IGZ1bmN0aW9uKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROdW1iZXI6IG51bWJlcixcbiAgZGF0YTogYW55LFxuICBwYXRoOiBQYXRoLFxuICBvcHRpb25hbDogYm9vbGVhblxuKSB7XG4gIGlmIChvcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICBjb25zdCBlcnJvclByZWZpeCA9IGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKTtcblxuICBpZiAoIShkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JykgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yUHJlZml4ICsgJyBtdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGlsZHJlbiB0byByZXBsYWNlLidcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWVyZ2VQYXRoczogUGF0aFtdID0gW107XG4gIGZvckVhY2goZGF0YSwgZnVuY3Rpb24oa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICBjb25zdCBjdXJQYXRoID0gbmV3IFBhdGgoa2V5KTtcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YShlcnJvclByZWZpeCwgdmFsdWUsIHBhdGguY2hpbGQoY3VyUGF0aCkpO1xuICAgIGlmIChjdXJQYXRoLmdldEJhY2soKSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgIGlmICghaXNWYWxpZFByaW9yaXR5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgXCJjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlIGZvciAnXCIgK1xuICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgIFwiJywgd2hpY2ggbXVzdCBiZSBhIHZhbGlkIFwiICtcbiAgICAgICAgICAgICdGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVBhdGhzLnB1c2goY3VyUGF0aCk7XG4gIH0pO1xuICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VQYXRocyhlcnJvclByZWZpeCwgbWVyZ2VQYXRocyk7XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROdW1iZXI6IG51bWJlcixcbiAgcHJpb3JpdHk6IGFueSxcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbikge1xuICBpZiAob3B0aW9uYWwgJiYgcHJpb3JpdHkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgJ2lzICcgK1xuICAgICAgICBwcmlvcml0eS50b1N0cmluZygpICtcbiAgICAgICAgJywgYnV0IG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsICcgK1xuICAgICAgICAnc2VydmVyIHZhbHVlLCBvciBudWxsKS4nXG4gICAgKTtcbiAgLy8gU3BlY2lhbCBjYXNlIHRvIGFsbG93IGltcG9ydGluZyBkYXRhIHdpdGggYSAuc3YuXG4gIGlmICghaXNWYWxpZFByaW9yaXR5KHByaW9yaXR5KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvclByZWZpeEZ4bihmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIEZpcmViYXNlIHByaW9yaXR5ICcgK1xuICAgICAgICAnKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLidcbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlRXZlbnRUeXBlID0gZnVuY3Rpb24oXG4gIGZuTmFtZTogc3RyaW5nLFxuICBhcmd1bWVudE51bWJlcjogbnVtYmVyLFxuICBldmVudFR5cGU6IHN0cmluZyxcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbikge1xuICBpZiAob3B0aW9uYWwgJiYgZXZlbnRUeXBlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICBjYXNlICdjaGlsZF9hZGRlZCc6XG4gICAgY2FzZSAnY2hpbGRfcmVtb3ZlZCc6XG4gICAgY2FzZSAnY2hpbGRfY2hhbmdlZCc6XG4gICAgY2FzZSAnY2hpbGRfbW92ZWQnOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGV2ZW50IHR5cGUgPSBcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIiwgXCJjaGlsZF9yZW1vdmVkXCIsICcgK1xuICAgICAgICAgICdcImNoaWxkX2NoYW5nZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZFwiLidcbiAgICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUtleSA9IGZ1bmN0aW9uKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROdW1iZXI6IG51bWJlcixcbiAga2V5OiBzdHJpbmcsXG4gIG9wdGlvbmFsOiBib29sZWFuXG4pIHtcbiAgaWYgKG9wdGlvbmFsICYmIGtleSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmICghaXNWYWxpZEtleShrZXkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICd3YXMgYW4gaW52YWxpZCBrZXkgPSBcIicgK1xuICAgICAgICBrZXkgK1xuICAgICAgICAnXCIuICBGaXJlYmFzZSBrZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xuICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLidcbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlUGF0aFN0cmluZyA9IGZ1bmN0aW9uKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROdW1iZXI6IG51bWJlcixcbiAgcGF0aFN0cmluZzogc3RyaW5nLFxuICBvcHRpb25hbDogYm9vbGVhblxuKSB7XG4gIGlmIChvcHRpb25hbCAmJiBwYXRoU3RyaW5nID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICBpZiAoIWlzVmFsaWRQYXRoU3RyaW5nKHBhdGhTdHJpbmcpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICd3YXMgYW4gaW52YWxpZCBwYXRoID0gXCInICtcbiAgICAgICAgcGF0aFN0cmluZyArXG4gICAgICAgICdcIi4gUGF0aHMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgJyArXG4gICAgICAgICdjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiJ1xuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVSb290UGF0aFN0cmluZyA9IGZ1bmN0aW9uKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROdW1iZXI6IG51bWJlcixcbiAgcGF0aFN0cmluZzogc3RyaW5nLFxuICBvcHRpb25hbDogYm9vbGVhblxuKSB7XG4gIGlmIChwYXRoU3RyaW5nKSB7XG4gICAgLy8gQWxsb3cgJy8uaW5mby8nIGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XG4gIH1cblxuICB2YWxpZGF0ZVBhdGhTdHJpbmcoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgcGF0aFN0cmluZywgb3B0aW9uYWwpO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlV3JpdGFibGVQYXRoID0gZnVuY3Rpb24oZm5OYW1lOiBzdHJpbmcsIHBhdGg6IFBhdGgpIHtcbiAgaWYgKHBhdGguZ2V0RnJvbnQoKSA9PT0gJy5pbmZvJykge1xuICAgIHRocm93IG5ldyBFcnJvcihmbk5hbWUgKyBcIiBmYWlsZWQgPSBDYW4ndCBtb2RpZnkgZGF0YSB1bmRlciAvLmluZm8vXCIpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVVcmwgPSBmdW5jdGlvbihcbiAgZm5OYW1lOiBzdHJpbmcsXG4gIGFyZ3VtZW50TnVtYmVyOiBudW1iZXIsXG4gIHBhcnNlZFVybDogeyByZXBvSW5mbzogUmVwb0luZm87IHBhdGg6IFBhdGggfVxuKSB7XG4gIC8vIFRPRE8gPSBWYWxpZGF0ZSBzZXJ2ZXIgYmV0dGVyLlxuICBjb25zdCBwYXRoU3RyaW5nID0gcGFyc2VkVXJsLnBhdGgudG9TdHJpbmcoKTtcbiAgaWYgKFxuICAgICEodHlwZW9mIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0ID09PSAnc3RyaW5nJykgfHxcbiAgICBwYXJzZWRVcmwucmVwb0luZm8uaG9zdC5sZW5ndGggPT09IDAgfHxcbiAgICAoIWlzVmFsaWRLZXkocGFyc2VkVXJsLnJlcG9JbmZvLm5hbWVzcGFjZSkgJiZcbiAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0LnNwbGl0KCc6JylbMF0gIT09ICdsb2NhbGhvc3QnKSB8fFxuICAgIChwYXRoU3RyaW5nLmxlbmd0aCAhPT0gMCAmJiAhaXNWYWxpZFJvb3RQYXRoU3RyaW5nKHBhdGhTdHJpbmcpKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvclByZWZpeEZ4bihmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBmYWxzZSkgK1xuICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIFVSTCBhbmQgJyArXG4gICAgICAgICd0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLidcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVDcmVkZW50aWFsID0gZnVuY3Rpb24oXG4gIGZuTmFtZTogc3RyaW5nLFxuICBhcmd1bWVudE51bWJlcjogbnVtYmVyLFxuICBjcmVkOiBhbnksXG4gIG9wdGlvbmFsOiBib29sZWFuXG4pIHtcbiAgaWYgKG9wdGlvbmFsICYmIGNyZWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZiAoISh0eXBlb2YgY3JlZCA9PT0gJ3N0cmluZycpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICdtdXN0IGJlIGEgdmFsaWQgY3JlZGVudGlhbCAoYSBzdHJpbmcpLidcbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQm9vbGVhbiA9IGZ1bmN0aW9uKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROdW1iZXI6IG51bWJlcixcbiAgYm9vbDogYW55LFxuICBvcHRpb25hbDogYm9vbGVhblxuKSB7XG4gIGlmIChvcHRpb25hbCAmJiBib29sID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICsgJ211c3QgYmUgYSBib29sZWFuLidcbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlU3RyaW5nID0gZnVuY3Rpb24oXG4gIGZuTmFtZTogc3RyaW5nLFxuICBhcmd1bWVudE51bWJlcjogbnVtYmVyLFxuICBzdHJpbmc6IGFueSxcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbikge1xuICBpZiAob3B0aW9uYWwgJiYgc3RyaW5nID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKCEodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBzdHJpbmcuJ1xuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZU9iamVjdCA9IGZ1bmN0aW9uKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROdW1iZXI6IG51bWJlcixcbiAgb2JqOiBhbnksXG4gIG9wdGlvbmFsOiBib29sZWFuXG4pIHtcbiAgaWYgKG9wdGlvbmFsICYmIG9iaiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmICghKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JykgfHwgb2JqID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBvYmplY3QuJ1xuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZU9iamVjdENvbnRhaW5zS2V5ID0gZnVuY3Rpb24oXG4gIGZuTmFtZTogc3RyaW5nLFxuICBhcmd1bWVudE51bWJlcjogbnVtYmVyLFxuICBvYmo6IGFueSxcbiAga2V5OiBzdHJpbmcsXG4gIG9wdGlvbmFsOiBib29sZWFuLFxuICBvcHRfdHlwZT86IHN0cmluZ1xuKSB7XG4gIGNvbnN0IG9iamVjdENvbnRhaW5zS2V5ID1cbiAgICBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgY29udGFpbnMob2JqLCBrZXkpO1xuXG4gIGlmICghb2JqZWN0Q29udGFpbnNLZXkpIHtcbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBlcnJvclByZWZpeEZ4bihmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICdtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicgK1xuICAgICAgICAgIGtleSArXG4gICAgICAgICAgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0X3R5cGUpIHtcbiAgICBjb25zdCB2YWwgPSBzYWZlR2V0KG9iaiwga2V5KTtcbiAgICBpZiAoXG4gICAgICAob3B0X3R5cGUgPT09ICdudW1iZXInICYmICEodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpKSB8fFxuICAgICAgKG9wdF90eXBlID09PSAnc3RyaW5nJyAmJiAhKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSkgfHxcbiAgICAgIChvcHRfdHlwZSA9PT0gJ2Jvb2xlYW4nICYmICEodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSkgfHxcbiAgICAgIChvcHRfdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB8fFxuICAgICAgKG9wdF90eXBlID09PSAnb2JqZWN0JyAmJiAhKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSAmJiB2YWwpXG4gICAgKSB7XG4gICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnY29udGFpbnMgaW52YWxpZCB2YWx1ZSBmb3Iga2V5IFwiJyArXG4gICAgICAgICAgICBrZXkgK1xuICAgICAgICAgICAgJ1wiIChtdXN0IGJlIG9mIHR5cGUgXCInICtcbiAgICAgICAgICAgIG9wdF90eXBlICtcbiAgICAgICAgICAgICdcIiknXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicgK1xuICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICdcIiB3aXRoIHR5cGUgXCInICtcbiAgICAgICAgICAgIG9wdF90eXBlICtcbiAgICAgICAgICAgICdcIidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgdmFsaWRhdGVBcmdDb3VudCwgdmFsaWRhdGVDYWxsYmFjayB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7XG4gIHZhbGlkYXRlV3JpdGFibGVQYXRoLFxuICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZyxcbiAgdmFsaWRhdGVQcmlvcml0eSxcbiAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZ1xufSBmcm9tICcuLi9jb3JlL3V0aWwvdmFsaWRhdGlvbic7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vY29yZS91dGlsL3V0aWwnO1xuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBSZXBvIH0gZnJvbSAnLi4vY29yZS9SZXBvJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi9jb3JlL3V0aWwvUGF0aCc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBPbkRpc2Nvbm5lY3Qge1xuICAvKipcbiAgICogQHBhcmFtIHshUmVwb30gcmVwb19cbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aF9cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVwb186IFJlcG8sIHByaXZhdGUgcGF0aF86IFBhdGgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICogQHJldHVybiB7IWZpcmViYXNlLlByb21pc2V9XG4gICAqL1xuICBjYW5jZWwob25Db21wbGV0ZT86IChhOiBFcnJvciB8IG51bGwpID0+IHZvaWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdPbkRpc2Nvbm5lY3QuY2FuY2VsJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdmFsaWRhdGVDYWxsYmFjaygnT25EaXNjb25uZWN0LmNhbmNlbCcsIDEsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkPHZvaWQ+KCk7XG4gICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RDYW5jZWwoXG4gICAgICB0aGlzLnBhdGhfLFxuICAgICAgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpXG4gICAgKTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAqIEByZXR1cm4geyFmaXJlYmFzZS5Qcm9taXNlfVxuICAgKi9cbiAgcmVtb3ZlKG9uQ29tcGxldGU/OiAoYTogRXJyb3IgfCBudWxsKSA9PiB2b2lkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnJlbW92ZScsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3QucmVtb3ZlJywgdGhpcy5wYXRoXyk7XG4gICAgdmFsaWRhdGVDYWxsYmFjaygnT25EaXNjb25uZWN0LnJlbW92ZScsIDEsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkPHZvaWQ+KCk7XG4gICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RTZXQoXG4gICAgICB0aGlzLnBhdGhfLFxuICAgICAgbnVsbCxcbiAgICAgIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKVxuICAgICk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAqIEByZXR1cm4geyFmaXJlYmFzZS5Qcm9taXNlfVxuICAgKi9cbiAgc2V0KHZhbHVlOiBhbnksIG9uQ29tcGxldGU/OiAoYTogRXJyb3IgfCBudWxsKSA9PiB2b2lkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnNldCcsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3Quc2V0JywgdGhpcy5wYXRoXyk7XG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ09uRGlzY29ubmVjdC5zZXQnLCAxLCB2YWx1ZSwgdGhpcy5wYXRoXywgZmFsc2UpO1xuICAgIHZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC5zZXQnLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZDx2b2lkPigpO1xuICAgIHRoaXMucmVwb18ub25EaXNjb25uZWN0U2V0KFxuICAgICAgdGhpcy5wYXRoXyxcbiAgICAgIHZhbHVlLFxuICAgICAgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpXG4gICAgKTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSBwcmlvcml0eVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAqIEByZXR1cm4geyFmaXJlYmFzZS5Qcm9taXNlfVxuICAgKi9cbiAgc2V0V2l0aFByaW9yaXR5KFxuICAgIHZhbHVlOiBhbnksXG4gICAgcHJpb3JpdHk6IG51bWJlciB8IHN0cmluZyB8IG51bGwsXG4gICAgb25Db21wbGV0ZT86IChhOiBFcnJvciB8IG51bGwpID0+IHZvaWRcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIDIsIDMsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgdGhpcy5wYXRoXyk7XG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoXG4gICAgICAnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsXG4gICAgICAxLFxuICAgICAgdmFsdWUsXG4gICAgICB0aGlzLnBhdGhfLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHZhbGlkYXRlUHJpb3JpdHkoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCAyLCBwcmlvcml0eSwgZmFsc2UpO1xuICAgIHZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCAzLCBvbkNvbXBsZXRlLCB0cnVlKTtcblxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkPHZvaWQ+KCk7XG4gICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkoXG4gICAgICB0aGlzLnBhdGhfLFxuICAgICAgdmFsdWUsXG4gICAgICBwcmlvcml0eSxcbiAgICAgIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKVxuICAgICk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RUb01lcmdlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICogQHJldHVybiB7IWZpcmViYXNlLlByb21pc2V9XG4gICAqL1xuICB1cGRhdGUoXG4gICAgb2JqZWN0VG9NZXJnZTogb2JqZWN0LFxuICAgIG9uQ29tcGxldGU/OiAoYTogRXJyb3IgfCBudWxsKSA9PiB2b2lkXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ09uRGlzY29ubmVjdC51cGRhdGUnLCAxLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnVwZGF0ZScsIHRoaXMucGF0aF8pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdFRvTWVyZ2UpKSB7XG4gICAgICBjb25zdCBuZXdPYmplY3RUb01lcmdlOiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RUb01lcmdlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5ld09iamVjdFRvTWVyZ2VbJycgKyBpXSA9IG9iamVjdFRvTWVyZ2VbaV07XG4gICAgICB9XG4gICAgICBvYmplY3RUb01lcmdlID0gbmV3T2JqZWN0VG9NZXJnZTtcbiAgICAgIHdhcm4oXG4gICAgICAgICdQYXNzaW5nIGFuIEFycmF5IHRvIGZpcmViYXNlLmRhdGFiYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlICcgK1xuICAgICAgICAgICdleGlzdGluZyBkYXRhLCBvciBhbiBPYmplY3Qgd2l0aCBpbnRlZ2VyIGtleXMgaWYgeW91IHJlYWxseSBkbyB3YW50IHRvIG9ubHkgdXBkYXRlIHNvbWUgb2YgdGhlIGNoaWxkcmVuLidcbiAgICAgICk7XG4gICAgfVxuICAgIHZhbGlkYXRlRmlyZWJhc2VNZXJnZURhdGFBcmcoXG4gICAgICAnT25EaXNjb25uZWN0LnVwZGF0ZScsXG4gICAgICAxLFxuICAgICAgb2JqZWN0VG9NZXJnZSxcbiAgICAgIHRoaXMucGF0aF8sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdmFsaWRhdGVDYWxsYmFjaygnT25EaXNjb25uZWN0LnVwZGF0ZScsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkPHZvaWQ+KCk7XG4gICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RVcGRhdGUoXG4gICAgICB0aGlzLnBhdGhfLFxuICAgICAgb2JqZWN0VG9NZXJnZSxcbiAgICAgIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKVxuICAgICk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBEYXRhU25hcHNob3QgfSBmcm9tICcuL0RhdGFTbmFwc2hvdCc7XG5pbXBvcnQgeyB2YWxpZGF0ZUFyZ0NvdW50IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZXN1bHQge1xuICAvKipcbiAgICogQSB0eXBlIGZvciB0aGUgcmVzb2x2ZSB2YWx1ZSBvZiBGaXJlYmFzZS50cmFuc2FjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBkaWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tbWl0dGVkXG4gICAqIEBwYXJhbSB7RGF0YVNuYXBzaG90fSBzbmFwc2hvdFxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIGNvbW1pdHRlZDogYm9vbGVhbiwgcHVibGljIHNuYXBzaG90OiBEYXRhU25hcHNob3QpIHt9XG5cbiAgLy8gRG8gbm90IGNyZWF0ZSBwdWJsaWMgZG9jdW1lbnRhdGlvbi4gVGhpcyBpcyBpbnRlbmRlZCB0byBtYWtlIEpTT04gc2VyaWFsaXphdGlvbiB3b3JrIGJ1dCBpcyBvdGhlcndpc2UgdW5uZWNlc3NhcnlcbiAgLy8gZm9yIGVuZC11c2Vyc1xuICB0b0pTT04oKTogb2JqZWN0IHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdUcmFuc2FjdGlvblJlc3VsdC50b0pTT04nLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICByZXR1cm4geyBjb21taXR0ZWQ6IHRoaXMuY29tbWl0dGVkLCBzbmFwc2hvdDogdGhpcy5zbmFwc2hvdC50b0pTT04oKSB9O1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcbiAqIEZhbmN5IElEIGdlbmVyYXRvciB0aGF0IGNyZWF0ZXMgMjAtY2hhcmFjdGVyIHN0cmluZyBpZGVudGlmaWVycyB3aXRoIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogMS4gVGhleSdyZSBiYXNlZCBvbiB0aW1lc3RhbXAgc28gdGhhdCB0aGV5IHNvcnQgKmFmdGVyKiBhbnkgZXhpc3RpbmcgaWRzLlxuICogMi4gVGhleSBjb250YWluIDcyLWJpdHMgb2YgcmFuZG9tIGRhdGEgYWZ0ZXIgdGhlIHRpbWVzdGFtcCBzbyB0aGF0IElEcyB3b24ndFxuICogICAgY29sbGlkZSB3aXRoIG90aGVyIGNsaWVudHMnIElEcy5cbiAqIDMuIFRoZXkgc29ydCAqbGV4aWNvZ3JhcGhpY2FsbHkqIChzbyB0aGUgdGltZXN0YW1wIGlzIGNvbnZlcnRlZCB0byBjaGFyYWN0ZXJzXG4gKiAgICB0aGF0IHdpbGwgc29ydCBwcm9wZXJseSkuXG4gKiA0LiBUaGV5J3JlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy4gRXZlbiBpZiB5b3UgZ2VuZXJhdGUgbW9yZSB0aGFuIG9uZSBpblxuICogICAgdGhlIHNhbWUgdGltZXN0YW1wLCB0aGUgbGF0dGVyIG9uZXMgd2lsbCBzb3J0IGFmdGVyIHRoZSBmb3JtZXIgb25lcy4gV2UgZG9cbiAqICAgIHRoaXMgYnkgdXNpbmcgdGhlIHByZXZpb3VzIHJhbmRvbSBiaXRzIGJ1dCBcImluY3JlbWVudGluZ1wiIHRoZW0gYnkgMSAob25seVxuICogICAgaW4gdGhlIGNhc2Ugb2YgYSB0aW1lc3RhbXAgY29sbGlzaW9uKS5cbiAqL1xuZXhwb3J0IGNvbnN0IG5leHRQdXNoSWQgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIE1vZGVsZWQgYWZ0ZXIgYmFzZTY0IHdlYi1zYWZlIGNoYXJzLCBidXQgb3JkZXJlZCBieSBBU0NJSS5cbiAgY29uc3QgUFVTSF9DSEFSUyA9XG4gICAgJy0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuXG4gIC8vIFRpbWVzdGFtcCBvZiBsYXN0IHB1c2gsIHVzZWQgdG8gcHJldmVudCBsb2NhbCBjb2xsaXNpb25zIGlmIHlvdSBwdXNoIHR3aWNlXG4gIC8vIGluIG9uZSBtcy5cbiAgbGV0IGxhc3RQdXNoVGltZSA9IDA7XG5cbiAgLy8gV2UgZ2VuZXJhdGUgNzItYml0cyBvZiByYW5kb21uZXNzIHdoaWNoIGdldCB0dXJuZWQgaW50byAxMiBjaGFyYWN0ZXJzIGFuZFxuICAvLyBhcHBlbmRlZCB0byB0aGUgdGltZXN0YW1wIHRvIHByZXZlbnQgY29sbGlzaW9ucyB3aXRoIG90aGVyIGNsaWVudHMuIFdlXG4gIC8vIHN0b3JlIHRoZSBsYXN0IGNoYXJhY3RlcnMgd2UgZ2VuZXJhdGVkIGJlY2F1c2UgaW4gdGhlIGV2ZW50IG9mIGEgY29sbGlzaW9uLFxuICAvLyB3ZSdsbCB1c2UgdGhvc2Ugc2FtZSBjaGFyYWN0ZXJzIGV4Y2VwdCBcImluY3JlbWVudGVkXCIgYnkgb25lLlxuICBjb25zdCBsYXN0UmFuZENoYXJzOiBudW1iZXJbXSA9IFtdO1xuXG4gIHJldHVybiBmdW5jdGlvbihub3c6IG51bWJlcikge1xuICAgIGNvbnN0IGR1cGxpY2F0ZVRpbWUgPSBub3cgPT09IGxhc3RQdXNoVGltZTtcbiAgICBsYXN0UHVzaFRpbWUgPSBub3c7XG5cbiAgICBsZXQgaTtcbiAgICBjb25zdCB0aW1lU3RhbXBDaGFycyA9IG5ldyBBcnJheSg4KTtcbiAgICBmb3IgKGkgPSA3OyBpID49IDA7IGktLSkge1xuICAgICAgdGltZVN0YW1wQ2hhcnNbaV0gPSBQVVNIX0NIQVJTLmNoYXJBdChub3cgJSA2NCk7XG4gICAgICAvLyBOT1RFOiBDYW4ndCB1c2UgPDwgaGVyZSBiZWNhdXNlIGphdmFzY3JpcHQgd2lsbCBjb252ZXJ0IHRvIGludCBhbmQgbG9zZVxuICAgICAgLy8gdGhlIHVwcGVyIGJpdHMuXG4gICAgICBub3cgPSBNYXRoLmZsb29yKG5vdyAvIDY0KTtcbiAgICB9XG4gICAgYXNzZXJ0KG5vdyA9PT0gMCwgJ0Nhbm5vdCBwdXNoIGF0IHRpbWUgPT0gMCcpO1xuXG4gICAgbGV0IGlkID0gdGltZVN0YW1wQ2hhcnMuam9pbignJyk7XG5cbiAgICBpZiAoIWR1cGxpY2F0ZVRpbWUpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIGxhc3RSYW5kQ2hhcnNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2NCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSB0aW1lc3RhbXAgaGFzbid0IGNoYW5nZWQgc2luY2UgbGFzdCBwdXNoLCB1c2UgdGhlIHNhbWUgcmFuZG9tXG4gICAgICAvLyBudW1iZXIsIGV4Y2VwdCBpbmNyZW1lbnRlZCBieSAxLlxuICAgICAgZm9yIChpID0gMTE7IGkgPj0gMCAmJiBsYXN0UmFuZENoYXJzW2ldID09PSA2MzsgaS0tKSB7XG4gICAgICAgIGxhc3RSYW5kQ2hhcnNbaV0gPSAwO1xuICAgICAgfVxuICAgICAgbGFzdFJhbmRDaGFyc1tpXSsrO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgaWQgKz0gUFVTSF9DSEFSUy5jaGFyQXQobGFzdFJhbmRDaGFyc1tpXSk7XG4gICAgfVxuICAgIGFzc2VydChpZC5sZW5ndGggPT09IDIwLCAnbmV4dFB1c2hJZDogTGVuZ3RoIHNob3VsZCBiZSAyMC4nKTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcbn0pKCk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBJbmRleCB9IGZyb20gJy4vaW5kZXhlcy9JbmRleCc7XG5cbi8qKlxuICogTm9kZSBpcyBhbiBpbnRlcmZhY2UgZGVmaW5pbmcgdGhlIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBub2RlcyBpblxuICogYSBEYXRhU25hcHNob3QuXG4gKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vZGUge1xuICAvKipcbiAgICogV2hldGhlciB0aGlzIG5vZGUgaXMgYSBsZWFmIG5vZGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyBhIGxlYWYgbm9kZS5cbiAgICovXG4gIGlzTGVhZk5vZGUoKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2V0cyB0aGUgcHJpb3JpdHkgb2YgdGhlIG5vZGUuXG4gICAqIEByZXR1cm4geyFOb2RlfSBUaGUgcHJpb3JpdHkgb2YgdGhlIG5vZGUuXG4gICAqL1xuICBnZXRQcmlvcml0eSgpOiBOb2RlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZHVwbGljYXRlIG5vZGUgd2l0aCB0aGUgbmV3IHByaW9yaXR5LlxuICAgKiBAcGFyYW0geyFOb2RlfSBuZXdQcmlvcml0eU5vZGUgTmV3IHByaW9yaXR5IHRvIHNldCBmb3IgdGhlIG5vZGUuXG4gICAqIEByZXR1cm4geyFOb2RlfSBOb2RlIHdpdGggbmV3IHByaW9yaXR5LlxuICAgKi9cbiAgdXBkYXRlUHJpb3JpdHkobmV3UHJpb3JpdHlOb2RlOiBOb2RlKTogTm9kZTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIGltbWVkaWF0ZSBjaGlsZCwgb3IgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGROYW1lIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCB0byByZXRyaWV2ZS5cbiAgICogQHJldHVybiB7IU5vZGV9IFRoZSByZXRyaWV2ZWQgY2hpbGQsIG9yIGFuIGVtcHR5IG5vZGUuXG4gICAqL1xuICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWU6IHN0cmluZyk6IE5vZGU7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjaGlsZCBieSBwYXRoLCBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggb2YgdGhlIGNoaWxkIHRvIHJldHJpZXZlLlxuICAgKiBAcmV0dXJuIHshTm9kZX0gVGhlIHJldHJpZXZlZCBjaGlsZCBvciBhbiBlbXB0eSBub2RlLlxuICAgKi9cbiAgZ2V0Q2hpbGQocGF0aDogUGF0aCk6IE5vZGU7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoaWxkIGltbWVkaWF0ZWx5IHByaW9yIHRvIHRoZSBzcGVjaWZpZWQgY2hpbGROb2RlLCBvciBudWxsLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGNoaWxkTmFtZSBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gZmluZCB0aGUgcHJlZGVjZXNzb3Igb2YuXG4gICAqIEBwYXJhbSB7IU5vZGV9IGNoaWxkTm9kZSBUaGUgbm9kZSB0byBmaW5kIHRoZSBwcmVkZWNlc3NvciBvZi5cbiAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4IFRoZSBpbmRleCB0byB1c2UgdG8gZGV0ZXJtaW5lIHRoZSBwcmVkZWNlc3NvclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgcHJlZGVjZXNzb3IgY2hpbGQsIG9yIG51bGwgaWYgY2hpbGROb2RlIGlzIHRoZSBmaXJzdCBjaGlsZC5cbiAgICovXG4gIGdldFByZWRlY2Vzc29yQ2hpbGROYW1lKFxuICAgIGNoaWxkTmFtZTogU3RyaW5nLFxuICAgIGNoaWxkTm9kZTogTm9kZSxcbiAgICBpbmRleDogSW5kZXhcbiAgKTogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGR1cGxpY2F0ZSBub2RlLCB3aXRoIHRoZSBzcGVjaWZpZWQgaW1tZWRpYXRlIGNoaWxkIHVwZGF0ZWQuXG4gICAqIEFueSB2YWx1ZSBpbiB0aGUgbm9kZSB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGNoaWxkIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHshTm9kZX0gbmV3Q2hpbGROb2RlIFRoZSBuZXcgY2hpbGQgbm9kZVxuICAgKiBAcmV0dXJuIHshTm9kZX0gVGhlIHVwZGF0ZWQgbm9kZS5cbiAgICovXG4gIHVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZTogc3RyaW5nLCBuZXdDaGlsZE5vZGU6IE5vZGUpOiBOb2RlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZHVwbGljYXRlIG5vZGUsIHdpdGggdGhlIHNwZWNpZmllZCBjaGlsZCB1cGRhdGVkLiAgQW55IHZhbHVlIHdpbGxcbiAgICogYmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgY2hpbGQgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0geyFOb2RlfSBuZXdDaGlsZE5vZGUgVGhlIG5ldyBjaGlsZCBub2RlLCB3aGljaCBtYXkgYmUgYW4gZW1wdHkgbm9kZVxuICAgKiBAcmV0dXJuIHshTm9kZX0gVGhlIHVwZGF0ZWQgbm9kZS5cbiAgICovXG4gIHVwZGF0ZUNoaWxkKHBhdGg6IFBhdGgsIG5ld0NoaWxkTm9kZTogTm9kZSk6IE5vZGU7XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIGltbWVkaWF0ZSBjaGlsZCBzcGVjaWZpZWQgZXhpc3RzXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY2hpbGROYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDaGlsZChjaGlsZE5hbWU6IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBub2RlIGhhcyBubyB2YWx1ZSBvciBjaGlsZHJlbi5cbiAgICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIG9mIHRoaXMgbm9kZS5cbiAgICovXG4gIG51bUNoaWxkcmVuKCk6IG51bWJlcjtcblxuICAvKipcbiAgICogQ2FsbHMgYWN0aW9uIGZvciBlYWNoIGNoaWxkLlxuICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhcbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsICFOb2RlKX0gYWN0aW9uIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yXG4gICAqIGVhY2ggY2hpbGQuICBJdCdzIHBhc3NlZCB0aGUgY2hpbGQgbmFtZSBhbmQgdGhlIGNoaWxkIG5vZGUuXG4gICAqIEByZXR1cm4geyp9IFRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5IG9uZVxuICAgKi9cbiAgZm9yRWFjaENoaWxkKGluZGV4OiBJbmRleCwgYWN0aW9uOiAoYTogc3RyaW5nLCBiOiBOb2RlKSA9PiB2b2lkKTogYW55O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleHBvcnRGb3JtYXQgVHJ1ZSBmb3IgZXhwb3J0IGZvcm1hdCAoYWxzbyB3aXJlIHByb3RvY29sIGZvcm1hdCkuXG4gICAqIEByZXR1cm4geyp9IFZhbHVlIG9mIHRoaXMgbm9kZSBhcyBKU09OLlxuICAgKi9cbiAgdmFsKGV4cG9ydEZvcm1hdD86IGJvb2xlYW4pOiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGhhc2ggcmVwcmVzZW50aW5nIHRoZSBub2RlIGNvbnRlbnRzLlxuICAgKi9cbiAgaGFzaCgpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG90aGVyIEFub3RoZXIgbm9kZVxuICAgKiBAcmV0dXJuIHshbnVtYmVyfSAtMSBmb3IgbGVzcyB0aGFuLCAwIGZvciBlcXVhbCwgMSBmb3IgZ3JlYXRlciB0aGFuIG90aGVyXG4gICAqL1xuICBjb21wYXJlVG8ob3RoZXI6IE5vZGUpOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoaXMgc25hcHNob3QgZXF1YWxzIG90aGVyXG4gICAqL1xuICBlcXVhbHMob3RoZXI6IE5vZGUpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAqIEByZXR1cm4geyFOb2RlfSBUaGlzIG5vZGUsIHdpdGggdGhlIHNwZWNpZmllZCBpbmRleCBub3cgYXZhaWxhYmxlXG4gICAqL1xuICB3aXRoSW5kZXgoaW5kZXhEZWZpbml0aW9uOiBJbmRleCk6IE5vZGU7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzSW5kZXhlZChpbmRleERlZmluaXRpb246IEluZGV4KTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVkTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lOiBzdHJpbmcsIHB1YmxpYyBub2RlOiBOb2RlKSB7fVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcmV0dXJuIHtOYW1lZE5vZGV9XG4gICAqL1xuICBzdGF0aWMgV3JhcChuYW1lOiBzdHJpbmcsIG5vZGU6IE5vZGUpIHtcbiAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE5vZGUsIE5hbWVkTm9kZSB9IGZyb20gJy4uL05vZGUnO1xuaW1wb3J0IHsgTUlOX05BTUUsIE1BWF9OQU1FIH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi8uLi91dGlsL1NvcnRlZE1hcCc7XG5cbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5kZXgge1xuICAvKipcbiAgICogQHBhcmFtIHshTmFtZWROb2RlfSBhXG4gICAqIEBwYXJhbSB7IU5hbWVkTm9kZX0gYlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhYnN0cmFjdCBjb21wYXJlKGE6IE5hbWVkTm9kZSwgYjogTmFtZWROb2RlKTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnN0cmFjdCBpc0RlZmluZWRPbihub2RlOiBOb2RlKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHJldHVybiB7ZnVuY3Rpb24oIU5hbWVkTm9kZSwgIU5hbWVkTm9kZSk6bnVtYmVyfSBBIHN0YW5kYWxvbmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3JcbiAgICogdGhpcyBpbmRleFxuICAgKi9cbiAgZ2V0Q29tcGFyZSgpOiBDb21wYXJhdG9yPE5hbWVkTm9kZT4ge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGJlZm9yZSBhbmQgYWZ0ZXIgdmFsdWUgZm9yIGEgbm9kZSwgZGV0ZXJtaW5lIGlmIHRoZSBpbmRleGVkIHZhbHVlIGhhcyBjaGFuZ2VkLiBFdmVuIGlmIHRoZXkgYXJlIGRpZmZlcmVudCxcbiAgICogaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBjaGFuZ2VzIGFyZSBpc29sYXRlZCB0byBwYXJ0cyBvZiB0aGUgc25hcHNob3QgdGhhdCBhcmUgbm90IGluZGV4ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG9sZE5vZGVcbiAgICogQHBhcmFtIHshTm9kZX0gbmV3Tm9kZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwb3J0aW9uIG9mIHRoZSBzbmFwc2hvdCBiZWluZyBpbmRleGVkIGNoYW5nZWQgYmV0d2VlbiBvbGROb2RlIGFuZCBuZXdOb2RlXG4gICAqL1xuICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGU6IE5vZGUsIG5ld05vZGU6IE5vZGUpOiBib29sZWFuIHtcbiAgICBjb25zdCBvbGRXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgb2xkTm9kZSk7XG4gICAgY29uc3QgbmV3V3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoTUlOX05BTUUsIG5ld05vZGUpO1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmUob2xkV3JhcHBlZCwgbmV3V3JhcHBlZCkgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU5hbWVkTm9kZX0gYSBub2RlIHdyYXBwZXIgdGhhdCB3aWxsIHNvcnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXG4gICAqIGFueSBvdGhlciBub2RlIHdyYXBwZXIsIHVzaW5nIHRoaXMgaW5kZXhcbiAgICovXG4gIG1pblBvc3QoKTogTmFtZWROb2RlIHtcbiAgICByZXR1cm4gKE5hbWVkTm9kZSBhcyBhbnkpLk1JTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfSBhIG5vZGUgd3JhcHBlciB0aGF0IHdpbGwgc29ydCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICogYW55IG90aGVyIG5vZGUgd3JhcHBlciwgdXNpbmcgdGhpcyBpbmRleFxuICAgKi9cbiAgYWJzdHJhY3QgbWF4UG9zdCgpOiBOYW1lZE5vZGU7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgKi9cbiAgYWJzdHJhY3QgbWFrZVBvc3QoaW5kZXhWYWx1ZTogYW55LCBuYW1lOiBzdHJpbmcpOiBOYW1lZE5vZGU7XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xuICAgKi9cbiAgYWJzdHJhY3QgdG9TdHJpbmcoKTogc3RyaW5nO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluZGV4IH0gZnJvbSAnLi9JbmRleCc7XG5pbXBvcnQgeyBOb2RlLCBOYW1lZE5vZGUgfSBmcm9tICcuLi9Ob2RlJztcbmltcG9ydCB7IG5hbWVDb21wYXJlLCBNQVhfTkFNRSB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydGlvbkVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQ2hpbGRyZW5Ob2RlIH0gZnJvbSAnLi4vQ2hpbGRyZW5Ob2RlJztcblxubGV0IF9fRU1QVFlfTk9ERTogQ2hpbGRyZW5Ob2RlO1xuXG5leHBvcnQgY2xhc3MgS2V5SW5kZXggZXh0ZW5kcyBJbmRleCB7XG4gIHN0YXRpYyBnZXQgX19FTVBUWV9OT0RFKCkge1xuICAgIHJldHVybiBfX0VNUFRZX05PREU7XG4gIH1cblxuICBzdGF0aWMgc2V0IF9fRU1QVFlfTk9ERSh2YWwpIHtcbiAgICBfX0VNUFRZX05PREUgPSB2YWw7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNvbXBhcmUoYTogTmFtZWROb2RlLCBiOiBOYW1lZE5vZGUpOiBudW1iZXIge1xuICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGlzRGVmaW5lZE9uKG5vZGU6IE5vZGUpOiBib29sZWFuIHtcbiAgICAvLyBXZSBjb3VsZCBwcm9iYWJseSByZXR1cm4gdHJ1ZSBoZXJlIChzaW5jZSBldmVyeSBub2RlIGhhcyBhIGtleSksIGJ1dCBpdCdzIG5ldmVyIGNhbGxlZFxuICAgIC8vIHNvIGp1c3QgbGVhdmluZyB1bmltcGxlbWVudGVkIGZvciBub3cuXG4gICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ0tleUluZGV4LmlzRGVmaW5lZE9uIG5vdCBleHBlY3RlZCB0byBiZSBjYWxsZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZTogTm9kZSwgbmV3Tm9kZTogTm9kZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIGtleSBmb3IgYSBub2RlIG5ldmVyIGNoYW5nZXMuXG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIG1pblBvc3QoKSB7XG4gICAgcmV0dXJuIChOYW1lZE5vZGUgYXMgYW55KS5NSU47XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIG1heFBvc3QoKTogTmFtZWROb2RlIHtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZWFsbHkgYmUgY3JlYXRlZCBvbmNlIGFuZCBjYWNoZWQgaW4gYSBzdGF0aWMgcHJvcGVydHksIGJ1dFxuICAgIC8vIE5hbWVkTm9kZSBpc24ndCBkZWZpbmVkIHlldCwgc28gSSBjYW4ndCB1c2UgaXQgaW4gYSBzdGF0aWMuICBCbGVoLlxuICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBfX0VNUFRZX05PREUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgKi9cbiAgbWFrZVBvc3QoaW5kZXhWYWx1ZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBOYW1lZE5vZGUge1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBpbmRleFZhbHVlID09PSAnc3RyaW5nJyxcbiAgICAgICdLZXlJbmRleCBpbmRleFZhbHVlIG11c3QgYWx3YXlzIGJlIGEgc3RyaW5nLidcbiAgICApO1xuICAgIC8vIFdlIGp1c3QgdXNlIGVtcHR5IG5vZGUsIGJ1dCBpdCdsbCBuZXZlciBiZSBjb21wYXJlZCwgc2luY2Ugb3VyIGNvbXBhcmF0b3Igb25seSBsb29rcyBhdCBuYW1lLlxuICAgIHJldHVybiBuZXcgTmFtZWROb2RlKGluZGV4VmFsdWUsIF9fRU1QVFlfTk9ERSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IXN0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXG4gICAqL1xuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiAnLmtleSc7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEtFWV9JTkRFWCA9IG5ldyBLZXlJbmRleCgpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGRvdWJsZVRvSUVFRTc1NFN0cmluZyB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBjb250YWlucyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL05vZGUnO1xuXG5sZXQgTUFYX05PREU6IE5vZGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXhOb2RlKHZhbDogTm9kZSkge1xuICBNQVhfTk9ERSA9IHZhbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyghc3RyaW5nfCFudW1iZXIpfSBwcmlvcml0eVxuICogQHJldHVybiB7IXN0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHByaW9yaXR5SGFzaFRleHQgPSBmdW5jdGlvbihwcmlvcml0eTogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicpXG4gICAgcmV0dXJuICdudW1iZXI6JyArIGRvdWJsZVRvSUVFRTc1NFN0cmluZyhwcmlvcml0eSk7XG4gIGVsc2UgcmV0dXJuICdzdHJpbmc6JyArIHByaW9yaXR5O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBhIHByaW9yaXR5IHNuYXBzaG90IE5vZGUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHshTm9kZX0gcHJpb3JpdHlOb2RlXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVByaW9yaXR5Tm9kZSA9IGZ1bmN0aW9uKHByaW9yaXR5Tm9kZTogTm9kZSkge1xuICBpZiAocHJpb3JpdHlOb2RlLmlzTGVhZk5vZGUoKSkge1xuICAgIGNvbnN0IHZhbCA9IHByaW9yaXR5Tm9kZS52YWwoKTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBjb250YWlucyh2YWwgYXMgeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0sICcuc3YnKSksXG4gICAgICAnUHJpb3JpdHkgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXIuJ1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KFxuICAgICAgcHJpb3JpdHlOb2RlID09PSBNQVhfTk9ERSB8fCBwcmlvcml0eU5vZGUuaXNFbXB0eSgpLFxuICAgICAgJ3ByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS4nXG4gICAgKTtcbiAgfVxuICAvLyBEb24ndCBjYWxsIGdldFByaW9yaXR5KCkgb24gTUFYX05PREUgdG8gYXZvaWQgaGl0dGluZyBhc3NlcnRpb24uXG4gIGFzc2VydChcbiAgICBwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFIHx8IHByaW9yaXR5Tm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSxcbiAgICBcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCJcbiAgKTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgZG91YmxlVG9JRUVFNzU0U3RyaW5nLCBzaGExIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IHByaW9yaXR5SGFzaFRleHQsIHZhbGlkYXRlUHJpb3JpdHlOb2RlIH0gZnJvbSAnLi9zbmFwJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL05vZGUnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBJbmRleCB9IGZyb20gJy4vaW5kZXhlcy9JbmRleCc7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciB9IGZyb20gJy4vQ2hpbGRyZW5Ob2RlJztcblxubGV0IF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3I6IENoaWxkcmVuTm9kZUNvbnN0cnVjdG9yO1xuXG4vKipcbiAqIExlYWZOb2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgbGVhZiBub2RlcyBpbiBhIERhdGFTbmFwc2hvdC4gIEl0XG4gKiBpbXBsZW1lbnRzIE5vZGUgYW5kIHN0b3JlcyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgKGEgc3RyaW5nLFxuICogbnVtYmVyLCBvciBib29sZWFuKSBhY2Nlc3NpYmxlIHZpYSBnZXRWYWx1ZSgpLlxuICovXG5leHBvcnQgY2xhc3MgTGVhZk5vZGUgaW1wbGVtZW50cyBOb2RlIHtcbiAgc3RhdGljIHNldCBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKHZhbDogQ2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yID0gdmFsO1xuICB9XG5cbiAgc3RhdGljIGdldCBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKCkge1xuICAgIHJldHVybiBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzb3J0IG9yZGVyIGZvciBjb21wYXJpbmcgbGVhZiBub2RlcyBvZiBkaWZmZXJlbnQgdHlwZXMuIElmIHR3byBsZWFmIG5vZGVzIGhhdmVcbiAgICogdGhlIHNhbWUgdHlwZSwgdGhlIGNvbXBhcmlzb24gZmFsbHMgYmFjayB0byB0aGVpciB2YWx1ZVxuICAgKiBAdHlwZSB7QXJyYXkuPCFzdHJpbmc+fVxuICAgKiBAY29uc3RcbiAgICovXG4gIHN0YXRpYyBWQUxVRV9UWVBFX09SREVSID0gWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ107XG5cbiAgcHJpdmF0ZSBsYXp5SGFzaF86IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAaW1wbGVtZW50cyB7Tm9kZX1cbiAgICogQHBhcmFtIHshKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbnxPYmplY3QpfSB2YWx1ZV8gVGhlIHZhbHVlIHRvIHN0b3JlIGluIHRoaXMgbGVhZiBub2RlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCB0eXBlIGlzIHBvc3NpYmxlIGluIHRoZSBldmVudCBvZiBhIGRlZmVycmVkIHZhbHVlXG4gICAqIEBwYXJhbSB7IU5vZGU9fSBwcmlvcml0eU5vZGVfIFRoZSBwcmlvcml0eSBvZiB0aGlzIG5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhbHVlXzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG9iamVjdCxcbiAgICBwcml2YXRlIHByaW9yaXR5Tm9kZV86IE5vZGUgPSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREVcbiAgKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgdGhpcy52YWx1ZV8gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlXyAhPT0gbnVsbCxcbiAgICAgIFwiTGVhZk5vZGUgc2hvdWxkbid0IGJlIGNyZWF0ZWQgd2l0aCBudWxsL3VuZGVmaW5lZCB2YWx1ZS5cIlxuICAgICk7XG5cbiAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGlzTGVhZk5vZGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgZ2V0UHJpb3JpdHkoKTogTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICB1cGRhdGVQcmlvcml0eShuZXdQcmlvcml0eU5vZGU6IE5vZGUpOiBOb2RlIHtcbiAgICByZXR1cm4gbmV3IExlYWZOb2RlKHRoaXMudmFsdWVfLCBuZXdQcmlvcml0eU5vZGUpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZTogc3RyaW5nKTogTm9kZSB7XG4gICAgLy8gSGFjayB0byB0cmVhdCBwcmlvcml0eSBhcyBhIHJlZ3VsYXIgY2hpbGRcbiAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgZ2V0Q2hpbGQocGF0aDogUGF0aCk6IE5vZGUge1xuICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmIChwYXRoLmdldEZyb250KCkgPT09ICcucHJpb3JpdHknKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgaGFzQ2hpbGQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGdldFByZWRlY2Vzc29yQ2hpbGROYW1lKGNoaWxkTmFtZTogU3RyaW5nLCBjaGlsZE5vZGU6IE5vZGUpOiBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICB1cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWU6IHN0cmluZywgbmV3Q2hpbGROb2RlOiBOb2RlKTogTm9kZSB7XG4gICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVByaW9yaXR5KG5ld0NoaWxkTm9kZSk7XG4gICAgfSBlbHNlIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpICYmIGNoaWxkTmFtZSAhPT0gJy5wcmlvcml0eScpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKFxuICAgICAgICBjaGlsZE5hbWUsXG4gICAgICAgIG5ld0NoaWxkTm9kZVxuICAgICAgKS51cGRhdGVQcmlvcml0eSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICB1cGRhdGVDaGlsZChwYXRoOiBQYXRoLCBuZXdDaGlsZE5vZGU6IE5vZGUpOiBOb2RlIHtcbiAgICBjb25zdCBmcm9udCA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XG4gICAgfSBlbHNlIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpICYmIGZyb250ICE9PSAnLnByaW9yaXR5Jykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgZnJvbnQgIT09ICcucHJpb3JpdHknIHx8IHBhdGguZ2V0TGVuZ3RoKCkgPT09IDEsXG4gICAgICAgICcucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGgnXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVJbW1lZGlhdGVDaGlsZChcbiAgICAgICAgZnJvbnQsXG4gICAgICAgIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERS51cGRhdGVDaGlsZChcbiAgICAgICAgICBwYXRoLnBvcEZyb250KCksXG4gICAgICAgICAgbmV3Q2hpbGROb2RlXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIG51bUNoaWxkcmVuKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgZm9yRWFjaENoaWxkKGluZGV4OiBJbmRleCwgYWN0aW9uOiAoczogc3RyaW5nLCBuOiBOb2RlKSA9PiB2b2lkKTogYW55IHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHZhbChleHBvcnRGb3JtYXQ/OiBib29sZWFuKTogT2JqZWN0IHtcbiAgICBpZiAoZXhwb3J0Rm9ybWF0ICYmICF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJy52YWx1ZSc6IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgJy5wcmlvcml0eSc6IHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKVxuICAgICAgfTtcbiAgICBlbHNlIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgaGFzaCgpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmxhenlIYXNoXyA9PT0gbnVsbCkge1xuICAgICAgbGV0IHRvSGFzaCA9ICcnO1xuICAgICAgaWYgKCF0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpKVxuICAgICAgICB0b0hhc2ggKz1cbiAgICAgICAgICAncHJpb3JpdHk6JyArXG4gICAgICAgICAgcHJpb3JpdHlIYXNoVGV4dCh0aGlzLnByaW9yaXR5Tm9kZV8udmFsKCkgYXMgbnVtYmVyIHwgc3RyaW5nKSArXG4gICAgICAgICAgJzonO1xuXG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHRoaXMudmFsdWVfO1xuICAgICAgdG9IYXNoICs9IHR5cGUgKyAnOic7XG4gICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdG9IYXNoICs9IGRvdWJsZVRvSUVFRTc1NFN0cmluZyh0aGlzLnZhbHVlXyBhcyBudW1iZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9IYXNoICs9IHRoaXMudmFsdWVfO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXp5SGFzaF8gPSBzaGExKHRvSGFzaCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbGVhZiBub2RlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R8c3RyaW5nfG51bWJlcnxib29sZWFufSBUaGUgdmFsdWUgb2YgdGhlIG5vZGUuXG4gICAqL1xuICBnZXRWYWx1ZSgpOiBvYmplY3QgfCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNvbXBhcmVUbyhvdGhlcjogTm9kZSk6IG51bWJlciB7XG4gICAgaWYgKG90aGVyID09PSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAob3RoZXIgaW5zdGFuY2VvZiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChvdGhlci5pc0xlYWZOb2RlKCksICdVbmtub3duIG5vZGUgdHlwZScpO1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvTGVhZk5vZGVfKG90aGVyIGFzIExlYWZOb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyaXNvbiBzcGVjaWZpY2FsbHkgZm9yIHR3byBsZWFmIG5vZGVzXG4gICAqIEBwYXJhbSB7IUxlYWZOb2RlfSBvdGhlckxlYWZcbiAgICogQHJldHVybiB7IW51bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY29tcGFyZVRvTGVhZk5vZGVfKG90aGVyTGVhZjogTGVhZk5vZGUpOiBudW1iZXIge1xuICAgIGNvbnN0IG90aGVyTGVhZlR5cGUgPSB0eXBlb2Ygb3RoZXJMZWFmLnZhbHVlXztcbiAgICBjb25zdCB0aGlzTGVhZlR5cGUgPSB0eXBlb2YgdGhpcy52YWx1ZV87XG4gICAgY29uc3Qgb3RoZXJJbmRleCA9IExlYWZOb2RlLlZBTFVFX1RZUEVfT1JERVIuaW5kZXhPZihvdGhlckxlYWZUeXBlKTtcbiAgICBjb25zdCB0aGlzSW5kZXggPSBMZWFmTm9kZS5WQUxVRV9UWVBFX09SREVSLmluZGV4T2YodGhpc0xlYWZUeXBlKTtcbiAgICBhc3NlcnQob3RoZXJJbmRleCA+PSAwLCAnVW5rbm93biBsZWFmIHR5cGU6ICcgKyBvdGhlckxlYWZUeXBlKTtcbiAgICBhc3NlcnQodGhpc0luZGV4ID49IDAsICdVbmtub3duIGxlYWYgdHlwZTogJyArIHRoaXNMZWFmVHlwZSk7XG4gICAgaWYgKG90aGVySW5kZXggPT09IHRoaXNJbmRleCkge1xuICAgICAgLy8gU2FtZSB0eXBlLCBjb21wYXJlIHZhbHVlc1xuICAgICAgaWYgKHRoaXNMZWFmVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gRGVmZXJyZWQgdmFsdWUgbm9kZXMgYXJlIGFsbCBlcXVhbCwgYnV0IHdlIHNob3VsZCBhbHNvIG5ldmVyIGdldCB0byB0aGlzIHBvaW50Li4uXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgd29ya3MgYmVjYXVzZSB0cnVlID4gZmFsc2UsIGFsbCBvdGhlcnMgYXJlIG51bWJlciBvciBzdHJpbmcgY29tcGFyaXNvbnNcbiAgICAgICAgaWYgKHRoaXMudmFsdWVfIDwgb3RoZXJMZWFmLnZhbHVlXykge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlXyA9PT0gb3RoZXJMZWFmLnZhbHVlXykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzSW5kZXggLSBvdGhlckluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgd2l0aEluZGV4KCk6IE5vZGUge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBpc0luZGV4ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGVxdWFscyhvdGhlcjogTm9kZSk6IGJvb2xlYW4ge1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgaWYgKG90aGVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSkge1xuICAgICAgY29uc3Qgb3RoZXJMZWFmID0gb3RoZXIgYXMgTGVhZk5vZGU7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnZhbHVlXyA9PT0gb3RoZXJMZWFmLnZhbHVlXyAmJlxuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8uZXF1YWxzKG90aGVyTGVhZi5wcmlvcml0eU5vZGVfKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluZGV4IH0gZnJvbSAnLi9JbmRleCc7XG5pbXBvcnQgeyBuYW1lQ29tcGFyZSwgTUFYX05BTUUgfSBmcm9tICcuLi8uLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgTmFtZWROb2RlLCBOb2RlIH0gZnJvbSAnLi4vTm9kZSc7XG5pbXBvcnQgeyBMZWFmTm9kZSB9IGZyb20gJy4uL0xlYWZOb2RlJztcblxubGV0IG5vZGVGcm9tSlNPTjogKGE6IGFueSkgPT4gTm9kZTtcbmxldCBNQVhfTk9ERTogTm9kZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldE5vZGVGcm9tSlNPTih2YWw6IChhOiBhbnkpID0+IE5vZGUpIHtcbiAgbm9kZUZyb21KU09OID0gdmFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TWF4Tm9kZSh2YWw6IE5vZGUpIHtcbiAgTUFYX05PREUgPSB2YWw7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SW5kZXh9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgUHJpb3JpdHlJbmRleCBleHRlbmRzIEluZGV4IHtcbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjb21wYXJlKGE6IE5hbWVkTm9kZSwgYjogTmFtZWROb2RlKTogbnVtYmVyIHtcbiAgICBjb25zdCBhUHJpb3JpdHkgPSBhLm5vZGUuZ2V0UHJpb3JpdHkoKTtcbiAgICBjb25zdCBiUHJpb3JpdHkgPSBiLm5vZGUuZ2V0UHJpb3JpdHkoKTtcbiAgICBjb25zdCBpbmRleENtcCA9IGFQcmlvcml0eS5jb21wYXJlVG8oYlByaW9yaXR5KTtcbiAgICBpZiAoaW5kZXhDbXAgPT09IDApIHtcbiAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbmRleENtcDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGlzRGVmaW5lZE9uKG5vZGU6IE5vZGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIW5vZGUuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZTogTm9kZSwgbmV3Tm9kZTogTm9kZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhb2xkTm9kZS5nZXRQcmlvcml0eSgpLmVxdWFscyhuZXdOb2RlLmdldFByaW9yaXR5KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBtaW5Qb3N0KCk6IE5hbWVkTm9kZSB7XG4gICAgcmV0dXJuIChOYW1lZE5vZGUgYXMgYW55KS5NSU47XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIG1heFBvc3QoKTogTmFtZWROb2RlIHtcbiAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShNQVhfTkFNRSwgbmV3IExlYWZOb2RlKCdbUFJJT1JJVFktUE9TVF0nLCBNQVhfTk9ERSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgKi9cbiAgbWFrZVBvc3QoaW5kZXhWYWx1ZTogYW55LCBuYW1lOiBzdHJpbmcpOiBOYW1lZE5vZGUge1xuICAgIGNvbnN0IHByaW9yaXR5Tm9kZSA9IG5vZGVGcm9tSlNPTihpbmRleFZhbHVlKTtcbiAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBuZXcgTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIHByaW9yaXR5Tm9kZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xuICAgKi9cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJy5wcmlvcml0eSc7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFBSSU9SSVRZX0lOREVYID0gbmV3IFByaW9yaXR5SW5kZXgoKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW1wbGVtZW50YXRpb24gb2YgYW4gaW1tdXRhYmxlIFNvcnRlZE1hcCB1c2luZyBhIExlZnQtbGVhbmluZ1xuICogUmVkLUJsYWNrIFRyZWUsIGFkYXB0ZWQgZnJvbSB0aGUgaW1wbGVtZW50YXRpb24gaW4gTXVnc1xuICogKGh0dHA6Ly9tYWRzMzc5LmdpdGh1Yi5jb20vbXVncy8pIGJ5IE1hZHMgSGFydG1hbm4gSmVuc2VuXG4gKiAobWFkczM3OUBnbWFpbC5jb20pLlxuICpcbiAqIE9yaWdpbmFsIHBhcGVyIG9uIExlZnQtbGVhbmluZyBSZWQtQmxhY2sgVHJlZXM6XG4gKiAgIGh0dHA6Ly93d3cuY3MucHJpbmNldG9uLmVkdS9+cnMvdGFsa3MvTExSQi9MTFJCLnBkZlxuICpcbiAqIEludmFyaWFudCAxOiBObyByZWQgbm9kZSBoYXMgYSByZWQgY2hpbGRcbiAqIEludmFyaWFudCAyOiBFdmVyeSBsZWFmIHBhdGggaGFzIHRoZSBzYW1lIG51bWJlciBvZiBibGFjayBub2Rlc1xuICogSW52YXJpYW50IDM6IE9ubHkgdGhlIGxlZnQgY2hpbGQgY2FuIGJlIHJlZCAobGVmdCBsZWFuaW5nKVxuICovXG5cbi8vIFRPRE86IFRoZXJlIGFyZSBzb21lIGltcHJvdmVtZW50cyBJJ2QgbGlrZSB0byBtYWtlIHRvIGltcHJvdmUgbWVtb3J5IC8gcGVyZjpcbi8vICAqIENyZWF0ZSB0d28gcHJvdG90eXBlcywgTExSZWROb2RlIGFuZCBMTEJsYWNrTm9kZSwgaW5zdGVhZCBvZiBzdG9yaW5nIGFcbi8vICAgIGNvbG9yIHByb3BlcnR5IGluIGV2ZXJ5IG5vZGUuXG4vLyBUT0RPOiBJdCB3b3VsZCBhbHNvIGJlIGdvb2QgKGFuZCBwb3NzaWJseSBuZWNlc3NhcnkpIHRvIGNyZWF0ZSBhIGJhc2Vcbi8vIGludGVyZmFjZSBmb3IgTExSQk5vZGUgYW5kIExMUkJFbXB0eU5vZGUuXG5cbmV4cG9ydCB0eXBlIENvbXBhcmF0b3I8Sz4gPSAoa2V5MTogSywga2V5MjogSykgPT4gbnVtYmVyO1xuXG4vKipcbiAqIEFuIGl0ZXJhdG9yIG92ZXIgYW4gTExSQk5vZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTb3J0ZWRNYXBJdGVyYXRvcjxLLCBWLCBUPiB7XG4gIC8qKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPCFMTFJCTm9kZT59XG4gICAqL1xuICBwcml2YXRlIG5vZGVTdGFja186IChMTFJCTm9kZTxLLCBWPiB8IExMUkJFbXB0eU5vZGU8SywgVj4pW10gPSBbXTtcblxuICAvKipcbiAgICogQHRlbXBsYXRlIEssIFYsIFRcbiAgICogQHBhcmFtIHtMTFJCTm9kZXxMTFJCRW1wdHlOb2RlfSBub2RlIE5vZGUgdG8gaXRlcmF0ZS5cbiAgICogQHBhcmFtIHs/S30gc3RhcnRLZXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbihLLCBLKTogbnVtYmVyfSBjb21wYXJhdG9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZXZlcnNlXyBXaGV0aGVyIG9yIG5vdCB0byBpdGVyYXRlIGluIHJldmVyc2VcbiAgICogQHBhcmFtIHsoZnVuY3Rpb24oSywgVik6VCk9fSByZXN1bHRHZW5lcmF0b3JfXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBub2RlOiBMTFJCTm9kZTxLLCBWPiB8IExMUkJFbXB0eU5vZGU8SywgVj4sXG4gICAgc3RhcnRLZXk6IEsgfCBudWxsLFxuICAgIGNvbXBhcmF0b3I6IENvbXBhcmF0b3I8Sz4sXG4gICAgcHJpdmF0ZSBpc1JldmVyc2VfOiBib29sZWFuLFxuICAgIHByaXZhdGUgcmVzdWx0R2VuZXJhdG9yXzogKChrOiBLLCB2OiBWKSA9PiBUKSB8IG51bGwgPSBudWxsXG4gICkge1xuICAgIGxldCBjbXAgPSAxO1xuICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgIG5vZGUgPSBub2RlIGFzIExMUkJOb2RlPEssIFY+O1xuICAgICAgY21wID0gc3RhcnRLZXkgPyBjb21wYXJhdG9yKG5vZGUua2V5LCBzdGFydEtleSkgOiAxO1xuICAgICAgLy8gZmxpcCB0aGUgY29tcGFyaXNvbiBpZiB3ZSdyZSBnb2luZyBpbiByZXZlcnNlXG4gICAgICBpZiAoaXNSZXZlcnNlXykgY21wICo9IC0xO1xuXG4gICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAvLyBUaGlzIG5vZGUgaXMgbGVzcyB0aGFuIG91ciBzdGFydCBrZXkuIGlnbm9yZSBpdFxuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBub2RlIGlzIGV4YWN0bHkgZXF1YWwgdG8gb3VyIHN0YXJ0IGtleS4gUHVzaCBpdCBvbiB0aGUgc3RhY2ssIGJ1dCBzdG9wIGl0ZXJhdGluZztcbiAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBub2RlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgc3RhcnQga2V5LCBhZGQgaXQgdG8gdGhlIHN0YWNrIGFuZCBtb3ZlIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXROZXh0KCk6IFQge1xuICAgIGlmICh0aGlzLm5vZGVTdGFja18ubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgIGxldCBub2RlID0gdGhpcy5ub2RlU3RhY2tfLnBvcCgpO1xuICAgIGxldCByZXN1bHQ6IFQ7XG4gICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXylcbiAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0R2VuZXJhdG9yXyhub2RlLmtleSwgbm9kZS52YWx1ZSk7XG4gICAgZWxzZSByZXN1bHQgPSB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH0gYXMgYW55O1xuXG4gICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xuICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGhhc05leHQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPiAwO1xuICB9XG5cbiAgcGVlaygpOiBUIHtcbiAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlU3RhY2tfW3RoaXMubm9kZVN0YWNrXy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGhpcy5yZXN1bHRHZW5lcmF0b3JfKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHRHZW5lcmF0b3JfKG5vZGUua2V5LCBub2RlLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgdmFsdWU6IG5vZGUudmFsdWUgfSBhcyBhbnk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG5vZGUgaW4gYSBMZWZ0LWxlYW5pbmcgUmVkLUJsYWNrIHRyZWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBMTFJCTm9kZTxLLCBWPiB7XG4gIGNvbG9yOiBib29sZWFuO1xuICBsZWZ0OiBMTFJCTm9kZTxLLCBWPiB8IExMUkJFbXB0eU5vZGU8SywgVj47XG4gIHJpZ2h0OiBMTFJCTm9kZTxLLCBWPiB8IExMUkJFbXB0eU5vZGU8SywgVj47XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBLLCBWXG4gICAqIEBwYXJhbSB7IUt9IGtleSBLZXkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZS5cbiAgICogQHBhcmFtIHshVn0gdmFsdWUgVmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZS5cbiAgICogQHBhcmFtIHs/Ym9vbGVhbn0gY29sb3IgV2hldGhlciB0aGlzIG5vZGUgaXMgcmVkLlxuICAgKiBAcGFyYW0gez8oTExSQk5vZGV8TExSQkVtcHR5Tm9kZSk9fSBsZWZ0IExlZnQgY2hpbGQuXG4gICAqIEBwYXJhbSB7PyhMTFJCTm9kZXxMTFJCRW1wdHlOb2RlKT19IHJpZ2h0IFJpZ2h0IGNoaWxkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGtleTogSyxcbiAgICBwdWJsaWMgdmFsdWU6IFYsXG4gICAgY29sb3I6IGJvb2xlYW4gfCBudWxsLFxuICAgIGxlZnQ/OiBMTFJCTm9kZTxLLCBWPiB8IExMUkJFbXB0eU5vZGU8SywgVj4gfCBudWxsLFxuICAgIHJpZ2h0PzogTExSQk5vZGU8SywgVj4gfCBMTFJCRW1wdHlOb2RlPEssIFY+IHwgbnVsbFxuICApIHtcbiAgICB0aGlzLmNvbG9yID0gY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogTExSQk5vZGUuUkVEO1xuICAgIHRoaXMubGVmdCA9XG4gICAgICBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogKFNvcnRlZE1hcC5FTVBUWV9OT0RFIGFzIExMUkJFbXB0eU5vZGU8SywgVj4pO1xuICAgIHRoaXMucmlnaHQgPVxuICAgICAgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogKFNvcnRlZE1hcC5FTVBUWV9OT0RFIGFzIExMUkJFbXB0eU5vZGU8SywgVj4pO1xuICB9XG5cbiAgc3RhdGljIFJFRCA9IHRydWU7XG4gIHN0YXRpYyBCTEFDSyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IHJlcGxhY2luZyBwaWVjZXMgb2YgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7P0t9IGtleSBOZXcga2V5IGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cbiAgICogQHBhcmFtIHs/Vn0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cbiAgICogQHBhcmFtIHs/Ym9vbGVhbn0gY29sb3IgTmV3IGNvbG9yIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cbiAgICogQHBhcmFtIHs/TExSQk5vZGV8TExSQkVtcHR5Tm9kZX0gbGVmdCBOZXcgbGVmdCBjaGlsZCBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXG4gICAqIEBwYXJhbSB7P0xMUkJOb2RlfExMUkJFbXB0eU5vZGV9IHJpZ2h0IE5ldyByaWdodCBjaGlsZCBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXG4gICAqIEByZXR1cm4geyFMTFJCTm9kZX0gVGhlIG5vZGUgY29weS5cbiAgICovXG4gIGNvcHkoXG4gICAga2V5OiBLIHwgbnVsbCxcbiAgICB2YWx1ZTogViB8IG51bGwsXG4gICAgY29sb3I6IGJvb2xlYW4gfCBudWxsLFxuICAgIGxlZnQ6IExMUkJOb2RlPEssIFY+IHwgTExSQkVtcHR5Tm9kZTxLLCBWPiB8IG51bGwsXG4gICAgcmlnaHQ6IExMUkJOb2RlPEssIFY+IHwgTExSQkVtcHR5Tm9kZTxLLCBWPiB8IG51bGxcbiAgKTogTExSQk5vZGU8SywgVj4ge1xuICAgIHJldHVybiBuZXcgTExSQk5vZGUoXG4gICAgICBrZXkgIT0gbnVsbCA/IGtleSA6IHRoaXMua2V5LFxuICAgICAgdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy52YWx1ZSxcbiAgICAgIGNvbG9yICE9IG51bGwgPyBjb2xvciA6IHRoaXMuY29sb3IsXG4gICAgICBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5sZWZ0LFxuICAgICAgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogdGhpcy5yaWdodFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSB0cmVlLlxuICAgKi9cbiAgY291bnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0LmNvdW50KCkgKyAxICsgdGhpcy5yaWdodC5jb3VudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXG4gICAqL1xuICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgKiBmb3IgZWFjaCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFLLCAhVik6Kn0gYWN0aW9uIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxuICAgKiAgIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgKiBAcmV0dXJuIHsqfSBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XG4gICAqICAgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uXG4gICAqL1xuICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbjogKGs6IEssIHY6IFYpID0+IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxlZnQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHx8XG4gICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XG4gICAgICB0aGlzLnJpZ2h0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgKiBmb3IgZWFjaCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFPYmplY3QsICFPYmplY3QpfSBhY3Rpb24gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXG4gICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgKiBAcmV0dXJuIHsqfSBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cbiAgICovXG4gIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uOiAoazogSywgdjogVikgPT4gdm9pZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJpZ2h0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB8fFxuICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxuICAgICAgdGhpcy5sZWZ0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU9iamVjdH0gVGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgbWluXygpOiBMTFJCTm9kZTxLLCBWPiB7XG4gICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKHRoaXMubGVmdCBhcyBMTFJCTm9kZTxLLCBWPikubWluXygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshS30gVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxuICAgKi9cbiAgbWluS2V5KCk6IEsge1xuICAgIHJldHVybiB0aGlzLm1pbl8oKS5rZXk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUt9IFRoZSBtYXhpbXVtIGtleSBpbiB0aGUgdHJlZS5cbiAgICovXG4gIG1heEtleSgpOiBLIHtcbiAgICBpZiAodGhpcy5yaWdodC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmlnaHQubWF4S2V5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7IU9iamVjdH0ga2V5IEtleSB0byBpbnNlcnQuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gdmFsdWUgVmFsdWUgdG8gaW5zZXJ0LlxuICAgKiBAcGFyYW0ge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3IgQ29tcGFyYXRvci5cbiAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgd2l0aCB0aGUga2V5L3ZhbHVlIGFkZGVkLlxuICAgKi9cbiAgaW5zZXJ0KGtleTogSywgdmFsdWU6IFYsIGNvbXBhcmF0b3I6IENvbXBhcmF0b3I8Sz4pOiBMTFJCTm9kZTxLLCBWPiB7XG4gICAgbGV0IGNtcCwgbjtcbiAgICBuID0gdGhpcztcbiAgICBjbXAgPSBjb21wYXJhdG9yKGtleSwgbi5rZXkpO1xuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvciksIG51bGwpO1xuICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICBuID0gbi5jb3B5KG51bGwsIHZhbHVlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4uY29weShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbi5yaWdodC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcilcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuLmZpeFVwXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4geyFMTFJCTm9kZXxMTFJCRW1wdHlOb2RlfSBOZXcgdHJlZSwgd2l0aCB0aGUgbWluaW11bSBrZXkgcmVtb3ZlZC5cbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlTWluXygpOiBMTFJCTm9kZTxLLCBWPiB8IExMUkJFbXB0eU5vZGU8SywgVj4ge1xuICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gU29ydGVkTWFwLkVNUFRZX05PREUgYXMgTExSQkVtcHR5Tm9kZTxLLCBWPjtcbiAgICB9XG4gICAgbGV0IG46IExMUkJOb2RlPEssIFY+ID0gdGhpcztcbiAgICBpZiAoIW4ubGVmdC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xuICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgKG4ubGVmdCBhcyBMTFJCTm9kZTxLLCBWPikucmVtb3ZlTWluXygpLCBudWxsKTtcbiAgICByZXR1cm4gbi5maXhVcF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yIENvbXBhcmF0b3IuXG4gICAqIEByZXR1cm4geyFMTFJCTm9kZXxMTFJCRW1wdHlOb2RlfSBOZXcgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGl0ZW0gcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZShcbiAgICBrZXk6IEssXG4gICAgY29tcGFyYXRvcjogQ29tcGFyYXRvcjxLPlxuICApOiBMTFJCTm9kZTxLLCBWPiB8IExMUkJFbXB0eU5vZGU8SywgVj4ge1xuICAgIGxldCBuLCBzbWFsbGVzdDtcbiAgICBuID0gdGhpcztcbiAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcbiAgICAgIGlmICghbi5sZWZ0LmlzRW1wdHkoKSAmJiAhbi5sZWZ0LmlzUmVkXygpICYmICFuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xuICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdF8oKTtcbiAgICAgIH1cbiAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSkgbiA9IG4ucm90YXRlUmlnaHRfKCk7XG4gICAgICBpZiAoIW4ucmlnaHQuaXNFbXB0eSgpICYmICFuLnJpZ2h0LmlzUmVkXygpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcbiAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0XygpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuLmtleSkgPT09IDApIHtcbiAgICAgICAgaWYgKG4ucmlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFIGFzIExMUkJFbXB0eU5vZGU8SywgVj47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc21hbGxlc3QgPSAobi5yaWdodCBhcyBMTFJCTm9kZTxLLCBWPikubWluXygpO1xuICAgICAgICAgIG4gPSBuLmNvcHkoXG4gICAgICAgICAgICBzbWFsbGVzdC5rZXksXG4gICAgICAgICAgICBzbWFsbGVzdC52YWx1ZSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgKG4ucmlnaHQgYXMgTExSQk5vZGU8SywgVj4pLnJlbW92ZU1pbl8oKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSk7XG4gICAgfVxuICAgIHJldHVybiBuLmZpeFVwXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyBhIFJFRCBub2RlLlxuICAgKi9cbiAgaXNSZWRfKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4geyFMTFJCTm9kZX0gTmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cbiAgICovXG4gIHByaXZhdGUgZml4VXBfKCk6IExMUkJOb2RlPEssIFY+IHtcbiAgICBsZXQgbiA9IHRoaXMgYXMgYW55O1xuICAgIGlmIChuLnJpZ2h0LmlzUmVkXygpICYmICFuLmxlZnQuaXNSZWRfKCkpIG4gPSBuLnJvdGF0ZUxlZnRfKCk7XG4gICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLmxlZnQubGVmdC5pc1JlZF8oKSkgbiA9IG4ucm90YXRlUmlnaHRfKCk7XG4gICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLnJpZ2h0LmlzUmVkXygpKSBuID0gbi5jb2xvckZsaXBfKCk7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZExlZnQuXG4gICAqL1xuICBwcml2YXRlIG1vdmVSZWRMZWZ0XygpOiBMTFJCTm9kZTxLLCBWPiB7XG4gICAgbGV0IG4gPSB0aGlzLmNvbG9yRmxpcF8oKTtcbiAgICBpZiAobi5yaWdodC5sZWZ0LmlzUmVkXygpKSB7XG4gICAgICBuID0gbi5jb3B5KFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICAobi5yaWdodCBhcyBMTFJCTm9kZTxLLCBWPikucm90YXRlUmlnaHRfKClcbiAgICAgICk7XG4gICAgICBuID0gbi5yb3RhdGVMZWZ0XygpO1xuICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlLCBhZnRlciBtb3ZlUmVkUmlnaHQuXG4gICAqL1xuICBwcml2YXRlIG1vdmVSZWRSaWdodF8oKTogTExSQk5vZGU8SywgVj4ge1xuICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXBfKCk7XG4gICAgaWYgKG4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XG4gICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcbiAgICAgIG4gPSBuLmNvbG9yRmxpcF8oKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgYWZ0ZXIgcm90YXRlTGVmdC5cbiAgICovXG4gIHByaXZhdGUgcm90YXRlTGVmdF8oKTogTExSQk5vZGU8SywgVj4ge1xuICAgIGNvbnN0IG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcbiAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKSBhcyBMTFJCTm9kZTxLLCBWPjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlLCBhZnRlciByb3RhdGVSaWdodC5cbiAgICovXG4gIHByaXZhdGUgcm90YXRlUmlnaHRfKCk6IExMUkJOb2RlPEssIFY+IHtcbiAgICBjb25zdCBuciA9IHRoaXMuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5SRUQsIHRoaXMubGVmdC5yaWdodCwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG51bGwsIG5yKSBhcyBMTFJCTm9kZTxLLCBWPjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlLCBhZnRlciBjb2xvckZsaXAuXG4gICAqL1xuICBwcml2YXRlIGNvbG9yRmxpcF8oKTogTExSQk5vZGU8SywgVj4ge1xuICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCAhdGhpcy5sZWZ0LmNvbG9yLCBudWxsLCBudWxsKTtcbiAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQuY29weShudWxsLCBudWxsLCAhdGhpcy5yaWdodC5jb2xvciwgbnVsbCwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXMuY29weShudWxsLCBudWxsLCAhdGhpcy5jb2xvciwgbGVmdCwgcmlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB0ZXN0aW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFsbCBpcyB3ZWxsLlxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja01heERlcHRoXygpOiBib29sZWFuIHtcbiAgICBjb25zdCBibGFja0RlcHRoID0gdGhpcy5jaGVja18oKTtcbiAgICByZXR1cm4gTWF0aC5wb3coMi4wLCBibGFja0RlcHRoKSA8PSB0aGlzLmNvdW50KCkgKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gTm90IHN1cmUgd2hhdCB0aGlzIHJldHVybnMgZXhhY3RseS4gOi0pLlxuICAgKi9cbiAgY2hlY2tfKCk6IG51bWJlciB7XG4gICAgbGV0IGJsYWNrRGVwdGg7XG4gICAgaWYgKHRoaXMuaXNSZWRfKCkgJiYgdGhpcy5sZWZ0LmlzUmVkXygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdSZWQgbm9kZSBoYXMgcmVkIGNoaWxkKCcgKyB0aGlzLmtleSArICcsJyArIHRoaXMudmFsdWUgKyAnKSdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJpZ2h0LmlzUmVkXygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdSaWdodCBjaGlsZCBvZiAoJyArIHRoaXMua2V5ICsgJywnICsgdGhpcy52YWx1ZSArICcpIGlzIHJlZCdcbiAgICAgICk7XG4gICAgfVxuICAgIGJsYWNrRGVwdGggPSB0aGlzLmxlZnQuY2hlY2tfKCk7XG4gICAgaWYgKGJsYWNrRGVwdGggIT09IHRoaXMucmlnaHQuY2hlY2tfKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmxhY2sgZGVwdGhzIGRpZmZlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmxhY2tEZXB0aCArICh0aGlzLmlzUmVkXygpID8gMCA6IDEpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW1wdHkgbm9kZSAoYSBsZWFmIG5vZGUgaW4gdGhlIFJlZC1CbGFjayBUcmVlKS5cbiAqL1xuZXhwb3J0IGNsYXNzIExMUkJFbXB0eU5vZGU8SywgVj4ge1xuICBrZXk6IEs7XG4gIHZhbHVlOiBWO1xuICBsZWZ0OiBMTFJCTm9kZTxLLCBWPiB8IExMUkJFbXB0eU5vZGU8SywgVj47XG4gIHJpZ2h0OiBMTFJCTm9kZTxLLCBWPiB8IExMUkJFbXB0eU5vZGU8SywgVj47XG4gIGNvbG9yOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHshTExSQkVtcHR5Tm9kZX0gVGhlIG5vZGUgY29weS5cbiAgICovXG4gIGNvcHkoXG4gICAga2V5OiBLIHwgbnVsbCxcbiAgICB2YWx1ZTogViB8IG51bGwsXG4gICAgY29sb3I6IGJvb2xlYW4gfCBudWxsLFxuICAgIGxlZnQ6IExMUkJOb2RlPEssIFY+IHwgTExSQkVtcHR5Tm9kZTxLLCBWPiB8IG51bGwsXG4gICAgcmlnaHQ6IExMUkJOb2RlPEssIFY+IHwgTExSQkVtcHR5Tm9kZTxLLCBWPiB8IG51bGxcbiAgKTogTExSQkVtcHR5Tm9kZTxLLCBWPiB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IUt9IGtleSBLZXkgdG8gYmUgYWRkZWQuXG4gICAqIEBwYXJhbSB7IVZ9IHZhbHVlIFZhbHVlIHRvIGJlIGFkZGVkLlxuICAgKiBAcGFyYW0ge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3IgQ29tcGFyYXRvci5cbiAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgd2l0aCBpdGVtIGFkZGVkLlxuICAgKi9cbiAgaW5zZXJ0KGtleTogSywgdmFsdWU6IFYsIGNvbXBhcmF0b3I6IENvbXBhcmF0b3I8Sz4pOiBMTFJCTm9kZTxLLCBWPiB7XG4gICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIHZhbHVlLCBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxuICAgKlxuICAgKiBAcGFyYW0geyFLfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7Q29tcGFyYXRvcn0gY29tcGFyYXRvciBDb21wYXJhdG9yLlxuICAgKiBAcmV0dXJuIHshTExSQkVtcHR5Tm9kZX0gTmV3IHRyZWUsIHdpdGggaXRlbSByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGtleTogSywgY29tcGFyYXRvcjogQ29tcGFyYXRvcjxLPik6IExMUkJFbXB0eU5vZGU8SywgVj4ge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cbiAgICovXG4gIGNvdW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICogZm9yIGVhY2ggbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbighSywgIVYpOip9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcbiAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxuICAgKi9cbiAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb246IChrOiBLLCB2OiBWKSA9PiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgKiBmb3IgZWFjaCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFLLCAhVil9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcbiAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxuICAgKi9cbiAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb246IChrOiBLLCB2OiBWKSA9PiB2b2lkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bGx9XG4gICAqL1xuICBtaW5LZXkoKTogbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVsbH1cbiAgICovXG4gIG1heEtleSgpOiBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5vdCBzdXJlIHdoYXQgdGhpcyByZXR1cm5zIGV4YWN0bHkuIDotKS5cbiAgICovXG4gIGNoZWNrXygpOiBudW1iZXIge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cbiAgICovXG4gIGlzUmVkXygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbW11dGFibGUgc29ydGVkIG1hcCBpbXBsZW1lbnRhdGlvbiwgYmFzZWQgb24gYSBMZWZ0LWxlYW5pbmcgUmVkLUJsYWNrXG4gKiB0cmVlLlxuICovXG5leHBvcnQgY2xhc3MgU29ydGVkTWFwPEssIFY+IHtcbiAgLyoqXG4gICAqIEFsd2F5cyB1c2UgdGhlIHNhbWUgZW1wdHkgbm9kZSwgdG8gcmVkdWNlIG1lbW9yeS5cbiAgICogQGNvbnN0XG4gICAqL1xuICBzdGF0aWMgRU1QVFlfTk9ERSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBLLCBWXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oSywgSyk6bnVtYmVyfSBjb21wYXJhdG9yXyBLZXkgY29tcGFyYXRvci5cbiAgICogQHBhcmFtIHtMTFJCTm9kZT19IHJvb3RfIChPcHRpb25hbCkgUm9vdCBub2RlIGZvciB0aGUgbWFwLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb21wYXJhdG9yXzogQ29tcGFyYXRvcjxLPixcbiAgICBwcml2YXRlIHJvb3RfOlxuICAgICAgfCBMTFJCTm9kZTxLLCBWPlxuICAgICAgfCBMTFJCRW1wdHlOb2RlPEssIFY+ID0gU29ydGVkTWFwLkVNUFRZX05PREUgYXMgTExSQkVtcHR5Tm9kZTxLLCBWPlxuICApIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQgb3IgcmVwbGFjZWQuXG4gICAqIChUT0RPOiBXZSBzaG91bGQgcGVyaGFwcyByZW5hbWUgdGhpcyBtZXRob2QgdG8gJ3B1dCcpXG4gICAqXG4gICAqIEBwYXJhbSB7IUt9IGtleSBLZXkgdG8gYmUgYWRkZWQuXG4gICAqIEBwYXJhbSB7IVZ9IHZhbHVlIFZhbHVlIHRvIGJlIGFkZGVkLlxuICAgKiBAcmV0dXJuIHshU29ydGVkTWFwLjxLLCBWPn0gTmV3IG1hcCwgd2l0aCBpdGVtIGFkZGVkLlxuICAgKi9cbiAgaW5zZXJ0KGtleTogSywgdmFsdWU6IFYpOiBTb3J0ZWRNYXA8SywgVj4ge1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKFxuICAgICAgdGhpcy5jb21wYXJhdG9yXyxcbiAgICAgIHRoaXMucm9vdF9cbiAgICAgICAgLmluc2VydChrZXksIHZhbHVlLCB0aGlzLmNvbXBhcmF0b3JfKVxuICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHshS30ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHshU29ydGVkTWFwLjxLLCBWPn0gTmV3IG1hcCwgd2l0aCBpdGVtIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoa2V5OiBLKTogU29ydGVkTWFwPEssIFY+IHtcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChcbiAgICAgIHRoaXMuY29tcGFyYXRvcl8sXG4gICAgICB0aGlzLnJvb3RfXG4gICAgICAgIC5yZW1vdmUoa2V5LCB0aGlzLmNvbXBhcmF0b3JfKVxuICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBub2RlIHdpdGggdGhlIGdpdmVuIGtleSwgb3IgbnVsbC5cbiAgICpcbiAgICogQHBhcmFtIHshS30ga2V5IFRoZSBrZXkgdG8gbG9vayB1cC5cbiAgICogQHJldHVybiB7P1Z9IFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwgaWYgdGhlXG4gICAqIGtleSBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZ2V0KGtleTogSyk6IFYgfCBudWxsIHtcbiAgICBsZXQgY21wO1xuICAgIGxldCBub2RlID0gdGhpcy5yb290XztcbiAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICBjbXAgPSB0aGlzLmNvbXBhcmF0b3JfKGtleSwgbm9kZS5rZXkpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGl0ZW0gKmJlZm9yZSogdGhlIHNwZWNpZmllZCBrZXksIG9yIG51bGwgaWYga2V5IGlzIHRoZSBmaXJzdCBpdGVtLlxuICAgKiBAcGFyYW0ge0t9IGtleSBUaGUga2V5IHRvIGZpbmQgdGhlIHByZWRlY2Vzc29yIG9mXG4gICAqIEByZXR1cm4gez9LfSBUaGUgcHJlZGVjZXNzb3Iga2V5LlxuICAgKi9cbiAgZ2V0UHJlZGVjZXNzb3JLZXkoa2V5OiBLKTogSyB8IG51bGwge1xuICAgIGxldCBjbXAsXG4gICAgICBub2RlID0gdGhpcy5yb290XyxcbiAgICAgIHJpZ2h0UGFyZW50ID0gbnVsbDtcbiAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICBjbXAgPSB0aGlzLmNvbXBhcmF0b3JfKGtleSwgbm9kZS5rZXkpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICBpZiAoIW5vZGUubGVmdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgIHdoaWxlICghbm9kZS5yaWdodC5pc0VtcHR5KCkpIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgIHJldHVybiBub2RlLmtleTtcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodFBhcmVudCkge1xuICAgICAgICAgIHJldHVybiByaWdodFBhcmVudC5rZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGZpcnN0IGl0ZW0uXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgIHJpZ2h0UGFyZW50ID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0F0dGVtcHRlZCB0byBmaW5kIHByZWRlY2Vzc29yIGtleSBmb3IgYSBub25leGlzdGVudCBrZXkuICBXaGF0IGdpdmVzPydcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1hcCBpcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucm9vdF8uaXNFbXB0eSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgbWFwLlxuICAgKi9cbiAgY291bnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yb290Xy5jb3VudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gez9LfSBUaGUgbWluaW11bSBrZXkgaW4gdGhlIG1hcC5cbiAgICovXG4gIG1pbktleSgpOiBLIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMucm9vdF8ubWluS2V5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7P0t9IFRoZSBtYXhpbXVtIGtleSBpbiB0aGUgbWFwLlxuICAgKi9cbiAgbWF4S2V5KCk6IEsgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5yb290Xy5tYXhLZXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIG1hcCBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFLLCAhVik6Kn0gYWN0aW9uIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgKiBAcmV0dXJuIHsqfSBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XG4gICAqICAgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uXG4gICAqL1xuICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbjogKGs6IEssIHY6IFYpID0+IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJvb3RfLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIG1hcCBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIU9iamVjdCwgIU9iamVjdCl9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuICBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICogQHJldHVybiB7Kn0gVHJ1ZSBpZiB0aGUgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxuICAgKi9cbiAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb246IChrOiBLLCB2OiBWKSA9PiB2b2lkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucm9vdF8ucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgU29ydGVkTWFwLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0geyhmdW5jdGlvbihLLCBWKTpUKT19IHJlc3VsdEdlbmVyYXRvclxuICAgKiBAcmV0dXJuIHtTb3J0ZWRNYXBJdGVyYXRvci48SywgViwgVD59IFRoZSBpdGVyYXRvci5cbiAgICovXG4gIGdldEl0ZXJhdG9yPFQ+KFxuICAgIHJlc3VsdEdlbmVyYXRvcj86IChrOiBLLCB2OiBWKSA9PiBUXG4gICk6IFNvcnRlZE1hcEl0ZXJhdG9yPEssIFYsIFQ+IHtcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKFxuICAgICAgdGhpcy5yb290XyxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmNvbXBhcmF0b3JfLFxuICAgICAgZmFsc2UsXG4gICAgICByZXN1bHRHZW5lcmF0b3JcbiAgICApO1xuICB9XG5cbiAgZ2V0SXRlcmF0b3JGcm9tPFQ+KFxuICAgIGtleTogSyxcbiAgICByZXN1bHRHZW5lcmF0b3I/OiAoazogSywgdjogVikgPT4gVFxuICApOiBTb3J0ZWRNYXBJdGVyYXRvcjxLLCBWLCBUPiB7XG4gICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcihcbiAgICAgIHRoaXMucm9vdF8sXG4gICAgICBrZXksXG4gICAgICB0aGlzLmNvbXBhcmF0b3JfLFxuICAgICAgZmFsc2UsXG4gICAgICByZXN1bHRHZW5lcmF0b3JcbiAgICApO1xuICB9XG5cbiAgZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbTxUPihcbiAgICBrZXk6IEssXG4gICAgcmVzdWx0R2VuZXJhdG9yPzogKGs6IEssIHY6IFYpID0+IFRcbiAgKTogU29ydGVkTWFwSXRlcmF0b3I8SywgViwgVD4ge1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IoXG4gICAgICB0aGlzLnJvb3RfLFxuICAgICAga2V5LFxuICAgICAgdGhpcy5jb21wYXJhdG9yXyxcbiAgICAgIHRydWUsXG4gICAgICByZXN1bHRHZW5lcmF0b3JcbiAgICApO1xuICB9XG5cbiAgZ2V0UmV2ZXJzZUl0ZXJhdG9yPFQ+KFxuICAgIHJlc3VsdEdlbmVyYXRvcj86IChrOiBLLCB2OiBWKSA9PiBUXG4gICk6IFNvcnRlZE1hcEl0ZXJhdG9yPEssIFYsIFQ+IHtcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKFxuICAgICAgdGhpcy5yb290XyxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmNvbXBhcmF0b3JfLFxuICAgICAgdHJ1ZSxcbiAgICAgIHJlc3VsdEdlbmVyYXRvclxuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBMTFJCTm9kZSB9IGZyb20gJy4uL3V0aWwvU29ydGVkTWFwJztcbmltcG9ydCB7IFNvcnRlZE1hcCB9IGZyb20gJy4uL3V0aWwvU29ydGVkTWFwJztcbmltcG9ydCB7IE5hbWVkTm9kZSB9IGZyb20gJy4vTm9kZSc7XG5cbmNvbnN0IExPR18yID0gTWF0aC5sb2coMik7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEJhc2UxMk51bSB7XG4gIGNvdW50OiBudW1iZXI7XG4gIHByaXZhdGUgY3VycmVudF86IG51bWJlcjtcbiAgcHJpdmF0ZSBiaXRzXzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGg6IG51bWJlcikge1xuICAgIGNvbnN0IGxvZ0Jhc2UyID0gKG51bTogbnVtYmVyKSA9PlxuICAgICAgcGFyc2VJbnQoKE1hdGgubG9nKG51bSkgLyBMT0dfMikgYXMgYW55LCAxMCk7XG4gICAgY29uc3QgYml0TWFzayA9IChiaXRzOiBudW1iZXIpID0+IHBhcnNlSW50KEFycmF5KGJpdHMgKyAxKS5qb2luKCcxJyksIDIpO1xuICAgIHRoaXMuY291bnQgPSBsb2dCYXNlMihsZW5ndGggKyAxKTtcbiAgICB0aGlzLmN1cnJlbnRfID0gdGhpcy5jb3VudCAtIDE7XG4gICAgY29uc3QgbWFzayA9IGJpdE1hc2sodGhpcy5jb3VudCk7XG4gICAgdGhpcy5iaXRzXyA9IChsZW5ndGggKyAxKSAmIG1hc2s7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG5leHRCaXRJc09uZSgpOiBib29sZWFuIHtcbiAgICAvL25vaW5zcGVjdGlvbiBKU0JpdHdpc2VPcGVyYXRvclVzYWdlXG4gICAgY29uc3QgcmVzdWx0ID0gISh0aGlzLmJpdHNfICYgKDB4MSA8PCB0aGlzLmN1cnJlbnRfKSk7XG4gICAgdGhpcy5jdXJyZW50Xy0tO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgY2hpbGQgbm9kZXMgYW5kIGNvbnN0cnVjdHMgYSBTb3J0ZWRTZXQgdXNpbmcgdGhlIGdpdmVuIGNvbXBhcmlzb25cbiAqIGZ1bmN0aW9uXG4gKlxuICogVXNlcyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbiB0aGUgcGFwZXIgbGlua2VkIGhlcmU6XG4gKiBodHRwOi8vY2l0ZXNlZXJ4LmlzdC5wc3UuZWR1L3ZpZXdkb2Mvc3VtbWFyeT9kb2k9MTAuMS4xLjQ2LjE0NThcbiAqXG4gKiBAdGVtcGxhdGUgSywgVlxuICogQHBhcmFtIHtBcnJheS48IU5hbWVkTm9kZT59IGNoaWxkTGlzdCBVbnNvcnRlZCBsaXN0IG9mIGNoaWxkcmVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCFOYW1lZE5vZGUsICFOYW1lZE5vZGUpOm51bWJlcn0gY21wIFRoZSBjb21wYXJpc29uIG1ldGhvZCB0byBiZSB1c2VkXG4gKiBAcGFyYW0geyhmdW5jdGlvbihOYW1lZE5vZGUpOkspPX0ga2V5Rm4gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZXh0cmFjdCBLIGZyb20gYSBub2RlIHdyYXBwZXIsIGlmIEsnc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgaXMgbm90IE5hbWVkTm9kZVxuICogQHBhcmFtIHsoZnVuY3Rpb24oSywgSyk6bnVtYmVyKT19IG1hcFNvcnRGbiBBbiBvcHRpb25hbCBvdmVycmlkZSBmb3IgY29tcGFyYXRvciB1c2VkIGJ5IHRoZSBnZW5lcmF0ZWQgc29ydGVkIG1hcFxuICogQHJldHVybiB7U29ydGVkTWFwLjxLLCBWPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJ1aWxkQ2hpbGRTZXQgPSBmdW5jdGlvbjxLLCBWPihcbiAgY2hpbGRMaXN0OiBOYW1lZE5vZGVbXSxcbiAgY21wOiAoYTogTmFtZWROb2RlLCBiOiBOYW1lZE5vZGUpID0+IG51bWJlcixcbiAga2V5Rm4/OiAoYTogTmFtZWROb2RlKSA9PiBLLFxuICBtYXBTb3J0Rm4/OiAoYTogSywgYjogSykgPT4gbnVtYmVyXG4pOiBTb3J0ZWRNYXA8SywgVj4ge1xuICBjaGlsZExpc3Quc29ydChjbXApO1xuXG4gIGNvbnN0IGJ1aWxkQmFsYW5jZWRUcmVlID0gZnVuY3Rpb24oXG4gICAgbG93OiBudW1iZXIsXG4gICAgaGlnaDogbnVtYmVyXG4gICk6IExMUkJOb2RlPEssIFY+IHwgbnVsbCB7XG4gICAgY29uc3QgbGVuZ3RoID0gaGlnaCAtIGxvdztcbiAgICBsZXQgbmFtZWROb2RlOiBOYW1lZE5vZGU7XG4gICAgbGV0IGtleTogSztcbiAgICBpZiAobGVuZ3RoID09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoID09IDEpIHtcbiAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFtsb3ddO1xuICAgICAga2V5ID0ga2V5Rm4gPyBrZXlGbihuYW1lZE5vZGUpIDogKChuYW1lZE5vZGUgYXMgYW55KSBhcyBLKTtcbiAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoXG4gICAgICAgIGtleSxcbiAgICAgICAgKG5hbWVkTm9kZS5ub2RlIGFzIGFueSkgYXMgVixcbiAgICAgICAgTExSQk5vZGUuQkxBQ0ssXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IHBhcnNlSW50KChsZW5ndGggLyAyKSBhcyBhbnksIDEwKSArIGxvdztcbiAgICAgIGNvbnN0IGxlZnQgPSBidWlsZEJhbGFuY2VkVHJlZShsb3csIG1pZGRsZSk7XG4gICAgICBjb25zdCByaWdodCA9IGJ1aWxkQmFsYW5jZWRUcmVlKG1pZGRsZSArIDEsIGhpZ2gpO1xuICAgICAgbmFtZWROb2RlID0gY2hpbGRMaXN0W21pZGRsZV07XG4gICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiAoKG5hbWVkTm9kZSBhcyBhbnkpIGFzIEspO1xuICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShcbiAgICAgICAga2V5LFxuICAgICAgICAobmFtZWROb2RlLm5vZGUgYXMgYW55KSBhcyBWLFxuICAgICAgICBMTFJCTm9kZS5CTEFDSyxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGJ1aWxkRnJvbTEyQXJyYXkgPSBmdW5jdGlvbihiYXNlMTI6IEJhc2UxMk51bSk6IExMUkJOb2RlPEssIFY+IHtcbiAgICBsZXQgbm9kZTogTExSQk5vZGU8SywgVj4gPSBudWxsO1xuICAgIGxldCByb290ID0gbnVsbDtcbiAgICBsZXQgaW5kZXggPSBjaGlsZExpc3QubGVuZ3RoO1xuXG4gICAgY29uc3QgYnVpbGRQZW5uYW50ID0gZnVuY3Rpb24oY2h1bmtTaXplOiBudW1iZXIsIGNvbG9yOiBib29sZWFuKSB7XG4gICAgICBjb25zdCBsb3cgPSBpbmRleCAtIGNodW5rU2l6ZTtcbiAgICAgIGNvbnN0IGhpZ2ggPSBpbmRleDtcbiAgICAgIGluZGV4IC09IGNodW5rU2l6ZTtcbiAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IGJ1aWxkQmFsYW5jZWRUcmVlKGxvdyArIDEsIGhpZ2gpO1xuICAgICAgY29uc3QgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XG4gICAgICBjb25zdCBrZXk6IEsgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiAoKG5hbWVkTm9kZSBhcyBhbnkpIGFzIEspO1xuICAgICAgYXR0YWNoUGVubmFudChcbiAgICAgICAgbmV3IExMUkJOb2RlKGtleSwgKG5hbWVkTm9kZS5ub2RlIGFzIGFueSkgYXMgViwgY29sb3IsIG51bGwsIGNoaWxkVHJlZSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGNvbnN0IGF0dGFjaFBlbm5hbnQgPSBmdW5jdGlvbihwZW5uYW50OiBMTFJCTm9kZTxLLCBWPikge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5sZWZ0ID0gcGVubmFudDtcbiAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290ID0gcGVubmFudDtcbiAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTEyLmNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGlzT25lID0gYmFzZTEyLm5leHRCaXRJc09uZSgpO1xuICAgICAgLy8gVGhlIG51bWJlciBvZiBub2RlcyB0YWtlbiBpbiBlYWNoIHNsaWNlIGlzIDJeKGFyci5sZW5ndGggLSAoaSArIDEpKVxuICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5wb3coMiwgYmFzZTEyLmNvdW50IC0gKGkgKyAxKSk7XG4gICAgICBpZiAoaXNPbmUpIHtcbiAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuQkxBQ0spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3VycmVudCA9PSAyXG4gICAgICAgIGJ1aWxkUGVubmFudChjaHVua1NpemUsIExMUkJOb2RlLkJMQUNLKTtcbiAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuUkVEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH07XG5cbiAgY29uc3QgYmFzZTEyID0gbmV3IEJhc2UxMk51bShjaGlsZExpc3QubGVuZ3RoKTtcbiAgY29uc3Qgcm9vdCA9IGJ1aWxkRnJvbTEyQXJyYXkoYmFzZTEyKTtcblxuICByZXR1cm4gbmV3IFNvcnRlZE1hcDxLLCBWPihtYXBTb3J0Rm4gfHwgKGNtcCBhcyBhbnkpLCByb290KTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgYnVpbGRDaGlsZFNldCB9IGZyb20gJy4vY2hpbGRTZXQnO1xuaW1wb3J0IHsgY29udGFpbnMsIGNsb25lLCBtYXAsIHNhZmVHZXQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBOYW1lZE5vZGUsIE5vZGUgfSBmcm9tICcuL05vZGUnO1xuaW1wb3J0IHsgUFJJT1JJVFlfSU5ERVggfSBmcm9tICcuL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG5pbXBvcnQgeyBLRVlfSU5ERVggfSBmcm9tICcuL2luZGV4ZXMvS2V5SW5kZXgnO1xuaW1wb3J0IHsgU29ydGVkTWFwIH0gZnJvbSAnLi4vdXRpbC9Tb3J0ZWRNYXAnO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuL2luZGV4ZXMvSW5kZXgnO1xuXG5sZXQgX2RlZmF1bHRJbmRleE1hcDogSW5kZXhNYXA7XG5cbmNvbnN0IGZhbGxiYWNrT2JqZWN0ID0ge307XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEZhbGxiYWNrVHlwZXxTb3J0ZWRNYXAuPE5hbWVkTm9kZSwgTm9kZT4+fSBpbmRleGVzXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBJbmRleD59IGluZGV4U2V0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIEluZGV4TWFwIHtcbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IEluZGV4TWFwIGZvciBub2RlcyB3aXRob3V0IGEgcHJpb3JpdHlcbiAgICogQHR5cGUgeyFJbmRleE1hcH1cbiAgICogQGNvbnN0XG4gICAqL1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKTogSW5kZXhNYXAge1xuICAgIGFzc2VydChcbiAgICAgIGZhbGxiYWNrT2JqZWN0ICYmIFBSSU9SSVRZX0lOREVYLFxuICAgICAgJ0NoaWxkcmVuTm9kZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJ1xuICAgICk7XG4gICAgX2RlZmF1bHRJbmRleE1hcCA9XG4gICAgICBfZGVmYXVsdEluZGV4TWFwIHx8XG4gICAgICBuZXcgSW5kZXhNYXAoXG4gICAgICAgIHsgJy5wcmlvcml0eSc6IGZhbGxiYWNrT2JqZWN0IH0sXG4gICAgICAgIHsgJy5wcmlvcml0eSc6IFBSSU9SSVRZX0lOREVYIH1cbiAgICAgICk7XG4gICAgcmV0dXJuIF9kZWZhdWx0SW5kZXhNYXA7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGluZGV4ZXNfOiB7XG4gICAgICBbazogc3RyaW5nXTogU29ydGVkTWFwPE5hbWVkTm9kZSwgTm9kZT4gfCAvKkZhbGxiYWNrVHlwZSovIG9iamVjdDtcbiAgICB9LFxuICAgIHByaXZhdGUgaW5kZXhTZXRfOiB7IFtrOiBzdHJpbmddOiBJbmRleCB9XG4gICkge31cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHshc3RyaW5nfSBpbmRleEtleVxuICAgKiBAcmV0dXJuIHs/U29ydGVkTWFwLjxOYW1lZE5vZGUsIE5vZGU+fVxuICAgKi9cbiAgZ2V0KGluZGV4S2V5OiBzdHJpbmcpOiBTb3J0ZWRNYXA8TmFtZWROb2RlLCBOb2RlPiB8IG51bGwge1xuICAgIGNvbnN0IHNvcnRlZE1hcCA9IHNhZmVHZXQodGhpcy5pbmRleGVzXywgaW5kZXhLZXkpO1xuICAgIGlmICghc29ydGVkTWFwKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGluZGV4IGRlZmluZWQgZm9yICcgKyBpbmRleEtleSk7XG5cbiAgICBpZiAoc29ydGVkTWFwID09PSBmYWxsYmFja09iamVjdCkge1xuICAgICAgLy8gVGhlIGluZGV4IGV4aXN0cywgYnV0IGl0IGZhbGxzIGJhY2sgdG8ganVzdCBuYW1lIGNvbXBhcmlzb24uIFJldHVybiBudWxsIHNvIHRoYXQgdGhlIGNhbGxpbmcgY29kZSB1c2VzIHRoZVxuICAgICAgLy8gcmVndWxhciBjaGlsZCBtYXBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc29ydGVkTWFwIGFzIFNvcnRlZE1hcDxOYW1lZE5vZGUsIE5vZGU+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNJbmRleChpbmRleERlZmluaXRpb246IEluZGV4KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGNvbnRhaW5zKHRoaXMuaW5kZXhTZXRfLCBpbmRleERlZmluaXRpb24udG9TdHJpbmcoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgKiBAcGFyYW0geyFTb3J0ZWRNYXAuPHN0cmluZywgIU5vZGU+fSBleGlzdGluZ0NoaWxkcmVuXG4gICAqIEByZXR1cm4geyFJbmRleE1hcH1cbiAgICovXG4gIGFkZEluZGV4KFxuICAgIGluZGV4RGVmaW5pdGlvbjogSW5kZXgsXG4gICAgZXhpc3RpbmdDaGlsZHJlbjogU29ydGVkTWFwPHN0cmluZywgTm9kZT5cbiAgKTogSW5kZXhNYXAge1xuICAgIGFzc2VydChcbiAgICAgIGluZGV4RGVmaW5pdGlvbiAhPT0gS0VZX0lOREVYLFxuICAgICAgXCJLZXlJbmRleCBhbHdheXMgZXhpc3RzIGFuZCBpc24ndCBtZWFudCB0byBiZSBhZGRlZCB0byB0aGUgSW5kZXhNYXAuXCJcbiAgICApO1xuICAgIGNvbnN0IGNoaWxkTGlzdCA9IFtdO1xuICAgIGxldCBzYXdJbmRleGVkVmFsdWUgPSBmYWxzZTtcbiAgICBjb25zdCBpdGVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXRJdGVyYXRvcihOYW1lZE5vZGUuV3JhcCk7XG4gICAgbGV0IG5leHQgPSBpdGVyLmdldE5leHQoKTtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgc2F3SW5kZXhlZFZhbHVlID1cbiAgICAgICAgc2F3SW5kZXhlZFZhbHVlIHx8IGluZGV4RGVmaW5pdGlvbi5pc0RlZmluZWRPbihuZXh0Lm5vZGUpO1xuICAgICAgY2hpbGRMaXN0LnB1c2gobmV4dCk7XG4gICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgfVxuICAgIGxldCBuZXdJbmRleDtcbiAgICBpZiAoc2F3SW5kZXhlZFZhbHVlKSB7XG4gICAgICBuZXdJbmRleCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleERlZmluaXRpb24uZ2V0Q29tcGFyZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3SW5kZXggPSBmYWxsYmFja09iamVjdDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXhOYW1lID0gaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbmV3SW5kZXhTZXQgPSBjbG9uZSh0aGlzLmluZGV4U2V0Xyk7XG4gICAgbmV3SW5kZXhTZXRbaW5kZXhOYW1lXSA9IGluZGV4RGVmaW5pdGlvbjtcbiAgICBjb25zdCBuZXdJbmRleGVzID0gY2xvbmUodGhpcy5pbmRleGVzXyk7XG4gICAgbmV3SW5kZXhlc1tpbmRleE5hbWVdID0gbmV3SW5kZXg7XG4gICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCBuZXdJbmRleFNldCk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIHRoYXQgdGhpcyBub2RlIGlzIHByb3Blcmx5IHRyYWNrZWQgaW4gYW55IGluZGV4ZXMgdGhhdCB3ZSdyZSBtYWludGFpbmluZ1xuICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IG5hbWVkTm9kZVxuICAgKiBAcGFyYW0geyFTb3J0ZWRNYXAuPHN0cmluZywgIU5vZGU+fSBleGlzdGluZ0NoaWxkcmVuXG4gICAqIEByZXR1cm4geyFJbmRleE1hcH1cbiAgICovXG4gIGFkZFRvSW5kZXhlcyhcbiAgICBuYW1lZE5vZGU6IE5hbWVkTm9kZSxcbiAgICBleGlzdGluZ0NoaWxkcmVuOiBTb3J0ZWRNYXA8c3RyaW5nLCBOb2RlPlxuICApOiBJbmRleE1hcCB7XG4gICAgY29uc3QgbmV3SW5kZXhlcyA9IG1hcChcbiAgICAgIHRoaXMuaW5kZXhlc18sXG4gICAgICAoaW5kZXhlZENoaWxkcmVuOiBTb3J0ZWRNYXA8TmFtZWROb2RlLCBOb2RlPiwgaW5kZXhOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzYWZlR2V0KHRoaXMuaW5kZXhTZXRfLCBpbmRleE5hbWUpO1xuICAgICAgICBhc3NlcnQoaW5kZXgsICdNaXNzaW5nIGluZGV4IGltcGxlbWVudGF0aW9uIGZvciAnICsgaW5kZXhOYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ZWRDaGlsZHJlbiA9PT0gZmFsbGJhY2tPYmplY3QpIHtcbiAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byBpbmRleCBldmVyeXRoaW5nXG4gICAgICAgICAgaWYgKGluZGV4LmlzRGVmaW5lZE9uKG5hbWVkTm9kZS5ub2RlKSkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBidWlsZCB0aGlzIGluZGV4XG4gICAgICAgICAgICBjb25zdCBjaGlsZExpc3QgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5hbWVkTm9kZS5XcmFwKTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgICAgICBpZiAobmV4dC5uYW1lICE9IG5hbWVkTm9kZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0LnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRMaXN0LnB1c2gobmFtZWROb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZENoaWxkU2V0KGNoaWxkTGlzdCwgaW5kZXguZ2V0Q29tcGFyZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gY2hhbmdlLCB0aGlzIHJlbWFpbnMgYSBmYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrT2JqZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ1NuYXAgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuYW1lZE5vZGUubmFtZSk7XG4gICAgICAgICAgbGV0IG5ld0NoaWxkcmVuID0gaW5kZXhlZENoaWxkcmVuO1xuICAgICAgICAgIGlmIChleGlzdGluZ1NuYXApIHtcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW4ucmVtb3ZlKFxuICAgICAgICAgICAgICBuZXcgTmFtZWROb2RlKG5hbWVkTm9kZS5uYW1lLCBleGlzdGluZ1NuYXApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3Q2hpbGRyZW4uaW5zZXJ0KG5hbWVkTm9kZSwgbmFtZWROb2RlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgSW5kZXhNYXAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgcmVtb3ZlZFxuICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IG5hbWVkTm9kZVxuICAgKiBAcGFyYW0geyFTb3J0ZWRNYXAuPHN0cmluZywgIU5vZGU+fSBleGlzdGluZ0NoaWxkcmVuXG4gICAqIEByZXR1cm4geyFJbmRleE1hcH1cbiAgICovXG4gIHJlbW92ZUZyb21JbmRleGVzKFxuICAgIG5hbWVkTm9kZTogTmFtZWROb2RlLFxuICAgIGV4aXN0aW5nQ2hpbGRyZW46IFNvcnRlZE1hcDxzdHJpbmcsIE5vZGU+XG4gICk6IEluZGV4TWFwIHtcbiAgICBjb25zdCBuZXdJbmRleGVzID0gbWFwKHRoaXMuaW5kZXhlc18sIGZ1bmN0aW9uKFxuICAgICAgaW5kZXhlZENoaWxkcmVuOiBTb3J0ZWRNYXA8TmFtZWROb2RlLCBOb2RlPlxuICAgICkge1xuICAgICAgaWYgKGluZGV4ZWRDaGlsZHJlbiA9PT0gZmFsbGJhY2tPYmplY3QpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmFsbGJhY2suIEp1c3QgcmV0dXJuIGl0LCBub3RoaW5nIHRvIGRvIGluIHRoaXMgY2FzZVxuICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xuICAgICAgICBpZiAoZXhpc3RpbmdTbmFwKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ZWRDaGlsZHJlbi5yZW1vdmUoXG4gICAgICAgICAgICBuZXcgTmFtZWROb2RlKG5hbWVkTm9kZS5uYW1lLCBleGlzdGluZ1NuYXApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyByZWNvcmQgb2YgdGhpcyBjaGlsZFxuICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IG5hbWVDb21wYXJlIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IE5hbWVkTm9kZSB9IGZyb20gJy4vTm9kZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBOQU1FX09OTFlfQ09NUEFSQVRPUihsZWZ0OiBOYW1lZE5vZGUsIHJpZ2h0OiBOYW1lZE5vZGUpIHtcbiAgcmV0dXJuIG5hbWVDb21wYXJlKGxlZnQubmFtZSwgcmlnaHQubmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBOQU1FX0NPTVBBUkFUT1IobGVmdDogc3RyaW5nLCByaWdodDogc3RyaW5nKSB7XG4gIHJldHVybiBuYW1lQ29tcGFyZShsZWZ0LCByaWdodCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgc2hhMSwgTUFYX05BTUUsIE1JTl9OQU1FIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IFNvcnRlZE1hcCwgU29ydGVkTWFwSXRlcmF0b3IgfSBmcm9tICcuLi91dGlsL1NvcnRlZE1hcCc7XG5pbXBvcnQgeyBOb2RlLCBOYW1lZE5vZGUgfSBmcm9tICcuL05vZGUnO1xuaW1wb3J0IHsgdmFsaWRhdGVQcmlvcml0eU5vZGUsIHByaW9yaXR5SGFzaFRleHQsIHNldE1heE5vZGUgfSBmcm9tICcuL3NuYXAnO1xuaW1wb3J0IHtcbiAgUFJJT1JJVFlfSU5ERVgsXG4gIHNldE1heE5vZGUgYXMgc2V0UHJpb3JpdHlNYXhOb2RlXG59IGZyb20gJy4vaW5kZXhlcy9Qcmlvcml0eUluZGV4JztcbmltcG9ydCB7IEtFWV9JTkRFWCwgS2V5SW5kZXggfSBmcm9tICcuL2luZGV4ZXMvS2V5SW5kZXgnO1xuaW1wb3J0IHsgSW5kZXhNYXAgfSBmcm9tICcuL0luZGV4TWFwJztcbmltcG9ydCB7IExlYWZOb2RlIH0gZnJvbSAnLi9MZWFmTm9kZSc7XG5pbXBvcnQgeyBOQU1FX0NPTVBBUkFUT1IgfSBmcm9tICcuL2NvbXBhcmF0b3JzJztcbmltcG9ydCB7IEluZGV4IH0gZnJvbSAnLi9pbmRleGVzL0luZGV4JztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi91dGlsL1BhdGgnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkcmVuTm9kZUNvbnN0cnVjdG9yIHtcbiAgbmV3IChcbiAgICBjaGlsZHJlbl86IFNvcnRlZE1hcDxzdHJpbmcsIE5vZGU+LFxuICAgIHByaW9yaXR5Tm9kZV86IE5vZGUgfCBudWxsLFxuICAgIGluZGV4TWFwXzogSW5kZXhNYXBcbiAgKTogQ2hpbGRyZW5Ob2RlO1xuICBFTVBUWV9OT0RFOiBDaGlsZHJlbk5vZGU7XG59XG5cbi8vIFRPRE86IEZvciBtZW1vcnkgc2F2aW5ncywgZG9uJ3Qgc3RvcmUgcHJpb3JpdHlOb2RlXyBpZiBpdCdzIGVtcHR5LlxuXG5sZXQgRU1QVFlfTk9ERTogQ2hpbGRyZW5Ob2RlO1xuXG4vKipcbiAqIENoaWxkcmVuTm9kZSBpcyBhIGNsYXNzIGZvciBzdG9yaW5nIGludGVybmFsIG5vZGVzIGluIGEgRGF0YVNuYXBzaG90XG4gKiAoaS5lLiBub2RlcyB3aXRoIGNoaWxkcmVuKS4gIEl0IGltcGxlbWVudHMgTm9kZSBhbmQgc3RvcmVzIHRoZVxuICogbGlzdCBvZiBjaGlsZHJlbiBpbiB0aGUgY2hpbGRyZW4gcHJvcGVydHksIHNvcnRlZCBieSBjaGlsZCBuYW1lLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge05vZGV9XG4gKi9cbmV4cG9ydCBjbGFzcyBDaGlsZHJlbk5vZGUgaW1wbGVtZW50cyBOb2RlIHtcbiAgcHJpdmF0ZSBsYXp5SGFzaF86IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIHN0YXRpYyBnZXQgRU1QVFlfTk9ERSgpOiBDaGlsZHJlbk5vZGUge1xuICAgIHJldHVybiAoXG4gICAgICBFTVBUWV9OT0RFIHx8XG4gICAgICAoRU1QVFlfTk9ERSA9IG5ldyBDaGlsZHJlbk5vZGUoXG4gICAgICAgIG5ldyBTb3J0ZWRNYXA8c3RyaW5nLCBOb2RlPihOQU1FX0NPTVBBUkFUT1IpLFxuICAgICAgICBudWxsLFxuICAgICAgICBJbmRleE1hcC5EZWZhdWx0XG4gICAgICApKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHshU29ydGVkTWFwLjxzdHJpbmcsICFOb2RlPn0gY2hpbGRyZW5fIExpc3Qgb2YgY2hpbGRyZW5cbiAgICogb2YgdGhpcyBub2RlLi5cbiAgICogQHBhcmFtIHs/Tm9kZX0gcHJpb3JpdHlOb2RlXyBUaGUgcHJpb3JpdHkgb2YgdGhpcyBub2RlIChhcyBhIHNuYXBzaG90IG5vZGUpLlxuICAgKiBAcGFyYW0geyFJbmRleE1hcH0gaW5kZXhNYXBfXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNoaWxkcmVuXzogU29ydGVkTWFwPHN0cmluZywgTm9kZT4sXG4gICAgcHJpdmF0ZSByZWFkb25seSBwcmlvcml0eU5vZGVfOiBOb2RlIHwgbnVsbCxcbiAgICBwcml2YXRlIGluZGV4TWFwXzogSW5kZXhNYXBcbiAgKSB7XG4gICAgLyoqXG4gICAgICogTm90ZTogVGhlIG9ubHkgcmVhc29uIHdlIGFsbG93IG51bGwgcHJpb3JpdHkgaXMgZm9yIEVNUFRZX05PREUsIHNpbmNlIHdlIGNhbid0IHVzZVxuICAgICAqIEVNUFRZX05PREUgYXMgdGhlIHByaW9yaXR5IG9mIEVNUFRZX05PREUuICBXZSBtaWdodCB3YW50IHRvIGNvbnNpZGVyIG1ha2luZyBFTVBUWV9OT0RFIGl0cyBvd25cbiAgICAgKiBjbGFzcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IENoaWxkcmVuTm9kZS5cbiAgICAgKi9cbiAgICBpZiAodGhpcy5wcmlvcml0eU5vZGVfKSB7XG4gICAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgIXRoaXMucHJpb3JpdHlOb2RlXyB8fCB0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpLFxuICAgICAgICAnQW4gZW1wdHkgbm9kZSBjYW5ub3QgaGF2ZSBhIHByaW9yaXR5J1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgaXNMZWFmTm9kZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgZ2V0UHJpb3JpdHkoKTogTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXyB8fCBFTVBUWV9OT0RFO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5Tm9kZTogTm9kZSk6IE5vZGUge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcbiAgICAgIC8vIERvbid0IGFsbG93IHByaW9yaXRpZXMgb24gZW1wdHkgbm9kZXNcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgbmV3UHJpb3JpdHlOb2RlLCB0aGlzLmluZGV4TWFwXyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZTogc3RyaW5nKTogTm9kZSB7XG4gICAgLy8gSGFjayB0byB0cmVhdCBwcmlvcml0eSBhcyBhIHJlZ3VsYXIgY2hpbGRcbiAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJpb3JpdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuXy5nZXQoY2hpbGROYW1lKTtcbiAgICAgIHJldHVybiBjaGlsZCA9PT0gbnVsbCA/IEVNUFRZX05PREUgOiBjaGlsZDtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgZ2V0Q2hpbGQocGF0aDogUGF0aCk6IE5vZGUge1xuICAgIGNvbnN0IGZyb250ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgIGlmIChmcm9udCA9PT0gbnVsbCkgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkuZ2V0Q2hpbGQocGF0aC5wb3BGcm9udCgpKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBoYXNDaGlsZChjaGlsZE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5nZXQoY2hpbGROYW1lKSAhPT0gbnVsbDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICB1cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWU6IHN0cmluZywgbmV3Q2hpbGROb2RlOiBOb2RlKTogTm9kZSB7XG4gICAgYXNzZXJ0KG5ld0NoaWxkTm9kZSwgJ1dlIHNob3VsZCBhbHdheXMgYmUgcGFzc2luZyBzbmFwc2hvdCBub2RlcycpO1xuICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuYW1lZE5vZGUgPSBuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgIGxldCBuZXdDaGlsZHJlbiwgbmV3SW5kZXhNYXAsIG5ld1ByaW9yaXR5O1xuICAgICAgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXy5yZW1vdmUoY2hpbGROYW1lKTtcbiAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5yZW1vdmVGcm9tSW5kZXhlcyhcbiAgICAgICAgICBuYW1lZE5vZGUsXG4gICAgICAgICAgdGhpcy5jaGlsZHJlbl9cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8uaW5zZXJ0KGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5hZGRUb0luZGV4ZXMobmFtZWROb2RlLCB0aGlzLmNoaWxkcmVuXyk7XG4gICAgICB9XG5cbiAgICAgIG5ld1ByaW9yaXR5ID0gbmV3Q2hpbGRyZW4uaXNFbXB0eSgpID8gRU1QVFlfTk9ERSA6IHRoaXMucHJpb3JpdHlOb2RlXztcbiAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKG5ld0NoaWxkcmVuLCBuZXdQcmlvcml0eSwgbmV3SW5kZXhNYXApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICB1cGRhdGVDaGlsZChwYXRoOiBQYXRoLCBuZXdDaGlsZE5vZGU6IE5vZGUpOiBOb2RlIHtcbiAgICBjb25zdCBmcm9udCA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGF0aC5nZXRGcm9udCgpICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoLmdldExlbmd0aCgpID09PSAxLFxuICAgICAgICAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IG5ld0ltbWVkaWF0ZUNoaWxkID0gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkudXBkYXRlQ2hpbGQoXG4gICAgICAgIHBhdGgucG9wRnJvbnQoKSxcbiAgICAgICAgbmV3Q2hpbGROb2RlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIG5ld0ltbWVkaWF0ZUNoaWxkKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIG51bUNoaWxkcmVuKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmNvdW50KCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIElOVEVHRVJfUkVHRVhQXyA9IC9eKDB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICB2YWwoZXhwb3J0Rm9ybWF0PzogYm9vbGVhbik6IG9iamVjdCB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IG9iajogeyBbazogc3RyaW5nXTogdW5rbm93biB9ID0ge307XG4gICAgbGV0IG51bUtleXMgPSAwLFxuICAgICAgbWF4S2V5ID0gMCxcbiAgICAgIGFsbEludGVnZXJLZXlzID0gdHJ1ZTtcbiAgICB0aGlzLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24oa2V5OiBzdHJpbmcsIGNoaWxkTm9kZTogTm9kZSkge1xuICAgICAgb2JqW2tleV0gPSBjaGlsZE5vZGUudmFsKGV4cG9ydEZvcm1hdCk7XG5cbiAgICAgIG51bUtleXMrKztcbiAgICAgIGlmIChhbGxJbnRlZ2VyS2V5cyAmJiBDaGlsZHJlbk5vZGUuSU5URUdFUl9SRUdFWFBfLnRlc3Qoa2V5KSkge1xuICAgICAgICBtYXhLZXkgPSBNYXRoLm1heChtYXhLZXksIE51bWJlcihrZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbEludGVnZXJLZXlzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWV4cG9ydEZvcm1hdCAmJiBhbGxJbnRlZ2VyS2V5cyAmJiBtYXhLZXkgPCAyICogbnVtS2V5cykge1xuICAgICAgLy8gY29udmVydCB0byBhcnJheS5cbiAgICAgIGNvbnN0IGFycmF5OiB1bmtub3duW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGtleSBpbiBvYmopIGFycmF5WyhrZXkgYXMgYW55KSBhcyBudW1iZXJdID0gb2JqW2tleV07XG5cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSkge1xuICAgICAgICBvYmpbJy5wcmlvcml0eSddID0gdGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgaGFzaCgpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmxhenlIYXNoXyA9PT0gbnVsbCkge1xuICAgICAgbGV0IHRvSGFzaCA9ICcnO1xuICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKVxuICAgICAgICB0b0hhc2ggKz1cbiAgICAgICAgICAncHJpb3JpdHk6JyArXG4gICAgICAgICAgcHJpb3JpdHlIYXNoVGV4dCh0aGlzLmdldFByaW9yaXR5KCkudmFsKCkgYXMgc3RyaW5nIHwgbnVtYmVyKSArXG4gICAgICAgICAgJzonO1xuXG4gICAgICB0aGlzLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24oa2V5LCBjaGlsZE5vZGUpIHtcbiAgICAgICAgY29uc3QgY2hpbGRIYXNoID0gY2hpbGROb2RlLmhhc2goKTtcbiAgICAgICAgaWYgKGNoaWxkSGFzaCAhPT0gJycpIHRvSGFzaCArPSAnOicgKyBrZXkgKyAnOicgKyBjaGlsZEhhc2g7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5sYXp5SGFzaF8gPSB0b0hhc2ggPT09ICcnID8gJycgOiBzaGExKHRvSGFzaCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBnZXRQcmVkZWNlc3NvckNoaWxkTmFtZShcbiAgICBjaGlsZE5hbWU6IHN0cmluZyxcbiAgICBjaGlsZE5vZGU6IE5vZGUsXG4gICAgaW5kZXg6IEluZGV4XG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4KTtcbiAgICBpZiAoaWR4KSB7XG4gICAgICBjb25zdCBwcmVkZWNlc3NvciA9IGlkeC5nZXRQcmVkZWNlc3NvcktleShcbiAgICAgICAgbmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIGNoaWxkTm9kZSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gcHJlZGVjZXNzb3IgPyBwcmVkZWNlc3Nvci5uYW1lIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmdldFByZWRlY2Vzc29yS2V5KGNoaWxkTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGdldEZpcnN0Q2hpbGROYW1lKGluZGV4RGVmaW5pdGlvbjogSW5kZXgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcbiAgICBpZiAoaWR4KSB7XG4gICAgICBjb25zdCBtaW5LZXkgPSBpZHgubWluS2V5KCk7XG4gICAgICByZXR1cm4gbWluS2V5ICYmIG1pbktleS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8ubWluS2V5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICogQHJldHVybiB7P05hbWVkTm9kZX1cbiAgICovXG4gIGdldEZpcnN0Q2hpbGQoaW5kZXhEZWZpbml0aW9uOiBJbmRleCk6IE5hbWVkTm9kZSB8IG51bGwge1xuICAgIGNvbnN0IG1pbktleSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcbiAgICBpZiAobWluS2V5KSB7XG4gICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShtaW5LZXksIHRoaXMuY2hpbGRyZW5fLmdldChtaW5LZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIGluZGV4LCByZXR1cm4gdGhlIGtleSBuYW1lIG9mIHRoZSBsYXJnZXN0IHZhbHVlIHdlIGhhdmUsIGFjY29yZGluZyB0byB0aGF0IGluZGV4XG4gICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uOiBJbmRleCk6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xuICAgIGlmIChpZHgpIHtcbiAgICAgIGNvbnN0IG1heEtleSA9IGlkeC5tYXhLZXkoKTtcbiAgICAgIHJldHVybiBtYXhLZXkgJiYgbWF4S2V5Lm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5tYXhLZXkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgKiBAcmV0dXJuIHs/TmFtZWROb2RlfVxuICAgKi9cbiAgZ2V0TGFzdENoaWxkKGluZGV4RGVmaW5pdGlvbjogSW5kZXgpOiBOYW1lZE5vZGUgfCBudWxsIHtcbiAgICBjb25zdCBtYXhLZXkgPSB0aGlzLmdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcbiAgICBpZiAobWF4S2V5KSB7XG4gICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShtYXhLZXksIHRoaXMuY2hpbGRyZW5fLmdldChtYXhLZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBmb3JFYWNoQ2hpbGQoXG4gICAgaW5kZXg6IEluZGV4LFxuICAgIGFjdGlvbjogKGtleTogc3RyaW5nLCBub2RlOiBOb2RlKSA9PiBib29sZWFuIHwgdm9pZFxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xuICAgIGlmIChpZHgpIHtcbiAgICAgIHJldHVybiBpZHguaW5vcmRlclRyYXZlcnNhbChmdW5jdGlvbih3cmFwcGVkTm9kZSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uKHdyYXBwZWROb2RlLm5hbWUsIHdyYXBwZWROb2RlLm5vZGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICogQHJldHVybiB7U29ydGVkTWFwSXRlcmF0b3J9XG4gICAqL1xuICBnZXRJdGVyYXRvcihcbiAgICBpbmRleERlZmluaXRpb246IEluZGV4XG4gICk6IFNvcnRlZE1hcEl0ZXJhdG9yPHN0cmluZyB8IE5hbWVkTm9kZSwgTm9kZSwgTmFtZWROb2RlPiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SXRlcmF0b3JGcm9tKGluZGV4RGVmaW5pdGlvbi5taW5Qb3N0KCksIGluZGV4RGVmaW5pdGlvbik7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHshTmFtZWROb2RlfSBzdGFydFBvc3RcbiAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgKiBAcmV0dXJuIHshU29ydGVkTWFwSXRlcmF0b3J9XG4gICAqL1xuICBnZXRJdGVyYXRvckZyb20oXG4gICAgc3RhcnRQb3N0OiBOYW1lZE5vZGUsXG4gICAgaW5kZXhEZWZpbml0aW9uOiBJbmRleFxuICApOiBTb3J0ZWRNYXBJdGVyYXRvcjxzdHJpbmcgfCBOYW1lZE5vZGUsIE5vZGUsIE5hbWVkTm9kZT4ge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xuICAgIGlmIChpZHgpIHtcbiAgICAgIHJldHVybiBpZHguZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwga2V5ID0+IGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0SXRlcmF0b3JGcm9tKFxuICAgICAgICBzdGFydFBvc3QubmFtZSxcbiAgICAgICAgTmFtZWROb2RlLldyYXBcbiAgICAgICk7XG4gICAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcbiAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgc3RhcnRQb3N0KSA8IDApIHtcbiAgICAgICAgaXRlcmF0b3IuZ2V0TmV4dCgpO1xuICAgICAgICBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAqIEByZXR1cm4geyFTb3J0ZWRNYXBJdGVyYXRvcn1cbiAgICovXG4gIGdldFJldmVyc2VJdGVyYXRvcihcbiAgICBpbmRleERlZmluaXRpb246IEluZGV4XG4gICk6IFNvcnRlZE1hcEl0ZXJhdG9yPHN0cmluZyB8IE5hbWVkTm9kZSwgTm9kZSwgTmFtZWROb2RlPiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShcbiAgICAgIGluZGV4RGVmaW5pdGlvbi5tYXhQb3N0KCksXG4gICAgICBpbmRleERlZmluaXRpb25cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5hbWVkTm9kZX0gZW5kUG9zdFxuICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAqIEByZXR1cm4geyFTb3J0ZWRNYXBJdGVyYXRvcn1cbiAgICovXG4gIGdldFJldmVyc2VJdGVyYXRvckZyb20oXG4gICAgZW5kUG9zdDogTmFtZWROb2RlLFxuICAgIGluZGV4RGVmaW5pdGlvbjogSW5kZXhcbiAgKTogU29ydGVkTWFwSXRlcmF0b3I8c3RyaW5nIHwgTmFtZWROb2RlLCBOb2RlLCBOYW1lZE5vZGU+IHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcbiAgICBpZiAoaWR4KSB7XG4gICAgICByZXR1cm4gaWR4LmdldFJldmVyc2VJdGVyYXRvckZyb20oZW5kUG9zdCwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmNoaWxkcmVuXy5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKFxuICAgICAgICBlbmRQb3N0Lm5hbWUsXG4gICAgICAgIE5hbWVkTm9kZS5XcmFwXG4gICAgICApO1xuICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XG4gICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIGVuZFBvc3QpID4gMCkge1xuICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XG4gICAgICAgIG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjb21wYXJlVG8ob3RoZXI6IENoaWxkcmVuTm9kZSk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAob3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpIHx8IG90aGVyLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChvdGhlciA9PT0gTUFYX05PREUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTXVzdCBiZSBhbm90aGVyIG5vZGUgd2l0aCBjaGlsZHJlbi5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgd2l0aEluZGV4KGluZGV4RGVmaW5pdGlvbjogSW5kZXgpOiBOb2RlIHtcbiAgICBpZiAoXG4gICAgICBpbmRleERlZmluaXRpb24gPT09IEtFWV9JTkRFWCB8fFxuICAgICAgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXhEZWZpbml0aW9uKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkSW5kZXgoXG4gICAgICAgIGluZGV4RGVmaW5pdGlvbixcbiAgICAgICAgdGhpcy5jaGlsZHJlbl9cbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgdGhpcy5wcmlvcml0eU5vZGVfLCBuZXdJbmRleE1hcCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBpc0luZGV4ZWQoaW5kZXg6IEluZGV4KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGluZGV4ID09PSBLRVlfSU5ERVggfHwgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBlcXVhbHMob3RoZXI6IE5vZGUpOiBib29sZWFuIHtcbiAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG90aGVyQ2hpbGRyZW5Ob2RlID0gb3RoZXIgYXMgQ2hpbGRyZW5Ob2RlO1xuICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuZXF1YWxzKG90aGVyQ2hpbGRyZW5Ob2RlLmdldFByaW9yaXR5KCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRoaXMuY2hpbGRyZW5fLmNvdW50KCkgPT09IG90aGVyQ2hpbGRyZW5Ob2RlLmNoaWxkcmVuXy5jb3VudCgpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgdGhpc0l0ZXIgPSB0aGlzLmdldEl0ZXJhdG9yKFBSSU9SSVRZX0lOREVYKTtcbiAgICAgICAgY29uc3Qgb3RoZXJJdGVyID0gb3RoZXJDaGlsZHJlbk5vZGUuZ2V0SXRlcmF0b3IoUFJJT1JJVFlfSU5ERVgpO1xuICAgICAgICBsZXQgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XG4gICAgICAgIGxldCBvdGhlckN1cnJlbnQgPSBvdGhlckl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICB3aGlsZSAodGhpc0N1cnJlbnQgJiYgb3RoZXJDdXJyZW50KSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpc0N1cnJlbnQubmFtZSAhPT0gb3RoZXJDdXJyZW50Lm5hbWUgfHxcbiAgICAgICAgICAgICF0aGlzQ3VycmVudC5ub2RlLmVxdWFscyhvdGhlckN1cnJlbnQubm9kZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc0N1cnJlbnQgPT09IG51bGwgJiYgb3RoZXJDdXJyZW50ID09PSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgU29ydGVkTWFwIG9yZGVyZWQgYnkgaW5kZXgsIG9yIG51bGwgaWYgdGhlIGRlZmF1bHQgKGJ5LWtleSkgb3JkZXJpbmcgY2FuIGJlIHVzZWRcbiAgICogaW5zdGVhZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgKiBAcmV0dXJuIHs/U29ydGVkTWFwLjxOYW1lZE5vZGUsIE5vZGU+fVxuICAgKi9cbiAgcHJpdmF0ZSByZXNvbHZlSW5kZXhfKFxuICAgIGluZGV4RGVmaW5pdGlvbjogSW5kZXhcbiAgKTogU29ydGVkTWFwPE5hbWVkTm9kZSwgTm9kZT4gfCBudWxsIHtcbiAgICBpZiAoaW5kZXhEZWZpbml0aW9uID09PSBLRVlfSU5ERVgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE1hcF8uZ2V0KGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtDaGlsZHJlbk5vZGV9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgTWF4Tm9kZSBleHRlbmRzIENoaWxkcmVuTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFxuICAgICAgbmV3IFNvcnRlZE1hcDxzdHJpbmcsIE5vZGU+KE5BTUVfQ09NUEFSQVRPUiksXG4gICAgICBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSxcbiAgICAgIEluZGV4TWFwLkRlZmF1bHRcbiAgICApO1xuICB9XG5cbiAgY29tcGFyZVRvKG90aGVyOiBOb2RlKTogbnVtYmVyIHtcbiAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cblxuICBlcXVhbHMob3RoZXI6IE5vZGUpOiBib29sZWFuIHtcbiAgICAvLyBOb3QgdGhhdCB3ZSBldmVyeSBjb21wYXJlIGl0LCBidXQgTUFYX05PREUgaXMgb25seSBldmVyIGVxdWFsIHRvIGl0c2VsZlxuICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcbiAgfVxuXG4gIGdldFByaW9yaXR5KCk6IE1heE5vZGUge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lOiBzdHJpbmcpOiBDaGlsZHJlbk5vZGUge1xuICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgfVxuXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogTWFya2VyIHRoYXQgd2lsbCBzb3J0IGhpZ2hlciB0aGFuIGFueSBvdGhlciBzbmFwc2hvdC5cbiAqIEB0eXBlIHshTUFYX05PREV9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9OT0RFID0gbmV3IE1heE5vZGUoKTtcblxuLyoqXG4gKiBEb2N1bWVudCBOYW1lZE5vZGUgZXh0ZW5zaW9uc1xuICovXG5kZWNsYXJlIG1vZHVsZSAnLi9Ob2RlJyB7XG4gIGludGVyZmFjZSBOYW1lZE5vZGUge1xuICAgIE1JTjogTmFtZWROb2RlO1xuICAgIE1BWDogTmFtZWROb2RlO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE5hbWVkTm9kZSwge1xuICBNSU46IHtcbiAgICB2YWx1ZTogbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpXG4gIH0sXG4gIE1BWDoge1xuICAgIHZhbHVlOiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBNQVhfTk9ERSlcbiAgfVxufSk7XG5cbi8qKlxuICogUmVmZXJlbmNlIEV4dGVuc2lvbnNcbiAqL1xuS2V5SW5kZXguX19FTVBUWV9OT0RFID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG5MZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yID0gQ2hpbGRyZW5Ob2RlO1xuc2V0TWF4Tm9kZShNQVhfTk9ERSk7XG5zZXRQcmlvcml0eU1heE5vZGUoTUFYX05PREUpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENoaWxkcmVuTm9kZSB9IGZyb20gJy4vQ2hpbGRyZW5Ob2RlJztcbmltcG9ydCB7IExlYWZOb2RlIH0gZnJvbSAnLi9MZWFmTm9kZSc7XG5pbXBvcnQgeyBOYW1lZE5vZGUsIE5vZGUgfSBmcm9tICcuL05vZGUnO1xuaW1wb3J0IHsgZm9yRWFjaCwgY29udGFpbnMgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBidWlsZENoaWxkU2V0IH0gZnJvbSAnLi9jaGlsZFNldCc7XG5pbXBvcnQgeyBOQU1FX0NPTVBBUkFUT1IsIE5BTUVfT05MWV9DT01QQVJBVE9SIH0gZnJvbSAnLi9jb21wYXJhdG9ycyc7XG5pbXBvcnQgeyBJbmRleE1hcCB9IGZyb20gJy4vSW5kZXhNYXAnO1xuaW1wb3J0IHsgUFJJT1JJVFlfSU5ERVgsIHNldE5vZGVGcm9tSlNPTiB9IGZyb20gJy4vaW5kZXhlcy9Qcmlvcml0eUluZGV4JztcbmltcG9ydCB7IFNvcnRlZE1hcCB9IGZyb20gJy4uL3V0aWwvU29ydGVkTWFwJztcblxuY29uc3QgVVNFX0hJTlpFID0gdHJ1ZTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgc25hcHNob3Qgbm9kZSByZXByZXNlbnRpbmcgdGhlIHBhc3NlZCBKU09OIGFuZCByZXR1cm5zIGl0LlxuICogQHBhcmFtIHsqfSBqc29uIEpTT04gdG8gY3JlYXRlIGEgbm9kZSBmb3IuXG4gKiBAcGFyYW0gez9zdHJpbmd8P251bWJlcj19IHByaW9yaXR5IE9wdGlvbmFsIHByaW9yaXR5IHRvIHVzZS4gIFRoaXMgd2lsbCBiZSBpZ25vcmVkIGlmIHRoZVxuICogcGFzc2VkIEpTT04gY29udGFpbnMgYSAucHJpb3JpdHkgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHshTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGVGcm9tSlNPTihcbiAganNvbjogYW55IHwgbnVsbCxcbiAgcHJpb3JpdHk6IHN0cmluZyB8IG51bWJlciB8IG51bGwgPSBudWxsXG4pOiBOb2RlIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gIH1cblxuICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmICcucHJpb3JpdHknIGluIGpzb24pIHtcbiAgICBwcmlvcml0eSA9IGpzb25bJy5wcmlvcml0eSddO1xuICB9XG5cbiAgYXNzZXJ0KFxuICAgIHByaW9yaXR5ID09PSBudWxsIHx8XG4gICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInIHx8XG4gICAgICAodHlwZW9mIHByaW9yaXR5ID09PSAnb2JqZWN0JyAmJiAnLnN2JyBpbiAocHJpb3JpdHkgYXMgb2JqZWN0KSksXG4gICAgJ0ludmFsaWQgcHJpb3JpdHkgdHlwZSBmb3VuZDogJyArIHR5cGVvZiBwcmlvcml0eVxuICApO1xuXG4gIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYgJy52YWx1ZScgaW4ganNvbiAmJiBqc29uWycudmFsdWUnXSAhPT0gbnVsbCkge1xuICAgIGpzb24gPSBqc29uWycudmFsdWUnXTtcbiAgfVxuXG4gIC8vIFZhbGlkIGxlYWYgbm9kZXMgaW5jbHVkZSBub24tb2JqZWN0cyBvciBzZXJ2ZXItdmFsdWUgd3JhcHBlciBvYmplY3RzXG4gIGlmICh0eXBlb2YganNvbiAhPT0gJ29iamVjdCcgfHwgJy5zdicgaW4ganNvbikge1xuICAgIGNvbnN0IGpzb25MZWFmID0ganNvbiBhcyBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgb2JqZWN0O1xuICAgIHJldHVybiBuZXcgTGVhZk5vZGUoanNvbkxlYWYsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xuICB9XG5cbiAgaWYgKCEoanNvbiBpbnN0YW5jZW9mIEFycmF5KSAmJiBVU0VfSElOWkUpIHtcbiAgICBjb25zdCBjaGlsZHJlbjogTmFtZWROb2RlW10gPSBbXTtcbiAgICBsZXQgY2hpbGRyZW5IYXZlUHJpb3JpdHkgPSBmYWxzZTtcbiAgICBjb25zdCBoaW56ZUpzb25PYmo6IHsgW2s6IHN0cmluZ106IGFueSB9ID0ganNvbiBhcyBvYmplY3Q7XG4gICAgZm9yRWFjaChoaW56ZUpzb25PYmosIChrZXk6IHN0cmluZywgY2hpbGQ6IGFueSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xuICAgICAgICAvLyBJZ25vcmUgbWV0YWRhdGEgbm9kZXNcbiAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbm9kZUZyb21KU09OKGhpbnplSnNvbk9ialtrZXldKTtcbiAgICAgICAgaWYgKCFjaGlsZE5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHkgPVxuICAgICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHkgfHwgIWNoaWxkTm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoa2V5LCBjaGlsZE5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRTZXQgPSBidWlsZENoaWxkU2V0KFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBOQU1FX09OTFlfQ09NUEFSQVRPUixcbiAgICAgIG5hbWVkTm9kZSA9PiBuYW1lZE5vZGUubmFtZSxcbiAgICAgIE5BTUVfQ09NUEFSQVRPUlxuICAgICkgYXMgU29ydGVkTWFwPHN0cmluZywgTm9kZT47XG4gICAgaWYgKGNoaWxkcmVuSGF2ZVByaW9yaXR5KSB7XG4gICAgICBjb25zdCBzb3J0ZWRDaGlsZFNldCA9IGJ1aWxkQ2hpbGRTZXQoXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBQUklPUklUWV9JTkRFWC5nZXRDb21wYXJlKClcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShcbiAgICAgICAgY2hpbGRTZXQsXG4gICAgICAgIG5vZGVGcm9tSlNPTihwcmlvcml0eSksXG4gICAgICAgIG5ldyBJbmRleE1hcChcbiAgICAgICAgICB7ICcucHJpb3JpdHknOiBzb3J0ZWRDaGlsZFNldCB9LFxuICAgICAgICAgIHsgJy5wcmlvcml0eSc6IFBSSU9SSVRZX0lOREVYIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGUoXG4gICAgICAgIGNoaWxkU2V0LFxuICAgICAgICBub2RlRnJvbUpTT04ocHJpb3JpdHkpLFxuICAgICAgICBJbmRleE1hcC5EZWZhdWx0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgbm9kZTogTm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgIGNvbnN0IGpzb25PYmogPSBqc29uIGFzIHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9O1xuICAgIGZvckVhY2goanNvbk9iaiwgKGtleTogc3RyaW5nLCBjaGlsZERhdGE6IGFueSkgPT4ge1xuICAgICAgaWYgKGNvbnRhaW5zKGpzb25PYmosIGtleSkpIHtcbiAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xuICAgICAgICAgIC8vIGlnbm9yZSBtZXRhZGF0YSBub2Rlcy5cbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGREYXRhKTtcbiAgICAgICAgICBpZiAoY2hpbGROb2RlLmlzTGVhZk5vZGUoKSB8fCAhY2hpbGROb2RlLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGtleSwgY2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGUudXBkYXRlUHJpb3JpdHkobm9kZUZyb21KU09OKHByaW9yaXR5KSk7XG4gIH1cbn1cblxuc2V0Tm9kZUZyb21KU09OKG5vZGVGcm9tSlNPTik7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuL0luZGV4JztcbmltcG9ydCB7IE5hbWVkTm9kZSwgTm9kZSB9IGZyb20gJy4uL05vZGUnO1xuaW1wb3J0IHsgbmFtZUNvbXBhcmUgfSBmcm9tICcuLi8uLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgbm9kZUZyb21KU09OIH0gZnJvbSAnLi4vbm9kZUZyb21KU09OJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtJbmRleH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBWYWx1ZUluZGV4IGV4dGVuZHMgSW5kZXgge1xuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNvbXBhcmUoYTogTmFtZWROb2RlLCBiOiBOYW1lZE5vZGUpOiBudW1iZXIge1xuICAgIGNvbnN0IGluZGV4Q21wID0gYS5ub2RlLmNvbXBhcmVUbyhiLm5vZGUpO1xuICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluZGV4Q21wO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgaXNEZWZpbmVkT24obm9kZTogTm9kZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGU6IE5vZGUsIG5ld05vZGU6IE5vZGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIW9sZE5vZGUuZXF1YWxzKG5ld05vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBtaW5Qb3N0KCk6IE5hbWVkTm9kZSB7XG4gICAgcmV0dXJuIChOYW1lZE5vZGUgYXMgYW55KS5NSU47XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIG1heFBvc3QoKTogTmFtZWROb2RlIHtcbiAgICByZXR1cm4gKE5hbWVkTm9kZSBhcyBhbnkpLk1BWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluZGV4VmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICovXG4gIG1ha2VQb3N0KGluZGV4VmFsdWU6IG9iamVjdCwgbmFtZTogc3RyaW5nKTogTmFtZWROb2RlIHtcbiAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlRnJvbUpTT04oaW5kZXhWYWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgdmFsdWVOb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshc3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGluY2x1c2lvbiBpbiBhIHF1ZXJ5IHNwZWNcbiAgICovXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICcudmFsdWUnO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBWQUxVRV9JTkRFWCA9IG5ldyBWYWx1ZUluZGV4KCk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgbmFtZUNvbXBhcmUsIE1BWF9OQU1FIH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IEluZGV4IH0gZnJvbSAnLi9JbmRleCc7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUsIE1BWF9OT0RFIH0gZnJvbSAnLi4vQ2hpbGRyZW5Ob2RlJztcbmltcG9ydCB7IE5hbWVkTm9kZSwgTm9kZSB9IGZyb20gJy4uL05vZGUnO1xuaW1wb3J0IHsgbm9kZUZyb21KU09OIH0gZnJvbSAnLi4vbm9kZUZyb21KU09OJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi8uLi91dGlsL1BhdGgnO1xuXG4vKipcbiAqIEBwYXJhbSB7IVBhdGh9IGluZGV4UGF0aFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SW5kZXh9XG4gKi9cbmV4cG9ydCBjbGFzcyBQYXRoSW5kZXggZXh0ZW5kcyBJbmRleCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5kZXhQYXRoXzogUGF0aCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBhc3NlcnQoXG4gICAgICAhaW5kZXhQYXRoXy5pc0VtcHR5KCkgJiYgaW5kZXhQYXRoXy5nZXRGcm9udCgpICE9PSAnLnByaW9yaXR5JyxcbiAgICAgIFwiQ2FuJ3QgY3JlYXRlIFBhdGhJbmRleCB3aXRoIGVtcHR5IHBhdGggb3IgLnByaW9yaXR5IGtleVwiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwXG4gICAqIEByZXR1cm4geyFOb2RlfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgZXh0cmFjdENoaWxkKHNuYXA6IE5vZGUpOiBOb2RlIHtcbiAgICByZXR1cm4gc25hcC5nZXRDaGlsZCh0aGlzLmluZGV4UGF0aF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBpc0RlZmluZWRPbihub2RlOiBOb2RlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICFub2RlLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXykuaXNFbXB0eSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjb21wYXJlKGE6IE5hbWVkTm9kZSwgYjogTmFtZWROb2RlKTogbnVtYmVyIHtcbiAgICBjb25zdCBhQ2hpbGQgPSB0aGlzLmV4dHJhY3RDaGlsZChhLm5vZGUpO1xuICAgIGNvbnN0IGJDaGlsZCA9IHRoaXMuZXh0cmFjdENoaWxkKGIubm9kZSk7XG4gICAgY29uc3QgaW5kZXhDbXAgPSBhQ2hpbGQuY29tcGFyZVRvKGJDaGlsZCk7XG4gICAgaWYgKGluZGV4Q21wID09PSAwKSB7XG4gICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5kZXhDbXA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBtYWtlUG9zdChpbmRleFZhbHVlOiBvYmplY3QsIG5hbWU6IHN0cmluZyk6IE5hbWVkTm9kZSB7XG4gICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZUZyb21KU09OKGluZGV4VmFsdWUpO1xuICAgIGNvbnN0IG5vZGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERS51cGRhdGVDaGlsZChcbiAgICAgIHRoaXMuaW5kZXhQYXRoXyxcbiAgICAgIHZhbHVlTm9kZVxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgbm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIG1heFBvc3QoKTogTmFtZWROb2RlIHtcbiAgICBjb25zdCBub2RlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUudXBkYXRlQ2hpbGQodGhpcy5pbmRleFBhdGhfLCBNQVhfTk9ERSk7XG4gICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIG5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmluZGV4UGF0aF8uc2xpY2UoKS5qb2luKCcvJyk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyB2YWxpZGF0ZUFyZ0NvdW50LCB2YWxpZGF0ZUNhbGxiYWNrIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgdmFsaWRhdGVQYXRoU3RyaW5nIH0gZnJvbSAnLi4vY29yZS91dGlsL3ZhbGlkYXRpb24nO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL2NvcmUvdXRpbC9QYXRoJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi4vY29yZS9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vY29yZS9zbmFwL05vZGUnO1xuaW1wb3J0IHsgUmVmZXJlbmNlIH0gZnJvbSAnLi9SZWZlcmVuY2UnO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuLi9jb3JlL3NuYXAvaW5kZXhlcy9JbmRleCc7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuLi9jb3JlL3NuYXAvQ2hpbGRyZW5Ob2RlJztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBmaXJlYmFzZSBkYXRhIHNuYXBzaG90LiAgSXQgd3JhcHMgYSBTbmFwc2hvdE5vZGUgYW5kXG4gKiBzdXJmYWNlcyB0aGUgcHVibGljIG1ldGhvZHMgKHZhbCwgZm9yRWFjaCwgZXRjLikgd2Ugd2FudCB0byBleHBvc2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhU25hcHNob3Qge1xuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZV8gQSBTbmFwc2hvdE5vZGUgdG8gd3JhcC5cbiAgICogQHBhcmFtIHshUmVmZXJlbmNlfSByZWZfIFRoZSByZWYgb2YgdGhlIGxvY2F0aW9uIHRoaXMgc25hcHNob3QgY2FtZSBmcm9tLlxuICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhfIFRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIHRoaXMgc25hcHNob3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbm9kZV86IE5vZGUsXG4gICAgcHJpdmF0ZSByZWFkb25seSByZWZfOiBSZWZlcmVuY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBpbmRleF86IEluZGV4XG4gICkge31cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzbmFwc2hvdCBjb250ZW50cyBhcyBKU09OLiAgUmV0dXJucyBudWxsIGlmIHRoZSBzbmFwc2hvdCBpc1xuICAgKiBlbXB0eS5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgRGF0YVNuYXBzaG90IGNvbnRlbnRzLCBvciBudWxsIGlmIGVtcHR5LlxuICAgKi9cbiAgdmFsKCk6IGFueSB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LnZhbCcsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm5vZGVfLnZhbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNuYXBzaG90IGNvbnRlbnRzIGFzIEpTT04sIGluY2x1ZGluZyBwcmlvcml0aWVzIG9mIG5vZGUuICBTdWl0YWJsZSBmb3IgZXhwb3J0aW5nXG4gICAqIHRoZSBlbnRpcmUgbm9kZSBjb250ZW50cy5cbiAgICogQHJldHVybiB7Kn0gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgRGF0YVNuYXBzaG90IGNvbnRlbnRzLCBvciBudWxsIGlmIGVtcHR5LlxuICAgKi9cbiAgZXhwb3J0VmFsKCk6IGFueSB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmV4cG9ydFZhbCcsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm5vZGVfLnZhbCh0cnVlKTtcbiAgfVxuXG4gIC8vIERvIG5vdCBjcmVhdGUgcHVibGljIGRvY3VtZW50YXRpb24uIFRoaXMgaXMgaW50ZW5kZWQgdG8gbWFrZSBKU09OIHNlcmlhbGl6YXRpb24gd29yayBidXQgaXMgb3RoZXJ3aXNlIHVubmVjZXNzYXJ5XG4gIC8vIGZvciBlbmQtdXNlcnNcbiAgdG9KU09OKCk6IGFueSB7XG4gICAgLy8gT3B0aW9uYWwgc3BhY2VyIGFyZ3VtZW50IGlzIHVubmVjZXNzYXJ5IGJlY2F1c2Ugd2UncmUgZGVwZW5kaW5nIG9uIHJlY3Vyc2lvbiByYXRoZXIgdGhhbiBzdHJpbmdpZnlpbmcgdGhlIGNvbnRlbnRcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QudG9KU09OJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMuZXhwb3J0VmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzbmFwc2hvdCBjb250YWlucyBhIG5vbi1udWxsIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzbmFwc2hvdCBjb250YWlucyBhIG5vbi1udWxsIHZhbHVlLCBvciBpcyBlbXB0eS5cbiAgICovXG4gIGV4aXN0cygpOiBib29sZWFuIHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QuZXhpc3RzJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgcmV0dXJuICF0aGlzLm5vZGVfLmlzRW1wdHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgRGF0YVNuYXBzaG90IG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQgbm9kZSdzIGNvbnRlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGNoaWxkUGF0aFN0cmluZyBQYXRoIHRvIGEgY2hpbGQuXG4gICAqIEByZXR1cm4geyFEYXRhU25hcHNob3R9IERhdGFTbmFwc2hvdCBmb3IgY2hpbGQgbm9kZS5cbiAgICovXG4gIGNoaWxkKGNoaWxkUGF0aFN0cmluZzogc3RyaW5nKTogRGF0YVNuYXBzaG90IHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QuY2hpbGQnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAvLyBFbnN1cmUgdGhlIGNoaWxkUGF0aCBpcyBhIHN0cmluZyAoY2FuIGJlIGEgbnVtYmVyKVxuICAgIGNoaWxkUGF0aFN0cmluZyA9IFN0cmluZyhjaGlsZFBhdGhTdHJpbmcpO1xuICAgIHZhbGlkYXRlUGF0aFN0cmluZygnRGF0YVNuYXBzaG90LmNoaWxkJywgMSwgY2hpbGRQYXRoU3RyaW5nLCBmYWxzZSk7XG5cbiAgICBjb25zdCBjaGlsZFBhdGggPSBuZXcgUGF0aChjaGlsZFBhdGhTdHJpbmcpO1xuICAgIGNvbnN0IGNoaWxkUmVmID0gdGhpcy5yZWZfLmNoaWxkKGNoaWxkUGF0aCk7XG4gICAgcmV0dXJuIG5ldyBEYXRhU25hcHNob3QoXG4gICAgICB0aGlzLm5vZGVfLmdldENoaWxkKGNoaWxkUGF0aCksXG4gICAgICBjaGlsZFJlZixcbiAgICAgIFBSSU9SSVRZX0lOREVYXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNuYXBzaG90IGNvbnRhaW5zIGEgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGNoaWxkUGF0aFN0cmluZyBQYXRoIHRvIGEgY2hpbGQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNoaWxkIGV4aXN0cy5cbiAgICovXG4gIGhhc0NoaWxkKGNoaWxkUGF0aFN0cmluZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90Lmhhc0NoaWxkJywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdmFsaWRhdGVQYXRoU3RyaW5nKCdEYXRhU25hcHNob3QuaGFzQ2hpbGQnLCAxLCBjaGlsZFBhdGhTdHJpbmcsIGZhbHNlKTtcblxuICAgIGNvbnN0IGNoaWxkUGF0aCA9IG5ldyBQYXRoKGNoaWxkUGF0aFN0cmluZyk7XG4gICAgcmV0dXJuICF0aGlzLm5vZGVfLmdldENoaWxkKGNoaWxkUGF0aCkuaXNFbXB0eSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByaW9yaXR5IG9mIHRoZSBvYmplY3QsIG9yIG51bGwgaWYgbm8gcHJpb3JpdHkgd2FzIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfG51bWJlcnxudWxsfSBUaGUgcHJpb3JpdHkuXG4gICAqL1xuICBnZXRQcmlvcml0eSgpOiBzdHJpbmcgfCBudW1iZXIgfCBudWxsIHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QuZ2V0UHJpb3JpdHknLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgIC8vIHR5cGVjYXN0IGhlcmUgYmVjYXVzZSB3ZSBuZXZlciByZXR1cm4gZGVmZXJyZWQgdmFsdWVzIG9yIGludGVybmFsIHByaW9yaXRpZXMgKE1BWF9QUklPUklUWSlcbiAgICByZXR1cm4gdGhpcy5ub2RlXy5nZXRQcmlvcml0eSgpLnZhbCgpIGFzIHN0cmluZyB8IG51bWJlciB8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZCBub2RlcyBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZm9yIGVhY2ggb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFEYXRhU25hcHNob3QpfSBhY3Rpb24gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqIGZvciBlYWNoIGNoaWxkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGZvckVhY2ggd2FzIGNhbmNlbGVkIGJ5IGFjdGlvbiByZXR1cm5pbmcgdHJ1ZSBmb3JcbiAgICogb25lIG9mIHRoZSBjaGlsZCBub2Rlcy5cbiAgICovXG4gIGZvckVhY2goYWN0aW9uOiAoZDogRGF0YVNuYXBzaG90KSA9PiBib29sZWFuIHwgdm9pZCk6IGJvb2xlYW4ge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5mb3JFYWNoJywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdmFsaWRhdGVDYWxsYmFjaygnRGF0YVNuYXBzaG90LmZvckVhY2gnLCAxLCBhY3Rpb24sIGZhbHNlKTtcblxuICAgIGlmICh0aGlzLm5vZGVfLmlzTGVhZk5vZGUoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgY2hpbGRyZW5Ob2RlID0gdGhpcy5ub2RlXyBhcyBDaGlsZHJlbk5vZGU7XG4gICAgLy8gU2FuaXRpemUgdGhlIHJldHVybiB2YWx1ZSB0byBhIGJvb2xlYW4uIENoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQgaGFzIGEgd2VpcmQgcmV0dXJuIHR5cGUuLi5cbiAgICByZXR1cm4gISFjaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkKHRoaXMuaW5kZXhfLCAoa2V5LCBub2RlKSA9PiB7XG4gICAgICByZXR1cm4gYWN0aW9uKFxuICAgICAgICBuZXcgRGF0YVNuYXBzaG90KG5vZGUsIHRoaXMucmVmXy5jaGlsZChrZXkpLCBQUklPUklUWV9JTkRFWClcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgRGF0YVNuYXBzaG90IGhhcyBjaGlsZHJlbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRGF0YVNuYXBzaG90IGNvbnRhaW5zIDEgb3IgbW9yZSBjaGlsZCBub2Rlcy5cbiAgICovXG4gIGhhc0NoaWxkcmVuKCk6IGJvb2xlYW4ge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5oYXNDaGlsZHJlbicsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXG4gICAgaWYgKHRoaXMubm9kZV8uaXNMZWFmTm9kZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSByZXR1cm4gIXRoaXMubm9kZV8uaXNFbXB0eSgpO1xuICB9XG5cbiAgZ2V0IGtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZfLmdldEtleSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBmb3IgdGhpcyBEYXRhU25hcHNob3QuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IHRoaXMgRGF0YVNuYXBzaG90IGNvbnRhaW5zLlxuICAgKi9cbiAgbnVtQ2hpbGRyZW4oKTogbnVtYmVyIHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QubnVtQ2hpbGRyZW4nLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgIHJldHVybiB0aGlzLm5vZGVfLm51bUNoaWxkcmVuKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UmVmZXJlbmNlfSBUaGUgRmlyZWJhc2UgcmVmZXJlbmNlIGZvciB0aGUgbG9jYXRpb24gdGhpcyBzbmFwc2hvdCdzIGRhdGEgY2FtZSBmcm9tLlxuICAgKi9cbiAgZ2V0UmVmKCk6IFJlZmVyZW5jZSB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LnJlZicsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIHRoaXMucmVmXztcbiAgfVxuXG4gIGdldCByZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVmKCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vdXRpbC9QYXRoJztcbmltcG9ydCB7IEV2ZW50UmVnaXN0cmF0aW9uIH0gZnJvbSAnLi9FdmVudFJlZ2lzdHJhdGlvbic7XG5pbXBvcnQgeyBEYXRhU25hcHNob3QgfSBmcm9tICcuLi8uLi9hcGkvRGF0YVNuYXBzaG90JztcblxuLyoqXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIGRhdGEgbmVlZGVkIHRvIHJhaXNlIGFuIGV2ZW50XG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnQge1xuICAvKipcbiAgICogQHJldHVybiB7IVBhdGh9XG4gICAqL1xuICBnZXRQYXRoKCk6IFBhdGg7XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFzdHJpbmd9XG4gICAqL1xuICBnZXRFdmVudFR5cGUoKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgICovXG4gIGdldEV2ZW50UnVubmVyKCk6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpOiBzdHJpbmc7XG59XG5cbi8qKlxuICogRW5jYXBzdWxhdGVzIHRoZSBkYXRhIG5lZWRlZCB0byByYWlzZSBhbiBldmVudFxuICogQGltcGxlbWVudHMge0V2ZW50fVxuICovXG5leHBvcnQgY2xhc3MgRGF0YUV2ZW50IGltcGxlbWVudHMgRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGUgT25lIG9mOiB2YWx1ZSwgY2hpbGRfYWRkZWQsIGNoaWxkX2NoYW5nZWQsIGNoaWxkX21vdmVkLCBjaGlsZF9yZW1vdmVkXG4gICAqIEBwYXJhbSB7IUV2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB0byB3aXRoIHRoZSBldmVudCBkYXRhLiBVc2VyIHByb3ZpZGVkXG4gICAqIEBwYXJhbSB7IURhdGFTbmFwc2hvdH0gc25hcHNob3QgVGhlIGRhdGEgYmFja2luZyB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHs/c3RyaW5nPX0gcHJldk5hbWUgT3B0aW9uYWwsIHRoZSBuYW1lIG9mIHRoZSBwcmV2aW91cyBjaGlsZCBmb3IgY2hpbGRfKiBldmVudHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgZXZlbnRUeXBlOlxuICAgICAgfCAndmFsdWUnXG4gICAgICB8ICcgY2hpbGRfYWRkZWQnXG4gICAgICB8ICcgY2hpbGRfY2hhbmdlZCdcbiAgICAgIHwgJyBjaGlsZF9tb3ZlZCdcbiAgICAgIHwgJyBjaGlsZF9yZW1vdmVkJyxcbiAgICBwdWJsaWMgZXZlbnRSZWdpc3RyYXRpb246IEV2ZW50UmVnaXN0cmF0aW9uLFxuICAgIHB1YmxpYyBzbmFwc2hvdDogRGF0YVNuYXBzaG90LFxuICAgIHB1YmxpYyBwcmV2TmFtZT86IHN0cmluZyB8IG51bGxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0UGF0aCgpOiBQYXRoIHtcbiAgICBjb25zdCByZWYgPSB0aGlzLnNuYXBzaG90LmdldFJlZigpO1xuICAgIGlmICh0aGlzLmV2ZW50VHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgcmV0dXJuIHJlZi5wYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVmLmdldFBhcmVudCgpLnBhdGg7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRFdmVudFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudFR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEV2ZW50UnVubmVyKCk6ICgpID0+IHZvaWQge1xuICAgIHJldHVybiB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uLmdldEV2ZW50UnVubmVyKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmdldFBhdGgoKS50b1N0cmluZygpICtcbiAgICAgICc6JyArXG4gICAgICB0aGlzLmV2ZW50VHlwZSArXG4gICAgICAnOicgK1xuICAgICAgc3RyaW5naWZ5KHRoaXMuc25hcHNob3QuZXhwb3J0VmFsKCkpXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2FuY2VsRXZlbnQgaW1wbGVtZW50cyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvblxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgZXZlbnRSZWdpc3RyYXRpb246IEV2ZW50UmVnaXN0cmF0aW9uLFxuICAgIHB1YmxpYyBlcnJvcjogRXJyb3IsXG4gICAgcHVibGljIHBhdGg6IFBhdGhcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0UGF0aCgpOiBQYXRoIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRFdmVudFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2NhbmNlbCc7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEV2ZW50UnVubmVyKCk6ICgpID0+IHZvaWQge1xuICAgIHJldHVybiB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uLmdldEV2ZW50UnVubmVyKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKSArICc6Y2FuY2VsJztcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IERhdGFTbmFwc2hvdCB9IGZyb20gJy4uLy4uL2FwaS9EYXRhU25hcHNob3QnO1xuaW1wb3J0IHsgRGF0YUV2ZW50LCBDYW5jZWxFdmVudCwgRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcbmltcG9ydCB7IGNvbnRhaW5zLCBnZXRDb3VudCwgZ2V0QW55S2V5LCBldmVyeSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgQ2hhbmdlIH0gZnJvbSAnLi9DaGFuZ2UnO1xuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuLi8uLi9hcGkvUXVlcnknO1xuXG4vKipcbiAqIEFuIEV2ZW50UmVnaXN0cmF0aW9uIGlzIGJhc2ljYWxseSBhbiBldmVudCB0eXBlICgndmFsdWUnLCAnY2hpbGRfYWRkZWQnLCBldGMuKSBhbmQgYSBjYWxsYmFja1xuICogdG8gYmUgbm90aWZpZWQgb2YgdGhhdCB0eXBlIG9mIGV2ZW50LlxuICpcbiAqIFRoYXQgc2FpZCwgaXQgY2FuIGFsc28gY29udGFpbiBhIGNhbmNlbCBjYWxsYmFjayB0byBiZSBub3RpZmllZCBpZiB0aGUgZXZlbnQgaXMgY2FuY2VsZWQuICBBbmRcbiAqIGN1cnJlbnRseSwgdGhpcyBjb2RlIGlzIG9yZ2FuaXplZCBhcm91bmQgdGhlIGlkZWEgdGhhdCB5b3Ugd291bGQgcmVnaXN0ZXIgbXVsdGlwbGUgY2hpbGRfIGNhbGxiYWNrc1xuICogdG9nZXRoZXIsIGFzIGEgc2luZ2xlIEV2ZW50UmVnaXN0cmF0aW9uLiAgVGhvdWdoIGN1cnJlbnRseSB3ZSBkb24ndCBkbyB0aGF0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50UmVnaXN0cmF0aW9uIHtcbiAgLyoqXG4gICAqIFRydWUgaWYgdGhpcyBjb250YWluZXIgaGFzIGEgY2FsbGJhY2sgdG8gdHJpZ2dlciBmb3IgdGhpcyBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZXNwb25kc1RvKGV2ZW50VHlwZTogc3RyaW5nKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHBhcmFtIHshQ2hhbmdlfSBjaGFuZ2VcbiAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAqIEByZXR1cm4geyFFdmVudH1cbiAgICovXG4gIGNyZWF0ZUV2ZW50KGNoYW5nZTogQ2hhbmdlLCBxdWVyeTogUXVlcnkpOiBFdmVudDtcblxuICAvKipcbiAgICogR2l2ZW4gZXZlbnQgZGF0YSwgcmV0dXJuIGEgZnVuY3Rpb24gdG8gdHJpZ2dlciB0aGUgdXNlcidzIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudERhdGFcbiAgICogQHJldHVybiB7ZnVuY3Rpb24oKX1cbiAgICovXG4gIGdldEV2ZW50UnVubmVyKGV2ZW50RGF0YTogRXZlbnQpOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFcnJvcn0gZXJyb3JcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcmV0dXJuIHs/Q2FuY2VsRXZlbnR9XG4gICAqL1xuICBjcmVhdGVDYW5jZWxFdmVudChlcnJvcjogRXJyb3IsIHBhdGg6IFBhdGgpOiBDYW5jZWxFdmVudCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50UmVnaXN0cmF0aW9ufSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWF0Y2hlcyhvdGhlcjogRXZlbnRSZWdpc3RyYXRpb24pOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBGYWxzZSBiYXNpY2FsbHkgbWVhbnMgdGhpcyBpcyBhIFwiZHVtbXlcIiBjYWxsYmFjayBjb250YWluZXIgYmVpbmcgdXNlZCBhcyBhIHNlbnRpbmVsXG4gICAqIHRvIHJlbW92ZSBhbGwgY2FsbGJhY2sgY29udGFpbmVycyBvZiBhIHBhcnRpY3VsYXIgdHlwZS4gIChlLmcuIGlmIHRoZSB1c2VyIGRvZXNcbiAgICogcmVmLm9mZigndmFsdWUnKSB3aXRob3V0IHNwZWNpZnlpbmcgYSBzcGVjaWZpYyBjYWxsYmFjaykuXG4gICAqXG4gICAqIChUT0RPOiBSZXdvcmsgdGhpcywgc2luY2UgaXQncyBoYWNreSlcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0FueUNhbGxiYWNrKCk6IGJvb2xlYW47XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyByZWdpc3RyYXRpb24gZm9yICd2YWx1ZScgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbiBpbXBsZW1lbnRzIEV2ZW50UmVnaXN0cmF0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9uKCFEYXRhU25hcHNob3QpfSBjYWxsYmFja19cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb24oRXJyb3IpfSBjYW5jZWxDYWxsYmFja19cbiAgICogQHBhcmFtIHs/T2JqZWN0fSBjb250ZXh0X1xuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjYWxsYmFja186ICgoZDogRGF0YVNuYXBzaG90KSA9PiB2b2lkKSB8IG51bGwsXG4gICAgcHJpdmF0ZSBjYW5jZWxDYWxsYmFja186ICgoZTogRXJyb3IpID0+IHZvaWQpIHwgbnVsbCxcbiAgICBwcml2YXRlIGNvbnRleHRfOiBPYmplY3QgfCBudWxsXG4gICkge31cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHJlc3BvbmRzVG8oZXZlbnRUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZXZlbnRUeXBlID09PSAndmFsdWUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjcmVhdGVFdmVudChjaGFuZ2U6IENoYW5nZSwgcXVlcnk6IFF1ZXJ5KTogRGF0YUV2ZW50IHtcbiAgICBjb25zdCBpbmRleCA9IHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkuZ2V0SW5kZXgoKTtcbiAgICByZXR1cm4gbmV3IERhdGFFdmVudChcbiAgICAgICd2YWx1ZScsXG4gICAgICB0aGlzLFxuICAgICAgbmV3IERhdGFTbmFwc2hvdChjaGFuZ2Uuc25hcHNob3ROb2RlLCBxdWVyeS5nZXRSZWYoKSwgaW5kZXgpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0RXZlbnRSdW5uZXIoZXZlbnREYXRhOiBDYW5jZWxFdmVudCB8IERhdGFFdmVudCk6ICgpID0+IHZvaWQge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY29udGV4dF87XG4gICAgaWYgKGV2ZW50RGF0YS5nZXRFdmVudFR5cGUoKSA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdGhpcy5jYW5jZWxDYWxsYmFja18sXG4gICAgICAgICdSYWlzaW5nIGEgY2FuY2VsIGV2ZW50IG9uIGEgbGlzdGVuZXIgd2l0aCBubyBjYW5jZWwgY2FsbGJhY2snXG4gICAgICApO1xuICAgICAgY29uc3QgY2FuY2VsQ0IgPSB0aGlzLmNhbmNlbENhbGxiYWNrXztcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gV2Uga25vdyB0aGF0IGVycm9yIGV4aXN0cywgd2UgY2hlY2tlZCBhYm92ZSB0aGF0IHRoaXMgaXMgYSBjYW5jZWwgZXZlbnRcbiAgICAgICAgY2FuY2VsQ0IuY2FsbChjdHgsIChldmVudERhdGEgYXMgQ2FuY2VsRXZlbnQpLmVycm9yKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNiID0gdGhpcy5jYWxsYmFja187XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNiLmNhbGwoY3R4LCAoZXZlbnREYXRhIGFzIERhdGFFdmVudCkuc25hcHNob3QpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNyZWF0ZUNhbmNlbEV2ZW50KGVycm9yOiBFcnJvciwgcGF0aDogUGF0aCk6IENhbmNlbEV2ZW50IHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuY2FuY2VsQ2FsbGJhY2tfKSB7XG4gICAgICByZXR1cm4gbmV3IENhbmNlbEV2ZW50KHRoaXMsIGVycm9yLCBwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBtYXRjaGVzKG90aGVyOiBFdmVudFJlZ2lzdHJhdGlvbik6IGJvb2xlYW4ge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFvdGhlci5jYWxsYmFja18gfHwgIXRoaXMuY2FsbGJhY2tfKSB7XG4gICAgICAvLyBJZiBubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdlIGNvbnNpZGVyIGl0IHRvIG1hdGNoIGFueSBjYWxsYmFjay5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBvdGhlci5jYWxsYmFja18gPT09IHRoaXMuY2FsbGJhY2tfICYmIG90aGVyLmNvbnRleHRfID09PSB0aGlzLmNvbnRleHRfXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgaGFzQW55Q2FsbGJhY2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tfICE9PSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcmVnaXN0cmF0aW9uIG9mIDEgb3IgbW9yZSBjaGlsZF94eHggZXZlbnRzLlxuICpcbiAqIEN1cnJlbnRseSwgaXQgaXMgYWx3YXlzIGV4YWN0bHkgMSBjaGlsZF94eHggZXZlbnQsIGJ1dCB0aGUgaWRlYSBpcyB3ZSBtaWdodCBsZXQgeW91XG4gKiByZWdpc3RlciBhIGdyb3VwIG9mIGNhbGxiYWNrcyB0b2dldGhlciBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0V2ZW50UmVnaXN0cmF0aW9ufVxuICovXG5leHBvcnQgY2xhc3MgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbiBpbXBsZW1lbnRzIEV2ZW50UmVnaXN0cmF0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7P09iamVjdC48c3RyaW5nLCBmdW5jdGlvbighRGF0YVNuYXBzaG90LCA/c3RyaW5nPSk+fSBjYWxsYmFja3NfXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9uKEVycm9yKX0gY2FuY2VsQ2FsbGJhY2tfXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dF9cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY2FsbGJhY2tzXzpcbiAgICAgIHwgKHsgW2s6IHN0cmluZ106IChkOiBEYXRhU25hcHNob3QsIHM/OiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkIH0pXG4gICAgICB8IG51bGwsXG4gICAgcHJpdmF0ZSBjYW5jZWxDYWxsYmFja186ICgoZTogRXJyb3IpID0+IHZvaWQpIHwgbnVsbCxcbiAgICBwcml2YXRlIGNvbnRleHRfPzogT2JqZWN0XG4gICkge31cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHJlc3BvbmRzVG8oZXZlbnRUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBsZXQgZXZlbnRUb0NoZWNrID1cbiAgICAgIGV2ZW50VHlwZSA9PT0gJ2NoaWxkcmVuX2FkZGVkJyA/ICdjaGlsZF9hZGRlZCcgOiBldmVudFR5cGU7XG4gICAgZXZlbnRUb0NoZWNrID1cbiAgICAgIGV2ZW50VG9DaGVjayA9PT0gJ2NoaWxkcmVuX3JlbW92ZWQnID8gJ2NoaWxkX3JlbW92ZWQnIDogZXZlbnRUb0NoZWNrO1xuICAgIHJldHVybiBjb250YWlucyh0aGlzLmNhbGxiYWNrc18sIGV2ZW50VG9DaGVjayk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNyZWF0ZUNhbmNlbEV2ZW50KGVycm9yOiBFcnJvciwgcGF0aDogUGF0aCk6IENhbmNlbEV2ZW50IHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuY2FuY2VsQ2FsbGJhY2tfKSB7XG4gICAgICByZXR1cm4gbmV3IENhbmNlbEV2ZW50KHRoaXMsIGVycm9yLCBwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjcmVhdGVFdmVudChjaGFuZ2U6IENoYW5nZSwgcXVlcnk6IFF1ZXJ5KTogRGF0YUV2ZW50IHtcbiAgICBhc3NlcnQoY2hhbmdlLmNoaWxkTmFtZSAhPSBudWxsLCAnQ2hpbGQgZXZlbnRzIHNob3VsZCBoYXZlIGEgY2hpbGROYW1lLicpO1xuICAgIGNvbnN0IHJlZiA9IHF1ZXJ5LmdldFJlZigpLmNoaWxkKC8qKiBAdHlwZSB7IXN0cmluZ30gKi8gKGNoYW5nZS5jaGlsZE5hbWUpKTtcbiAgICBjb25zdCBpbmRleCA9IHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkuZ2V0SW5kZXgoKTtcbiAgICByZXR1cm4gbmV3IERhdGFFdmVudChcbiAgICAgIGNoYW5nZS50eXBlIGFzIGFueSxcbiAgICAgIHRoaXMsXG4gICAgICBuZXcgRGF0YVNuYXBzaG90KGNoYW5nZS5zbmFwc2hvdE5vZGUsIHJlZiwgaW5kZXggYXMgYW55KSxcbiAgICAgIGNoYW5nZS5wcmV2TmFtZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEV2ZW50UnVubmVyKGV2ZW50RGF0YTogQ2FuY2VsRXZlbnQgfCBEYXRhRXZlbnQpOiAoKSA9PiB2b2lkIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmNvbnRleHRfO1xuICAgIGlmIChldmVudERhdGEuZ2V0RXZlbnRUeXBlKCkgPT09ICdjYW5jZWwnKSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRoaXMuY2FuY2VsQ2FsbGJhY2tfLFxuICAgICAgICAnUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGNhbmNlbENCID0gdGhpcy5jYW5jZWxDYWxsYmFja187XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdlIGtub3cgdGhhdCBlcnJvciBleGlzdHMsIHdlIGNoZWNrZWQgYWJvdmUgdGhhdCB0aGlzIGlzIGEgY2FuY2VsIGV2ZW50XG4gICAgICAgIGNhbmNlbENCLmNhbGwoY3R4LCAoZXZlbnREYXRhIGFzIENhbmNlbEV2ZW50KS5lcnJvcik7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjYiA9IHRoaXMuY2FsbGJhY2tzX1soZXZlbnREYXRhIGFzIERhdGFFdmVudCkuZXZlbnRUeXBlXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2IuY2FsbChcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgKGV2ZW50RGF0YSBhcyBEYXRhRXZlbnQpLnNuYXBzaG90LFxuICAgICAgICAgIChldmVudERhdGEgYXMgRGF0YUV2ZW50KS5wcmV2TmFtZVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIG1hdGNoZXMob3RoZXI6IEV2ZW50UmVnaXN0cmF0aW9uKTogYm9vbGVhbiB7XG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrc18gfHwgIW90aGVyLmNhbGxiYWNrc18pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY29udGV4dF8gPT09IG90aGVyLmNvbnRleHRfKSB7XG4gICAgICAgIGNvbnN0IG90aGVyQ291bnQgPSBnZXRDb3VudChvdGhlci5jYWxsYmFja3NfKTtcbiAgICAgICAgY29uc3QgdGhpc0NvdW50ID0gZ2V0Q291bnQodGhpcy5jYWxsYmFja3NfKTtcbiAgICAgICAgaWYgKG90aGVyQ291bnQgPT09IHRoaXNDb3VudCkge1xuICAgICAgICAgIC8vIElmIGNvdW50IGlzIDEsIGRvIGFuIGV4YWN0IG1hdGNoIG9uIGV2ZW50VHlwZSwgaWYgZWl0aGVyIGlzIGRlZmluZWQgYnV0IG51bGwsIGl0J3MgYSBtYXRjaC5cbiAgICAgICAgICAvLyAgSWYgZXZlbnQgdHlwZXMgZG9uJ3QgbWF0Y2gsIG5vdCBhIG1hdGNoXG4gICAgICAgICAgLy8gSWYgY291bnQgaXMgbm90IDEsIGV4YWN0IG1hdGNoIGFjcm9zcyBhbGxcblxuICAgICAgICAgIGlmIChvdGhlckNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcktleSAvKiogQHR5cGUgeyFzdHJpbmd9ICovID0gZ2V0QW55S2V5KG90aGVyLmNhbGxiYWNrc18pO1xuICAgICAgICAgICAgY29uc3QgdGhpc0tleSAvKiogQHR5cGUgeyFzdHJpbmd9ICovID0gZ2V0QW55S2V5KHRoaXMuY2FsbGJhY2tzXyk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0aGlzS2V5ID09PSBvdGhlcktleSAmJlxuICAgICAgICAgICAgICAoIW90aGVyLmNhbGxiYWNrc19bb3RoZXJLZXldIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuY2FsbGJhY2tzX1t0aGlzS2V5XSB8fFxuICAgICAgICAgICAgICAgIG90aGVyLmNhbGxiYWNrc19bb3RoZXJLZXldID09PSB0aGlzLmNhbGxiYWNrc19bdGhpc0tleV0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFeGFjdCBtYXRjaCBvbiBlYWNoIGtleS5cbiAgICAgICAgICAgIHJldHVybiBldmVyeShcbiAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NfLFxuICAgICAgICAgICAgICAoZXZlbnRUeXBlLCBjYikgPT4gb3RoZXIuY2FsbGJhY2tzX1tldmVudFR5cGVdID09PSBjYlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGhhc0FueUNhbGxiYWNrKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrc18gIT09IG51bGw7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBLRVlfSU5ERVggfSBmcm9tICcuLi9jb3JlL3NuYXAvaW5kZXhlcy9LZXlJbmRleCc7XG5pbXBvcnQgeyBQUklPUklUWV9JTkRFWCB9IGZyb20gJy4uL2NvcmUvc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuaW1wb3J0IHsgVkFMVUVfSU5ERVggfSBmcm9tICcuLi9jb3JlL3NuYXAvaW5kZXhlcy9WYWx1ZUluZGV4JztcbmltcG9ydCB7IFBhdGhJbmRleCB9IGZyb20gJy4uL2NvcmUvc25hcC9pbmRleGVzL1BhdGhJbmRleCc7XG5pbXBvcnQgeyBNSU5fTkFNRSwgTUFYX05BTUUsIE9iamVjdFRvVW5pcXVlS2V5IH0gZnJvbSAnLi4vY29yZS91dGlsL3V0aWwnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL2NvcmUvdXRpbC9QYXRoJztcbmltcG9ydCB7XG4gIGlzVmFsaWRQcmlvcml0eSxcbiAgdmFsaWRhdGVFdmVudFR5cGUsXG4gIHZhbGlkYXRlUGF0aFN0cmluZyxcbiAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcsXG4gIHZhbGlkYXRlS2V5XG59IGZyb20gJy4uL2NvcmUvdXRpbC92YWxpZGF0aW9uJztcbmltcG9ydCB7XG4gIGVycm9yUHJlZml4LFxuICB2YWxpZGF0ZUFyZ0NvdW50LFxuICB2YWxpZGF0ZUNhbGxiYWNrLFxuICB2YWxpZGF0ZUNvbnRleHRPYmplY3Rcbn0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHtcbiAgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbixcbiAgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbixcbiAgRXZlbnRSZWdpc3RyYXRpb25cbn0gZnJvbSAnLi4vY29yZS92aWV3L0V2ZW50UmVnaXN0cmF0aW9uJztcbmltcG9ydCB7IERlZmVycmVkIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgUmVwbyB9IGZyb20gJy4uL2NvcmUvUmVwbyc7XG5pbXBvcnQgeyBRdWVyeVBhcmFtcyB9IGZyb20gJy4uL2NvcmUvdmlldy9RdWVyeVBhcmFtcyc7XG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tICcuL1JlZmVyZW5jZSc7XG5pbXBvcnQgeyBEYXRhU25hcHNob3QgfSBmcm9tICcuL0RhdGFTbmFwc2hvdCc7XG5cbmxldCBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yOiBuZXcgKHJlcG86IFJlcG8sIHBhdGg6IFBhdGgpID0+IFF1ZXJ5O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNuYXBzaG90Q2FsbGJhY2sge1xuICAoYTogRGF0YVNuYXBzaG90LCBiPzogc3RyaW5nIHwgbnVsbCk6IGFueTtcbn1cblxuLyoqXG4gKiBBIFF1ZXJ5IHJlcHJlc2VudHMgYSBmaWx0ZXIgdG8gYmUgYXBwbGllZCB0byBhIGZpcmViYXNlIGxvY2F0aW9uLiAgVGhpcyBvYmplY3QgcHVyZWx5IHJlcHJlc2VudHMgdGhlXG4gKiBxdWVyeSBleHByZXNzaW9uIChhbmQgZXhwb3NlcyBvdXIgcHVibGljIEFQSSB0byBidWlsZCB0aGUgcXVlcnkpLiAgVGhlIGFjdHVhbCBxdWVyeSBsb2dpYyBpcyBpbiBWaWV3QmFzZS5qcy5cbiAqXG4gKiBTaW5jZSBldmVyeSBGaXJlYmFzZSByZWZlcmVuY2UgaXMgYSBxdWVyeSwgRmlyZWJhc2UgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFF1ZXJ5IHtcbiAgc3RhdGljIHNldCBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yKHZhbCkge1xuICAgIF9fcmVmZXJlbmNlQ29uc3RydWN0b3IgPSB2YWw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IF9fcmVmZXJlbmNlQ29uc3RydWN0b3IoKSB7XG4gICAgYXNzZXJ0KF9fcmVmZXJlbmNlQ29uc3RydWN0b3IsICdSZWZlcmVuY2UudHMgaGFzIG5vdCBiZWVuIGxvYWRlZCcpO1xuICAgIHJldHVybiBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlcG86IFJlcG8sXG4gICAgcHVibGljIHBhdGg6IFBhdGgsXG4gICAgcHJpdmF0ZSBxdWVyeVBhcmFtc186IFF1ZXJ5UGFyYW1zLFxuICAgIHByaXZhdGUgb3JkZXJCeUNhbGxlZF86IGJvb2xlYW5cbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgc3RhcnQvZW5kIHZhbHVlcyBmb3IgcXVlcmllcy5cbiAgICogQHBhcmFtIHshUXVlcnlQYXJhbXN9IHBhcmFtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgdmFsaWRhdGVRdWVyeUVuZHBvaW50c18ocGFyYW1zOiBRdWVyeVBhcmFtcykge1xuICAgIGxldCBzdGFydE5vZGUgPSBudWxsO1xuICAgIGxldCBlbmROb2RlID0gbnVsbDtcbiAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcbiAgICAgIHN0YXJ0Tm9kZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5oYXNFbmQoKSkge1xuICAgICAgZW5kTm9kZSA9IHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5nZXRJbmRleCgpID09PSBLRVlfSU5ERVgpIHtcbiAgICAgIGNvbnN0IHRvb01hbnlBcmdzRXJyb3IgPVxuICAgICAgICAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gJyArXG4gICAgICAgICdzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS4nO1xuICAgICAgY29uc3Qgd3JvbmdBcmdUeXBlRXJyb3IgPVxuICAgICAgICAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwnICtcbiAgICAgICAgJ29yIGVxdWFsVG8oKSBtdXN0IGJlIGEgc3RyaW5nLic7XG4gICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnROYW1lID0gcGFyYW1zLmdldEluZGV4U3RhcnROYW1lKCk7XG4gICAgICAgIGlmIChzdGFydE5hbWUgIT0gTUlOX05BTUUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodG9vTWFueUFyZ3NFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YXJ0Tm9kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iod3JvbmdBcmdUeXBlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XG4gICAgICAgIGNvbnN0IGVuZE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhFbmROYW1lKCk7XG4gICAgICAgIGlmIChlbmROYW1lICE9IE1BWF9OQU1FKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRvb01hbnlBcmdzRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmROb2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5nZXRJbmRleCgpID09PSBQUklPUklUWV9JTkRFWCkge1xuICAgICAgaWYgKFxuICAgICAgICAoc3RhcnROb2RlICE9IG51bGwgJiYgIWlzVmFsaWRQcmlvcml0eShzdGFydE5vZGUpKSB8fFxuICAgICAgICAoZW5kTm9kZSAhPSBudWxsICYmICFpc1ZhbGlkUHJpb3JpdHkoZW5kTm9kZSkpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdRdWVyeTogV2hlbiBvcmRlcmluZyBieSBwcmlvcml0eSwgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksICcgK1xuICAgICAgICAgICAgJ2VuZEF0KCksIG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgdmFsaWQgcHJpb3JpdHkgdmFsdWUgKG51bGwsIGEgbnVtYmVyLCBvciBhIHN0cmluZykuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtcy5nZXRJbmRleCgpIGluc3RhbmNlb2YgUGF0aEluZGV4IHx8XG4gICAgICAgICAgcGFyYW1zLmdldEluZGV4KCkgPT09IFZBTFVFX0lOREVYLFxuICAgICAgICAndW5rbm93biBpbmRleCB0eXBlLidcbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIChzdGFydE5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RhcnROb2RlID09PSAnb2JqZWN0JykgfHxcbiAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiB0eXBlb2YgZW5kTm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdRdWVyeTogRmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpIGNhbm5vdCBiZSAnICtcbiAgICAgICAgICAgICdhbiBvYmplY3QuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCBsaW1pdCogaGFzIGJlZW4gY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgY29tYmluYXRpb24gb2YgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyB2YWxpZGF0ZUxpbWl0XyhwYXJhbXM6IFF1ZXJ5UGFyYW1zKSB7XG4gICAgaWYgKFxuICAgICAgcGFyYW1zLmhhc1N0YXJ0KCkgJiZcbiAgICAgIHBhcmFtcy5oYXNFbmQoKSAmJlxuICAgICAgcGFyYW1zLmhhc0xpbWl0KCkgJiZcbiAgICAgICFwYXJhbXMuaGFzQW5jaG9yZWRMaW1pdCgpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiUXVlcnk6IENhbid0IGNvbWJpbmUgc3RhcnRBdCgpLCBlbmRBdCgpLCBhbmQgbGltaXQoKS4gVXNlIGxpbWl0VG9GaXJzdCgpIG9yIGxpbWl0VG9MYXN0KCkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgbm8gb3RoZXIgb3JkZXIgYnkgY2FsbCBoYXMgYmVlbiBtYWRlXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZm5OYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsXyhmbk5hbWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLm9yZGVyQnlDYWxsZWRfID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZm5OYW1lICsgXCI6IFlvdSBjYW4ndCBjb21iaW5lIG11bHRpcGxlIG9yZGVyQnkgY2FsbHMuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshUXVlcnlQYXJhbXN9XG4gICAqL1xuICBnZXRRdWVyeVBhcmFtcygpOiBRdWVyeVBhcmFtcyB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlQYXJhbXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFSZWZlcmVuY2V9XG4gICAqL1xuICBnZXRSZWYoKTogUmVmZXJlbmNlIHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5yZWYnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAvLyBUaGlzIGlzIGEgc2xpZ2h0IGhhY2suIFdlIGNhbm5vdCBnb29nLnJlcXVpcmUoJ2ZiLmFwaS5GaXJlYmFzZScpLCBzaW5jZSBGaXJlYmFzZSByZXF1aXJlcyBmYi5hcGkuUXVlcnkuXG4gICAgLy8gSG93ZXZlciwgd2Ugd2lsbCBhbHdheXMgZXhwb3J0ICdGaXJlYmFzZScgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2UsIHNvIGl0J3MgZ3VhcmFudGVlZCB0byBleGlzdCBieSB0aGUgdGltZSB0aGlzXG4gICAgLy8gbWV0aG9kIGdldHMgY2FsbGVkLlxuICAgIHJldHVybiBuZXcgUXVlcnkuX19yZWZlcmVuY2VDb25zdHJ1Y3Rvcih0aGlzLnJlcG8sIHRoaXMucGF0aCkgYXMgUmVmZXJlbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKERhdGFTbmFwc2hvdCwgc3RyaW5nPSl9IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7KGZ1bmN0aW9uKEVycm9yKXxPYmplY3QpPX0gY2FuY2VsQ2FsbGJhY2tPckNvbnRleHRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBjb250ZXh0XG4gICAqIEByZXR1cm4geyFmdW5jdGlvbihEYXRhU25hcHNob3QsIHN0cmluZz0pfVxuICAgKi9cbiAgb24oXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IFNuYXBzaG90Q2FsbGJhY2ssXG4gICAgY2FuY2VsQ2FsbGJhY2tPckNvbnRleHQ/OiAoKGE6IEVycm9yKSA9PiBhbnkpIHwgT2JqZWN0IHwgbnVsbCxcbiAgICBjb250ZXh0PzogT2JqZWN0IHwgbnVsbFxuICApOiBTbmFwc2hvdENhbGxiYWNrIHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vbicsIDIsIDQsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHZhbGlkYXRlRXZlbnRUeXBlKCdRdWVyeS5vbicsIDEsIGV2ZW50VHlwZSwgZmFsc2UpO1xuICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1F1ZXJ5Lm9uJywgMiwgY2FsbGJhY2ssIGZhbHNlKTtcblxuICAgIGNvbnN0IHJldCA9IFF1ZXJ5LmdldENhbmNlbEFuZENvbnRleHRBcmdzXyhcbiAgICAgICdRdWVyeS5vbicsXG4gICAgICBjYW5jZWxDYWxsYmFja09yQ29udGV4dCxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuXG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgdGhpcy5vblZhbHVlRXZlbnQoY2FsbGJhY2ssIHJldC5jYW5jZWwsIHJldC5jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2FsbGJhY2tzOiB7IFtrOiBzdHJpbmddOiB0eXBlb2YgY2FsbGJhY2sgfSA9IHt9O1xuICAgICAgY2FsbGJhY2tzW2V2ZW50VHlwZV0gPSBjYWxsYmFjaztcbiAgICAgIHRoaXMub25DaGlsZEV2ZW50KGNhbGxiYWNrcywgcmV0LmNhbmNlbCwgcmV0LmNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oIURhdGFTbmFwc2hvdCl9IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9uKEVycm9yKX0gY2FuY2VsQ2FsbGJhY2tcbiAgICogQHBhcmFtIHs/T2JqZWN0fSBjb250ZXh0XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RlY3RlZCBvblZhbHVlRXZlbnQoXG4gICAgY2FsbGJhY2s6IChhOiBEYXRhU25hcHNob3QpID0+IHZvaWQsXG4gICAgY2FuY2VsQ2FsbGJhY2s6ICgoYTogRXJyb3IpID0+IHZvaWQpIHwgbnVsbCxcbiAgICBjb250ZXh0OiBPYmplY3QgfCBudWxsXG4gICkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBjYW5jZWxDYWxsYmFjayB8fCBudWxsLFxuICAgICAgY29udGV4dCB8fCBudWxsXG4gICAgKTtcbiAgICB0aGlzLnJlcG8uYWRkRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHRoaXMsIGNvbnRhaW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFmdW5jdGlvbighRGF0YVNuYXBzaG90LCA/c3RyaW5nKT59IGNhbGxiYWNrc1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbihFcnJvcil9IGNhbmNlbENhbGxiYWNrXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29udGV4dFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBvbkNoaWxkRXZlbnQoXG4gICAgY2FsbGJhY2tzOiB7IFtrOiBzdHJpbmddOiBTbmFwc2hvdENhbGxiYWNrIH0sXG4gICAgY2FuY2VsQ2FsbGJhY2s6ICgoYTogRXJyb3IpID0+IGFueSkgfCBudWxsLFxuICAgIGNvbnRleHQ6IE9iamVjdCB8IG51bGxcbiAgKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENoaWxkRXZlbnRSZWdpc3RyYXRpb24oXG4gICAgICBjYWxsYmFja3MsXG4gICAgICBjYW5jZWxDYWxsYmFjayxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHRoaXMucmVwby5hZGRFdmVudENhbGxiYWNrRm9yUXVlcnkodGhpcywgY29udGFpbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IGV2ZW50VHlwZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbighRGF0YVNuYXBzaG90LCA/c3RyaW5nPSkpPX0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBjb250ZXh0XG4gICAqL1xuICBvZmYoXG4gICAgZXZlbnRUeXBlPzogc3RyaW5nLFxuICAgIGNhbGxiYWNrPzogU25hcHNob3RDYWxsYmFjayxcbiAgICBjb250ZXh0PzogT2JqZWN0IHwgbnVsbFxuICApOiB2b2lkIHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vZmYnLCAwLCAzLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YWxpZGF0ZUV2ZW50VHlwZSgnUXVlcnkub2ZmJywgMSwgZXZlbnRUeXBlLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUNhbGxiYWNrKCdRdWVyeS5vZmYnLCAyLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgdmFsaWRhdGVDb250ZXh0T2JqZWN0KCdRdWVyeS5vZmYnLCAzLCBjb250ZXh0LCB0cnVlKTtcblxuICAgIGxldCBjb250YWluZXI6IEV2ZW50UmVnaXN0cmF0aW9uIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGNhbGxiYWNrczogeyBbazogc3RyaW5nXTogdHlwZW9mIGNhbGxiYWNrIH0gfCBudWxsID0gbnVsbDtcbiAgICBpZiAoZXZlbnRUeXBlID09PSAndmFsdWUnKSB7XG4gICAgICBjb25zdCB2YWx1ZUNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbnVsbDtcbiAgICAgIGNvbnRhaW5lciA9IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKFxuICAgICAgICB2YWx1ZUNhbGxiYWNrLFxuICAgICAgICBudWxsLFxuICAgICAgICBjb250ZXh0IHx8IG51bGxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFja3MgPSB7fTtcbiAgICAgICAgY2FsbGJhY2tzW2V2ZW50VHlwZV0gPSBjYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lciA9IG5ldyBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrcywgbnVsbCwgY29udGV4dCB8fCBudWxsKTtcbiAgICB9XG4gICAgdGhpcy5yZXBvLnJlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeSh0aGlzLCBjb250YWluZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGEgbGlzdGVuZXIsIHdhaXRzIGZvciB0aGUgZmlyc3QgZXZlbnQsIGFuZCB0aGVuIHJlbW92ZXMgdGhlIGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFEYXRhU25hcHNob3QsIHN0cmluZz0pfSB1c2VyQ2FsbGJhY2tcbiAgICogQHBhcmFtIGZhaWx1cmVDYWxsYmFja09yQ29udGV4dFxuICAgKiBAcGFyYW0gY29udGV4dFxuICAgKiBAcmV0dXJuIHshZmlyZWJhc2UuUHJvbWlzZX1cbiAgICovXG4gIG9uY2UoXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgdXNlckNhbGxiYWNrPzogU25hcHNob3RDYWxsYmFjayxcbiAgICBmYWlsdXJlQ2FsbGJhY2tPckNvbnRleHQ/OiAoKGE6IEVycm9yKSA9PiB2b2lkKSB8IE9iamVjdCB8IG51bGwsXG4gICAgY29udGV4dD86IE9iamVjdCB8IG51bGxcbiAgKTogUHJvbWlzZTxEYXRhU25hcHNob3Q+IHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vbmNlJywgMSwgNCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdmFsaWRhdGVFdmVudFR5cGUoJ1F1ZXJ5Lm9uY2UnLCAxLCBldmVudFR5cGUsIGZhbHNlKTtcbiAgICB2YWxpZGF0ZUNhbGxiYWNrKCdRdWVyeS5vbmNlJywgMiwgdXNlckNhbGxiYWNrLCB0cnVlKTtcblxuICAgIGNvbnN0IHJldCA9IFF1ZXJ5LmdldENhbmNlbEFuZENvbnRleHRBcmdzXyhcbiAgICAgICdRdWVyeS5vbmNlJyxcbiAgICAgIGZhaWx1cmVDYWxsYmFja09yQ29udGV4dCxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IHRoaXMgbW9yZSBlZmZpY2llbnRseSAoaW4gcGFydGljdWxhciwgdXNlICdnZXQnIHdpcmUgcHJvdG9jb2wgZm9yICd2YWx1ZScgZXZlbnQpXG4gICAgLy8gVE9ETzogY29uc2lkZXIgYWN0dWFsbHkgd2lyaW5nIHRoZSBjYWxsYmFja3MgaW50byB0aGUgcHJvbWlzZS4gV2UgY2Fubm90IGRvIHRoaXMgd2l0aG91dCBhIGJyZWFraW5nIGNoYW5nZVxuICAgIC8vIGJlY2F1c2UgdGhlIEFQSSBjdXJyZW50bHkgZXhwZWN0cyBjYWxsYmFja3Mgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBpZiB0aGUgZGF0YSBpcyBjYWNoZWQsIGJ1dCB0aGlzIGlzXG4gICAgLy8gYWdhaW5zdCB0aGUgUHJvbWlzZSBzcGVjaWZpY2F0aW9uLlxuICAgIGxldCBmaXJzdENhbGwgPSB0cnVlO1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkPERhdGFTbmFwc2hvdD4oKTtcblxuICAgIC8vIEEgZHVtbXkgZXJyb3IgaGFuZGxlciBpbiBjYXNlIGEgdXNlciB3YXNuJ3QgZXhwZWN0aW5nIHByb21pc2VzXG4gICAgZGVmZXJyZWQucHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG5cbiAgICBjb25zdCBvbmNlQ2FsbGJhY2sgPSAoc25hcHNob3Q6IERhdGFTbmFwc2hvdCkgPT4ge1xuICAgICAgLy8gTk9URTogRXZlbiB0aG91Z2ggd2UgdW5zdWJzY3JpYmUsIHdlIG1heSBnZXQgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGlmIGEgc2luZ2xlIGFjdGlvbiAoZS5nLiBzZXQoKSB3aXRoIEpTT04pXG4gICAgICAvLyB0cmlnZ2VycyBtdWx0aXBsZSBldmVudHMgKGUuZy4gY2hpbGRfYWRkZWQgb3IgY2hpbGRfY2hhbmdlZCkuXG4gICAgICBpZiAoZmlyc3RDYWxsKSB7XG4gICAgICAgIGZpcnN0Q2FsbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9mZihldmVudFR5cGUsIG9uY2VDYWxsYmFjayk7XG5cbiAgICAgICAgaWYgKHVzZXJDYWxsYmFjaykge1xuICAgICAgICAgIHVzZXJDYWxsYmFjay5iaW5kKHJldC5jb250ZXh0KShzbmFwc2hvdCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzbmFwc2hvdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub24oXG4gICAgICBldmVudFR5cGUsXG4gICAgICBvbmNlQ2FsbGJhY2ssXG4gICAgICAvKmNhbmNlbD0qLyBlcnIgPT4ge1xuICAgICAgICB0aGlzLm9mZihldmVudFR5cGUsIG9uY2VDYWxsYmFjayk7XG5cbiAgICAgICAgaWYgKHJldC5jYW5jZWwpIHJldC5jYW5jZWwuYmluZChyZXQuY29udGV4dCkoZXJyKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBsaW1pdCBhbmQgYW5jaG9yIGl0IHRvIHRoZSBzdGFydCBvZiB0aGUgd2luZG93LlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IGxpbWl0XG4gICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICovXG4gIGxpbWl0VG9GaXJzdChsaW1pdDogbnVtYmVyKTogUXVlcnkge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LmxpbWl0VG9GaXJzdCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHxcbiAgICAgIE1hdGguZmxvb3IobGltaXQpICE9PSBsaW1pdCB8fFxuICAgICAgbGltaXQgPD0gMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnUXVlcnkubGltaXRUb0ZpcnN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5xdWVyeVBhcmFtc18uaGFzTGltaXQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnUXVlcnkubGltaXRUb0ZpcnN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgJyArXG4gICAgICAgICAgJ2xpbWl0VG9GaXJzdCwgb3IgbGltaXRUb0xhc3QpLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBRdWVyeShcbiAgICAgIHRoaXMucmVwbyxcbiAgICAgIHRoaXMucGF0aCxcbiAgICAgIHRoaXMucXVlcnlQYXJhbXNfLmxpbWl0VG9GaXJzdChsaW1pdCksXG4gICAgICB0aGlzLm9yZGVyQnlDYWxsZWRfXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBsaW1pdCBhbmQgYW5jaG9yIGl0IHRvIHRoZSBlbmQgb2YgdGhlIHdpbmRvdy5cbiAgICogQHBhcmFtIHshbnVtYmVyfSBsaW1pdFxuICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAqL1xuICBsaW1pdFRvTGFzdChsaW1pdDogbnVtYmVyKTogUXVlcnkge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LmxpbWl0VG9MYXN0JywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgTWF0aC5mbG9vcihsaW1pdCkgIT09IGxpbWl0IHx8XG4gICAgICBsaW1pdCA8PSAwXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdRdWVyeS5saW1pdFRvTGFzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucXVlcnlQYXJhbXNfLmhhc0xpbWl0KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1F1ZXJ5LmxpbWl0VG9MYXN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgJyArXG4gICAgICAgICAgJ2xpbWl0VG9GaXJzdCwgb3IgbGltaXRUb0xhc3QpLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBRdWVyeShcbiAgICAgIHRoaXMucmVwbyxcbiAgICAgIHRoaXMucGF0aCxcbiAgICAgIHRoaXMucXVlcnlQYXJhbXNfLmxpbWl0VG9MYXN0KGxpbWl0KSxcbiAgICAgIHRoaXMub3JkZXJCeUNhbGxlZF9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgY2hpbGQgcGF0aCwgcmV0dXJuIGEgbmV3IHF1ZXJ5IG9yZGVyZWQgYnkgdGhlIHNwZWNpZmllZCBncmFuZGNoaWxkIHBhdGguXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aFxuICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAqL1xuICBvcmRlckJ5Q2hpbGQocGF0aDogc3RyaW5nKTogUXVlcnkge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGlmIChwYXRoID09PSAnJGtleScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIka2V5XCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5S2V5KCkgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJyRwcmlvcml0eScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIkcHJpb3JpdHlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlQcmlvcml0eSgpIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHBhdGggPT09ICckdmFsdWUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHZhbHVlXCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHZhbGlkYXRlUGF0aFN0cmluZygnUXVlcnkub3JkZXJCeUNoaWxkJywgMSwgcGF0aCwgZmFsc2UpO1xuICAgIHRoaXMudmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGxfKCdRdWVyeS5vcmRlckJ5Q2hpbGQnKTtcbiAgICBjb25zdCBwYXJzZWRQYXRoID0gbmV3IFBhdGgocGF0aCk7XG4gICAgaWYgKHBhcnNlZFBhdGguaXNFbXB0eSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdRdWVyeS5vcmRlckJ5Q2hpbGQ6IGNhbm5vdCBwYXNzIGluIGVtcHR5IHBhdGguICBVc2UgUXVlcnkub3JkZXJCeVZhbHVlKCkgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IG5ldyBQYXRoSW5kZXgocGFyc2VkUGF0aCk7XG4gICAgY29uc3QgbmV3UGFyYW1zID0gdGhpcy5xdWVyeVBhcmFtc18ub3JkZXJCeShpbmRleCk7XG4gICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18obmV3UGFyYW1zKTtcblxuICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5yZXBvLCB0aGlzLnBhdGgsIG5ld1BhcmFtcywgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBLZXlJbmRleFxuICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAqL1xuICBvcmRlckJ5S2V5KCk6IFF1ZXJ5IHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vcmRlckJ5S2V5JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdGhpcy52YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbF8oJ1F1ZXJ5Lm9yZGVyQnlLZXknKTtcbiAgICBjb25zdCBuZXdQYXJhbXMgPSB0aGlzLnF1ZXJ5UGFyYW1zXy5vcmRlckJ5KEtFWV9JTkRFWCk7XG4gICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18obmV3UGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgcXVlcnkgb3JkZXJlZCBieSB0aGUgUHJpb3JpdHlJbmRleFxuICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAqL1xuICBvcmRlckJ5UHJpb3JpdHkoKTogUXVlcnkge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9yZGVyQnlQcmlvcml0eScsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHRoaXMudmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGxfKCdRdWVyeS5vcmRlckJ5UHJpb3JpdHknKTtcbiAgICBjb25zdCBuZXdQYXJhbXMgPSB0aGlzLnF1ZXJ5UGFyYW1zXy5vcmRlckJ5KFBSSU9SSVRZX0lOREVYKTtcbiAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5yZXBvLCB0aGlzLnBhdGgsIG5ld1BhcmFtcywgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBWYWx1ZUluZGV4XG4gICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICovXG4gIG9yZGVyQnlWYWx1ZSgpOiBRdWVyeSB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub3JkZXJCeVZhbHVlJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdGhpcy52YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbF8oJ1F1ZXJ5Lm9yZGVyQnlWYWx1ZScpO1xuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHRoaXMucXVlcnlQYXJhbXNfLm9yZGVyQnkoVkFMVUVfSU5ERVgpO1xuICAgIFF1ZXJ5LnZhbGlkYXRlUXVlcnlFbmRwb2ludHNfKG5ld1BhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLnJlcG8sIHRoaXMucGF0aCwgbmV3UGFyYW1zLCAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfGJvb2xlYW58bnVsbH0gdmFsdWVcbiAgICogQHBhcmFtIHs/c3RyaW5nPX0gbmFtZVxuICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAqL1xuICBzdGFydEF0KFxuICAgIHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCBib29sZWFuIHwgbnVsbCA9IG51bGwsXG4gICAgbmFtZT86IHN0cmluZyB8IG51bGxcbiAgKTogUXVlcnkge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LnN0YXJ0QXQnLCAwLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnUXVlcnkuc3RhcnRBdCcsIDEsIHZhbHVlLCB0aGlzLnBhdGgsIHRydWUpO1xuICAgIHZhbGlkYXRlS2V5KCdRdWVyeS5zdGFydEF0JywgMiwgbmFtZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBuZXdQYXJhbXMgPSB0aGlzLnF1ZXJ5UGFyYW1zXy5zdGFydEF0KHZhbHVlLCBuYW1lKTtcbiAgICBRdWVyeS52YWxpZGF0ZUxpbWl0XyhuZXdQYXJhbXMpO1xuICAgIFF1ZXJ5LnZhbGlkYXRlUXVlcnlFbmRwb2ludHNfKG5ld1BhcmFtcyk7XG4gICAgaWYgKHRoaXMucXVlcnlQYXJhbXNfLmhhc1N0YXJ0KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1F1ZXJ5LnN0YXJ0QXQ6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQgJyArXG4gICAgICAgICAgJ29yIGVxdWFsVG8pLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGluZyB3aXRoIG5vIHBhcmFtcyB0ZWxscyB1cyB0byBzdGFydCBhdCB0aGUgYmVnaW5uaW5nLlxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLnJlcG8sIHRoaXMucGF0aCwgbmV3UGFyYW1zLCB0aGlzLm9yZGVyQnlDYWxsZWRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8Ym9vbGVhbnxudWxsfSB2YWx1ZVxuICAgKiBAcGFyYW0gez9zdHJpbmc9fSBuYW1lXG4gICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICovXG4gIGVuZEF0KFxuICAgIHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCBib29sZWFuIHwgbnVsbCA9IG51bGwsXG4gICAgbmFtZT86IHN0cmluZyB8IG51bGxcbiAgKTogUXVlcnkge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LmVuZEF0JywgMCwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ1F1ZXJ5LmVuZEF0JywgMSwgdmFsdWUsIHRoaXMucGF0aCwgdHJ1ZSk7XG4gICAgdmFsaWRhdGVLZXkoJ1F1ZXJ5LmVuZEF0JywgMiwgbmFtZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBuZXdQYXJhbXMgPSB0aGlzLnF1ZXJ5UGFyYW1zXy5lbmRBdCh2YWx1ZSwgbmFtZSk7XG4gICAgUXVlcnkudmFsaWRhdGVMaW1pdF8obmV3UGFyYW1zKTtcbiAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNFbmQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnUXVlcnkuZW5kQXQ6IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciAnICtcbiAgICAgICAgICAnZXF1YWxUbykuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIHRoaXMub3JkZXJCeUNhbGxlZF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIHNlbGVjdGlvbiBvZiBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZSwgYW5kLCBvcHRpb25hbGx5LFxuICAgKiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xib29sZWFufG51bGx9IHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZVxuICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAqL1xuICBlcXVhbFRvKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCBib29sZWFuIHwgbnVsbCwgbmFtZT86IHN0cmluZykge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LmVxdWFsVG8nLCAxLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnUXVlcnkuZXF1YWxUbycsIDEsIHZhbHVlLCB0aGlzLnBhdGgsIGZhbHNlKTtcbiAgICB2YWxpZGF0ZUtleSgnUXVlcnkuZXF1YWxUbycsIDIsIG5hbWUsIHRydWUpO1xuICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNTdGFydCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdRdWVyeS5lcXVhbFRvOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0IG9yICcgK1xuICAgICAgICAgICdlcXVhbFRvKS4nXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5xdWVyeVBhcmFtc18uaGFzRW5kKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1F1ZXJ5LmVxdWFsVG86IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciAnICtcbiAgICAgICAgICAnZXF1YWxUbykuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRBdCh2YWx1ZSwgbmFtZSkuZW5kQXQodmFsdWUsIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFzdHJpbmd9IFVSTCBmb3IgdGhpcyBsb2NhdGlvbi5cbiAgICovXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkudG9TdHJpbmcnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgIHJldHVybiB0aGlzLnJlcG8udG9TdHJpbmcoKSArIHRoaXMucGF0aC50b1VybEVuY29kZWRTdHJpbmcoKTtcbiAgfVxuXG4gIC8vIERvIG5vdCBjcmVhdGUgcHVibGljIGRvY3VtZW50YXRpb24uIFRoaXMgaXMgaW50ZW5kZWQgdG8gbWFrZSBKU09OIHNlcmlhbGl6YXRpb24gd29yayBidXQgaXMgb3RoZXJ3aXNlIHVubmVjZXNzYXJ5XG4gIC8vIGZvciBlbmQtdXNlcnMuXG4gIHRvSlNPTigpIHtcbiAgICAvLyBBbiBvcHRpb25hbCBzcGFjZXIgYXJndW1lbnQgaXMgdW5uZWNlc3NhcnkgZm9yIGEgc3RyaW5nLlxuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LnRvSlNPTicsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHVzZWQgYnkgdGhpcyBRdWVyeS5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG4gIHF1ZXJ5T2JqZWN0KCk6IE9iamVjdCB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlQYXJhbXNfLmdldFF1ZXJ5T2JqZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IXN0cmluZ31cbiAgICovXG4gIHF1ZXJ5SWRlbnRpZmllcigpOiBzdHJpbmcge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMucXVlcnlPYmplY3QoKTtcbiAgICBjb25zdCBpZCA9IE9iamVjdFRvVW5pcXVlS2V5KG9iaik7XG4gICAgcmV0dXJuIGlkID09PSAne30nID8gJ2RlZmF1bHQnIDogaWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgdGhpcyBxdWVyeSBhbmQgdGhlIHByb3ZpZGVkIHF1ZXJ5IGFyZSBlcXVpdmFsZW50OyBvdGhlcndpc2UsIHJldHVybiBmYWxzZS5cbiAgICogQHBhcmFtIHtRdWVyeX0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRXF1YWwob3RoZXI6IFF1ZXJ5KTogYm9vbGVhbiB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuaXNFcXVhbCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUXVlcnkpKSB7XG4gICAgICBjb25zdCBlcnJvciA9XG4gICAgICAgICdRdWVyeS5pc0VxdWFsIGZhaWxlZDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBmaXJlYmFzZS5kYXRhYmFzZS5RdWVyeS4nO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICBjb25zdCBzYW1lUmVwbyA9IHRoaXMucmVwbyA9PT0gb3RoZXIucmVwbztcbiAgICBjb25zdCBzYW1lUGF0aCA9IHRoaXMucGF0aC5lcXVhbHMob3RoZXIucGF0aCk7XG4gICAgY29uc3Qgc2FtZVF1ZXJ5SWRlbnRpZmllciA9XG4gICAgICB0aGlzLnF1ZXJ5SWRlbnRpZmllcigpID09PSBvdGhlci5xdWVyeUlkZW50aWZpZXIoKTtcblxuICAgIHJldHVybiBzYW1lUmVwbyAmJiBzYW1lUGF0aCAmJiBzYW1lUXVlcnlJZGVudGlmaWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB1c2VkIGJ5IC5vbiBhbmQgLm9uY2UgdG8gZXh0cmFjdCB0aGUgY29udGV4dCBhbmQgb3IgY2FuY2VsIGFyZ3VtZW50cy5cbiAgICogQHBhcmFtIHshc3RyaW5nfSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWUgKG9uIG9yIG9uY2UpXG4gICAqIEBwYXJhbSB7KGZ1bmN0aW9uKEVycm9yKXxPYmplY3QpPX0gY2FuY2VsT3JDb250ZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dFxuICAgKiBAcmV0dXJuIHt7Y2FuY2VsOiA/ZnVuY3Rpb24oRXJyb3IpLCBjb250ZXh0OiA/T2JqZWN0fX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldENhbmNlbEFuZENvbnRleHRBcmdzXyhcbiAgICBmbk5hbWU6IHN0cmluZyxcbiAgICBjYW5jZWxPckNvbnRleHQ/OiAoKGE6IEVycm9yKSA9PiB2b2lkKSB8IE9iamVjdCB8IG51bGwsXG4gICAgY29udGV4dD86IE9iamVjdCB8IG51bGxcbiAgKTogeyBjYW5jZWw6ICgoYTogRXJyb3IpID0+IHZvaWQpIHwgbnVsbDsgY29udGV4dDogT2JqZWN0IHwgbnVsbCB9IHtcbiAgICBjb25zdCByZXQ6IHtcbiAgICAgIGNhbmNlbDogKChhOiBFcnJvcikgPT4gdm9pZCkgfCBudWxsO1xuICAgICAgY29udGV4dDogT2JqZWN0IHwgbnVsbDtcbiAgICB9ID0geyBjYW5jZWw6IG51bGwsIGNvbnRleHQ6IG51bGwgfTtcbiAgICBpZiAoY2FuY2VsT3JDb250ZXh0ICYmIGNvbnRleHQpIHtcbiAgICAgIHJldC5jYW5jZWwgPSBjYW5jZWxPckNvbnRleHQgYXMgKGE6IEVycm9yKSA9PiB2b2lkO1xuICAgICAgdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIDMsIHJldC5jYW5jZWwsIHRydWUpO1xuXG4gICAgICByZXQuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB2YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCA0LCByZXQuY29udGV4dCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChjYW5jZWxPckNvbnRleHQpIHtcbiAgICAgIC8vIHdlIGhhdmUgZWl0aGVyIGEgY2FuY2VsIGNhbGxiYWNrIG9yIGEgY29udGV4dC5cbiAgICAgIGlmICh0eXBlb2YgY2FuY2VsT3JDb250ZXh0ID09PSAnb2JqZWN0JyAmJiBjYW5jZWxPckNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gaXQncyBhIGNvbnRleHQhXG4gICAgICAgIHJldC5jb250ZXh0ID0gY2FuY2VsT3JDb250ZXh0O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2FuY2VsT3JDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldC5jYW5jZWwgPSBjYW5jZWxPckNvbnRleHQgYXMgKGE6IEVycm9yKSA9PiB2b2lkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGVycm9yUHJlZml4KGZuTmFtZSwgMywgdHJ1ZSkgK1xuICAgICAgICAgICAgJyBtdXN0IGVpdGhlciBiZSBhIGNhbmNlbCBjYWxsYmFjayBvciBhIGNvbnRleHQgb2JqZWN0LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGdldCByZWYoKTogUmVmZXJlbmNlIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWYoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGlzRW1wdHksIGdldENvdW50LCBmb3JFYWNoLCBjb250YWlucyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgc2V0IHdpdGggYSBjb3VudCBvZiBlbGVtZW50cy5cbiAqXG4gKiBAdGVtcGxhdGUgSywgVlxuICovXG5leHBvcnQgY2xhc3MgQ291bnRlZFNldDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBWPiB7XG4gIHNldDogeyBbazogc3RyaW5nXTogViB9ID0ge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUt9IGl0ZW1cbiAgICogQHBhcmFtIHtWfSB2YWxcbiAgICovXG4gIGFkZChpdGVtOiBLLCB2YWw6IFYpIHtcbiAgICB0aGlzLnNldFtpdGVtIGFzIGFueV0gPSB2YWwgIT09IG51bGwgPyB2YWwgOiAodHJ1ZSBhcyBhbnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUt9IGtleVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbnMoa2V5OiBLKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zKHRoaXMuc2V0LCBrZXkgYXMgc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFLfSBpdGVtXG4gICAqIEByZXR1cm4ge1Z9XG4gICAqL1xuICBnZXQoaXRlbTogSyk6IFYgfCB2b2lkIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWlucyhpdGVtKSA/IHRoaXMuc2V0W2l0ZW0gYXMgYW55XSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFLfSBpdGVtXG4gICAqL1xuICByZW1vdmUoaXRlbTogSykge1xuICAgIGRlbGV0ZSB0aGlzLnNldFtpdGVtIGFzIGFueV07XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBldmVyeXRoaW5nIGluIHRoZSBzZXRcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuc2V0ID0ge307XG4gIH1cblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHNldFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNFbXB0eSh0aGlzLnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzZXRcbiAgICovXG4gIGNvdW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGdldENvdW50KHRoaXMuc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gYSBmdW5jdGlvbiBvbiBlYWNoIGssdiBwYWlyIGluIHRoZSBzZXRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihLLCBWKX0gZm5cbiAgICovXG4gIGVhY2goZm46IChrOiBLIHwgc3RyaW5nLCB2OiBWKSA9PiB2b2lkKSB7XG4gICAgZm9yRWFjaCh0aGlzLnNldCwgKGs6IHN0cmluZywgdjogVikgPT4gZm4oaywgdikpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vc3RseSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge0FycmF5LjxLPn0gVGhlIGtleXMgcHJlc2VudCBpbiB0aGlzIENvdW50ZWRTZXRcbiAgICovXG4gIGtleXMoKTogS1tdIHtcbiAgICBjb25zdCBrZXlzOiBLW10gPSBbXTtcbiAgICBmb3JFYWNoKHRoaXMuc2V0LCAoazogc3RyaW5nKSA9PiB7XG4gICAgICBrZXlzLnB1c2goayBhcyBLKTtcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFBhdGggfSBmcm9tICcuL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBQUklPUklUWV9JTkRFWCB9IGZyb20gJy4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuaW1wb3J0IHsgQ291bnRlZFNldCB9IGZyb20gJy4vdXRpbC9Db3VudGVkU2V0JztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL3NuYXAvTm9kZSc7XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIHN0b3JlIGEgc3BhcnNlIHNldCBvZiBzbmFwc2hvdHMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGFyc2VTbmFwc2hvdFRyZWUge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge05vZGV9XG4gICAqL1xuICBwcml2YXRlIHZhbHVlXzogTm9kZSB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Q291bnRlZFNldH1cbiAgICovXG4gIHByaXZhdGUgY2hpbGRyZW5fOiBDb3VudGVkU2V0PHN0cmluZywgU3BhcnNlU25hcHNob3RUcmVlPiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBub2RlIHN0b3JlZCBhdCB0aGUgZ2l2ZW4gcGF0aCBpZiBvbmUgZXhpc3RzLlxuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFBhdGggdG8gbG9vayB1cCBzbmFwc2hvdCBmb3IuXG4gICAqIEByZXR1cm4gez9Ob2RlfSBUaGUgcmV0cmlldmVkIG5vZGUsIG9yIG51bGwuXG4gICAqL1xuICBmaW5kKHBhdGg6IFBhdGgpOiBOb2RlIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMudmFsdWVfICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXy5nZXRDaGlsZChwYXRoKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoLmlzRW1wdHkoKSAmJiB0aGlzLmNoaWxkcmVuXyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICAgIHBhdGggPSBwYXRoLnBvcEZyb250KCk7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbl8uY29udGFpbnMoY2hpbGRLZXkpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZEtleSkgYXMgU3BhcnNlU25hcHNob3RUcmVlO1xuICAgICAgICByZXR1cm4gY2hpbGRUcmVlLmZpbmQocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gbm9kZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGguIElmIHRoZXJlIGlzIGFscmVhZHkgYSBub2RlXG4gICAqIGF0IGEgc2hhbGxvd2VyIHBhdGgsIGl0IG1lcmdlcyB0aGUgbmV3IGRhdGEgaW50byB0aGF0IHNuYXBzaG90IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cbiAgICogQHBhcmFtIHshTm9kZX0gZGF0YSBUaGUgbmV3IGRhdGEsIG9yIG51bGwuXG4gICAqL1xuICByZW1lbWJlcihwYXRoOiBQYXRoLCBkYXRhOiBOb2RlKSB7XG4gICAgaWYgKHBhdGguaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLnZhbHVlXyA9IGRhdGE7XG4gICAgICB0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlXyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy52YWx1ZV8gPSB0aGlzLnZhbHVlXy51cGRhdGVDaGlsZChwYXRoLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbl8gPSBuZXcgQ291bnRlZFNldDxzdHJpbmcsIFNwYXJzZVNuYXBzaG90VHJlZT4oKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoLmdldEZyb250KCk7XG4gICAgICBpZiAoIXRoaXMuY2hpbGRyZW5fLmNvbnRhaW5zKGNoaWxkS2V5KSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuXy5hZGQoY2hpbGRLZXksIG5ldyBTcGFyc2VTbmFwc2hvdFRyZWUoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkS2V5KSBhcyBTcGFyc2VTbmFwc2hvdFRyZWU7XG4gICAgICBwYXRoID0gcGF0aC5wb3BGcm9udCgpO1xuICAgICAgY2hpbGQucmVtZW1iZXIocGF0aCwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1cmdlIHRoZSBkYXRhIGF0IHBhdGggZnJvbSB0aGUgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIG5vZGUgc2hvdWxkIG5vdyBiZSByZW1vdmVkLlxuICAgKi9cbiAgZm9yZ2V0KHBhdGg6IFBhdGgpOiBib29sZWFuIHtcbiAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMudmFsdWVfID0gbnVsbDtcbiAgICAgIHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy52YWx1ZV8gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVfLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgIC8vIFdlJ3JlIHRyeWluZyB0byBmb3JnZXQgYSBub2RlIHRoYXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgICAgICAgIHRoaXMudmFsdWVfID0gbnVsbDtcblxuICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHZhbHVlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24oa2V5LCB0cmVlKSB7XG4gICAgICAgICAgICBzZWxmLnJlbWVtYmVyKG5ldyBQYXRoKGtleSksIHRyZWUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9yZ2V0KHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2hpbGRyZW5fICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICBwYXRoID0gcGF0aC5wb3BGcm9udCgpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uY29udGFpbnMoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgY29uc3Qgc2FmZVRvUmVtb3ZlID0gKHRoaXMuY2hpbGRyZW5fLmdldChcbiAgICAgICAgICAgIGNoaWxkS2V5XG4gICAgICAgICAgKSBhcyBTcGFyc2VTbmFwc2hvdFRyZWUpLmZvcmdldChwYXRoKTtcbiAgICAgICAgICBpZiAoc2FmZVRvUmVtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuXy5yZW1vdmUoY2hpbGRLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgb2YgdGhlIHN0b3JlZCB0cmVlIGFuZCBjYWxscyB0aGVcbiAgICogY2FsbGJhY2sgb24gZWFjaCBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHByZWZpeFBhdGggUGF0aCB0byBsb29rIHVwIG5vZGUgZm9yLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHRyZWUuXG4gICAqL1xuICBmb3JFYWNoVHJlZShwcmVmaXhQYXRoOiBQYXRoLCBmdW5jOiAoYTogUGF0aCwgYjogTm9kZSkgPT4gYW55KSB7XG4gICAgaWYgKHRoaXMudmFsdWVfICE9PSBudWxsKSB7XG4gICAgICBmdW5jKHByZWZpeFBhdGgsIHRoaXMudmFsdWVfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JFYWNoQ2hpbGQoKGtleSwgdHJlZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgocHJlZml4UGF0aC50b1N0cmluZygpICsgJy8nICsga2V5KTtcbiAgICAgICAgdHJlZS5mb3JFYWNoVHJlZShwYXRoLCBmdW5jKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggaW1tZWRpYXRlIGNoaWxkIGFuZCB0cmlnZ2VycyB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggY2hpbGQuXG4gICAqL1xuICBmb3JFYWNoQ2hpbGQoZnVuYzogKGE6IHN0cmluZywgYjogU3BhcnNlU25hcHNob3RUcmVlKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW5fICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuXy5lYWNoKChrZXksIHRyZWUpID0+IHtcbiAgICAgICAgZnVuYyhrZXksIHRyZWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgeyBTcGFyc2VTbmFwc2hvdFRyZWUgfSBmcm9tICcuLi9TcGFyc2VTbmFwc2hvdFRyZWUnO1xuaW1wb3J0IHsgTGVhZk5vZGUgfSBmcm9tICcuLi9zbmFwL0xlYWZOb2RlJztcbmltcG9ydCB7IG5vZGVGcm9tSlNPTiB9IGZyb20gJy4uL3NuYXAvbm9kZUZyb21KU09OJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL3NuYXAvTm9kZSc7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuLi9zbmFwL0NoaWxkcmVuTm9kZSc7XG5cbi8qKlxuICogR2VuZXJhdGUgcGxhY2Vob2xkZXJzIGZvciBkZWZlcnJlZCB2YWx1ZXMuXG4gKiBAcGFyYW0gez9PYmplY3R9IHZhbHVlc1xuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlV2l0aFZhbHVlcyA9IGZ1bmN0aW9uKFxuICB2YWx1ZXM6IHtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9IHwgbnVsbFxuKTogeyBbazogc3RyaW5nXTogYW55IH0ge1xuICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG4gIHZhbHVlc1sndGltZXN0YW1wJ10gPSB2YWx1ZXNbJ3RpbWVzdGFtcCddIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBWYWx1ZSB0byB1c2Ugd2hlbiBmaXJpbmcgbG9jYWwgZXZlbnRzLiBXaGVuIHdyaXRpbmcgc2VydmVyIHZhbHVlcywgZmlyZVxuICogbG9jYWwgZXZlbnRzIHdpdGggYW4gYXBwcm94aW1hdGUgdmFsdWUsIG90aGVyd2lzZSByZXR1cm4gdmFsdWUgYXMtaXMuXG4gKiBAcGFyYW0geyhPYmplY3R8c3RyaW5nfG51bWJlcnxib29sZWFuKX0gdmFsdWVcbiAqIEBwYXJhbSB7IU9iamVjdH0gc2VydmVyVmFsdWVzXG4gKiBAcmV0dXJuIHshKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbil9XG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uKFxuICB2YWx1ZTogeyBbazogc3RyaW5nXTogYW55IH0gfCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuLFxuICBzZXJ2ZXJWYWx1ZXM6IHsgW2s6IHN0cmluZ106IGFueSB9XG4pOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHZhbHVlIGFzIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW47XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KCcuc3YnIGluIHZhbHVlLCAnVW5leHBlY3RlZCBsZWFmIG5vZGUgb3IgcHJpb3JpdHkgY29udGVudHMnKTtcbiAgICByZXR1cm4gc2VydmVyVmFsdWVzW3ZhbHVlWycuc3YnXV07XG4gIH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgcmVwbGFjZSBhbGwgZGVmZXJyZWQgdmFsdWVzIGFuZCBwcmlvcml0aWVzIGluIHRoZSB0cmVlIHdpdGggdGhlXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy5cbiAqIEBwYXJhbSB7IVNwYXJzZVNuYXBzaG90VHJlZX0gdHJlZVxuICogQHBhcmFtIHshT2JqZWN0fSBzZXJ2ZXJWYWx1ZXNcbiAqIEByZXR1cm4geyFTcGFyc2VTbmFwc2hvdFRyZWV9XG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlRGVmZXJyZWRWYWx1ZVRyZWUgPSBmdW5jdGlvbihcbiAgdHJlZTogU3BhcnNlU25hcHNob3RUcmVlLFxuICBzZXJ2ZXJWYWx1ZXM6IE9iamVjdFxuKTogU3BhcnNlU25hcHNob3RUcmVlIHtcbiAgY29uc3QgcmVzb2x2ZWRUcmVlID0gbmV3IFNwYXJzZVNuYXBzaG90VHJlZSgpO1xuICB0cmVlLmZvckVhY2hUcmVlKG5ldyBQYXRoKCcnKSwgZnVuY3Rpb24ocGF0aCwgbm9kZSkge1xuICAgIHJlc29sdmVkVHJlZS5yZW1lbWJlcihcbiAgICAgIHBhdGgsXG4gICAgICByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5vZGUsIHNlcnZlclZhbHVlcylcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIHJlc29sdmVkVHJlZTtcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgcmVwbGFjZSBhbGwgZGVmZXJyZWQgdmFsdWVzIGFuZCBwcmlvcml0aWVzIGluIHRoZSBub2RlIHdpdGggdGhlXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy4gIElmIHRoZXJlIGFyZSBubyBzZXJ2ZXIgdmFsdWVzIGluIHRoZSBub2RlLFxuICogaXQnbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAcGFyYW0geyFPYmplY3R9IHNlcnZlclZhbHVlc1xuICogQHJldHVybiB7IU5vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90ID0gZnVuY3Rpb24oXG4gIG5vZGU6IE5vZGUsXG4gIHNlcnZlclZhbHVlczogT2JqZWN0XG4pOiBOb2RlIHtcbiAgY29uc3QgcmF3UHJpID0gbm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpIGFzXG4gICAgfCBvYmplY3RcbiAgICB8IGJvb2xlYW5cbiAgICB8IG51bGxcbiAgICB8IG51bWJlclxuICAgIHwgc3RyaW5nO1xuICBjb25zdCBwcmlvcml0eSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlKHJhd1ByaSwgc2VydmVyVmFsdWVzKTtcbiAgbGV0IG5ld05vZGU6IE5vZGU7XG5cbiAgaWYgKG5vZGUuaXNMZWFmTm9kZSgpKSB7XG4gICAgY29uc3QgbGVhZk5vZGUgPSBub2RlIGFzIExlYWZOb2RlO1xuICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZURlZmVycmVkVmFsdWUobGVhZk5vZGUuZ2V0VmFsdWUoKSwgc2VydmVyVmFsdWVzKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gbGVhZk5vZGUuZ2V0VmFsdWUoKSB8fFxuICAgICAgcHJpb3JpdHkgIT09IGxlYWZOb2RlLmdldFByaW9yaXR5KCkudmFsKClcbiAgICApIHtcbiAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUodmFsdWUsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2hpbGRyZW5Ob2RlID0gbm9kZSBhcyBDaGlsZHJlbk5vZGU7XG4gICAgbmV3Tm9kZSA9IGNoaWxkcmVuTm9kZTtcbiAgICBpZiAocHJpb3JpdHkgIT09IGNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XG4gICAgICBuZXdOb2RlID0gbmV3Tm9kZS51cGRhdGVQcmlvcml0eShuZXcgTGVhZk5vZGUocHJpb3JpdHkpKTtcbiAgICB9XG4gICAgY2hpbGRyZW5Ob2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24oY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcbiAgICAgIGNvbnN0IG5ld0NoaWxkTm9kZSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QoXG4gICAgICAgIGNoaWxkTm9kZSxcbiAgICAgICAgc2VydmVyVmFsdWVzXG4gICAgICApO1xuICAgICAgaWYgKG5ld0NoaWxkTm9kZSAhPT0gY2hpbGROb2RlKSB7XG4gICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vdXRpbC9QYXRoJztcblxuLyoqXG4gKlxuICogQGVudW1cbiAqL1xuZXhwb3J0IGVudW0gT3BlcmF0aW9uVHlwZSB7XG4gIE9WRVJXUklURSxcbiAgTUVSR0UsXG4gIEFDS19VU0VSX1dSSVRFLFxuICBMSVNURU5fQ09NUExFVEVcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEB0eXBlIHshT3BlcmF0aW9uU291cmNlfVxuICAgKi9cbiAgc291cmNlOiBPcGVyYXRpb25Tb3VyY2U7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHshT3BlcmF0aW9uVHlwZX1cbiAgICovXG4gIHR5cGU6IE9wZXJhdGlvblR5cGU7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHshUGF0aH1cbiAgICovXG4gIHBhdGg6IFBhdGg7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZE5hbWVcbiAgICogQHJldHVybiB7P09wZXJhdGlvbn1cbiAgICovXG4gIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZTogc3RyaW5nKTogT3BlcmF0aW9uIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZyb21Vc2VyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZyb21TZXJ2ZXJcbiAqIEBwYXJhbSB7P3N0cmluZ30gcXVlcnlJZFxuICogQHBhcmFtIHtib29sZWFufSB0YWdnZWRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgT3BlcmF0aW9uU291cmNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGZyb21Vc2VyOiBib29sZWFuLFxuICAgIHB1YmxpYyBmcm9tU2VydmVyOiBib29sZWFuLFxuICAgIHB1YmxpYyBxdWVyeUlkOiBzdHJpbmcgfCBudWxsLFxuICAgIHB1YmxpYyB0YWdnZWQ6IGJvb2xlYW5cbiAgKSB7XG4gICAgYXNzZXJ0KCF0YWdnZWQgfHwgZnJvbVNlcnZlciwgJ1RhZ2dlZCBxdWVyaWVzIG11c3QgYmUgZnJvbSBzZXJ2ZXIuJyk7XG4gIH1cbiAgLyoqXG4gICAqIEBjb25zdFxuICAgKiBAdHlwZSB7IU9wZXJhdGlvblNvdXJjZX1cbiAgICovXG4gIHN0YXRpYyBVc2VyID0gbmV3IE9wZXJhdGlvblNvdXJjZShcbiAgICAvKmZyb21Vc2VyPSovIHRydWUsXG4gICAgZmFsc2UsXG4gICAgbnVsbCxcbiAgICAvKnRhZ2dlZD0qLyBmYWxzZVxuICApO1xuXG4gIC8qKlxuICAgKiBAY29uc3RcbiAgICogQHR5cGUgeyFPcGVyYXRpb25Tb3VyY2V9XG4gICAqL1xuICBzdGF0aWMgU2VydmVyID0gbmV3IE9wZXJhdGlvblNvdXJjZShcbiAgICBmYWxzZSxcbiAgICAvKmZyb21TZXJ2ZXI9Ki8gdHJ1ZSxcbiAgICBudWxsLFxuICAgIC8qdGFnZ2VkPSovIGZhbHNlXG4gICk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeUlkXG4gICAqIEByZXR1cm4geyFPcGVyYXRpb25Tb3VyY2V9XG4gICAqL1xuICBzdGF0aWMgZm9yU2VydmVyVGFnZ2VkUXVlcnkgPSBmdW5jdGlvbihxdWVyeUlkOiBzdHJpbmcpOiBPcGVyYXRpb25Tb3VyY2Uge1xuICAgIHJldHVybiBuZXcgT3BlcmF0aW9uU291cmNlKFxuICAgICAgZmFsc2UsXG4gICAgICAvKmZyb21TZXJ2ZXI9Ki8gdHJ1ZSxcbiAgICAgIHF1ZXJ5SWQsXG4gICAgICAvKnRhZ2dlZD0qLyB0cnVlXG4gICAgKTtcbiAgfTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vdXRpbC9QYXRoJztcbmltcG9ydCB7IE9wZXJhdGlvbiwgT3BlcmF0aW9uU291cmNlLCBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi9PcGVyYXRpb24nO1xuaW1wb3J0IHsgSW1tdXRhYmxlVHJlZSB9IGZyb20gJy4uL3V0aWwvSW1tdXRhYmxlVHJlZSc7XG5cbmV4cG9ydCBjbGFzcyBBY2tVc2VyV3JpdGUgaW1wbGVtZW50cyBPcGVyYXRpb24ge1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgdHlwZSA9IE9wZXJhdGlvblR5cGUuQUNLX1VTRVJfV1JJVEU7XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHNvdXJjZSA9IE9wZXJhdGlvblNvdXJjZS5Vc2VyO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWU8IWJvb2xlYW4+fSBhZmZlY3RlZFRyZWUgQSB0cmVlIGNvbnRhaW5pbmcgdHJ1ZSBmb3IgZWFjaCBhZmZlY3RlZCBwYXRoLiBBZmZlY3RlZCBwYXRocyBjYW4ndCBvdmVybGFwLlxuICAgKiBAcGFyYW0geyFib29sZWFufSByZXZlcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKkBpbmhlcml0RG9jICovIHB1YmxpYyBwYXRoOiBQYXRoLFxuICAgIC8qKkBpbmhlcml0RG9jICovIHB1YmxpYyBhZmZlY3RlZFRyZWU6IEltbXV0YWJsZVRyZWU8Ym9vbGVhbj4sXG4gICAgLyoqQGluaGVyaXREb2MgKi8gcHVibGljIHJldmVydDogYm9vbGVhblxuICApIHt9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWU6IHN0cmluZyk6IEFja1VzZXJXcml0ZSB7XG4gICAgaWYgKCF0aGlzLnBhdGguaXNFbXB0eSgpKSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRoaXMucGF0aC5nZXRGcm9udCgpID09PSBjaGlsZE5hbWUsXG4gICAgICAgICdvcGVyYXRpb25Gb3JDaGlsZCBjYWxsZWQgZm9yIHVucmVsYXRlZCBjaGlsZC4nXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBBY2tVc2VyV3JpdGUoXG4gICAgICAgIHRoaXMucGF0aC5wb3BGcm9udCgpLFxuICAgICAgICB0aGlzLmFmZmVjdGVkVHJlZSxcbiAgICAgICAgdGhpcy5yZXZlcnRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFmZmVjdGVkVHJlZS52YWx1ZSAhPSBudWxsKSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRoaXMuYWZmZWN0ZWRUcmVlLmNoaWxkcmVuLmlzRW1wdHkoKSxcbiAgICAgICAgJ2FmZmVjdGVkVHJlZSBzaG91bGQgbm90IGhhdmUgb3ZlcmxhcHBpbmcgYWZmZWN0ZWQgcGF0aHMuJ1xuICAgICAgKTtcbiAgICAgIC8vIEFsbCBjaGlsZCBsb2NhdGlvbnMgYXJlIGFmZmVjdGVkIGFzIHdlbGw7IGp1c3QgcmV0dXJuIHNhbWUgb3BlcmF0aW9uLlxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuYWZmZWN0ZWRUcmVlLnN1YnRyZWUobmV3IFBhdGgoY2hpbGROYW1lKSk7XG4gICAgICByZXR1cm4gbmV3IEFja1VzZXJXcml0ZShQYXRoLkVtcHR5LCBjaGlsZFRyZWUsIHRoaXMucmV2ZXJ0KTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBTb3J0ZWRNYXAgfSBmcm9tICcuL1NvcnRlZE1hcCc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCB7IHN0cmluZ0NvbXBhcmUgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxubGV0IGVtcHR5Q2hpbGRyZW5TaW5nbGV0b246IFNvcnRlZE1hcDxzdHJpbmcsIEltbXV0YWJsZVRyZWU8bnVsbD4+O1xuXG4vKipcbiAqIFNpbmdsZXRvbiBlbXB0eSBjaGlsZHJlbiBjb2xsZWN0aW9uLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUgeyFTb3J0ZWRNYXAuPHN0cmluZywgIUltbXV0YWJsZVRyZWUuPD8+Pn1cbiAqL1xuY29uc3QgRW1wdHlDaGlsZHJlbiA9ICgpOiBTb3J0ZWRNYXA8c3RyaW5nLCBJbW11dGFibGVUcmVlPG51bGw+PiA9PiB7XG4gIGlmICghZW1wdHlDaGlsZHJlblNpbmdsZXRvbikge1xuICAgIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b24gPSBuZXcgU29ydGVkTWFwPHN0cmluZywgSW1tdXRhYmxlVHJlZTxudWxsPj4oXG4gICAgICBzdHJpbmdDb21wYXJlXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZW1wdHlDaGlsZHJlblNpbmdsZXRvbjtcbn07XG5cbi8qKlxuICogQSB0cmVlIHdpdGggaW1tdXRhYmxlIGVsZW1lbnRzLlxuICovXG5leHBvcnQgY2xhc3MgSW1tdXRhYmxlVHJlZTxUPiB7XG4gIHN0YXRpYyBFbXB0eSA9IG5ldyBJbW11dGFibGVUcmVlPGFueT4obnVsbCk7XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhVD59IG9ialxuICAgKiBAcmV0dXJuIHshSW1tdXRhYmxlVHJlZS48IVQ+fVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Q8VD4ob2JqOiB7IFtrOiBzdHJpbmddOiBUIH0pOiBJbW11dGFibGVUcmVlPFQ+IHtcbiAgICBsZXQgdHJlZTogSW1tdXRhYmxlVHJlZTxUPiA9IEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgZm9yRWFjaChvYmosIChjaGlsZFBhdGg6IHN0cmluZywgY2hpbGRTbmFwOiBUKSA9PiB7XG4gICAgICB0cmVlID0gdHJlZS5zZXQobmV3IFBhdGgoY2hpbGRQYXRoKSwgY2hpbGRTbmFwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0gez9UfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1NvcnRlZE1hcC48c3RyaW5nLCAhSW1tdXRhYmxlVHJlZS48VD4+PX0gY2hpbGRyZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSB2YWx1ZTogVCB8IG51bGwsXG4gICAgcHVibGljIHJlYWRvbmx5IGNoaWxkcmVuOiBTb3J0ZWRNYXA8XG4gICAgICBzdHJpbmcsXG4gICAgICBJbW11dGFibGVUcmVlPFQ+XG4gICAgPiA9IEVtcHR5Q2hpbGRyZW4oKVxuICApIHt9XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIHZhbHVlIGlzIGVtcHR5IGFuZCB0aGVyZSBhcmUgbm8gY2hpbGRyZW5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG51bGwgJiYgdGhpcy5jaGlsZHJlbi5pc0VtcHR5KCk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBwYXRoIGFuZCBwcmVkaWNhdGUsIHJldHVybiB0aGUgZmlyc3Qgbm9kZSBhbmQgdGhlIHBhdGggdG8gdGhhdCBub2RlXG4gICAqIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxuICAgKlxuICAgKiBUT0RPIERvIGEgcGVyZiB0ZXN0IC0tIElmIHdlJ3JlIGNyZWF0aW5nIGEgYnVuY2ggb2Yge3BhdGg6IHZhbHVlOn0gb2JqZWN0c1xuICAgKiBvbiB0aGUgd2F5IGJhY2sgb3V0LCBpdCBtYXkgYmUgYmV0dGVyIHRvIHBhc3MgZG93biBhIHBhdGhTb0ZhciBvYmouXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aCBUaGUgcmVtYWluZGVyIG9mIHRoZSBwYXRoXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Ym9vbGVhbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gc2F0aXNmeSB0byByZXR1cm4gYVxuICAgKiAgIG5vZGVcbiAgICogQHJldHVybiB7P3twYXRoOiFQYXRoLCB2YWx1ZTohVH19XG4gICAqL1xuICBmaW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShcbiAgICByZWxhdGl2ZVBhdGg6IFBhdGgsXG4gICAgcHJlZGljYXRlOiAoYTogVCkgPT4gYm9vbGVhblxuICApOiB7IHBhdGg6IFBhdGg7IHZhbHVlOiBUIH0gfCBudWxsIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPSBudWxsICYmIHByZWRpY2F0ZSh0aGlzLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIHsgcGF0aDogUGF0aC5FbXB0eSwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbGF0aXZlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZSA9IGNoaWxkLmZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlKFxuICAgICAgICAgICAgcmVsYXRpdmVQYXRoLnBvcEZyb250KCksXG4gICAgICAgICAgICBwcmVkaWNhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gbmV3IFBhdGgoZnJvbnQpLmNoaWxkKFxuICAgICAgICAgICAgICBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlLnBhdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBmdWxsUGF0aCwgdmFsdWU6IGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUudmFsdWUgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQsIGlmIGl0IGV4aXN0cywgdGhlIHNob3J0ZXN0IHN1YnBhdGggb2YgdGhlIGdpdmVuIHBhdGggdGhhdCBwb2ludHMgYSBkZWZpbmVkXG4gICAqIHZhbHVlIGluIHRoZSB0cmVlXG4gICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aFxuICAgKiBAcmV0dXJuIHs/e3BhdGg6ICFQYXRoLCB2YWx1ZTogIVR9fVxuICAgKi9cbiAgZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKFxuICAgIHJlbGF0aXZlUGF0aDogUGF0aFxuICApOiB7IHBhdGg6IFBhdGg7IHZhbHVlOiBUIH0gfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5maW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShyZWxhdGl2ZVBhdGgsICgpID0+IHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aFxuICAgKiBAcmV0dXJuIHshSW1tdXRhYmxlVHJlZS48VD59IFRoZSBzdWJ0cmVlIGF0IHRoZSBnaXZlbiBwYXRoXG4gICAqL1xuICBzdWJ0cmVlKHJlbGF0aXZlUGF0aDogUGF0aCk6IEltbXV0YWJsZVRyZWU8VD4ge1xuICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcbiAgICAgIGlmIChjaGlsZFRyZWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVHJlZS5zdWJ0cmVlKHJlbGF0aXZlUGF0aC5wb3BGcm9udCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGggUGF0aCB0byBzZXQgdmFsdWUgYXQuXG4gICAqIEBwYXJhbSB7P1R9IHRvU2V0IFZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybiB7IUltbXV0YWJsZVRyZWUuPFQ+fSBSZXN1bHRpbmcgdHJlZS5cbiAgICovXG4gIHNldChyZWxhdGl2ZVBhdGg6IFBhdGgsIHRvU2V0OiBUIHwgbnVsbCk6IEltbXV0YWJsZVRyZWU8VD4ge1xuICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodG9TZXQsIHRoaXMuY2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgSW1tdXRhYmxlVHJlZS5FbXB0eTtcbiAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0KHJlbGF0aXZlUGF0aC5wb3BGcm9udCgpLCB0b1NldCk7XG4gICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XG4gICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aCBQYXRoIHRvIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7IUltbXV0YWJsZVRyZWUuPFQ+fSBSZXN1bHRpbmcgdHJlZS5cbiAgICovXG4gIHJlbW92ZShyZWxhdGl2ZVBhdGg6IFBhdGgpOiBJbW11dGFibGVUcmVlPFQ+IHtcbiAgICBpZiAocmVsYXRpdmVQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwsIHRoaXMuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBjaGlsZC5yZW1vdmUocmVsYXRpdmVQYXRoLnBvcEZyb250KCkpO1xuICAgICAgICBsZXQgbmV3Q2hpbGRyZW47XG4gICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ucmVtb3ZlKGZyb250KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwgJiYgbmV3Q2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSB0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGggUGF0aCB0byBnZXQgdmFsdWUgZm9yLlxuICAgKiBAcmV0dXJuIHs/VH0gVmFsdWUgYXQgcGF0aCwgb3IgbnVsbC5cbiAgICovXG4gIGdldChyZWxhdGl2ZVBhdGg6IFBhdGgpOiBUIHwgbnVsbCB7XG4gICAgaWYgKHJlbGF0aXZlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLmdldChyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgc3VidHJlZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCB0aGUgZ2l2ZW4gbmV3IHRyZWUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aCBQYXRoIHRvIHJlcGxhY2Ugc3VidHJlZSBmb3IuXG4gICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWV9IG5ld1RyZWUgTmV3IHRyZWUuXG4gICAqIEByZXR1cm4geyFJbW11dGFibGVUcmVlfSBSZXN1bHRpbmcgdHJlZS5cbiAgICovXG4gIHNldFRyZWUocmVsYXRpdmVQYXRoOiBQYXRoLCBuZXdUcmVlOiBJbW11dGFibGVUcmVlPFQ+KTogSW1tdXRhYmxlVHJlZTxUPiB7XG4gICAgaWYgKHJlbGF0aXZlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBuZXdUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgSW1tdXRhYmxlVHJlZS5FbXB0eTtcbiAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0VHJlZShyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSwgbmV3VHJlZSk7XG4gICAgICBsZXQgbmV3Q2hpbGRyZW47XG4gICAgICBpZiAobmV3Q2hpbGQuaXNFbXB0eSgpKSB7XG4gICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5yZW1vdmUoZnJvbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmluc2VydChmcm9udCwgbmV3Q2hpbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBkZXB0aCBmaXJzdCBmb2xkIG9uIHRoaXMgdHJlZS4gVHJhbnNmb3JtcyBhIHRyZWUgaW50byBhIHNpbmdsZVxuICAgKiB2YWx1ZSwgZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IG9wZXJhdGVzIG9uIHRoZSBwYXRoIHRvIGEgbm9kZSwgYW4gb3B0aW9uYWxcbiAgICogY3VycmVudCB2YWx1ZSwgYW5kIGEgbWFwIG9mIGNoaWxkIG5hbWVzIHRvIGZvbGRlZCBzdWJ0cmVlc1xuICAgKiBAdGVtcGxhdGUgVlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFBhdGgsID9ULCBPYmplY3QuPHN0cmluZywgVj4pOlZ9IGZuXG4gICAqIEByZXR1cm4ge1Z9XG4gICAqL1xuICBmb2xkPFY+KGZuOiAocGF0aDogUGF0aCwgdmFsdWU6IFQsIGNoaWxkcmVuOiB7IFtrOiBzdHJpbmddOiBWIH0pID0+IFYpOiBWIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkXyhQYXRoLkVtcHR5LCBmbik7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlIGhlbHBlciBmb3IgcHVibGljLWZhY2luZyBmb2xkKCkgbWV0aG9kXG4gICAqIEB0ZW1wbGF0ZSBWXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhTb0ZhclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFBhdGgsID9ULCBPYmplY3QuPHN0cmluZywgVj4pOlZ9IGZuXG4gICAqIEByZXR1cm4ge1Z9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGZvbGRfPFY+KFxuICAgIHBhdGhTb0ZhcjogUGF0aCxcbiAgICBmbjogKHBhdGg6IFBhdGgsIHZhbHVlOiBUIHwgbnVsbCwgY2hpbGRyZW46IHsgW2s6IHN0cmluZ106IFYgfSkgPT4gVlxuICApOiBWIHtcbiAgICBjb25zdCBhY2N1bTogeyBbazogc3RyaW5nXTogViB9ID0ge307XG4gICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uKFxuICAgICAgY2hpbGRLZXk6IHN0cmluZyxcbiAgICAgIGNoaWxkVHJlZTogSW1tdXRhYmxlVHJlZTxUPlxuICAgICkge1xuICAgICAgYWNjdW1bY2hpbGRLZXldID0gY2hpbGRUcmVlLmZvbGRfKHBhdGhTb0Zhci5jaGlsZChjaGlsZEtleSksIGZuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm4ocGF0aFNvRmFyLCB0aGlzLnZhbHVlLCBhY2N1bSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgZmlyc3QgbWF0Y2hpbmcgdmFsdWUgb24gdGhlIGdpdmVuIHBhdGguIFJldHVybiB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGYgdG8gaXQuXG4gICAqIEB0ZW1wbGF0ZSBWXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oIVBhdGgsICFUKTo/Vn0gZlxuICAgKiBAcmV0dXJuIHs/Vn1cbiAgICovXG4gIGZpbmRPblBhdGg8Vj4ocGF0aDogUGF0aCwgZjogKHBhdGg6IFBhdGgsIHZhbHVlOiBUKSA9PiBWIHwgbnVsbCk6IFYgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5maW5kT25QYXRoXyhwYXRoLCBQYXRoLkVtcHR5LCBmKTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZE9uUGF0aF88Vj4oXG4gICAgcGF0aFRvRm9sbG93OiBQYXRoLFxuICAgIHBhdGhTb0ZhcjogUGF0aCxcbiAgICBmOiAocGF0aDogUGF0aCwgdmFsdWU6IFQpID0+IFYgfCBudWxsXG4gICk6IFYgfCBudWxsIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlID8gZihwYXRoU29GYXIsIHRoaXMudmFsdWUpIDogZmFsc2U7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGhUb0ZvbGxvdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhUb0ZvbGxvdy5nZXRGcm9udCgpITtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xuICAgICAgICBpZiAobmV4dENoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRDaGlsZC5maW5kT25QYXRoXyhcbiAgICAgICAgICAgIHBhdGhUb0ZvbGxvdy5wb3BGcm9udCgpLFxuICAgICAgICAgICAgcGF0aFNvRmFyLmNoaWxkKGZyb250KSxcbiAgICAgICAgICAgIGZcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oIVBhdGgsICFUKX0gZlxuICAgKiBAcmV0dXJucyB7IUltbXV0YWJsZVRyZWUuPFQ+fVxuICAgKi9cbiAgZm9yZWFjaE9uUGF0aChcbiAgICBwYXRoOiBQYXRoLFxuICAgIGY6IChwYXRoOiBQYXRoLCB2YWx1ZTogVCkgPT4gdm9pZFxuICApOiBJbW11dGFibGVUcmVlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5mb3JlYWNoT25QYXRoXyhwYXRoLCBQYXRoLkVtcHR5LCBmKTtcbiAgfVxuXG4gIHByaXZhdGUgZm9yZWFjaE9uUGF0aF8oXG4gICAgcGF0aFRvRm9sbG93OiBQYXRoLFxuICAgIGN1cnJlbnRSZWxhdGl2ZVBhdGg6IFBhdGgsXG4gICAgZjogKHBhdGg6IFBhdGgsIHZhbHVlOiBUKSA9PiB2b2lkXG4gICk6IEltbXV0YWJsZVRyZWU8VD4ge1xuICAgIGlmIChwYXRoVG9Gb2xsb3cuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgZihjdXJyZW50UmVsYXRpdmVQYXRoLCB0aGlzLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyb250ID0gcGF0aFRvRm9sbG93LmdldEZyb250KCk7XG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICBpZiAobmV4dENoaWxkKSB7XG4gICAgICAgIHJldHVybiBuZXh0Q2hpbGQuZm9yZWFjaE9uUGF0aF8oXG4gICAgICAgICAgcGF0aFRvRm9sbG93LnBvcEZyb250KCksXG4gICAgICAgICAgY3VycmVudFJlbGF0aXZlUGF0aC5jaGlsZChmcm9udCksXG4gICAgICAgICAgZlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBub2RlIGluIHRoZSB0cmVlIHRoYXQgaGFzIGEgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIVBhdGgsICFUKX0gZiBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoXG4gICAqICAgdGhlIHBhdGggZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0byBhIG5vZGUsIGFuZCB0aGUgdmFsdWUgYXQgdGhhdCBub2RlLlxuICAgKiAgIENhbGxlZCBpbiBkZXB0aC1maXJzdCBvcmRlci5cbiAgICovXG4gIGZvcmVhY2goZjogKHBhdGg6IFBhdGgsIHZhbHVlOiBUKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5mb3JlYWNoXyhQYXRoLkVtcHR5LCBmKTtcbiAgfVxuXG4gIHByaXZhdGUgZm9yZWFjaF8oXG4gICAgY3VycmVudFJlbGF0aXZlUGF0aDogUGF0aCxcbiAgICBmOiAocGF0aDogUGF0aCwgdmFsdWU6IFQpID0+IHZvaWRcbiAgKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSB7XG4gICAgICBjaGlsZFRyZWUuZm9yZWFjaF8oY3VycmVudFJlbGF0aXZlUGF0aC5jaGlsZChjaGlsZE5hbWUpLCBmKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgZihjdXJyZW50UmVsYXRpdmVQYXRoLCB0aGlzLnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsICFUKX0gZlxuICAgKi9cbiAgZm9yZWFjaENoaWxkKGY6IChuYW1lOiBzdHJpbmcsIHZhbHVlOiBUKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKFxuICAgICAgKGNoaWxkTmFtZTogc3RyaW5nLCBjaGlsZFRyZWU6IEltbXV0YWJsZVRyZWU8VD4pID0+IHtcbiAgICAgICAgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xuICAgICAgICAgIGYoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgT3BlcmF0aW9uLCBPcGVyYXRpb25Tb3VyY2UsIE9wZXJhdGlvblR5cGUgfSBmcm9tICcuL09wZXJhdGlvbic7XG5cbi8qKlxuICogQHBhcmFtIHshT3BlcmF0aW9uU291cmNlfSBzb3VyY2VcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge09wZXJhdGlvbn1cbiAqL1xuZXhwb3J0IGNsYXNzIExpc3RlbkNvbXBsZXRlIGltcGxlbWVudHMgT3BlcmF0aW9uIHtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHR5cGUgPSBPcGVyYXRpb25UeXBlLkxJU1RFTl9DT01QTEVURTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgc291cmNlOiBPcGVyYXRpb25Tb3VyY2UsIHB1YmxpYyBwYXRoOiBQYXRoKSB7fVxuXG4gIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZTogc3RyaW5nKTogTGlzdGVuQ29tcGxldGUge1xuICAgIGlmICh0aGlzLnBhdGguaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBQYXRoLkVtcHR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBMaXN0ZW5Db21wbGV0ZSh0aGlzLnNvdXJjZSwgdGhpcy5wYXRoLnBvcEZyb250KCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE9wZXJhdGlvbiwgT3BlcmF0aW9uU291cmNlLCBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi9PcGVyYXRpb24nO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vc25hcC9Ob2RlJztcblxuLyoqXG4gKiBAcGFyYW0geyFPcGVyYXRpb25Tb3VyY2V9IHNvdXJjZVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQHBhcmFtIHshTm9kZX0gc25hcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7T3BlcmF0aW9ufVxuICovXG5leHBvcnQgY2xhc3MgT3ZlcndyaXRlIGltcGxlbWVudHMgT3BlcmF0aW9uIHtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHR5cGUgPSBPcGVyYXRpb25UeXBlLk9WRVJXUklURTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgc291cmNlOiBPcGVyYXRpb25Tb3VyY2UsXG4gICAgcHVibGljIHBhdGg6IFBhdGgsXG4gICAgcHVibGljIHNuYXA6IE5vZGVcbiAgKSB7fVxuXG4gIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZTogc3RyaW5nKTogT3ZlcndyaXRlIHtcbiAgICBpZiAodGhpcy5wYXRoLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUoXG4gICAgICAgIHRoaXMuc291cmNlLFxuICAgICAgICBQYXRoLkVtcHR5LFxuICAgICAgICB0aGlzLnNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUodGhpcy5zb3VyY2UsIHRoaXMucGF0aC5wb3BGcm9udCgpLCB0aGlzLnNuYXApO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE9wZXJhdGlvbiwgT3BlcmF0aW9uU291cmNlLCBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi9PcGVyYXRpb24nO1xuaW1wb3J0IHsgT3ZlcndyaXRlIH0gZnJvbSAnLi9PdmVyd3JpdGUnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBJbW11dGFibGVUcmVlIH0gZnJvbSAnLi4vdXRpbC9JbW11dGFibGVUcmVlJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9zbmFwL05vZGUnO1xuXG4vKipcbiAqIEBwYXJhbSB7IU9wZXJhdGlvblNvdXJjZX0gc291cmNlXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAcGFyYW0geyFJbW11dGFibGVUcmVlLjwhTm9kZT59IGNoaWxkcmVuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtPcGVyYXRpb259XG4gKi9cbmV4cG9ydCBjbGFzcyBNZXJnZSBpbXBsZW1lbnRzIE9wZXJhdGlvbiB7XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICB0eXBlID0gT3BlcmF0aW9uVHlwZS5NRVJHRTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAvKipAaW5oZXJpdERvYyAqLyBwdWJsaWMgc291cmNlOiBPcGVyYXRpb25Tb3VyY2UsXG4gICAgLyoqQGluaGVyaXREb2MgKi8gcHVibGljIHBhdGg6IFBhdGgsXG4gICAgLyoqQGluaGVyaXREb2MgKi8gcHVibGljIGNoaWxkcmVuOiBJbW11dGFibGVUcmVlPE5vZGU+XG4gICkge31cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZTogc3RyaW5nKTogT3BlcmF0aW9uIHtcbiAgICBpZiAodGhpcy5wYXRoLmlzRW1wdHkoKSkge1xuICAgICAgY29uc3QgY2hpbGRUcmVlID0gdGhpcy5jaGlsZHJlbi5zdWJ0cmVlKG5ldyBQYXRoKGNoaWxkTmFtZSkpO1xuICAgICAgaWYgKGNoaWxkVHJlZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyB1bmFmZmVjdGVkXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZFRyZWUudmFsdWUpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIHNuYXBzaG90IGZvciB0aGUgY2hpbGQgaW4gcXVlc3Rpb24uICBUaGlzIGJlY29tZXMgYW4gb3ZlcndyaXRlIG9mIHRoZSBjaGlsZC5cbiAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUodGhpcy5zb3VyY2UsIFBhdGguRW1wdHksIGNoaWxkVHJlZS52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbWVyZ2UgYXQgYSBkZWVwZXIgbGV2ZWxcbiAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgUGF0aC5FbXB0eSwgY2hpbGRUcmVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0aGlzLnBhdGguZ2V0RnJvbnQoKSA9PT0gY2hpbGROYW1lLFxuICAgICAgICBcIkNhbid0IGdldCBhIG1lcmdlIGZvciBhIGNoaWxkIG5vdCBvbiB0aGUgcGF0aCBvZiB0aGUgb3BlcmF0aW9uXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IE1lcmdlKHRoaXMuc291cmNlLCB0aGlzLnBhdGgucG9wRnJvbnQoKSwgdGhpcy5jaGlsZHJlbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiAoXG4gICAgICAnT3BlcmF0aW9uKCcgK1xuICAgICAgdGhpcy5wYXRoICtcbiAgICAgICc6ICcgK1xuICAgICAgdGhpcy5zb3VyY2UudG9TdHJpbmcoKSArXG4gICAgICAnIG1lcmdlOiAnICtcbiAgICAgIHRoaXMuY2hpbGRyZW4udG9TdHJpbmcoKSArXG4gICAgICAnKSdcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL3NuYXAvTm9kZSc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vdXRpbC9QYXRoJztcblxuLyoqXG4gKiBBIGNhY2hlIG5vZGUgb25seSBzdG9yZXMgY29tcGxldGUgY2hpbGRyZW4uIEFkZGl0aW9uYWxseSBpdCBob2xkcyBhIGZsYWcgd2hldGhlciB0aGUgbm9kZSBjYW4gYmUgY29uc2lkZXJlZCBmdWxseVxuICogaW5pdGlhbGl6ZWQgaW4gdGhlIHNlbnNlIHRoYXQgd2Uga25vdyBhdCBvbmUgcG9pbnQgaW4gdGltZSB0aGlzIHJlcHJlc2VudGVkIGEgdmFsaWQgc3RhdGUgb2YgdGhlIHdvcmxkLCBlLmcuXG4gKiBpbml0aWFsaXplZCB3aXRoIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBvciBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBieSB0aGUgY2xpZW50LiBUaGUgZmlsdGVyZWQgZmxhZyBhbHNvIHRyYWNrc1xuICogd2hldGhlciBhIG5vZGUgcG90ZW50aWFsbHkgaGFkIGNoaWxkcmVuIHJlbW92ZWQgZHVlIHRvIGEgZmlsdGVyLlxuICovXG5leHBvcnQgY2xhc3MgQ2FjaGVOb2RlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVfXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZnVsbHlJbml0aWFsaXplZF9cbiAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJlZF9cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbm9kZV86IE5vZGUsXG4gICAgcHJpdmF0ZSBmdWxseUluaXRpYWxpemVkXzogYm9vbGVhbixcbiAgICBwcml2YXRlIGZpbHRlcmVkXzogYm9vbGVhblxuICApIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgd2FzIGZ1bGx5IGluaXRpYWxpemVkIHdpdGggZWl0aGVyIHNlcnZlciBkYXRhIG9yIGEgY29tcGxldGUgb3ZlcndyaXRlIGJ5IHRoZSBjbGllbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRnVsbHlJbml0aWFsaXplZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5mdWxseUluaXRpYWxpemVkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBub2RlIGlzIHBvdGVudGlhbGx5IG1pc3NpbmcgY2hpbGRyZW4gZHVlIHRvIGEgZmlsdGVyIGFwcGxpZWQgdG8gdGhlIG5vZGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRmlsdGVyZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29tcGxldGVGb3JQYXRoKHBhdGg6IFBhdGgpOiBib29sZWFuIHtcbiAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRnVsbHlJbml0aWFsaXplZCgpICYmICF0aGlzLmZpbHRlcmVkXztcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZEtleSA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvbXBsZXRlRm9yQ2hpbGQoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfKSB8fCB0aGlzLm5vZGVfLmhhc0NoaWxkKGtleSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFOb2RlfVxuICAgKi9cbiAgZ2V0Tm9kZSgpOiBOb2RlIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlXztcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENoaWxkcmVuTm9kZSB9IGZyb20gJy4uL3NuYXAvQ2hpbGRyZW5Ob2RlJztcbmltcG9ydCB7IENhY2hlTm9kZSB9IGZyb20gJy4vQ2FjaGVOb2RlJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9zbmFwL05vZGUnO1xuXG4vKipcbiAqIFN0b3JlcyB0aGUgZGF0YSB3ZSBoYXZlIGNhY2hlZCBmb3IgYSB2aWV3LlxuICpcbiAqIHNlcnZlclNuYXAgaXMgdGhlIGNhY2hlZCBzZXJ2ZXIgZGF0YSwgZXZlbnRTbmFwIGlzIHRoZSBjYWNoZWQgZXZlbnQgZGF0YSAoc2VydmVyIGRhdGEgcGx1cyBhbnkgbG9jYWwgd3JpdGVzKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZXdDYWNoZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0geyFDYWNoZU5vZGV9IGV2ZW50Q2FjaGVfXG4gICAqIEBwYXJhbSB7IUNhY2hlTm9kZX0gc2VydmVyQ2FjaGVfXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50Q2FjaGVfOiBDYWNoZU5vZGUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXJ2ZXJDYWNoZV86IENhY2hlTm9kZVxuICApIHt9XG5cbiAgLyoqXG4gICAqIEBjb25zdFxuICAgKiBAdHlwZSB7Vmlld0NhY2hlfVxuICAgKi9cbiAgc3RhdGljIEVtcHR5ID0gbmV3IFZpZXdDYWNoZShcbiAgICBuZXcgQ2FjaGVOb2RlKFxuICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsXG4gICAgICAvKmZ1bGx5SW5pdGlhbGl6ZWQ9Ki8gZmFsc2UsXG4gICAgICAvKmZpbHRlcmVkPSovIGZhbHNlXG4gICAgKSxcbiAgICBuZXcgQ2FjaGVOb2RlKFxuICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsXG4gICAgICAvKmZ1bGx5SW5pdGlhbGl6ZWQ9Ki8gZmFsc2UsXG4gICAgICAvKmZpbHRlcmVkPSovIGZhbHNlXG4gICAgKVxuICApO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSBldmVudFNuYXBcbiAgICogQHBhcmFtIHtib29sZWFufSBjb21wbGV0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbHRlcmVkXG4gICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAqL1xuICB1cGRhdGVFdmVudFNuYXAoXG4gICAgZXZlbnRTbmFwOiBOb2RlLFxuICAgIGNvbXBsZXRlOiBib29sZWFuLFxuICAgIGZpbHRlcmVkOiBib29sZWFuXG4gICk6IFZpZXdDYWNoZSB7XG4gICAgcmV0dXJuIG5ldyBWaWV3Q2FjaGUoXG4gICAgICBuZXcgQ2FjaGVOb2RlKGV2ZW50U25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSxcbiAgICAgIHRoaXMuc2VydmVyQ2FjaGVfXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSBzZXJ2ZXJTbmFwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcGxldGVcbiAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJlZFxuICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgKi9cbiAgdXBkYXRlU2VydmVyU25hcChcbiAgICBzZXJ2ZXJTbmFwOiBOb2RlLFxuICAgIGNvbXBsZXRlOiBib29sZWFuLFxuICAgIGZpbHRlcmVkOiBib29sZWFuXG4gICk6IFZpZXdDYWNoZSB7XG4gICAgcmV0dXJuIG5ldyBWaWV3Q2FjaGUoXG4gICAgICB0aGlzLmV2ZW50Q2FjaGVfLFxuICAgICAgbmV3IENhY2hlTm9kZShzZXJ2ZXJTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQ2FjaGVOb2RlfVxuICAgKi9cbiAgZ2V0RXZlbnRDYWNoZSgpOiBDYWNoZU5vZGUge1xuICAgIHJldHVybiB0aGlzLmV2ZW50Q2FjaGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgZ2V0Q29tcGxldGVFdmVudFNuYXAoKTogTm9kZSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmV2ZW50Q2FjaGVfLmlzRnVsbHlJbml0aWFsaXplZCgpXG4gICAgICA/IHRoaXMuZXZlbnRDYWNoZV8uZ2V0Tm9kZSgpXG4gICAgICA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUNhY2hlTm9kZX1cbiAgICovXG4gIGdldFNlcnZlckNhY2hlKCk6IENhY2hlTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyQ2FjaGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKCk6IE5vZGUgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJDYWNoZV8uaXNGdWxseUluaXRpYWxpemVkKClcbiAgICAgID8gdGhpcy5zZXJ2ZXJDYWNoZV8uZ2V0Tm9kZSgpXG4gICAgICA6IG51bGw7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vc25hcC9Ob2RlJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqIEBwYXJhbSB7IXN0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZVxuICogQHBhcmFtIHshTm9kZX0gc25hcHNob3ROb2RlIFRoZSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGNoaWxkTmFtZSBUaGUgbmFtZSBmb3IgdGhpcyBjaGlsZCwgaWYgaXQncyBhIGNoaWxkIGV2ZW50XG4gKiBAcGFyYW0ge05vZGU9fSBvbGRTbmFwIFVzZWQgZm9yIGludGVybWVkaWF0ZSBwcm9jZXNzaW5nIG9mIGNoaWxkIGNoYW5nZWQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZz19IHByZXZOYW1lIFRoZSBuYW1lIGZvciB0aGUgcHJldmlvdXMgY2hpbGQsIGlmIGFwcGxpY2FibGVcbiAqL1xuZXhwb3J0IGNsYXNzIENoYW5nZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyB0eXBlOiBzdHJpbmcsXG4gICAgcHVibGljIHNuYXBzaG90Tm9kZTogTm9kZSxcbiAgICBwdWJsaWMgY2hpbGROYW1lPzogc3RyaW5nLFxuICAgIHB1YmxpYyBvbGRTbmFwPzogTm9kZSxcbiAgICBwdWJsaWMgcHJldk5hbWU/OiBzdHJpbmcgfCBudWxsXG4gICkge31cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gc25hcHNob3RcbiAgICogQHJldHVybiB7IUNoYW5nZX1cbiAgICovXG4gIHN0YXRpYyB2YWx1ZUNoYW5nZShzbmFwc2hvdDogTm9kZSk6IENoYW5nZSB7XG4gICAgcmV0dXJuIG5ldyBDaGFuZ2UoQ2hhbmdlLlZBTFVFLCBzbmFwc2hvdCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90XG4gICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAqL1xuICBzdGF0aWMgY2hpbGRBZGRlZENoYW5nZShjaGlsZEtleTogc3RyaW5nLCBzbmFwc2hvdDogTm9kZSk6IENoYW5nZSB7XG4gICAgcmV0dXJuIG5ldyBDaGFuZ2UoQ2hhbmdlLkNISUxEX0FEREVELCBzbmFwc2hvdCwgY2hpbGRLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZEtleVxuICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwc2hvdFxuICAgKiBAcmV0dXJuIHshQ2hhbmdlfVxuICAgKi9cbiAgc3RhdGljIGNoaWxkUmVtb3ZlZENoYW5nZShjaGlsZEtleTogc3RyaW5nLCBzbmFwc2hvdDogTm9kZSk6IENoYW5nZSB7XG4gICAgcmV0dXJuIG5ldyBDaGFuZ2UoQ2hhbmdlLkNISUxEX1JFTU9WRUQsIHNuYXBzaG90LCBjaGlsZEtleSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAqIEBwYXJhbSB7IU5vZGV9IG5ld1NuYXBzaG90XG4gICAqIEBwYXJhbSB7IU5vZGV9IG9sZFNuYXBzaG90XG4gICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAqL1xuICBzdGF0aWMgY2hpbGRDaGFuZ2VkQ2hhbmdlKFxuICAgIGNoaWxkS2V5OiBzdHJpbmcsXG4gICAgbmV3U25hcHNob3Q6IE5vZGUsXG4gICAgb2xkU25hcHNob3Q6IE5vZGVcbiAgKTogQ2hhbmdlIHtcbiAgICByZXR1cm4gbmV3IENoYW5nZShDaGFuZ2UuQ0hJTERfQ0hBTkdFRCwgbmV3U25hcHNob3QsIGNoaWxkS2V5LCBvbGRTbmFwc2hvdCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90XG4gICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAqL1xuICBzdGF0aWMgY2hpbGRNb3ZlZENoYW5nZShjaGlsZEtleTogc3RyaW5nLCBzbmFwc2hvdDogTm9kZSk6IENoYW5nZSB7XG4gICAgcmV0dXJuIG5ldyBDaGFuZ2UoQ2hhbmdlLkNISUxEX01PVkVELCBzbmFwc2hvdCwgY2hpbGRLZXkpO1xuICB9XG5cbiAgLy9ldmVudCB0eXBlc1xuICAvKiogRXZlbnQgdHlwZSBmb3IgYSBjaGlsZCBhZGRlZCAqL1xuICBzdGF0aWMgQ0hJTERfQURERUQgPSAnY2hpbGRfYWRkZWQnO1xuXG4gIC8qKiBFdmVudCB0eXBlIGZvciBhIGNoaWxkIHJlbW92ZWQgKi9cbiAgc3RhdGljIENISUxEX1JFTU9WRUQgPSAnY2hpbGRfcmVtb3ZlZCc7XG5cbiAgLyoqIEV2ZW50IHR5cGUgZm9yIGEgY2hpbGQgY2hhbmdlZCAqL1xuICBzdGF0aWMgQ0hJTERfQ0hBTkdFRCA9ICdjaGlsZF9jaGFuZ2VkJztcblxuICAvKiogRXZlbnQgdHlwZSBmb3IgYSBjaGlsZCBtb3ZlZCAqL1xuICBzdGF0aWMgQ0hJTERfTU9WRUQgPSAnY2hpbGRfbW92ZWQnO1xuXG4gIC8qKiBFdmVudCB0eXBlIGZvciBhIHZhbHVlIGNoYW5nZSAqL1xuICBzdGF0aWMgVkFMVUUgPSAndmFsdWUnO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENoYW5nZSB9IGZyb20gJy4uL0NoYW5nZSc7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuLi8uLi9zbmFwL0NoaWxkcmVuTm9kZSc7XG5pbXBvcnQgeyBQUklPUklUWV9JTkRFWCB9IGZyb20gJy4uLy4uL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4JztcbmltcG9ydCB7IE5vZGVGaWx0ZXIgfSBmcm9tICcuL05vZGVGaWx0ZXInO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuLi8uLi9zbmFwL2luZGV4ZXMvSW5kZXgnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uLy4uL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBDb21wbGV0ZUNoaWxkU291cmNlIH0gZnJvbSAnLi4vQ29tcGxldGVDaGlsZFNvdXJjZSc7XG5pbXBvcnQgeyBDaGlsZENoYW5nZUFjY3VtdWxhdG9yIH0gZnJvbSAnLi4vQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcic7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vLi4vc25hcC9Ob2RlJztcblxuLyoqXG4gKiBEb2Vzbid0IHJlYWxseSBmaWx0ZXIgbm9kZXMgYnV0IGFwcGxpZXMgYW4gaW5kZXggdG8gdGhlIG5vZGUgYW5kIGtlZXBzIHRyYWNrIG9mIGFueSBjaGFuZ2VzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7Tm9kZUZpbHRlcn1cbiAqIEBwYXJhbSB7IUluZGV4fSBpbmRleFxuICovXG5leHBvcnQgY2xhc3MgSW5kZXhlZEZpbHRlciBpbXBsZW1lbnRzIE5vZGVGaWx0ZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGluZGV4XzogSW5kZXgpIHt9XG5cbiAgdXBkYXRlQ2hpbGQoXG4gICAgc25hcDogTm9kZSxcbiAgICBrZXk6IHN0cmluZyxcbiAgICBuZXdDaGlsZDogTm9kZSxcbiAgICBhZmZlY3RlZFBhdGg6IFBhdGgsXG4gICAgc291cmNlOiBDb21wbGV0ZUNoaWxkU291cmNlLFxuICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yOiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yIHwgbnVsbFxuICApOiBOb2RlIHtcbiAgICBhc3NlcnQoXG4gICAgICBzbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XyksXG4gICAgICAnQSBub2RlIG11c3QgYmUgaW5kZXhlZCBpZiBvbmx5IGEgY2hpbGQgaXMgdXBkYXRlZCdcbiAgICApO1xuICAgIGNvbnN0IG9sZENoaWxkID0gc25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpO1xuICAgIC8vIENoZWNrIGlmIGFueXRoaW5nIGFjdHVhbGx5IGNoYW5nZWQuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKS5lcXVhbHMobmV3Q2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKSlcbiAgICApIHtcbiAgICAgIC8vIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdoZXJlIGEgY2hpbGQgY2FuIGVudGVyIG9yIGxlYXZlIHRoZSB2aWV3IGJlY2F1c2UgYWZmZWN0ZWRQYXRoIHdhcyBzZXQgdG8gbnVsbC5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgYWZmZWN0ZWRQYXRoIHdpbGwgYXBwZWFyIG51bGwgaW4gYm90aCB0aGUgb2xkIGFuZCBuZXcgc25hcHNob3RzLiAgU28gd2UgbmVlZFxuICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgdGhlc2UgY2FzZXMgYXMgXCJub3RoaW5nIGNoYW5nZWQuXCJcbiAgICAgIGlmIChvbGRDaGlsZC5pc0VtcHR5KCkgPT0gbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZC5cblxuICAgICAgICAvLyBUaGlzIGFzc2VydCBzaG91bGQgYmUgdmFsaWQsIGJ1dCBpdCdzIGV4cGVuc2l2ZSAoY2FuIGRvbWluYXRlIHBlcmYgdGVzdGluZykgc28gZG9uJ3QgYWN0dWFsbHkgZG8gaXQuXG4gICAgICAgIC8vYXNzZXJ0KG9sZENoaWxkLmVxdWFscyhuZXdDaGlsZCksICdPbGQgYW5kIG5ldyBzbmFwc2hvdHMgc2hvdWxkIGJlIGVxdWFsLicpO1xuICAgICAgICByZXR1cm4gc25hcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0Q2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgaWYgKG5ld0NoaWxkLmlzRW1wdHkoKSkge1xuICAgICAgICBpZiAoc25hcC5oYXNDaGlsZChrZXkpKSB7XG4gICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShcbiAgICAgICAgICAgIENoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2Uoa2V5LCBvbGRDaGlsZClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIHNuYXAuaXNMZWFmTm9kZSgpLFxuICAgICAgICAgICAgJ0EgY2hpbGQgcmVtb3ZlIHdpdGhvdXQgYW4gb2xkIGNoaWxkIG9ubHkgbWFrZXMgc2Vuc2Ugb24gYSBsZWFmIG5vZGUnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvbGRDaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShcbiAgICAgICAgICBDaGFuZ2UuY2hpbGRBZGRlZENoYW5nZShrZXksIG5ld0NoaWxkKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShcbiAgICAgICAgICBDaGFuZ2UuY2hpbGRDaGFuZ2VkQ2hhbmdlKGtleSwgbmV3Q2hpbGQsIG9sZENoaWxkKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc25hcC5pc0xlYWZOb2RlKCkgJiYgbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gc25hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBub2RlIGlzIGluZGV4ZWRcbiAgICAgIHJldHVybiBzbmFwLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGtleSwgbmV3Q2hpbGQpLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICB1cGRhdGVGdWxsTm9kZShcbiAgICBvbGRTbmFwOiBOb2RlLFxuICAgIG5ld1NuYXA6IE5vZGUsXG4gICAgb3B0Q2hhbmdlQWNjdW11bGF0b3I6IENoaWxkQ2hhbmdlQWNjdW11bGF0b3IgfCBudWxsXG4gICk6IE5vZGUge1xuICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XG4gICAgICBpZiAoIW9sZFNuYXAuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgIG9sZFNuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbihrZXksIGNoaWxkTm9kZSkge1xuICAgICAgICAgIGlmICghbmV3U25hcC5oYXNDaGlsZChrZXkpKSB7XG4gICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKFxuICAgICAgICAgICAgICBDaGFuZ2UuY2hpbGRSZW1vdmVkQ2hhbmdlKGtleSwgY2hpbGROb2RlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFuZXdTbmFwLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICBuZXdTbmFwLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24oa2V5LCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICBpZiAob2xkU25hcC5oYXNDaGlsZChrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGlsZCA9IG9sZFNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KTtcbiAgICAgICAgICAgIGlmICghb2xkQ2hpbGQuZXF1YWxzKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShcbiAgICAgICAgICAgICAgICBDaGFuZ2UuY2hpbGRDaGFuZ2VkQ2hhbmdlKGtleSwgY2hpbGROb2RlLCBvbGRDaGlsZClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShcbiAgICAgICAgICAgICAgQ2hhbmdlLmNoaWxkQWRkZWRDaGFuZ2Uoa2V5LCBjaGlsZE5vZGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdTbmFwLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHVwZGF0ZVByaW9yaXR5KG9sZFNuYXA6IE5vZGUsIG5ld1ByaW9yaXR5OiBOb2RlKTogTm9kZSB7XG4gICAgaWYgKG9sZFNuYXAuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvbGRTbmFwLnVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGZpbHRlcnNOb2RlcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEluZGV4ZWRGaWx0ZXIoKTogSW5kZXhlZEZpbHRlciB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEluZGV4KCk6IEluZGV4IHtcbiAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBnZXRWYWx1ZXMsIHNhZmVHZXQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBDaGFuZ2UgfSBmcm9tICcuL0NoYW5nZSc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydGlvbkVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvciB7XG4gIHByaXZhdGUgY2hhbmdlTWFwXzogeyBbazogc3RyaW5nXTogQ2hhbmdlIH0gPSB7fTtcblxuICAvKipcbiAgICogQHBhcmFtIHshQ2hhbmdlfSBjaGFuZ2VcbiAgICovXG4gIHRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlOiBDaGFuZ2UpIHtcbiAgICBjb25zdCB0eXBlID0gY2hhbmdlLnR5cGU7XG4gICAgY29uc3QgY2hpbGRLZXkgLyoqIEB0eXBlIHshc3RyaW5nfSAqLyA9IGNoYW5nZS5jaGlsZE5hbWU7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZSA9PSBDaGFuZ2UuQ0hJTERfQURERUQgfHxcbiAgICAgICAgdHlwZSA9PSBDaGFuZ2UuQ0hJTERfQ0hBTkdFRCB8fFxuICAgICAgICB0eXBlID09IENoYW5nZS5DSElMRF9SRU1PVkVELFxuICAgICAgJ09ubHkgY2hpbGQgY2hhbmdlcyBzdXBwb3J0ZWQgZm9yIHRyYWNraW5nJ1xuICAgICk7XG4gICAgYXNzZXJ0KFxuICAgICAgY2hpbGRLZXkgIT09ICcucHJpb3JpdHknLFxuICAgICAgJ09ubHkgbm9uLXByaW9yaXR5IGNoaWxkIGNoYW5nZXMgY2FuIGJlIHRyYWNrZWQuJ1xuICAgICk7XG4gICAgY29uc3Qgb2xkQ2hhbmdlID0gc2FmZUdldCh0aGlzLmNoYW5nZU1hcF8sIGNoaWxkS2V5KSBhcyBDaGFuZ2U7XG4gICAgaWYgKG9sZENoYW5nZSkge1xuICAgICAgY29uc3Qgb2xkVHlwZSA9IG9sZENoYW5nZS50eXBlO1xuICAgICAgaWYgKHR5cGUgPT0gQ2hhbmdlLkNISUxEX0FEREVEICYmIG9sZFR5cGUgPT0gQ2hhbmdlLkNISUxEX1JFTU9WRUQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXBfW2NoaWxkS2V5XSA9IENoYW5nZS5jaGlsZENoYW5nZWRDaGFuZ2UoXG4gICAgICAgICAgY2hpbGRLZXksXG4gICAgICAgICAgY2hhbmdlLnNuYXBzaG90Tm9kZSxcbiAgICAgICAgICBvbGRDaGFuZ2Uuc25hcHNob3ROb2RlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlID09IENoYW5nZS5DSElMRF9SRU1PVkVEICYmXG4gICAgICAgIG9sZFR5cGUgPT0gQ2hhbmdlLkNISUxEX0FEREVEXG4gICAgICApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlTWFwX1tjaGlsZEtleV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlID09IENoYW5nZS5DSElMRF9SRU1PVkVEICYmXG4gICAgICAgIG9sZFR5cGUgPT0gQ2hhbmdlLkNISUxEX0NIQU5HRURcbiAgICAgICkge1xuICAgICAgICB0aGlzLmNoYW5nZU1hcF9bY2hpbGRLZXldID0gQ2hhbmdlLmNoaWxkUmVtb3ZlZENoYW5nZShcbiAgICAgICAgICBjaGlsZEtleSxcbiAgICAgICAgICBvbGRDaGFuZ2Uub2xkU25hcFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdHlwZSA9PSBDaGFuZ2UuQ0hJTERfQ0hBTkdFRCAmJlxuICAgICAgICBvbGRUeXBlID09IENoYW5nZS5DSElMRF9BRERFRFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTWFwX1tjaGlsZEtleV0gPSBDaGFuZ2UuY2hpbGRBZGRlZENoYW5nZShcbiAgICAgICAgICBjaGlsZEtleSxcbiAgICAgICAgICBjaGFuZ2Uuc25hcHNob3ROb2RlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlID09IENoYW5nZS5DSElMRF9DSEFOR0VEICYmXG4gICAgICAgIG9sZFR5cGUgPT0gQ2hhbmdlLkNISUxEX0NIQU5HRURcbiAgICAgICkge1xuICAgICAgICB0aGlzLmNoYW5nZU1hcF9bY2hpbGRLZXldID0gQ2hhbmdlLmNoaWxkQ2hhbmdlZENoYW5nZShcbiAgICAgICAgICBjaGlsZEtleSxcbiAgICAgICAgICBjaGFuZ2Uuc25hcHNob3ROb2RlLFxuICAgICAgICAgIG9sZENoYW5nZS5vbGRTbmFwXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcihcbiAgICAgICAgICAnSWxsZWdhbCBjb21iaW5hdGlvbiBvZiBjaGFuZ2VzOiAnICtcbiAgICAgICAgICAgIGNoYW5nZSArXG4gICAgICAgICAgICAnIG9jY3VycmVkIGFmdGVyICcgK1xuICAgICAgICAgICAgb2xkQ2hhbmdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhbmdlTWFwX1tjaGlsZEtleV0gPSBjaGFuZ2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFBcnJheS48IUNoYW5nZT59XG4gICAqL1xuICBnZXRDaGFuZ2VzKCk6IENoYW5nZVtdIHtcbiAgICByZXR1cm4gZ2V0VmFsdWVzKHRoaXMuY2hhbmdlTWFwXyk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDYWNoZU5vZGUgfSBmcm9tICcuL0NhY2hlTm9kZSc7XG5pbXBvcnQgeyBOYW1lZE5vZGUsIE5vZGUgfSBmcm9tICcuLi9zbmFwL05vZGUnO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuLi9zbmFwL2luZGV4ZXMvSW5kZXgnO1xuaW1wb3J0IHsgV3JpdGVUcmVlUmVmIH0gZnJvbSAnLi4vV3JpdGVUcmVlJztcbmltcG9ydCB7IFZpZXdDYWNoZSB9IGZyb20gJy4vVmlld0NhY2hlJztcblxuLyoqXG4gKiBTaW5jZSB1cGRhdGVzIHRvIGZpbHRlcmVkIG5vZGVzIG1pZ2h0IHJlcXVpcmUgbm9kZXMgdG8gYmUgcHVsbGVkIGluIGZyb20gXCJvdXRzaWRlXCIgdGhlIG5vZGUsIHRoaXMgaW50ZXJmYWNlXG4gKiBjYW4gaGVscCB0byBnZXQgY29tcGxldGUgY2hpbGRyZW4gdGhhdCBjYW4gYmUgcHVsbGVkIGluLlxuICogQSBjbGFzcyBpbXBsZW1lbnRpbmcgdGhpcyBpbnRlcmZhY2UgdGFrZXMgcG90ZW50aWFsbHkgbXVsdGlwbGUgc291cmNlcyAoZS5nLiB1c2VyIHdyaXRlcywgc2VydmVyIGRhdGEgZnJvbVxuICogb3RoZXIgdmlld3MgZXRjLikgdG8gdHJ5IGl0J3MgYmVzdCB0byBnZXQgYSBjb21wbGV0ZSBjaGlsZCB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBpbiBwdWxsaW5nIGludG8gdGhlIHZpZXcuXG4gKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRlQ2hpbGRTb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHshc3RyaW5nfSBjaGlsZEtleVxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIGdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXk6IHN0cmluZyk6IE5vZGUgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhcbiAgICogQHBhcmFtIHshTmFtZWROb2RlfSBjaGlsZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VcbiAgICogQHJldHVybiB7P05hbWVkTm9kZX1cbiAgICovXG4gIGdldENoaWxkQWZ0ZXJDaGlsZChcbiAgICBpbmRleDogSW5kZXgsXG4gICAgY2hpbGQ6IE5hbWVkTm9kZSxcbiAgICByZXZlcnNlOiBib29sZWFuXG4gICk6IE5hbWVkTm9kZSB8IG51bGw7XG59XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IG5ldmVyIHJldHVybnMgYW55IGFkZGl0aW9uYWwgY2hpbGRyZW5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyBDb21wbGV0ZUNoaWxkU291cmNlXG4gKi9cbmV4cG9ydCBjbGFzcyBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfIGltcGxlbWVudHMgQ29tcGxldGVDaGlsZFNvdXJjZSB7XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleT86IHN0cmluZyk6IE5vZGUgfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0Q2hpbGRBZnRlckNoaWxkKFxuICAgIGluZGV4PzogSW5kZXgsXG4gICAgY2hpbGQ/OiBOYW1lZE5vZGUsXG4gICAgcmV2ZXJzZT86IGJvb2xlYW5cbiAgKTogTmFtZWROb2RlIHwgbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHshQ29tcGxldGVDaGlsZFNvdXJjZX1cbiAqL1xuZXhwb3J0IGNvbnN0IE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSA9IG5ldyBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfKCk7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IHVzZXMgYSBXcml0ZVRyZWUgaW4gYWRkaXRpb24gdG8gYW55IG90aGVyIHNlcnZlciBkYXRhIG9yXG4gKiBvbGQgZXZlbnQgY2FjaGVzIGF2YWlsYWJsZSB0byBjYWxjdWxhdGUgY29tcGxldGUgY2hpbGRyZW4uXG4gKlxuICpcbiAqIEBpbXBsZW1lbnRzIENvbXBsZXRlQ2hpbGRTb3VyY2VcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2UgaW1wbGVtZW50cyBDb21wbGV0ZUNoaWxkU291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzX1xuICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IHZpZXdDYWNoZV9cbiAgICogQHBhcmFtIHs/Tm9kZX0gb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV9cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgd3JpdGVzXzogV3JpdGVUcmVlUmVmLFxuICAgIHByaXZhdGUgdmlld0NhY2hlXzogVmlld0NhY2hlLFxuICAgIHByaXZhdGUgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV86IE5vZGUgfCBudWxsID0gbnVsbFxuICApIHt9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRDb21wbGV0ZUNoaWxkKGNoaWxkS2V5OiBzdHJpbmcpOiBOb2RlIHwgbnVsbCB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMudmlld0NhY2hlXy5nZXRFdmVudENhY2hlKCk7XG4gICAgaWYgKG5vZGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VydmVyTm9kZSA9XG4gICAgICAgIHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gIT0gbnVsbFxuICAgICAgICAgID8gbmV3IENhY2hlTm9kZSh0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfLCB0cnVlLCBmYWxzZSlcbiAgICAgICAgICA6IHRoaXMudmlld0NhY2hlXy5nZXRTZXJ2ZXJDYWNoZSgpO1xuICAgICAgcmV0dXJuIHRoaXMud3JpdGVzXy5jYWxjQ29tcGxldGVDaGlsZChjaGlsZEtleSwgc2VydmVyTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRDaGlsZEFmdGVyQ2hpbGQoXG4gICAgaW5kZXg6IEluZGV4LFxuICAgIGNoaWxkOiBOYW1lZE5vZGUsXG4gICAgcmV2ZXJzZTogYm9vbGVhblxuICApOiBOYW1lZE5vZGUgfCBudWxsIHtcbiAgICBjb25zdCBjb21wbGV0ZVNlcnZlckRhdGEgPVxuICAgICAgdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXG4gICAgICAgID8gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlX1xuICAgICAgICA6IHRoaXMudmlld0NhY2hlXy5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKTtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMud3JpdGVzXy5jYWxjSW5kZXhlZFNsaWNlKFxuICAgICAgY29tcGxldGVTZXJ2ZXJEYXRhLFxuICAgICAgY2hpbGQsXG4gICAgICAxLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIGluZGV4XG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE9wZXJhdGlvbiwgT3BlcmF0aW9uVHlwZSB9IGZyb20gJy4uL29wZXJhdGlvbi9PcGVyYXRpb24nO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRpb25FcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENoaWxkQ2hhbmdlQWNjdW11bGF0b3IgfSBmcm9tICcuL0NoaWxkQ2hhbmdlQWNjdW11bGF0b3InO1xuaW1wb3J0IHsgQ2hhbmdlIH0gZnJvbSAnLi9DaGFuZ2UnO1xuaW1wb3J0IHsgQ2hpbGRyZW5Ob2RlIH0gZnJvbSAnLi4vc25hcC9DaGlsZHJlbk5vZGUnO1xuaW1wb3J0IHsgS0VZX0lOREVYIH0gZnJvbSAnLi4vc25hcC9pbmRleGVzL0tleUluZGV4JztcbmltcG9ydCB7IEltbXV0YWJsZVRyZWUgfSBmcm9tICcuLi91dGlsL0ltbXV0YWJsZVRyZWUnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL3V0aWwvUGF0aCc7XG5pbXBvcnQge1xuICBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlLFxuICBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsXG4gIENvbXBsZXRlQ2hpbGRTb3VyY2Vcbn0gZnJvbSAnLi9Db21wbGV0ZUNoaWxkU291cmNlJztcbmltcG9ydCB7IFZpZXdDYWNoZSB9IGZyb20gJy4vVmlld0NhY2hlJztcbmltcG9ydCB7IE5vZGVGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlci9Ob2RlRmlsdGVyJztcbmltcG9ydCB7IFdyaXRlVHJlZVJlZiB9IGZyb20gJy4uL1dyaXRlVHJlZSc7XG5pbXBvcnQgeyBPdmVyd3JpdGUgfSBmcm9tICcuLi9vcGVyYXRpb24vT3ZlcndyaXRlJztcbmltcG9ydCB7IE1lcmdlIH0gZnJvbSAnLi4vb3BlcmF0aW9uL01lcmdlJztcbmltcG9ydCB7IEFja1VzZXJXcml0ZSB9IGZyb20gJy4uL29wZXJhdGlvbi9BY2tVc2VyV3JpdGUnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL3NuYXAvTm9kZSc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9jZXNzb3JSZXN1bHQge1xuICAvKipcbiAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICogQHBhcmFtIHshQXJyYXkuPCFDaGFuZ2U+fSBjaGFuZ2VzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgdmlld0NhY2hlOiBWaWV3Q2FjaGUsXG4gICAgcHVibGljIHJlYWRvbmx5IGNoYW5nZXM6IENoYW5nZVtdXG4gICkge31cbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZXdQcm9jZXNzb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHshTm9kZUZpbHRlcn0gZmlsdGVyX1xuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBmaWx0ZXJfOiBOb2RlRmlsdGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IHZpZXdDYWNoZVxuICAgKi9cbiAgYXNzZXJ0SW5kZXhlZCh2aWV3Q2FjaGU6IFZpZXdDYWNoZSkge1xuICAgIGFzc2VydChcbiAgICAgIHZpZXdDYWNoZVxuICAgICAgICAuZ2V0RXZlbnRDYWNoZSgpXG4gICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgLmlzSW5kZXhlZCh0aGlzLmZpbHRlcl8uZ2V0SW5kZXgoKSksXG4gICAgICAnRXZlbnQgc25hcCBub3QgaW5kZXhlZCdcbiAgICApO1xuICAgIGFzc2VydChcbiAgICAgIHZpZXdDYWNoZVxuICAgICAgICAuZ2V0U2VydmVyQ2FjaGUoKVxuICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgIC5pc0luZGV4ZWQodGhpcy5maWx0ZXJfLmdldEluZGV4KCkpLFxuICAgICAgJ1NlcnZlciBzbmFwIG5vdCBpbmRleGVkJ1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshVmlld0NhY2hlfSBvbGRWaWV3Q2FjaGVcbiAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZUNhY2hlXG4gICAqIEByZXR1cm4geyFQcm9jZXNzb3JSZXN1bHR9XG4gICAqL1xuICBhcHBseU9wZXJhdGlvbihcbiAgICBvbGRWaWV3Q2FjaGU6IFZpZXdDYWNoZSxcbiAgICBvcGVyYXRpb246IE9wZXJhdGlvbixcbiAgICB3cml0ZXNDYWNoZTogV3JpdGVUcmVlUmVmLFxuICAgIGNvbXBsZXRlQ2FjaGU6IE5vZGUgfCBudWxsXG4gICk6IFByb2Nlc3NvclJlc3VsdCB7XG4gICAgY29uc3QgYWNjdW11bGF0b3IgPSBuZXcgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcigpO1xuICAgIGxldCBuZXdWaWV3Q2FjaGUsIGZpbHRlclNlcnZlck5vZGU7XG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLk9WRVJXUklURSkge1xuICAgICAgY29uc3Qgb3ZlcndyaXRlID0gb3BlcmF0aW9uIGFzIE92ZXJ3cml0ZTtcbiAgICAgIGlmIChvdmVyd3JpdGUuc291cmNlLmZyb21Vc2VyKSB7XG4gICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMuYXBwbHlVc2VyT3ZlcndyaXRlXyhcbiAgICAgICAgICBvbGRWaWV3Q2FjaGUsXG4gICAgICAgICAgb3ZlcndyaXRlLnBhdGgsXG4gICAgICAgICAgb3ZlcndyaXRlLnNuYXAsXG4gICAgICAgICAgd3JpdGVzQ2FjaGUsXG4gICAgICAgICAgY29tcGxldGVDYWNoZSxcbiAgICAgICAgICBhY2N1bXVsYXRvclxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVNlcnZlciwgJ1Vua25vd24gc291cmNlLicpO1xuICAgICAgICAvLyBXZSBmaWx0ZXIgdGhlIG5vZGUgaWYgaXQncyBhIHRhZ2dlZCB1cGRhdGUgb3IgdGhlIG5vZGUgaGFzIGJlZW4gcHJldmlvdXNseSBmaWx0ZXJlZCAgYW5kIHRoZVxuICAgICAgICAvLyB1cGRhdGUgaXMgbm90IGF0IHRoZSByb290IGluIHdoaWNoIGNhc2UgaXQgaXMgb2sgKGFuZCBuZWNlc3NhcnkpIHRvIG1hcmsgdGhlIG5vZGUgdW5maWx0ZXJlZFxuICAgICAgICAvLyBhZ2FpblxuICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlID1cbiAgICAgICAgICBvdmVyd3JpdGUuc291cmNlLnRhZ2dlZCB8fFxuICAgICAgICAgIChvbGRWaWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0ZpbHRlcmVkKCkgJiZcbiAgICAgICAgICAgICFvdmVyd3JpdGUucGF0aC5pc0VtcHR5KCkpO1xuICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLmFwcGx5U2VydmVyT3ZlcndyaXRlXyhcbiAgICAgICAgICBvbGRWaWV3Q2FjaGUsXG4gICAgICAgICAgb3ZlcndyaXRlLnBhdGgsXG4gICAgICAgICAgb3ZlcndyaXRlLnNuYXAsXG4gICAgICAgICAgd3JpdGVzQ2FjaGUsXG4gICAgICAgICAgY29tcGxldGVDYWNoZSxcbiAgICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlLFxuICAgICAgICAgIGFjY3VtdWxhdG9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5NRVJHRSkge1xuICAgICAgY29uc3QgbWVyZ2UgPSBvcGVyYXRpb24gYXMgTWVyZ2U7XG4gICAgICBpZiAobWVyZ2Uuc291cmNlLmZyb21Vc2VyKSB7XG4gICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMuYXBwbHlVc2VyTWVyZ2VfKFxuICAgICAgICAgIG9sZFZpZXdDYWNoZSxcbiAgICAgICAgICBtZXJnZS5wYXRoLFxuICAgICAgICAgIG1lcmdlLmNoaWxkcmVuLFxuICAgICAgICAgIHdyaXRlc0NhY2hlLFxuICAgICAgICAgIGNvbXBsZXRlQ2FjaGUsXG4gICAgICAgICAgYWNjdW11bGF0b3JcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydChtZXJnZS5zb3VyY2UuZnJvbVNlcnZlciwgJ1Vua25vd24gc291cmNlLicpO1xuICAgICAgICAvLyBXZSBmaWx0ZXIgdGhlIG5vZGUgaWYgaXQncyBhIHRhZ2dlZCB1cGRhdGUgb3IgdGhlIG5vZGUgaGFzIGJlZW4gcHJldmlvdXNseSBmaWx0ZXJlZFxuICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlID1cbiAgICAgICAgICBtZXJnZS5zb3VyY2UudGFnZ2VkIHx8IG9sZFZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRmlsdGVyZWQoKTtcbiAgICAgICAgbmV3Vmlld0NhY2hlID0gdGhpcy5hcHBseVNlcnZlck1lcmdlXyhcbiAgICAgICAgICBvbGRWaWV3Q2FjaGUsXG4gICAgICAgICAgbWVyZ2UucGF0aCxcbiAgICAgICAgICBtZXJnZS5jaGlsZHJlbixcbiAgICAgICAgICB3cml0ZXNDYWNoZSxcbiAgICAgICAgICBjb21wbGV0ZUNhY2hlLFxuICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUsXG4gICAgICAgICAgYWNjdW11bGF0b3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFKSB7XG4gICAgICBjb25zdCBhY2tVc2VyV3JpdGUgPSBvcGVyYXRpb24gYXMgQWNrVXNlcldyaXRlO1xuICAgICAgaWYgKCFhY2tVc2VyV3JpdGUucmV2ZXJ0KSB7XG4gICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMuYWNrVXNlcldyaXRlXyhcbiAgICAgICAgICBvbGRWaWV3Q2FjaGUsXG4gICAgICAgICAgYWNrVXNlcldyaXRlLnBhdGgsXG4gICAgICAgICAgYWNrVXNlcldyaXRlLmFmZmVjdGVkVHJlZSxcbiAgICAgICAgICB3cml0ZXNDYWNoZSxcbiAgICAgICAgICBjb21wbGV0ZUNhY2hlLFxuICAgICAgICAgIGFjY3VtdWxhdG9yXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLnJldmVydFVzZXJXcml0ZV8oXG4gICAgICAgICAgb2xkVmlld0NhY2hlLFxuICAgICAgICAgIGFja1VzZXJXcml0ZS5wYXRoLFxuICAgICAgICAgIHdyaXRlc0NhY2hlLFxuICAgICAgICAgIGNvbXBsZXRlQ2FjaGUsXG4gICAgICAgICAgYWNjdW11bGF0b3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLkxJU1RFTl9DT01QTEVURSkge1xuICAgICAgbmV3Vmlld0NhY2hlID0gdGhpcy5saXN0ZW5Db21wbGV0ZV8oXG4gICAgICAgIG9sZFZpZXdDYWNoZSxcbiAgICAgICAgb3BlcmF0aW9uLnBhdGgsXG4gICAgICAgIHdyaXRlc0NhY2hlLFxuICAgICAgICBhY2N1bXVsYXRvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ1Vua25vd24gb3BlcmF0aW9uIHR5cGU6ICcgKyBvcGVyYXRpb24udHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZXMgPSBhY2N1bXVsYXRvci5nZXRDaGFuZ2VzKCk7XG4gICAgVmlld1Byb2Nlc3Nvci5tYXliZUFkZFZhbHVlRXZlbnRfKG9sZFZpZXdDYWNoZSwgbmV3Vmlld0NhY2hlLCBjaGFuZ2VzKTtcbiAgICByZXR1cm4gbmV3IFByb2Nlc3NvclJlc3VsdChuZXdWaWV3Q2FjaGUsIGNoYW5nZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gb2xkVmlld0NhY2hlXG4gICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gbmV3Vmlld0NhY2hlXG4gICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gYWNjdW11bGF0b3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIG1heWJlQWRkVmFsdWVFdmVudF8oXG4gICAgb2xkVmlld0NhY2hlOiBWaWV3Q2FjaGUsXG4gICAgbmV3Vmlld0NhY2hlOiBWaWV3Q2FjaGUsXG4gICAgYWNjdW11bGF0b3I6IENoYW5nZVtdXG4gICkge1xuICAgIGNvbnN0IGV2ZW50U25hcCA9IG5ld1ZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCk7XG4gICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xuICAgICAgY29uc3QgaXNMZWFmT3JFbXB0eSA9XG4gICAgICAgIGV2ZW50U25hcC5nZXROb2RlKCkuaXNMZWFmTm9kZSgpIHx8IGV2ZW50U25hcC5nZXROb2RlKCkuaXNFbXB0eSgpO1xuICAgICAgY29uc3Qgb2xkQ29tcGxldGVTbmFwID0gb2xkVmlld0NhY2hlLmdldENvbXBsZXRlRXZlbnRTbmFwKCk7XG4gICAgICBpZiAoXG4gICAgICAgIGFjY3VtdWxhdG9yLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgIW9sZFZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCkgfHxcbiAgICAgICAgKGlzTGVhZk9yRW1wdHkgJiZcbiAgICAgICAgICAhZXZlbnRTbmFwXG4gICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAuZXF1YWxzKC8qKiBAdHlwZSB7IU5vZGV9ICovIChvbGRDb21wbGV0ZVNuYXApKSkgfHxcbiAgICAgICAgIWV2ZW50U25hcFxuICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAuZ2V0UHJpb3JpdHkoKVxuICAgICAgICAgIC5lcXVhbHMob2xkQ29tcGxldGVTbmFwLmdldFByaW9yaXR5KCkpXG4gICAgICApIHtcbiAgICAgICAgYWNjdW11bGF0b3IucHVzaChcbiAgICAgICAgICBDaGFuZ2UudmFsdWVDaGFuZ2UoXG4gICAgICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqLyBuZXdWaWV3Q2FjaGUuZ2V0Q29tcGxldGVFdmVudFNuYXAoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICogQHBhcmFtIHshUGF0aH0gY2hhbmdlUGF0aFxuICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAqIEBwYXJhbSB7IUNvbXBsZXRlQ2hpbGRTb3VyY2V9IHNvdXJjZVxuICAgKiBAcGFyYW0geyFDaGlsZENoYW5nZUFjY3VtdWxhdG9yfSBhY2N1bXVsYXRvclxuICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50XyhcbiAgICB2aWV3Q2FjaGU6IFZpZXdDYWNoZSxcbiAgICBjaGFuZ2VQYXRoOiBQYXRoLFxuICAgIHdyaXRlc0NhY2hlOiBXcml0ZVRyZWVSZWYsXG4gICAgc291cmNlOiBDb21wbGV0ZUNoaWxkU291cmNlLFxuICAgIGFjY3VtdWxhdG9yOiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yXG4gICk6IFZpZXdDYWNoZSB7XG4gICAgY29uc3Qgb2xkRXZlbnRTbmFwID0gdmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKTtcbiAgICBpZiAod3JpdGVzQ2FjaGUuc2hhZG93aW5nV3JpdGUoY2hhbmdlUGF0aCkgIT0gbnVsbCkge1xuICAgICAgLy8gd2UgaGF2ZSBhIHNoYWRvd2luZyB3cml0ZSwgaWdub3JlIGNoYW5nZXNcbiAgICAgIHJldHVybiB2aWV3Q2FjaGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdFdmVudENhY2hlLCBzZXJ2ZXJOb2RlO1xuICAgICAgaWYgKGNoYW5nZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRoaXMgcGxheXMgd2l0aCBcInNsaWRpbmcgYWNrIHdpbmRvd3NcIlxuICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCksXG4gICAgICAgICAgJ0lmIGNoYW5nZSBwYXRoIGlzIGVtcHR5LCB3ZSBtdXN0IGhhdmUgY29tcGxldGUgc2VydmVyIGRhdGEnXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0ZpbHRlcmVkKCkpIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNwZWNpYWwgY2FzZSB0aGlzLCBiZWNhdXNlIHdlIG5lZWQgdG8gb25seSBhcHBseSB3cml0ZXMgdG8gY29tcGxldGUgY2hpbGRyZW4sIG9yXG4gICAgICAgICAgLy8gd2UgbWlnaHQgZW5kIHVwIHJhaXNpbmcgZXZlbnRzIGZvciBpbmNvbXBsZXRlIGNoaWxkcmVuLiBJZiB0aGUgc2VydmVyIGRhdGEgaXMgZmlsdGVyZWQgZGVlcFxuICAgICAgICAgIC8vIHdyaXRlcyBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0byBiZSBjb21wbGV0ZVxuICAgICAgICAgIGNvbnN0IHNlcnZlckNhY2hlID0gdmlld0NhY2hlLmdldENvbXBsZXRlU2VydmVyU25hcCgpO1xuICAgICAgICAgIGNvbnN0IGNvbXBsZXRlQ2hpbGRyZW4gPVxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgaW5zdGFuY2VvZiBDaGlsZHJlbk5vZGVcbiAgICAgICAgICAgICAgPyBzZXJ2ZXJDYWNoZVxuICAgICAgICAgICAgICA6IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICAgIGNvbnN0IGNvbXBsZXRlRXZlbnRDaGlsZHJlbiA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuXG4gICAgICAgICAgKTtcbiAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKFxuICAgICAgICAgICAgdmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5nZXROb2RlKCksXG4gICAgICAgICAgICBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4sXG4gICAgICAgICAgICBhY2N1bXVsYXRvclxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY29tcGxldGVOb2RlID0gd3JpdGVzQ2FjaGUuY2FsY0NvbXBsZXRlRXZlbnRDYWNoZShcbiAgICAgICAgICAgIHZpZXdDYWNoZS5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVGdWxsTm9kZShcbiAgICAgICAgICAgIHZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCkuZ2V0Tm9kZSgpLFxuICAgICAgICAgICAgY29tcGxldGVOb2RlLFxuICAgICAgICAgICAgYWNjdW11bGF0b3JcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaGlsZEtleSA9IGNoYW5nZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgaWYgKGNoaWxkS2V5ID09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgY2hhbmdlUGF0aC5nZXRMZW5ndGgoKSA9PSAxLFxuICAgICAgICAgICAgXCJDYW4ndCBoYXZlIGEgcHJpb3JpdHkgd2l0aCBhZGRpdGlvbmFsIHBhdGggY29tcG9uZW50c1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBvbGRFdmVudE5vZGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xuICAgICAgICAgIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5nZXROb2RlKCk7XG4gICAgICAgICAgLy8gd2UgbWlnaHQgaGF2ZSBvdmVyd3JpdGVzIGZvciB0aGlzIHByaW9yaXR5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByaW9yaXR5ID0gd3JpdGVzQ2FjaGUuY2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZShcbiAgICAgICAgICAgIGNoYW5nZVBhdGgsXG4gICAgICAgICAgICBvbGRFdmVudE5vZGUsXG4gICAgICAgICAgICBzZXJ2ZXJOb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodXBkYXRlZFByaW9yaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlUHJpb3JpdHkoXG4gICAgICAgICAgICAgIG9sZEV2ZW50Tm9kZSxcbiAgICAgICAgICAgICAgdXBkYXRlZFByaW9yaXR5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwcmlvcml0eSBkaWRuJ3QgY2hhbmdlLCBrZWVwIG9sZCBub2RlXG4gICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VQYXRoID0gY2hhbmdlUGF0aC5wb3BGcm9udCgpO1xuICAgICAgICAgIC8vIHVwZGF0ZSBjaGlsZFxuICAgICAgICAgIGxldCBuZXdFdmVudENoaWxkO1xuICAgICAgICAgIGlmIChvbGRFdmVudFNuYXAuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgICAgICAgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmdldE5vZGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50Q2hpbGRVcGRhdGUgPSB3cml0ZXNDYWNoZS5jYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKFxuICAgICAgICAgICAgICBjaGFuZ2VQYXRoLFxuICAgICAgICAgICAgICBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLFxuICAgICAgICAgICAgICBzZXJ2ZXJOb2RlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGV2ZW50Q2hpbGRVcGRhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdFdmVudENoaWxkID0gb2xkRXZlbnRTbmFwXG4gICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSlcbiAgICAgICAgICAgICAgICAudXBkYXRlQ2hpbGQoY2hpbGRDaGFuZ2VQYXRoLCBldmVudENoaWxkVXBkYXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZCwganVzdCBrZWVwIHRoZSBvbGQgY2hpbGRcbiAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IG9sZEV2ZW50U25hcFxuICAgICAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdFdmVudENoaWxkID0gd3JpdGVzQ2FjaGUuY2FsY0NvbXBsZXRlQ2hpbGQoXG4gICAgICAgICAgICAgIGNoaWxkS2V5LFxuICAgICAgICAgICAgICB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5ld0V2ZW50Q2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVDaGlsZChcbiAgICAgICAgICAgICAgb2xkRXZlbnRTbmFwLmdldE5vZGUoKSxcbiAgICAgICAgICAgICAgY2hpbGRLZXksXG4gICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQsXG4gICAgICAgICAgICAgIGNoaWxkQ2hhbmdlUGF0aCxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gY29tcGxldGUgY2hpbGQgYXZhaWxhYmxlIG9yIG5vIGNoYW5nZVxuICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmlld0NhY2hlLnVwZGF0ZUV2ZW50U25hcChcbiAgICAgICAgbmV3RXZlbnRDYWNoZSxcbiAgICAgICAgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IGNoYW5nZVBhdGguaXNFbXB0eSgpLFxuICAgICAgICB0aGlzLmZpbHRlcl8uZmlsdGVyc05vZGVzKClcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gb2xkVmlld0NhY2hlXG4gICAqIEBwYXJhbSB7IVBhdGh9IGNoYW5nZVBhdGhcbiAgICogQHBhcmFtIHshTm9kZX0gY2hhbmdlZFNuYXBcbiAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZUNhY2hlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyU2VydmVyTm9kZVxuICAgKiBAcGFyYW0geyFDaGlsZENoYW5nZUFjY3VtdWxhdG9yfSBhY2N1bXVsYXRvclxuICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXBwbHlTZXJ2ZXJPdmVyd3JpdGVfKFxuICAgIG9sZFZpZXdDYWNoZTogVmlld0NhY2hlLFxuICAgIGNoYW5nZVBhdGg6IFBhdGgsXG4gICAgY2hhbmdlZFNuYXA6IE5vZGUsXG4gICAgd3JpdGVzQ2FjaGU6IFdyaXRlVHJlZVJlZixcbiAgICBjb21wbGV0ZUNhY2hlOiBOb2RlIHwgbnVsbCxcbiAgICBmaWx0ZXJTZXJ2ZXJOb2RlOiBib29sZWFuLFxuICAgIGFjY3VtdWxhdG9yOiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yXG4gICk6IFZpZXdDYWNoZSB7XG4gICAgY29uc3Qgb2xkU2VydmVyU25hcCA9IG9sZFZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpO1xuICAgIGxldCBuZXdTZXJ2ZXJDYWNoZTtcbiAgICBjb25zdCBzZXJ2ZXJGaWx0ZXIgPSBmaWx0ZXJTZXJ2ZXJOb2RlXG4gICAgICA/IHRoaXMuZmlsdGVyX1xuICAgICAgOiB0aGlzLmZpbHRlcl8uZ2V0SW5kZXhlZEZpbHRlcigpO1xuICAgIGlmIChjaGFuZ2VQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUoXG4gICAgICAgIG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLFxuICAgICAgICBjaGFuZ2VkU25hcCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHNlcnZlckZpbHRlci5maWx0ZXJzTm9kZXMoKSAmJiAhb2xkU2VydmVyU25hcC5pc0ZpbHRlcmVkKCkpIHtcbiAgICAgIC8vIHdlIHdhbnQgdG8gZmlsdGVyIHRoZSBzZXJ2ZXIgbm9kZSwgYnV0IHdlIGRpZG4ndCBmaWx0ZXIgdGhlIHNlcnZlciBub2RlIHlldCwgc28gc2ltdWxhdGUgYSBmdWxsIHVwZGF0ZVxuICAgICAgY29uc3QgbmV3U2VydmVyTm9kZSA9IG9sZFNlcnZlclNuYXBcbiAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAudXBkYXRlQ2hpbGQoY2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xuICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUoXG4gICAgICAgIG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLFxuICAgICAgICBuZXdTZXJ2ZXJOb2RlLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGlsZEtleSA9IGNoYW5nZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgIW9sZFNlcnZlclNuYXAuaXNDb21wbGV0ZUZvclBhdGgoY2hhbmdlUGF0aCkgJiZcbiAgICAgICAgY2hhbmdlUGF0aC5nZXRMZW5ndGgoKSA+IDFcbiAgICAgICkge1xuICAgICAgICAvLyBXZSBkb24ndCB1cGRhdGUgaW5jb21wbGV0ZSBub2RlcyB3aXRoIHVwZGF0ZXMgaW50ZW5kZWQgZm9yIG90aGVyIGxpc3RlbmVyc1xuICAgICAgICByZXR1cm4gb2xkVmlld0NhY2hlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRDaGFuZ2VQYXRoID0gY2hhbmdlUGF0aC5wb3BGcm9udCgpO1xuICAgICAgY29uc3QgY2hpbGROb2RlID0gb2xkU2VydmVyU25hcC5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xuICAgICAgaWYgKGNoaWxkS2V5ID09ICcucHJpb3JpdHknKSB7XG4gICAgICAgIG5ld1NlcnZlckNhY2hlID0gc2VydmVyRmlsdGVyLnVwZGF0ZVByaW9yaXR5KFxuICAgICAgICAgIG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLFxuICAgICAgICAgIG5ld0NoaWxkTm9kZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlQ2hpbGQoXG4gICAgICAgICAgb2xkU2VydmVyU25hcC5nZXROb2RlKCksXG4gICAgICAgICAgY2hpbGRLZXksXG4gICAgICAgICAgbmV3Q2hpbGROb2RlLFxuICAgICAgICAgIGNoaWxkQ2hhbmdlUGF0aCxcbiAgICAgICAgICBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGUudXBkYXRlU2VydmVyU25hcChcbiAgICAgIG5ld1NlcnZlckNhY2hlLFxuICAgICAgb2xkU2VydmVyU25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBjaGFuZ2VQYXRoLmlzRW1wdHkoKSxcbiAgICAgIHNlcnZlckZpbHRlci5maWx0ZXJzTm9kZXMoKVxuICAgICk7XG4gICAgY29uc3Qgc291cmNlID0gbmV3IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2UoXG4gICAgICB3cml0ZXNDYWNoZSxcbiAgICAgIG5ld1ZpZXdDYWNoZSxcbiAgICAgIGNvbXBsZXRlQ2FjaGVcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnRfKFxuICAgICAgbmV3Vmlld0NhY2hlLFxuICAgICAgY2hhbmdlUGF0aCxcbiAgICAgIHdyaXRlc0NhY2hlLFxuICAgICAgc291cmNlLFxuICAgICAgYWNjdW11bGF0b3JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gb2xkVmlld0NhY2hlXG4gICAqIEBwYXJhbSB7IVBhdGh9IGNoYW5nZVBhdGhcbiAgICogQHBhcmFtIHshTm9kZX0gY2hhbmdlZFNuYXBcbiAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZUNhY2hlXG4gICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhcHBseVVzZXJPdmVyd3JpdGVfKFxuICAgIG9sZFZpZXdDYWNoZTogVmlld0NhY2hlLFxuICAgIGNoYW5nZVBhdGg6IFBhdGgsXG4gICAgY2hhbmdlZFNuYXA6IE5vZGUsXG4gICAgd3JpdGVzQ2FjaGU6IFdyaXRlVHJlZVJlZixcbiAgICBjb21wbGV0ZUNhY2hlOiBOb2RlIHwgbnVsbCxcbiAgICBhY2N1bXVsYXRvcjogQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvclxuICApOiBWaWV3Q2FjaGUge1xuICAgIGNvbnN0IG9sZEV2ZW50U25hcCA9IG9sZFZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCk7XG4gICAgbGV0IG5ld1ZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZTtcbiAgICBjb25zdCBzb3VyY2UgPSBuZXcgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZShcbiAgICAgIHdyaXRlc0NhY2hlLFxuICAgICAgb2xkVmlld0NhY2hlLFxuICAgICAgY29tcGxldGVDYWNoZVxuICAgICk7XG4gICAgaWYgKGNoYW5nZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKFxuICAgICAgICBvbGRWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKSxcbiAgICAgICAgY2hhbmdlZFNuYXAsXG4gICAgICAgIGFjY3VtdWxhdG9yXG4gICAgICApO1xuICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlLnVwZGF0ZUV2ZW50U25hcChcbiAgICAgICAgbmV3RXZlbnRDYWNoZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5maWx0ZXJfLmZpbHRlcnNOb2RlcygpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGlsZEtleSA9IGNoYW5nZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVQcmlvcml0eShcbiAgICAgICAgICBvbGRWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKSxcbiAgICAgICAgICBjaGFuZ2VkU25hcFxuICAgICAgICApO1xuICAgICAgICBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGUudXBkYXRlRXZlbnRTbmFwKFxuICAgICAgICAgIG5ld0V2ZW50Q2FjaGUsXG4gICAgICAgICAgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLFxuICAgICAgICAgIG9sZEV2ZW50U25hcC5pc0ZpbHRlcmVkKClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlUGF0aCA9IGNoYW5nZVBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgbGV0IG5ld0NoaWxkO1xuICAgICAgICBpZiAoY2hpbGRDaGFuZ2VQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgIC8vIENoaWxkIG92ZXJ3cml0ZSwgd2UgY2FuIHJlcGxhY2UgdGhlIGNoaWxkXG4gICAgICAgICAgbmV3Q2hpbGQgPSBjaGFuZ2VkU25hcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBzb3VyY2UuZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGNoaWxkQ2hhbmdlUGF0aC5nZXRCYWNrKCkgPT09ICcucHJpb3JpdHknICYmXG4gICAgICAgICAgICAgIGNoaWxkTm9kZS5nZXRDaGlsZChjaGlsZENoYW5nZVBhdGgucGFyZW50KCkpLmlzRW1wdHkoKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcmlvcml0eSB1cGRhdGUgb24gYW4gZW1wdHkgbm9kZS4gSWYgdGhpcyBub2RlIGV4aXN0cyBvbiB0aGUgc2VydmVyLCB0aGVcbiAgICAgICAgICAgICAgLy8gc2VydmVyIHdpbGwgc2VuZCBkb3duIHRoZSBwcmlvcml0eSBpbiB0aGUgdXBkYXRlLCBzbyBpZ25vcmUgZm9yIG5vd1xuICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBjb21wbGV0ZSBjaGlsZCBub2RlIGF2YWlsYWJsZVxuICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpKSB7XG4gICAgICAgICAgY29uc3QgbmV3RXZlbnRTbmFwID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUNoaWxkKFxuICAgICAgICAgICAgb2xkRXZlbnRTbmFwLmdldE5vZGUoKSxcbiAgICAgICAgICAgIGNoaWxkS2V5LFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICBjaGlsZENoYW5nZVBhdGgsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBhY2N1bXVsYXRvclxuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlLnVwZGF0ZUV2ZW50U25hcChcbiAgICAgICAgICAgIG5ld0V2ZW50U25hcCxcbiAgICAgICAgICAgIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSxcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyXy5maWx0ZXJzTm9kZXMoKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdWaWV3Q2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBjYWNoZUhhc0NoaWxkXyhcbiAgICB2aWV3Q2FjaGU6IFZpZXdDYWNoZSxcbiAgICBjaGlsZEtleTogc3RyaW5nXG4gICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2aWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGVcbiAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXBwbHlVc2VyTWVyZ2VfKFxuICAgIHZpZXdDYWNoZTogVmlld0NhY2hlLFxuICAgIHBhdGg6IFBhdGgsXG4gICAgY2hhbmdlZENoaWxkcmVuOiBJbW11dGFibGVUcmVlPE5vZGU+LFxuICAgIHdyaXRlc0NhY2hlOiBXcml0ZVRyZWVSZWYsXG4gICAgc2VydmVyQ2FjaGU6IE5vZGUgfCBudWxsLFxuICAgIGFjY3VtdWxhdG9yOiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yXG4gICk6IFZpZXdDYWNoZSB7XG4gICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcbiAgICAvLyB3aW5kb3cgbGVhdmluZyByb29tIGZvciBuZXcgaXRlbXMuICBJdCdzIGltcG9ydGFudCB3ZSBwcm9jZXNzIHRoZXNlIGNoYW5nZXMgZmlyc3QsIHNvIHdlXG4gICAgLy8gaXRlcmF0ZSB0aGUgY2hhbmdlcyB0d2ljZSwgZmlyc3QgcHJvY2Vzc2luZyBhbnkgdGhhdCBhZmZlY3QgaXRlbXMgY3VycmVudGx5IGluIHZpZXcuXG4gICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxuICAgIC8vIGFuZCBldmVudCBzbmFwLiAgSSdtIG5vdCBzdXJlIGlmIHRoaXMgd2lsbCByZXN1bHQgaW4gZWRnZSBjYXNlcyB3aGVuIGEgY2hpbGQgaXMgaW4gb25lIGJ1dFxuICAgIC8vIG5vdCB0aGUgb3RoZXIuXG4gICAgbGV0IGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcbiAgICBjaGFuZ2VkQ2hpbGRyZW4uZm9yZWFjaCgocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHdyaXRlUGF0aCA9IHBhdGguY2hpbGQocmVsYXRpdmVQYXRoKTtcbiAgICAgIGlmIChWaWV3UHJvY2Vzc29yLmNhY2hlSGFzQ2hpbGRfKHZpZXdDYWNoZSwgd3JpdGVQYXRoLmdldEZyb250KCkpKSB7XG4gICAgICAgIGN1clZpZXdDYWNoZSA9IHRoaXMuYXBwbHlVc2VyT3ZlcndyaXRlXyhcbiAgICAgICAgICBjdXJWaWV3Q2FjaGUsXG4gICAgICAgICAgd3JpdGVQYXRoLFxuICAgICAgICAgIGNoaWxkTm9kZSxcbiAgICAgICAgICB3cml0ZXNDYWNoZSxcbiAgICAgICAgICBzZXJ2ZXJDYWNoZSxcbiAgICAgICAgICBhY2N1bXVsYXRvclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY2hhbmdlZENoaWxkcmVuLmZvcmVhY2goKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCB3cml0ZVBhdGggPSBwYXRoLmNoaWxkKHJlbGF0aXZlUGF0aCk7XG4gICAgICBpZiAoIVZpZXdQcm9jZXNzb3IuY2FjaGVIYXNDaGlsZF8odmlld0NhY2hlLCB3cml0ZVBhdGguZ2V0RnJvbnQoKSkpIHtcbiAgICAgICAgY3VyVmlld0NhY2hlID0gdGhpcy5hcHBseVVzZXJPdmVyd3JpdGVfKFxuICAgICAgICAgIGN1clZpZXdDYWNoZSxcbiAgICAgICAgICB3cml0ZVBhdGgsXG4gICAgICAgICAgY2hpbGROb2RlLFxuICAgICAgICAgIHdyaXRlc0NhY2hlLFxuICAgICAgICAgIHNlcnZlckNhY2hlLFxuICAgICAgICAgIGFjY3VtdWxhdG9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3VyVmlld0NhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtJbW11dGFibGVUcmVlLjwhTm9kZT59IG1lcmdlXG4gICAqIEByZXR1cm4geyFOb2RlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhcHBseU1lcmdlXyhub2RlOiBOb2RlLCBtZXJnZTogSW1tdXRhYmxlVHJlZTxOb2RlPik6IE5vZGUge1xuICAgIG1lcmdlLmZvcmVhY2goZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IHZpZXdDYWNoZVxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWUuPCFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGVcbiAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJTZXJ2ZXJOb2RlXG4gICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFwcGx5U2VydmVyTWVyZ2VfKFxuICAgIHZpZXdDYWNoZTogVmlld0NhY2hlLFxuICAgIHBhdGg6IFBhdGgsXG4gICAgY2hhbmdlZENoaWxkcmVuOiBJbW11dGFibGVUcmVlPE5vZGU+LFxuICAgIHdyaXRlc0NhY2hlOiBXcml0ZVRyZWVSZWYsXG4gICAgc2VydmVyQ2FjaGU6IE5vZGUgfCBudWxsLFxuICAgIGZpbHRlclNlcnZlck5vZGU6IGJvb2xlYW4sXG4gICAgYWNjdW11bGF0b3I6IENoaWxkQ2hhbmdlQWNjdW11bGF0b3JcbiAgKTogVmlld0NhY2hlIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2FjaGUgeWV0LCB0aGlzIG1lcmdlIHdhcyBpbnRlbmRlZCBmb3IgYSBwcmV2aW91c2x5IGxpc3RlbiBpbiB0aGUgc2FtZSBsb2NhdGlvbi4gSWdub3JlIGl0IGFuZFxuICAgIC8vIHdhaXQgZm9yIHRoZSBjb21wbGV0ZSBkYXRhIHVwZGF0ZSBjb21pbmcgc29vbi5cbiAgICBpZiAoXG4gICAgICB2aWV3Q2FjaGVcbiAgICAgICAgLmdldFNlcnZlckNhY2hlKClcbiAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAuaXNFbXB0eSgpICYmXG4gICAgICAhdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKClcbiAgICApIHtcbiAgICAgIHJldHVybiB2aWV3Q2FjaGU7XG4gICAgfVxuXG4gICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcbiAgICAvLyB3aW5kb3cgbGVhdmluZyByb29tIGZvciBuZXcgaXRlbXMuICBJdCdzIGltcG9ydGFudCB3ZSBwcm9jZXNzIHRoZXNlIGNoYW5nZXMgZmlyc3QsIHNvIHdlXG4gICAgLy8gaXRlcmF0ZSB0aGUgY2hhbmdlcyB0d2ljZSwgZmlyc3QgcHJvY2Vzc2luZyBhbnkgdGhhdCBhZmZlY3QgaXRlbXMgY3VycmVudGx5IGluIHZpZXcuXG4gICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxuICAgIC8vIGFuZCBldmVudCBzbmFwLiAgSSdtIG5vdCBzdXJlIGlmIHRoaXMgd2lsbCByZXN1bHQgaW4gZWRnZSBjYXNlcyB3aGVuIGEgY2hpbGQgaXMgaW4gb25lIGJ1dFxuICAgIC8vIG5vdCB0aGUgb3RoZXIuXG4gICAgbGV0IGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcbiAgICBsZXQgdmlld01lcmdlVHJlZTtcbiAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHZpZXdNZXJnZVRyZWUgPSBjaGFuZ2VkQ2hpbGRyZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXdNZXJnZVRyZWUgPSBJbW11dGFibGVUcmVlLkVtcHR5LnNldFRyZWUocGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3Qgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmdldE5vZGUoKTtcbiAgICB2aWV3TWVyZ2VUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkS2V5LCBjaGlsZFRyZWUpID0+IHtcbiAgICAgIGlmIChzZXJ2ZXJOb2RlLmhhc0NoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJDaGlsZCA9IHZpZXdDYWNoZVxuICAgICAgICAgIC5nZXRTZXJ2ZXJDYWNoZSgpXG4gICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgIGNvbnN0IG5ld0NoaWxkID0gdGhpcy5hcHBseU1lcmdlXyhzZXJ2ZXJDaGlsZCwgY2hpbGRUcmVlKTtcbiAgICAgICAgY3VyVmlld0NhY2hlID0gdGhpcy5hcHBseVNlcnZlck92ZXJ3cml0ZV8oXG4gICAgICAgICAgY3VyVmlld0NhY2hlLFxuICAgICAgICAgIG5ldyBQYXRoKGNoaWxkS2V5KSxcbiAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICB3cml0ZXNDYWNoZSxcbiAgICAgICAgICBzZXJ2ZXJDYWNoZSxcbiAgICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlLFxuICAgICAgICAgIGFjY3VtdWxhdG9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmlld01lcmdlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRNZXJnZVRyZWUpID0+IHtcbiAgICAgIGNvbnN0IGlzVW5rbm93bkRlZXBNZXJnZSA9XG4gICAgICAgICF2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpICYmXG4gICAgICAgIGNoaWxkTWVyZ2VUcmVlLnZhbHVlID09IG51bGw7XG4gICAgICBpZiAoIXNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpICYmICFpc1Vua25vd25EZWVwTWVyZ2UpIHtcbiAgICAgICAgY29uc3Qgc2VydmVyQ2hpbGQgPSB2aWV3Q2FjaGVcbiAgICAgICAgICAuZ2V0U2VydmVyQ2FjaGUoKVxuICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICBjb25zdCBuZXdDaGlsZCA9IHRoaXMuYXBwbHlNZXJnZV8oc2VydmVyQ2hpbGQsIGNoaWxkTWVyZ2VUcmVlKTtcbiAgICAgICAgY3VyVmlld0NhY2hlID0gdGhpcy5hcHBseVNlcnZlck92ZXJ3cml0ZV8oXG4gICAgICAgICAgY3VyVmlld0NhY2hlLFxuICAgICAgICAgIG5ldyBQYXRoKGNoaWxkS2V5KSxcbiAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICB3cml0ZXNDYWNoZSxcbiAgICAgICAgICBzZXJ2ZXJDYWNoZSxcbiAgICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlLFxuICAgICAgICAgIGFjY3VtdWxhdG9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3VyVmlld0NhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAqIEBwYXJhbSB7IVBhdGh9IGFja1BhdGhcbiAgICogQHBhcmFtIHshSW1tdXRhYmxlVHJlZTwhYm9vbGVhbj59IGFmZmVjdGVkVHJlZVxuICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlQ2FjaGVcbiAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYWNrVXNlcldyaXRlXyhcbiAgICB2aWV3Q2FjaGU6IFZpZXdDYWNoZSxcbiAgICBhY2tQYXRoOiBQYXRoLFxuICAgIGFmZmVjdGVkVHJlZTogSW1tdXRhYmxlVHJlZTxib29sZWFuPixcbiAgICB3cml0ZXNDYWNoZTogV3JpdGVUcmVlUmVmLFxuICAgIGNvbXBsZXRlQ2FjaGU6IE5vZGUgfCBudWxsLFxuICAgIGFjY3VtdWxhdG9yOiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yXG4gICk6IFZpZXdDYWNoZSB7XG4gICAgaWYgKHdyaXRlc0NhY2hlLnNoYWRvd2luZ1dyaXRlKGFja1BhdGgpICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB2aWV3Q2FjaGU7XG4gICAgfVxuXG4gICAgLy8gT25seSBmaWx0ZXIgc2VydmVyIG5vZGUgaWYgaXQgaXMgY3VycmVudGx5IGZpbHRlcmVkXG4gICAgY29uc3QgZmlsdGVyU2VydmVyTm9kZSA9IHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRmlsdGVyZWQoKTtcblxuICAgIC8vIEVzc2VudGlhbGx5IHdlJ2xsIGp1c3QgZ2V0IG91ciBleGlzdGluZyBzZXJ2ZXIgY2FjaGUgZm9yIHRoZSBhZmZlY3RlZCBwYXRocyBhbmQgcmUtYXBwbHkgaXQgYXMgYSBzZXJ2ZXIgdXBkYXRlXG4gICAgLy8gbm93IHRoYXQgaXQgd29uJ3QgYmUgc2hhZG93ZWQuXG4gICAgY29uc3Qgc2VydmVyQ2FjaGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKTtcbiAgICBpZiAoYWZmZWN0ZWRUcmVlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gb3ZlcndyaXRlLlxuICAgICAgaWYgKFxuICAgICAgICAoYWNrUGF0aC5pc0VtcHR5KCkgJiYgc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHx8XG4gICAgICAgIHNlcnZlckNhY2hlLmlzQ29tcGxldGVGb3JQYXRoKGFja1BhdGgpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlTZXJ2ZXJPdmVyd3JpdGVfKFxuICAgICAgICAgIHZpZXdDYWNoZSxcbiAgICAgICAgICBhY2tQYXRoLFxuICAgICAgICAgIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChhY2tQYXRoKSxcbiAgICAgICAgICB3cml0ZXNDYWNoZSxcbiAgICAgICAgICBjb21wbGV0ZUNhY2hlLFxuICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUsXG4gICAgICAgICAgYWNjdW11bGF0b3JcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYWNrUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGdvb2Z5IGVkZ2UgY2FzZSB3aGVyZSB3ZSBhcmUgYWNraW5nIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBidXQgZG9uJ3QgaGF2ZSBmdWxsIGRhdGEuICBXZVxuICAgICAgICAvLyBzaG91bGQganVzdCByZS1hcHBseSB3aGF0ZXZlciB3ZSBoYXZlIGluIG91ciBjYWNoZSBhcyBhIG1lcmdlLlxuICAgICAgICBsZXQgY2hhbmdlZENoaWxkcmVuID0gSW1tdXRhYmxlVHJlZS5FbXB0eTtcbiAgICAgICAgc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmZvckVhY2hDaGlsZChLRVlfSU5ERVgsIGZ1bmN0aW9uKG5hbWUsIG5vZGUpIHtcbiAgICAgICAgICBjaGFuZ2VkQ2hpbGRyZW4gPSBjaGFuZ2VkQ2hpbGRyZW4uc2V0KG5ldyBQYXRoKG5hbWUpLCBub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5U2VydmVyTWVyZ2VfKFxuICAgICAgICAgIHZpZXdDYWNoZSxcbiAgICAgICAgICBhY2tQYXRoLFxuICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbixcbiAgICAgICAgICB3cml0ZXNDYWNoZSxcbiAgICAgICAgICBjb21wbGV0ZUNhY2hlLFxuICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUsXG4gICAgICAgICAgYWNjdW11bGF0b3JcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBtZXJnZS5cbiAgICAgIGxldCBjaGFuZ2VkQ2hpbGRyZW4gPSBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgYWZmZWN0ZWRUcmVlLmZvcmVhY2goZnVuY3Rpb24obWVyZ2VQYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJDYWNoZVBhdGggPSBhY2tQYXRoLmNoaWxkKG1lcmdlUGF0aCk7XG4gICAgICAgIGlmIChzZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yUGF0aChzZXJ2ZXJDYWNoZVBhdGgpKSB7XG4gICAgICAgICAgY2hhbmdlZENoaWxkcmVuID0gY2hhbmdlZENoaWxkcmVuLnNldChcbiAgICAgICAgICAgIG1lcmdlUGF0aCxcbiAgICAgICAgICAgIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChzZXJ2ZXJDYWNoZVBhdGgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVNlcnZlck1lcmdlXyhcbiAgICAgICAgdmlld0NhY2hlLFxuICAgICAgICBhY2tQYXRoLFxuICAgICAgICBjaGFuZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHdyaXRlc0NhY2hlLFxuICAgICAgICBjb21wbGV0ZUNhY2hlLFxuICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlLFxuICAgICAgICBhY2N1bXVsYXRvclxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGxpc3RlbkNvbXBsZXRlXyhcbiAgICB2aWV3Q2FjaGU6IFZpZXdDYWNoZSxcbiAgICBwYXRoOiBQYXRoLFxuICAgIHdyaXRlc0NhY2hlOiBXcml0ZVRyZWVSZWYsXG4gICAgYWNjdW11bGF0b3I6IENoaWxkQ2hhbmdlQWNjdW11bGF0b3JcbiAgKTogVmlld0NhY2hlIHtcbiAgICBjb25zdCBvbGRTZXJ2ZXJOb2RlID0gdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCk7XG4gICAgY29uc3QgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlLnVwZGF0ZVNlcnZlclNuYXAoXG4gICAgICBvbGRTZXJ2ZXJOb2RlLmdldE5vZGUoKSxcbiAgICAgIG9sZFNlcnZlck5vZGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHwgcGF0aC5pc0VtcHR5KCksXG4gICAgICBvbGRTZXJ2ZXJOb2RlLmlzRmlsdGVyZWQoKVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudF8oXG4gICAgICBuZXdWaWV3Q2FjaGUsXG4gICAgICBwYXRoLFxuICAgICAgd3JpdGVzQ2FjaGUsXG4gICAgICBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsXG4gICAgICBhY2N1bXVsYXRvclxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyQ2FjaGVcbiAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmV2ZXJ0VXNlcldyaXRlXyhcbiAgICB2aWV3Q2FjaGU6IFZpZXdDYWNoZSxcbiAgICBwYXRoOiBQYXRoLFxuICAgIHdyaXRlc0NhY2hlOiBXcml0ZVRyZWVSZWYsXG4gICAgY29tcGxldGVTZXJ2ZXJDYWNoZTogTm9kZSB8IG51bGwsXG4gICAgYWNjdW11bGF0b3I6IENoaWxkQ2hhbmdlQWNjdW11bGF0b3JcbiAgKTogVmlld0NhY2hlIHtcbiAgICBsZXQgY29tcGxldGU7XG4gICAgaWYgKHdyaXRlc0NhY2hlLnNoYWRvd2luZ1dyaXRlKHBhdGgpICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB2aWV3Q2FjaGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKFxuICAgICAgICB3cml0ZXNDYWNoZSxcbiAgICAgICAgdmlld0NhY2hlLFxuICAgICAgICBjb21wbGV0ZVNlcnZlckNhY2hlXG4gICAgICApO1xuICAgICAgY29uc3Qgb2xkRXZlbnRDYWNoZSA9IHZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCkuZ2V0Tm9kZSgpO1xuICAgICAgbGV0IG5ld0V2ZW50Q2FjaGU7XG4gICAgICBpZiAocGF0aC5pc0VtcHR5KCkgfHwgcGF0aC5nZXRGcm9udCgpID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICBsZXQgbmV3Tm9kZTtcbiAgICAgICAgaWYgKHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUoXG4gICAgICAgICAgICB2aWV3Q2FjaGUuZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNlcnZlckNoaWxkcmVuID0gdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuZ2V0Tm9kZSgpO1xuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIHNlcnZlckNoaWxkcmVuIGluc3RhbmNlb2YgQ2hpbGRyZW5Ob2RlLFxuICAgICAgICAgICAgJ3NlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZSdcbiAgICAgICAgICApO1xuICAgICAgICAgIG5ld05vZGUgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKFxuICAgICAgICAgICAgc2VydmVyQ2hpbGRyZW4gYXMgQ2hpbGRyZW5Ob2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZSBhcyBOb2RlO1xuICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKFxuICAgICAgICAgIG9sZEV2ZW50Q2FjaGUsXG4gICAgICAgICAgbmV3Tm9kZSxcbiAgICAgICAgICBhY2N1bXVsYXRvclxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoLmdldEZyb250KCk7XG4gICAgICAgIGxldCBuZXdDaGlsZCA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUNoaWxkKFxuICAgICAgICAgIGNoaWxkS2V5LFxuICAgICAgICAgIHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXdDaGlsZCA9PSBudWxsICYmXG4gICAgICAgICAgdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBuZXdDaGlsZCA9IG9sZEV2ZW50Q2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDaGlsZCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVDaGlsZChcbiAgICAgICAgICAgIG9sZEV2ZW50Q2FjaGUsXG4gICAgICAgICAgICBjaGlsZEtleSxcbiAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgcGF0aC5wb3BGcm9udCgpLFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgYWNjdW11bGF0b3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHZpZXdDYWNoZVxuICAgICAgICAgICAgLmdldEV2ZW50Q2FjaGUoKVxuICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgLmhhc0NoaWxkKGNoaWxkS2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBObyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUsIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lLCBpZiBhbnlcbiAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUNoaWxkKFxuICAgICAgICAgICAgb2xkRXZlbnRDYWNoZSxcbiAgICAgICAgICAgIGNoaWxkS2V5LFxuICAgICAgICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsXG4gICAgICAgICAgICBwYXRoLnBvcEZyb250KCksXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBhY2N1bXVsYXRvclxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5ld0V2ZW50Q2FjaGUuaXNFbXB0eSgpICYmXG4gICAgICAgICAgdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gV2UgbWlnaHQgaGF2ZSByZXZlcnRlZCBhbGwgY2hpbGQgd3JpdGVzLiBNYXliZSB0aGUgb2xkIGV2ZW50IHdhcyBhIGxlYWYgbm9kZVxuICAgICAgICAgIGNvbXBsZXRlID0gd3JpdGVzQ2FjaGUuY2FsY0NvbXBsZXRlRXZlbnRDYWNoZShcbiAgICAgICAgICAgIHZpZXdDYWNoZS5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGNvbXBsZXRlLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVGdWxsTm9kZShcbiAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSxcbiAgICAgICAgICAgICAgY29tcGxldGUsXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29tcGxldGUgPVxuICAgICAgICB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxuICAgICAgICB3cml0ZXNDYWNoZS5zaGFkb3dpbmdXcml0ZShQYXRoLkVtcHR5KSAhPSBudWxsO1xuICAgICAgcmV0dXJuIHZpZXdDYWNoZS51cGRhdGVFdmVudFNuYXAoXG4gICAgICAgIG5ld0V2ZW50Q2FjaGUsXG4gICAgICAgIGNvbXBsZXRlLFxuICAgICAgICB0aGlzLmZpbHRlcl8uZmlsdGVyc05vZGVzKClcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgTmFtZWROb2RlLCBOb2RlIH0gZnJvbSAnLi4vc25hcC9Ob2RlJztcbmltcG9ydCB7IENoYW5nZSB9IGZyb20gJy4vQ2hhbmdlJztcbmltcG9ydCB7IGFzc2VydGlvbkVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuLi8uLi9hcGkvUXVlcnknO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuLi9zbmFwL2luZGV4ZXMvSW5kZXgnO1xuaW1wb3J0IHsgRXZlbnRSZWdpc3RyYXRpb24gfSBmcm9tICcuL0V2ZW50UmVnaXN0cmF0aW9uJztcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi9FdmVudCc7XG5cbi8qKlxuICogQW4gRXZlbnRHZW5lcmF0b3IgaXMgdXNlZCB0byBjb252ZXJ0IFwicmF3XCIgY2hhbmdlcyAoQ2hhbmdlKSBhcyBjb21wdXRlZCBieSB0aGVcbiAqIENhY2hlRGlmZmVyIGludG8gYWN0dWFsIGV2ZW50cyAoRXZlbnQpIHRoYXQgY2FuIGJlIHJhaXNlZC4gIFNlZSBnZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXMoKVxuICogZm9yIGRldGFpbHMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEdlbmVyYXRvciB7XG4gIHByaXZhdGUgaW5kZXhfOiBJbmRleDtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5X1xuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBxdWVyeV86IFF1ZXJ5KSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUluZGV4fVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhfID0gdGhpcy5xdWVyeV8uZ2V0UXVlcnlQYXJhbXMoKS5nZXRJbmRleCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgc2V0IG9mIHJhdyBjaGFuZ2VzIChubyBtb3ZlZCBldmVudHMgYW5kIHByZXZOYW1lIG5vdCBzcGVjaWZpZWQgeWV0KSwgYW5kIGEgc2V0IG9mXG4gICAqIEV2ZW50UmVnaXN0cmF0aW9ucyB0aGF0IHNob3VsZCBiZSBub3RpZmllZCBvZiB0aGVzZSBjaGFuZ2VzLCBnZW5lcmF0ZSB0aGUgYWN0dWFsIGV2ZW50cyB0byBiZSByYWlzZWQuXG4gICAqXG4gICAqIE5vdGVzOlxuICAgKiAgLSBjaGlsZF9tb3ZlZCBldmVudHMgd2lsbCBiZSBzeW50aGVzaXplZCBhdCB0aGlzIHRpbWUgZm9yIGFueSBjaGlsZF9jaGFuZ2VkIGV2ZW50cyB0aGF0IGFmZmVjdFxuICAgKiAgICBvdXIgaW5kZXguXG4gICAqICAtIHByZXZOYW1lIHdpbGwgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgaW5kZXggb3JkZXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gY2hhbmdlc1xuICAgKiBAcGFyYW0geyFOb2RlfSBldmVudENhY2hlXG4gICAqIEBwYXJhbSB7IUFycmF5LjwhRXZlbnRSZWdpc3RyYXRpb24+fSBldmVudFJlZ2lzdHJhdGlvbnNcbiAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgKi9cbiAgZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKFxuICAgIGNoYW5nZXM6IENoYW5nZVtdLFxuICAgIGV2ZW50Q2FjaGU6IE5vZGUsXG4gICAgZXZlbnRSZWdpc3RyYXRpb25zOiBFdmVudFJlZ2lzdHJhdGlvbltdXG4gICk6IEV2ZW50W10ge1xuICAgIGNvbnN0IGV2ZW50czogRXZlbnRbXSA9IFtdO1xuICAgIGNvbnN0IG1vdmVzOiBDaGFuZ2VbXSA9IFtdO1xuXG4gICAgY2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGNoYW5nZS50eXBlID09PSBDaGFuZ2UuQ0hJTERfQ0hBTkdFRCAmJlxuICAgICAgICB0aGlzLmluZGV4Xy5pbmRleGVkVmFsdWVDaGFuZ2VkKFxuICAgICAgICAgIGNoYW5nZS5vbGRTbmFwIGFzIE5vZGUsXG4gICAgICAgICAgY2hhbmdlLnNuYXBzaG90Tm9kZVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgbW92ZXMucHVzaChcbiAgICAgICAgICBDaGFuZ2UuY2hpbGRNb3ZlZENoYW5nZShcbiAgICAgICAgICAgIGNoYW5nZS5jaGlsZE5hbWUgYXMgc3RyaW5nLFxuICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90Tm9kZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhcbiAgICAgIGV2ZW50cyxcbiAgICAgIENoYW5nZS5DSElMRF9SRU1PVkVELFxuICAgICAgY2hhbmdlcyxcbiAgICAgIGV2ZW50UmVnaXN0cmF0aW9ucyxcbiAgICAgIGV2ZW50Q2FjaGVcbiAgICApO1xuICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhcbiAgICAgIGV2ZW50cyxcbiAgICAgIENoYW5nZS5DSElMRF9BRERFRCxcbiAgICAgIGNoYW5nZXMsXG4gICAgICBldmVudFJlZ2lzdHJhdGlvbnMsXG4gICAgICBldmVudENhY2hlXG4gICAgKTtcbiAgICB0aGlzLmdlbmVyYXRlRXZlbnRzRm9yVHlwZV8oXG4gICAgICBldmVudHMsXG4gICAgICBDaGFuZ2UuQ0hJTERfTU9WRUQsXG4gICAgICBtb3ZlcyxcbiAgICAgIGV2ZW50UmVnaXN0cmF0aW9ucyxcbiAgICAgIGV2ZW50Q2FjaGVcbiAgICApO1xuICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhcbiAgICAgIGV2ZW50cyxcbiAgICAgIENoYW5nZS5DSElMRF9DSEFOR0VELFxuICAgICAgY2hhbmdlcyxcbiAgICAgIGV2ZW50UmVnaXN0cmF0aW9ucyxcbiAgICAgIGV2ZW50Q2FjaGVcbiAgICApO1xuICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhcbiAgICAgIGV2ZW50cyxcbiAgICAgIENoYW5nZS5WQUxVRSxcbiAgICAgIGNoYW5nZXMsXG4gICAgICBldmVudFJlZ2lzdHJhdGlvbnMsXG4gICAgICBldmVudENhY2hlXG4gICAgKTtcblxuICAgIHJldHVybiBldmVudHM7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gY2hhbmdlcyBvZiBhIHNpbmdsZSBjaGFuZ2UgdHlwZSwgZ2VuZXJhdGUgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0geyFBcnJheS48IUV2ZW50Pn0gZXZlbnRzXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gY2hhbmdlc1xuICAgKiBAcGFyYW0geyFBcnJheS48IUV2ZW50UmVnaXN0cmF0aW9uPn0gcmVnaXN0cmF0aW9uc1xuICAgKiBAcGFyYW0geyFOb2RlfSBldmVudENhY2hlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlRXZlbnRzRm9yVHlwZV8oXG4gICAgZXZlbnRzOiBFdmVudFtdLFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLFxuICAgIGNoYW5nZXM6IENoYW5nZVtdLFxuICAgIHJlZ2lzdHJhdGlvbnM6IEV2ZW50UmVnaXN0cmF0aW9uW10sXG4gICAgZXZlbnRDYWNoZTogTm9kZVxuICApIHtcbiAgICBjb25zdCBmaWx0ZXJlZENoYW5nZXMgPSBjaGFuZ2VzLmZpbHRlcihjaGFuZ2UgPT4gY2hhbmdlLnR5cGUgPT09IGV2ZW50VHlwZSk7XG5cbiAgICBmaWx0ZXJlZENoYW5nZXMuc29ydCh0aGlzLmNvbXBhcmVDaGFuZ2VzXy5iaW5kKHRoaXMpKTtcbiAgICBmaWx0ZXJlZENoYW5nZXMuZm9yRWFjaChjaGFuZ2UgPT4ge1xuICAgICAgY29uc3QgbWF0ZXJpYWxpemVkQ2hhbmdlID0gdGhpcy5tYXRlcmlhbGl6ZVNpbmdsZUNoYW5nZV8oXG4gICAgICAgIGNoYW5nZSxcbiAgICAgICAgZXZlbnRDYWNoZVxuICAgICAgKTtcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChyZWdpc3RyYXRpb24gPT4ge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLnJlc3BvbmRzVG8oY2hhbmdlLnR5cGUpKSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2goXG4gICAgICAgICAgICByZWdpc3RyYXRpb24uY3JlYXRlRXZlbnQobWF0ZXJpYWxpemVkQ2hhbmdlLCB0aGlzLnF1ZXJ5XylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDaGFuZ2V9IGNoYW5nZVxuICAgKiBAcGFyYW0geyFOb2RlfSBldmVudENhY2hlXG4gICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIG1hdGVyaWFsaXplU2luZ2xlQ2hhbmdlXyhjaGFuZ2U6IENoYW5nZSwgZXZlbnRDYWNoZTogTm9kZSk6IENoYW5nZSB7XG4gICAgaWYgKGNoYW5nZS50eXBlID09PSAndmFsdWUnIHx8IGNoYW5nZS50eXBlID09PSAnY2hpbGRfcmVtb3ZlZCcpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZS5wcmV2TmFtZSA9IGV2ZW50Q2FjaGUuZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoXG4gICAgICAgIC8qKiBAdHlwZSB7IXN0cmluZ30gKi9cbiAgICAgICAgY2hhbmdlLmNoaWxkTmFtZSxcbiAgICAgICAgY2hhbmdlLnNuYXBzaG90Tm9kZSxcbiAgICAgICAgdGhpcy5pbmRleF9cbiAgICAgICk7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDaGFuZ2V9IGFcbiAgICogQHBhcmFtIHshQ2hhbmdlfSBiXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY29tcGFyZUNoYW5nZXNfKGE6IENoYW5nZSwgYjogQ2hhbmdlKSB7XG4gICAgaWYgKGEuY2hpbGROYW1lID09IG51bGwgfHwgYi5jaGlsZE5hbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ1Nob3VsZCBvbmx5IGNvbXBhcmUgY2hpbGRfIGV2ZW50cy4nKTtcbiAgICB9XG4gICAgY29uc3QgYVdyYXBwZWQgPSBuZXcgTmFtZWROb2RlKGEuY2hpbGROYW1lLCBhLnNuYXBzaG90Tm9kZSk7XG4gICAgY29uc3QgYldyYXBwZWQgPSBuZXcgTmFtZWROb2RlKGIuY2hpbGROYW1lLCBiLnNuYXBzaG90Tm9kZSk7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhfLmNvbXBhcmUoYVdyYXBwZWQsIGJXcmFwcGVkKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluZGV4ZWRGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlci9JbmRleGVkRmlsdGVyJztcbmltcG9ydCB7IFZpZXdQcm9jZXNzb3IgfSBmcm9tICcuL1ZpZXdQcm9jZXNzb3InO1xuaW1wb3J0IHsgQ2hpbGRyZW5Ob2RlIH0gZnJvbSAnLi4vc25hcC9DaGlsZHJlbk5vZGUnO1xuaW1wb3J0IHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi9DYWNoZU5vZGUnO1xuaW1wb3J0IHsgVmlld0NhY2hlIH0gZnJvbSAnLi9WaWV3Q2FjaGUnO1xuaW1wb3J0IHsgRXZlbnRHZW5lcmF0b3IgfSBmcm9tICcuL0V2ZW50R2VuZXJhdG9yJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IE9wZXJhdGlvbiwgT3BlcmF0aW9uVHlwZSB9IGZyb20gJy4uL29wZXJhdGlvbi9PcGVyYXRpb24nO1xuaW1wb3J0IHsgQ2hhbmdlIH0gZnJvbSAnLi9DaGFuZ2UnO1xuaW1wb3J0IHsgUFJJT1JJVFlfSU5ERVggfSBmcm9tICcuLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gJy4uLy4uL2FwaS9RdWVyeSc7XG5pbXBvcnQgeyBFdmVudFJlZ2lzdHJhdGlvbiB9IGZyb20gJy4vRXZlbnRSZWdpc3RyYXRpb24nO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL3NuYXAvTm9kZSc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vdXRpbC9QYXRoJztcbmltcG9ydCB7IFdyaXRlVHJlZVJlZiB9IGZyb20gJy4uL1dyaXRlVHJlZSc7XG5pbXBvcnQgeyBDYW5jZWxFdmVudCwgRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcblxuLyoqXG4gKiBBIHZpZXcgcmVwcmVzZW50cyBhIHNwZWNpZmljIGxvY2F0aW9uIGFuZCBxdWVyeSB0aGF0IGhhcyAxIG9yIG1vcmUgZXZlbnQgcmVnaXN0cmF0aW9ucy5cbiAqXG4gKiBJdCBkb2VzIHNldmVyYWwgdGhpbmdzOlxuICogIC0gTWFpbnRhaW5zIHRoZSBsaXN0IG9mIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgbG9jYXRpb24vcXVlcnkuXG4gKiAgLSBNYWludGFpbnMgYSBjYWNoZSBvZiB0aGUgZGF0YSB2aXNpYmxlIGZvciB0aGlzIGxvY2F0aW9uL3F1ZXJ5LlxuICogIC0gQXBwbGllcyBuZXcgb3BlcmF0aW9ucyAodmlhIGFwcGx5T3BlcmF0aW9uKSwgdXBkYXRlcyB0aGUgY2FjaGUsIGFuZCBiYXNlZCBvbiB0aGUgZXZlbnRcbiAqICAgIHJlZ2lzdHJhdGlvbnMgcmV0dXJucyB0aGUgc2V0IG9mIGV2ZW50cyB0byBiZSByYWlzZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZXcge1xuICBwcml2YXRlIHByb2Nlc3Nvcl86IFZpZXdQcm9jZXNzb3I7XG4gIHByaXZhdGUgdmlld0NhY2hlXzogVmlld0NhY2hlO1xuICBwcml2YXRlIGV2ZW50UmVnaXN0cmF0aW9uc186IEV2ZW50UmVnaXN0cmF0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBldmVudEdlbmVyYXRvcl86IEV2ZW50R2VuZXJhdG9yO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlfXG4gICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gaW5pdGlhbFZpZXdDYWNoZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBxdWVyeV86IFF1ZXJ5LCBpbml0aWFsVmlld0NhY2hlOiBWaWV3Q2FjaGUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnF1ZXJ5Xy5nZXRRdWVyeVBhcmFtcygpO1xuXG4gICAgY29uc3QgaW5kZXhGaWx0ZXIgPSBuZXcgSW5kZXhlZEZpbHRlcihwYXJhbXMuZ2V0SW5kZXgoKSk7XG4gICAgY29uc3QgZmlsdGVyID0gcGFyYW1zLmdldE5vZGVGaWx0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtWaWV3UHJvY2Vzc29yfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wcm9jZXNzb3JfID0gbmV3IFZpZXdQcm9jZXNzb3IoZmlsdGVyKTtcblxuICAgIGNvbnN0IGluaXRpYWxTZXJ2ZXJDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKTtcbiAgICBjb25zdCBpbml0aWFsRXZlbnRDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpO1xuXG4gICAgLy8gRG9uJ3QgZmlsdGVyIHNlcnZlciBub2RlIHdpdGggb3RoZXIgZmlsdGVyIHRoYW4gaW5kZXgsIHdhaXQgZm9yIHRhZ2dlZCBsaXN0ZW5cbiAgICBjb25zdCBzZXJ2ZXJTbmFwID0gaW5kZXhGaWx0ZXIudXBkYXRlRnVsbE5vZGUoXG4gICAgICBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSxcbiAgICAgIGluaXRpYWxTZXJ2ZXJDYWNoZS5nZXROb2RlKCksXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBjb25zdCBldmVudFNuYXAgPSBmaWx0ZXIudXBkYXRlRnVsbE5vZGUoXG4gICAgICBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSxcbiAgICAgIGluaXRpYWxFdmVudENhY2hlLmdldE5vZGUoKSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGNvbnN0IG5ld1NlcnZlckNhY2hlID0gbmV3IENhY2hlTm9kZShcbiAgICAgIHNlcnZlclNuYXAsXG4gICAgICBpbml0aWFsU2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCksXG4gICAgICBpbmRleEZpbHRlci5maWx0ZXJzTm9kZXMoKVxuICAgICk7XG4gICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG5ldyBDYWNoZU5vZGUoXG4gICAgICBldmVudFNuYXAsXG4gICAgICBpbml0aWFsRXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSxcbiAgICAgIGZpbHRlci5maWx0ZXJzTm9kZXMoKVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IVZpZXdDYWNoZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmlld0NhY2hlXyA9IG5ldyBWaWV3Q2FjaGUobmV3RXZlbnRDYWNoZSwgbmV3U2VydmVyQ2FjaGUpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFFdmVudEdlbmVyYXRvcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRHZW5lcmF0b3JfID0gbmV3IEV2ZW50R2VuZXJhdG9yKHRoaXMucXVlcnlfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAqL1xuICBnZXRRdWVyeSgpOiBRdWVyeSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgZ2V0U2VydmVyQ2FjaGUoKTogTm9kZSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnZpZXdDYWNoZV8uZ2V0U2VydmVyQ2FjaGUoKS5nZXROb2RlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIGdldENvbXBsZXRlU2VydmVyQ2FjaGUocGF0aDogUGF0aCk6IE5vZGUgfCBudWxsIHtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMudmlld0NhY2hlXy5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIC8vIElmIHRoaXMgaXNuJ3QgYSBcImxvYWRzQWxsRGF0YVwiIHZpZXcsIHRoZW4gY2FjaGUgaXNuJ3QgYWN0dWFsbHkgYSBjb21wbGV0ZSBjYWNoZSBhbmRcbiAgICAgIC8vIHdlIG5lZWQgdG8gc2VlIGlmIGl0IGNvbnRhaW5zIHRoZSBjaGlsZCB3ZSdyZSBpbnRlcmVzdGVkIGluLlxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnF1ZXJ5Xy5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpIHx8XG4gICAgICAgICghcGF0aC5pc0VtcHR5KCkgJiYgIWNhY2hlLmdldEltbWVkaWF0ZUNoaWxkKHBhdGguZ2V0RnJvbnQoKSkuaXNFbXB0eSgpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXRDaGlsZChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAqL1xuICBhZGRFdmVudFJlZ2lzdHJhdGlvbihldmVudFJlZ2lzdHJhdGlvbjogRXZlbnRSZWdpc3RyYXRpb24pIHtcbiAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18ucHVzaChldmVudFJlZ2lzdHJhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uIElmIG51bGwsIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxuICAgKiBAcGFyYW0ge0Vycm9yPX0gY2FuY2VsRXJyb3IgSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IENhbmNlbCBldmVudHMsIGlmIGNhbmNlbEVycm9yIHdhcyBwcm92aWRlZC5cbiAgICovXG4gIHJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKFxuICAgIGV2ZW50UmVnaXN0cmF0aW9uOiBFdmVudFJlZ2lzdHJhdGlvbiB8IG51bGwsXG4gICAgY2FuY2VsRXJyb3I/OiBFcnJvclxuICApOiBFdmVudFtdIHtcbiAgICBjb25zdCBjYW5jZWxFdmVudHM6IENhbmNlbEV2ZW50W10gPSBbXTtcbiAgICBpZiAoY2FuY2VsRXJyb3IpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgZXZlbnRSZWdpc3RyYXRpb24gPT0gbnVsbCxcbiAgICAgICAgJ0EgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHBhdGggPSB0aGlzLnF1ZXJ5Xy5wYXRoO1xuICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfLmZvckVhY2goZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIGNhbmNlbEVycm9yIC8qKiBAdHlwZSB7IUVycm9yfSAqLyA9IGNhbmNlbEVycm9yO1xuICAgICAgICBjb25zdCBtYXliZUV2ZW50ID0gcmVnaXN0cmF0aW9uLmNyZWF0ZUNhbmNlbEV2ZW50KGNhbmNlbEVycm9yLCBwYXRoKTtcbiAgICAgICAgaWYgKG1heWJlRXZlbnQpIHtcbiAgICAgICAgICBjYW5jZWxFdmVudHMucHVzaChtYXliZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50UmVnaXN0cmF0aW9uKSB7XG4gICAgICBsZXQgcmVtYWluaW5nID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zX1tpXTtcbiAgICAgICAgaWYgKCFleGlzdGluZy5tYXRjaGVzKGV2ZW50UmVnaXN0cmF0aW9uKSkge1xuICAgICAgICAgIHJlbWFpbmluZy5wdXNoKGV4aXN0aW5nKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudFJlZ2lzdHJhdGlvbi5oYXNBbnlDYWxsYmFjaygpKSB7XG4gICAgICAgICAgLy8gV2UncmUgcmVtb3ZpbmcganVzdCB0aGlzIG9uZVxuICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5jb25jYXQodGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXyA9IHJlbWFpbmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gW107XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxFdmVudHM7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZ2l2ZW4gT3BlcmF0aW9uLCB1cGRhdGVzIG91ciBjYWNoZSwgYW5kIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZVNlcnZlckNhY2hlXG4gICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn1cbiAgICovXG4gIGFwcGx5T3BlcmF0aW9uKFxuICAgIG9wZXJhdGlvbjogT3BlcmF0aW9uLFxuICAgIHdyaXRlc0NhY2hlOiBXcml0ZVRyZWVSZWYsXG4gICAgY29tcGxldGVTZXJ2ZXJDYWNoZTogTm9kZSB8IG51bGxcbiAgKTogRXZlbnRbXSB7XG4gICAgaWYgKFxuICAgICAgb3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTUVSR0UgJiZcbiAgICAgIG9wZXJhdGlvbi5zb3VyY2UucXVlcnlJZCAhPT0gbnVsbFxuICAgICkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8uZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKCksXG4gICAgICAgICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBmdWxsIGNhY2hlIGJlZm9yZSBoYW5kbGluZyBtZXJnZXMnXG4gICAgICApO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8uZ2V0Q29tcGxldGVFdmVudFNuYXAoKSxcbiAgICAgICAgJ01pc3NpbmcgZXZlbnQgY2FjaGUsIGV2ZW4gdGhvdWdoIHdlIGhhdmUgYSBzZXJ2ZXIgY2FjaGUnXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZFZpZXdDYWNoZSA9IHRoaXMudmlld0NhY2hlXztcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnByb2Nlc3Nvcl8uYXBwbHlPcGVyYXRpb24oXG4gICAgICBvbGRWaWV3Q2FjaGUsXG4gICAgICBvcGVyYXRpb24sXG4gICAgICB3cml0ZXNDYWNoZSxcbiAgICAgIGNvbXBsZXRlU2VydmVyQ2FjaGVcbiAgICApO1xuICAgIHRoaXMucHJvY2Vzc29yXy5hc3NlcnRJbmRleGVkKHJlc3VsdC52aWV3Q2FjaGUpO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgcmVzdWx0LnZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XG4gICAgICAgICFvbGRWaWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSxcbiAgICAgICdPbmNlIGEgc2VydmVyIHNuYXAgaXMgY29tcGxldGUsIGl0IHNob3VsZCBuZXZlciBnbyBiYWNrJ1xuICAgICk7XG5cbiAgICB0aGlzLnZpZXdDYWNoZV8gPSByZXN1bHQudmlld0NhY2hlO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyhcbiAgICAgIHJlc3VsdC5jaGFuZ2VzLFxuICAgICAgcmVzdWx0LnZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCkuZ2V0Tm9kZSgpLFxuICAgICAgbnVsbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnRSZWdpc3RyYXRpb259IHJlZ2lzdHJhdGlvblxuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAqL1xuICBnZXRJbml0aWFsRXZlbnRzKHJlZ2lzdHJhdGlvbjogRXZlbnRSZWdpc3RyYXRpb24pOiBFdmVudFtdIHtcbiAgICBjb25zdCBldmVudFNuYXAgPSB0aGlzLnZpZXdDYWNoZV8uZ2V0RXZlbnRDYWNoZSgpO1xuICAgIGNvbnN0IGluaXRpYWxDaGFuZ2VzOiBDaGFuZ2VbXSA9IFtdO1xuICAgIGlmICghZXZlbnRTbmFwLmdldE5vZGUoKS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgIGNvbnN0IGV2ZW50Tm9kZSA9IGV2ZW50U25hcC5nZXROb2RlKCkgYXMgQ2hpbGRyZW5Ob2RlO1xuICAgICAgZXZlbnROb2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24oa2V5LCBjaGlsZE5vZGUpIHtcbiAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChDaGFuZ2UuY2hpbGRBZGRlZENoYW5nZShrZXksIGNoaWxkTm9kZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChldmVudFNuYXAuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcbiAgICAgIGluaXRpYWxDaGFuZ2VzLnB1c2goQ2hhbmdlLnZhbHVlQ2hhbmdlKGV2ZW50U25hcC5nZXROb2RlKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyhcbiAgICAgIGluaXRpYWxDaGFuZ2VzLFxuICAgICAgZXZlbnRTbmFwLmdldE5vZGUoKSxcbiAgICAgIHJlZ2lzdHJhdGlvblxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHshQXJyYXkuPCFDaGFuZ2U+fSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7IU5vZGV9IGV2ZW50Q2FjaGVcbiAgICogQHBhcmFtIHtFdmVudFJlZ2lzdHJhdGlvbj19IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn1cbiAgICovXG4gIGdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18oXG4gICAgY2hhbmdlczogQ2hhbmdlW10sXG4gICAgZXZlbnRDYWNoZTogTm9kZSxcbiAgICBldmVudFJlZ2lzdHJhdGlvbj86IEV2ZW50UmVnaXN0cmF0aW9uXG4gICk6IEV2ZW50W10ge1xuICAgIGNvbnN0IHJlZ2lzdHJhdGlvbnMgPSBldmVudFJlZ2lzdHJhdGlvblxuICAgICAgPyBbZXZlbnRSZWdpc3RyYXRpb25dXG4gICAgICA6IHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXztcbiAgICByZXR1cm4gdGhpcy5ldmVudEdlbmVyYXRvcl8uZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKFxuICAgICAgY2hhbmdlcyxcbiAgICAgIGV2ZW50Q2FjaGUsXG4gICAgICByZWdpc3RyYXRpb25zXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENhY2hlTm9kZSB9IGZyb20gJy4vdmlldy9DYWNoZU5vZGUnO1xuaW1wb3J0IHsgQ2hpbGRyZW5Ob2RlIH0gZnJvbSAnLi9zbmFwL0NoaWxkcmVuTm9kZSc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBpc0VtcHR5LCBmb3JFYWNoLCBmaW5kVmFsdWUsIHNhZmVHZXQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBWaWV3Q2FjaGUgfSBmcm9tICcuL3ZpZXcvVmlld0NhY2hlJztcbmltcG9ydCB7IFZpZXcgfSBmcm9tICcuL3ZpZXcvVmlldyc7XG5pbXBvcnQgeyBPcGVyYXRpb24gfSBmcm9tICcuL29wZXJhdGlvbi9PcGVyYXRpb24nO1xuaW1wb3J0IHsgV3JpdGVUcmVlUmVmIH0gZnJvbSAnLi9Xcml0ZVRyZWUnO1xuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuLi9hcGkvUXVlcnknO1xuaW1wb3J0IHsgRXZlbnRSZWdpc3RyYXRpb24gfSBmcm9tICcuL3ZpZXcvRXZlbnRSZWdpc3RyYXRpb24nO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vc25hcC9Ob2RlJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vdmlldy9FdmVudCc7XG5pbXBvcnQgeyBSZWZlcmVuY2UsIFJlZmVyZW5jZUNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vYXBpL1JlZmVyZW5jZSc7XG5cbmxldCBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yOiBSZWZlcmVuY2VDb25zdHJ1Y3RvcjtcblxuLyoqXG4gKiBTeW5jUG9pbnQgcmVwcmVzZW50cyBhIHNpbmdsZSBsb2NhdGlvbiBpbiBhIFN5bmNUcmVlIHdpdGggMSBvciBtb3JlIGV2ZW50IHJlZ2lzdHJhdGlvbnMsIG1lYW5pbmcgd2UgbmVlZCB0b1xuICogbWFpbnRhaW4gMSBvciBtb3JlIFZpZXdzIGF0IHRoaXMgbG9jYXRpb24gdG8gY2FjaGUgc2VydmVyIGRhdGEgYW5kIHJhaXNlIGFwcHJvcHJpYXRlIGV2ZW50cyBmb3Igc2VydmVyIGNoYW5nZXNcbiAqIGFuZCB1c2VyIHdyaXRlcyAoc2V0LCB0cmFuc2FjdGlvbiwgdXBkYXRlKS5cbiAqXG4gKiBJdCdzIHJlc3BvbnNpYmxlIGZvcjpcbiAqICAtIE1haW50YWluaW5nIHRoZSBzZXQgb2YgMSBvciBtb3JlIHZpZXdzIG5lY2Vzc2FyeSBhdCB0aGlzIGxvY2F0aW9uIChhIFN5bmNQb2ludCB3aXRoIDAgdmlld3Mgc2hvdWxkIGJlIHJlbW92ZWQpLlxuICogIC0gUHJveHlpbmcgdXNlciAvIHNlcnZlciBvcGVyYXRpb25zIHRvIHRoZSB2aWV3cyBhcyBhcHByb3ByaWF0ZSAoaS5lLiBhcHBseVNlcnZlck92ZXJ3cml0ZSxcbiAqICAgIGFwcGx5VXNlck92ZXJ3cml0ZSwgZXRjLilcbiAqL1xuZXhwb3J0IGNsYXNzIFN5bmNQb2ludCB7XG4gIHN0YXRpYyBzZXQgX19yZWZlcmVuY2VDb25zdHJ1Y3Rvcih2YWw6IFJlZmVyZW5jZUNvbnN0cnVjdG9yKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgIV9fcmVmZXJlbmNlQ29uc3RydWN0b3IsXG4gICAgICAnX19yZWZlcmVuY2VDb25zdHJ1Y3RvciBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQnXG4gICAgKTtcbiAgICBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yID0gdmFsO1xuICB9XG5cbiAgc3RhdGljIGdldCBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yKCkge1xuICAgIGFzc2VydChfX3JlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcbiAgICByZXR1cm4gX19yZWZlcmVuY2VDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgVmlld3MgYmVpbmcgdHJhY2tlZCBhdCB0aGlzIGxvY2F0aW9uIGluIHRoZSB0cmVlLCBzdG9yZWQgYXMgYSBtYXAgd2hlcmUgdGhlIGtleSBpcyBhXG4gICAqIHF1ZXJ5SWQgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgVmlldyBmb3IgdGhhdCBxdWVyeS5cbiAgICpcbiAgICogTk9URTogVGhpcyBsaXN0IHdpbGwgYmUgcXVpdGUgc21hbGwgKHVzdWFsbHkgMSwgYnV0IHBlcmhhcHMgMiBvciAzOyBhbnkgbW9yZSBpcyBhbiBvZGQgdXNlIGNhc2UpLlxuICAgKlxuICAgKiBAdHlwZSB7IU9iamVjdC48IXN0cmluZywgIVZpZXc+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSB2aWV3c186IHsgW2s6IHN0cmluZ106IFZpZXcgfSA9IHt9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNFbXB0eSh0aGlzLnZpZXdzXyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgKiBAcGFyYW0gez9Ob2RlfSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXG4gICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn1cbiAgICovXG4gIGFwcGx5T3BlcmF0aW9uKFxuICAgIG9wZXJhdGlvbjogT3BlcmF0aW9uLFxuICAgIHdyaXRlc0NhY2hlOiBXcml0ZVRyZWVSZWYsXG4gICAgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZTogTm9kZSB8IG51bGxcbiAgKTogRXZlbnRbXSB7XG4gICAgY29uc3QgcXVlcnlJZCA9IG9wZXJhdGlvbi5zb3VyY2UucXVlcnlJZDtcbiAgICBpZiAocXVlcnlJZCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdmlldyA9IHNhZmVHZXQodGhpcy52aWV3c18sIHF1ZXJ5SWQpO1xuICAgICAgYXNzZXJ0KHZpZXcgIT0gbnVsbCwgJ1N5bmNUcmVlIGdhdmUgdXMgYW4gb3AgZm9yIGFuIGludmFsaWQgcXVlcnkuJyk7XG4gICAgICByZXR1cm4gdmlldy5hcHBseU9wZXJhdGlvbihcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICB3cml0ZXNDYWNoZSxcbiAgICAgICAgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGV2ZW50czogRXZlbnRbXSA9IFtdO1xuXG4gICAgICBmb3JFYWNoKHRoaXMudmlld3NfLCBmdW5jdGlvbihrZXk6IHN0cmluZywgdmlldzogVmlldykge1xuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KFxuICAgICAgICAgIHZpZXcuYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgY2FsbGJhY2sgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgKiBAcGFyYW0geyFFdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgKiBAcGFyYW0gez9Ob2RlfSBzZXJ2ZXJDYWNoZSBDb21wbGV0ZSBzZXJ2ZXIgY2FjaGUsIGlmIHdlIGhhdmUgaXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VydmVyQ2FjaGVDb21wbGV0ZVxuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICovXG4gIGFkZEV2ZW50UmVnaXN0cmF0aW9uKFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICBldmVudFJlZ2lzdHJhdGlvbjogRXZlbnRSZWdpc3RyYXRpb24sXG4gICAgd3JpdGVzQ2FjaGU6IFdyaXRlVHJlZVJlZixcbiAgICBzZXJ2ZXJDYWNoZTogTm9kZSB8IG51bGwsXG4gICAgc2VydmVyQ2FjaGVDb21wbGV0ZTogYm9vbGVhblxuICApOiBFdmVudFtdIHtcbiAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG4gICAgbGV0IHZpZXcgPSBzYWZlR2V0KHRoaXMudmlld3NfLCBxdWVyeUlkKTtcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIC8vIFRPRE86IG1ha2Ugd3JpdGVzQ2FjaGUgdGFrZSBmbGFnIGZvciBjb21wbGV0ZSBzZXJ2ZXIgbm9kZVxuICAgICAgbGV0IGV2ZW50Q2FjaGUgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENhY2hlKFxuICAgICAgICBzZXJ2ZXJDYWNoZUNvbXBsZXRlID8gc2VydmVyQ2FjaGUgOiBudWxsXG4gICAgICApO1xuICAgICAgbGV0IGV2ZW50Q2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgaWYgKGV2ZW50Q2FjaGUpIHtcbiAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2VydmVyQ2FjaGUgaW5zdGFuY2VvZiBDaGlsZHJlbk5vZGUpIHtcbiAgICAgICAgZXZlbnRDYWNoZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4oc2VydmVyQ2FjaGUpO1xuICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50Q2FjaGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCB2aWV3Q2FjaGUgPSBuZXcgVmlld0NhY2hlKFxuICAgICAgICBuZXcgQ2FjaGVOb2RlKFxuICAgICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovIChldmVudENhY2hlKSxcbiAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKSxcbiAgICAgICAgbmV3IENhY2hlTm9kZShcbiAgICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqLyAoc2VydmVyQ2FjaGUpLFxuICAgICAgICAgIHNlcnZlckNhY2hlQ29tcGxldGUsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHZpZXcgPSBuZXcgVmlldyhxdWVyeSwgdmlld0NhY2hlKTtcbiAgICAgIHRoaXMudmlld3NfW3F1ZXJ5SWRdID0gdmlldztcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8gZXhpc3Qgbm93LCB3ZSBqdXN0IGNyZWF0ZWQgYW55dGhpbmcgdGhhdCB3YXMgbWlzc2luZ1xuICAgIHZpZXcuYWRkRXZlbnRSZWdpc3RyYXRpb24oZXZlbnRSZWdpc3RyYXRpb24pO1xuICAgIHJldHVybiB2aWV3LmdldEluaXRpYWxFdmVudHMoZXZlbnRSZWdpc3RyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBjYWxsYmFjayhzKS4gIFJldHVybiBjYW5jZWxFdmVudHMgaWYgYSBjYW5jZWxFcnJvciBpcyBzcGVjaWZpZWQuXG4gICAqXG4gICAqIElmIHF1ZXJ5IGlzIHRoZSBkZWZhdWx0IHF1ZXJ5LCB3ZSdsbCBjaGVjayBhbGwgdmlld3MgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRSZWdpc3RyYXRpb24uXG4gICAqIElmIGV2ZW50UmVnaXN0cmF0aW9uIGlzIG51bGwsIHdlJ2xsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIHZpZXcocykuXG4gICAqXG4gICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgKiBAcGFyYW0gez9FdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb24gSWYgbnVsbCwgcmVtb3ZlIGFsbCBjYWxsYmFja3MuXG4gICAqIEBwYXJhbSB7RXJyb3I9fSBjYW5jZWxFcnJvciBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge3tyZW1vdmVkOiFBcnJheS48IVF1ZXJ5PiwgZXZlbnRzOiFBcnJheS48IUV2ZW50Pn19IHJlbW92ZWQgcXVlcmllcyBhbmQgYW55IGNhbmNlbCBldmVudHNcbiAgICovXG4gIHJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICBldmVudFJlZ2lzdHJhdGlvbjogRXZlbnRSZWdpc3RyYXRpb24gfCBudWxsLFxuICAgIGNhbmNlbEVycm9yPzogRXJyb3JcbiAgKTogeyByZW1vdmVkOiBRdWVyeVtdOyBldmVudHM6IEV2ZW50W10gfSB7XG4gICAgY29uc3QgcXVlcnlJZCA9IHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpO1xuICAgIGNvbnN0IHJlbW92ZWQ6IFF1ZXJ5W10gPSBbXTtcbiAgICBsZXQgY2FuY2VsRXZlbnRzOiBFdmVudFtdID0gW107XG4gICAgY29uc3QgaGFkQ29tcGxldGVWaWV3ID0gdGhpcy5oYXNDb21wbGV0ZVZpZXcoKTtcbiAgICBpZiAocXVlcnlJZCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAvLyBXaGVuIHlvdSBkbyByZWYub2ZmKC4uLiksIHdlIHNlYXJjaCBhbGwgdmlld3MgZm9yIHRoZSByZWdpc3RyYXRpb24gdG8gcmVtb3ZlLlxuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBmb3JFYWNoKHRoaXMudmlld3NfLCBmdW5jdGlvbih2aWV3UXVlcnlJZDogc3RyaW5nLCB2aWV3OiBWaWV3KSB7XG4gICAgICAgIGNhbmNlbEV2ZW50cyA9IGNhbmNlbEV2ZW50cy5jb25jYXQoXG4gICAgICAgICAgdmlldy5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2aWV3LmlzRW1wdHkoKSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLnZpZXdzX1t2aWV3UXVlcnlJZF07XG5cbiAgICAgICAgICAvLyBXZSdsbCBkZWFsIHdpdGggY29tcGxldGUgdmlld3MgbGF0ZXIuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXZpZXdcbiAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1zKClcbiAgICAgICAgICAgICAgLmxvYWRzQWxsRGF0YSgpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5nZXRRdWVyeSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHNwZWNpZmljIHZpZXcuXG4gICAgICBjb25zdCB2aWV3ID0gc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgICBpZiAodmlldykge1xuICAgICAgICBjYW5jZWxFdmVudHMgPSBjYW5jZWxFdmVudHMuY29uY2F0KFxuICAgICAgICAgIHZpZXcucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKVxuICAgICAgICApO1xuICAgICAgICBpZiAodmlldy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy52aWV3c19bcXVlcnlJZF07XG5cbiAgICAgICAgICAvLyBXZSdsbCBkZWFsIHdpdGggY29tcGxldGUgdmlld3MgbGF0ZXIuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXZpZXdcbiAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1zKClcbiAgICAgICAgICAgICAgLmxvYWRzQWxsRGF0YSgpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5nZXRRdWVyeSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFkQ29tcGxldGVWaWV3ICYmICF0aGlzLmhhc0NvbXBsZXRlVmlldygpKSB7XG4gICAgICAvLyBXZSByZW1vdmVkIG91ciBsYXN0IGNvbXBsZXRlIHZpZXcuXG4gICAgICByZW1vdmVkLnB1c2goXG4gICAgICAgIG5ldyBTeW5jUG9pbnQuX19yZWZlcmVuY2VDb25zdHJ1Y3RvcihxdWVyeS5yZXBvLCBxdWVyeS5wYXRoKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyByZW1vdmVkOiByZW1vdmVkLCBldmVudHM6IGNhbmNlbEV2ZW50cyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFBcnJheS48IVZpZXc+fVxuICAgKi9cbiAgZ2V0UXVlcnlWaWV3cygpOiBWaWV3W10ge1xuICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMudmlld3NfKS5tYXAoa2V5ID0+IHRoaXMudmlld3NfW2tleV0pO1xuICAgIHJldHVybiB2YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgIHJldHVybiAhdmlld1xuICAgICAgICAuZ2V0UXVlcnkoKVxuICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAubG9hZHNBbGxEYXRhKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0byB0aGUgZGVzaXJlZCBjb21wbGV0ZSBzbmFwc2hvdFxuICAgKiBAcmV0dXJuIHs/Tm9kZX0gQSBjb21wbGV0ZSBjYWNoZSwgaWYgaXQgZXhpc3RzXG4gICAqL1xuICBnZXRDb21wbGV0ZVNlcnZlckNhY2hlKHBhdGg6IFBhdGgpOiBOb2RlIHwgbnVsbCB7XG4gICAgbGV0IHNlcnZlckNhY2hlOiBOb2RlIHwgbnVsbCA9IG51bGw7XG4gICAgZm9yRWFjaCh0aGlzLnZpZXdzXywgKGtleTogc3RyaW5nLCB2aWV3OiBWaWV3KSA9PiB7XG4gICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlIHx8IHZpZXcuZ2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShwYXRoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VydmVyQ2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAqIEByZXR1cm4gez9WaWV3fVxuICAgKi9cbiAgdmlld0ZvclF1ZXJ5KHF1ZXJ5OiBRdWVyeSk6IFZpZXcgfCBudWxsIHtcbiAgICBjb25zdCBwYXJhbXMgPSBxdWVyeS5nZXRRdWVyeVBhcmFtcygpO1xuICAgIGlmIChwYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXRlVmlldygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG4gICAgICByZXR1cm4gc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgdmlld0V4aXN0c0ZvclF1ZXJ5KHF1ZXJ5OiBRdWVyeSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZpZXdGb3JRdWVyeShxdWVyeSkgIT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ29tcGxldGVWaWV3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldENvbXBsZXRlVmlldygpICE9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7P1ZpZXd9XG4gICAqL1xuICBnZXRDb21wbGV0ZVZpZXcoKTogVmlldyB8IG51bGwge1xuICAgIGNvbnN0IGNvbXBsZXRlVmlldyA9IGZpbmRWYWx1ZSh0aGlzLnZpZXdzXywgKHZpZXc6IFZpZXcpID0+XG4gICAgICB2aWV3XG4gICAgICAgIC5nZXRRdWVyeSgpXG4gICAgICAgIC5nZXRRdWVyeVBhcmFtcygpXG4gICAgICAgIC5sb2Fkc0FsbERhdGEoKVxuICAgICk7XG4gICAgcmV0dXJuIGNvbXBsZXRlVmlldyB8fCBudWxsO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW1tdXRhYmxlVHJlZSB9IGZyb20gJy4vdXRpbC9JbW11dGFibGVUcmVlJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBmb3JFYWNoIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgTm9kZSwgTmFtZWROb2RlIH0gZnJvbSAnLi9zbmFwL05vZGUnO1xuaW1wb3J0IHsgUFJJT1JJVFlfSU5ERVggfSBmcm9tICcuL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4JztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENoaWxkcmVuTm9kZSB9IGZyb20gJy4vc25hcC9DaGlsZHJlbk5vZGUnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIHdyaXRlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIG5vZGVzIGluIHVuaXNvbi4gSXQgYWJzdHJhY3RzIGF3YXkgdGhlIGxvZ2ljIHdpdGhcbiAqIGRlYWxpbmcgd2l0aCBwcmlvcml0eSB3cml0ZXMgYW5kIG11bHRpcGxlIG5lc3RlZCB3cml0ZXMuIEF0IGFueSBnaXZlbiBwYXRoIHRoZXJlIGlzIG9ubHkgYWxsb3dlZCB0byBiZSBvbmUgd3JpdGVcbiAqIG1vZGlmeWluZyB0aGF0IHBhdGguIEFueSB3cml0ZSB0byBhbiBleGlzdGluZyBwYXRoIG9yIHNoYWRvd2luZyBhbiBleGlzdGluZyBwYXRoIHdpbGwgbW9kaWZ5IHRoYXQgZXhpc3Rpbmcgd3JpdGVcbiAqIHRvIHJlZmxlY3QgdGhlIHdyaXRlIGFkZGVkLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshSW1tdXRhYmxlVHJlZS48IU5vZGU+fSB3cml0ZVRyZWVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvdW5kV3JpdGUge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHdyaXRlVHJlZV86IEltbXV0YWJsZVRyZWU8Tm9kZT4pIHt9XG4gIC8qKlxuICAgKiBAdHlwZSB7IUNvbXBvdW5kV3JpdGV9XG4gICAqL1xuICBzdGF0aWMgRW1wdHkgPSBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShudWxsKSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcmV0dXJuIHshQ29tcG91bmRXcml0ZX1cbiAgICovXG4gIGFkZFdyaXRlKHBhdGg6IFBhdGgsIG5vZGU6IE5vZGUpOiBDb21wb3VuZFdyaXRlIHtcbiAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShub2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvb3Rtb3N0ID0gdGhpcy53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcbiAgICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJvb3RNb3N0UGF0aCA9IHJvb3Rtb3N0LnBhdGg7XG4gICAgICAgIGxldCB2YWx1ZSA9IHJvb3Rtb3N0LnZhbHVlO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBQYXRoLnJlbGF0aXZlUGF0aChyb290TW9zdFBhdGgsIHBhdGgpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aCwgbm9kZSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZSh0aGlzLndyaXRlVHJlZV8uc2V0KHJvb3RNb3N0UGF0aCwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHN1YnRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShub2RlKTtcbiAgICAgICAgY29uc3QgbmV3V3JpdGVUcmVlID0gdGhpcy53cml0ZVRyZWVfLnNldFRyZWUocGF0aCwgc3VidHJlZSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXdXcml0ZVRyZWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhTm9kZT59IHVwZGF0ZXNcbiAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9XG4gICAqL1xuICBhZGRXcml0ZXMocGF0aDogUGF0aCwgdXBkYXRlczogeyBbbmFtZTogc3RyaW5nXTogTm9kZSB9KTogQ29tcG91bmRXcml0ZSB7XG4gICAgbGV0IG5ld1dyaXRlID0gdGhpcyBhcyBDb21wb3VuZFdyaXRlO1xuICAgIGZvckVhY2godXBkYXRlcywgZnVuY3Rpb24oY2hpbGRLZXk6IHN0cmluZywgbm9kZTogTm9kZSkge1xuICAgICAgbmV3V3JpdGUgPSBuZXdXcml0ZS5hZGRXcml0ZShwYXRoLmNoaWxkKGNoaWxkS2V5KSwgbm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1dyaXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcmVtb3ZlIGEgd3JpdGUgYXQgdGhlIGdpdmVuIHBhdGggYW5kIGRlZXBlciBwYXRocy4gVGhpcyB3aWxsIDxlbT5ub3Q8L2VtPiBtb2RpZnkgYSB3cml0ZSBhdCBhIGhpZ2hlclxuICAgKiBsb2NhdGlvbiwgd2hpY2ggbXVzdCBiZSByZW1vdmVkIGJ5IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCB0aGF0IHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggYXQgd2hpY2ggYSB3cml0ZSBhbmQgYWxsIGRlZXBlciB3cml0ZXMgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9IFRoZSBuZXcgQ29tcG91bmRXcml0ZSB3aXRoIHRoZSByZW1vdmVkIHBhdGhcbiAgICovXG4gIHJlbW92ZVdyaXRlKHBhdGg6IFBhdGgpOiBDb21wb3VuZFdyaXRlIHtcbiAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBDb21wb3VuZFdyaXRlLkVtcHR5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdXcml0ZVRyZWUgPSB0aGlzLndyaXRlVHJlZV8uc2V0VHJlZShwYXRoLCBJbW11dGFibGVUcmVlLkVtcHR5KTtcbiAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXdXcml0ZVRyZWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBDb21wb3VuZFdyaXRlIHdpbGwgZnVsbHkgb3ZlcndyaXRlIGEgbm9kZSBhdCBhIGdpdmVuIGxvY2F0aW9uIGFuZCBjYW4gdGhlcmVmb3JlIGJlXG4gICAqIGNvbnNpZGVyZWQgXCJjb21wbGV0ZVwiLlxuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrIGZvclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZXJlIGlzIGEgY29tcGxldGUgd3JpdGUgYXQgdGhhdCBwYXRoXG4gICAqL1xuICBoYXNDb21wbGV0ZVdyaXRlKHBhdGg6IFBhdGgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV0ZU5vZGUocGF0aCkgIT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9kZSBmb3IgYSBwYXRoIGlmIGFuZCBvbmx5IGlmIHRoZSBub2RlIGlzIGEgXCJjb21wbGV0ZVwiIG92ZXJ3cml0ZSBhdCB0aGF0IHBhdGguIFRoaXMgd2lsbCBub3QgYWdncmVnYXRlXG4gICAqIHdyaXRlcyBmcm9tIGRlZXBlciBwYXRocywgYnV0IHdpbGwgcmV0dXJuIGNoaWxkIG5vZGVzIGZyb20gYSBtb3JlIHNoYWxsb3cgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0byBnZXQgYSBjb21wbGV0ZSB3cml0ZVxuICAgKiBAcmV0dXJuIHs/Tm9kZX0gVGhlIG5vZGUgaWYgY29tcGxldGUgYXQgdGhhdCBwYXRoLCBvciBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIGdldENvbXBsZXRlTm9kZShwYXRoOiBQYXRoKTogTm9kZSB8IG51bGwge1xuICAgIGNvbnN0IHJvb3Rtb3N0ID0gdGhpcy53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcbiAgICBpZiAocm9vdG1vc3QgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlX1xuICAgICAgICAuZ2V0KHJvb3Rtb3N0LnBhdGgpXG4gICAgICAgIC5nZXRDaGlsZChQYXRoLnJlbGF0aXZlUGF0aChyb290bW9zdC5wYXRoLCBwYXRoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBjaGlsZHJlbiB0aGF0IGFyZSBndWFyYW50ZWVkIHRvIGJlIGEgY29tcGxldGUgb3ZlcndyaXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHshQXJyYXkuPE5hbWVkTm9kZT59IEEgbGlzdCBvZiBhbGwgY29tcGxldGUgY2hpbGRyZW4uXG4gICAqL1xuICBnZXRDb21wbGV0ZUNoaWxkcmVuKCk6IEFycmF5PE5hbWVkTm9kZT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuOiBOYW1lZE5vZGVbXSA9IFtdO1xuICAgIGxldCBub2RlID0gdGhpcy53cml0ZVRyZWVfLnZhbHVlO1xuICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgIC8vIElmIGl0J3MgYSBsZWFmIG5vZGUsIGl0IGhhcyBubyBjaGlsZHJlbjsgc28gbm90aGluZyB0byBkby5cbiAgICAgIGlmICghbm9kZS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgKG5vZGUgYXMgQ2hpbGRyZW5Ob2RlKS5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIGZ1bmN0aW9uKFxuICAgICAgICAgIGNoaWxkTmFtZSxcbiAgICAgICAgICBjaGlsZE5vZGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGROb2RlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyaXRlVHJlZV8uY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbChmdW5jdGlvbihjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICBpZiAoY2hpbGRUcmVlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqIEByZXR1cm4geyFDb21wb3VuZFdyaXRlfVxuICAgKi9cbiAgY2hpbGRDb21wb3VuZFdyaXRlKHBhdGg6IFBhdGgpOiBDb21wb3VuZFdyaXRlIHtcbiAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gdGhpcy5nZXRDb21wbGV0ZU5vZGUocGF0aCk7XG4gICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShzaGFkb3dpbmdOb2RlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUodGhpcy53cml0ZVRyZWVfLnN1YnRyZWUocGF0aCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBDb21wb3VuZFdyaXRlIGlzIGVtcHR5IGFuZCB0aGVyZWZvcmUgZG9lcyBub3QgbW9kaWZ5IGFueSBub2Rlcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIENvbXBvdW5kV3JpdGUgaXMgZW1wdHlcbiAgICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlXy5pc0VtcHR5KCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIENvbXBvdW5kV3JpdGUgdG8gYSBub2RlLiBUaGUgbm9kZSBpcyByZXR1cm5lZCB3aXRoIGFsbCB3cml0ZXMgZnJvbSB0aGlzIENvbXBvdW5kV3JpdGUgYXBwbGllZCB0byB0aGVcbiAgICogbm9kZVxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIFRoZSBub2RlIHRvIGFwcGx5IHRoaXMgQ29tcG91bmRXcml0ZSB0b1xuICAgKiBAcmV0dXJuIHshTm9kZX0gVGhlIG5vZGUgd2l0aCBhbGwgd3JpdGVzIGFwcGxpZWRcbiAgICovXG4gIGFwcGx5KG5vZGU6IE5vZGUpOiBOb2RlIHtcbiAgICByZXR1cm4gQ29tcG91bmRXcml0ZS5hcHBseVN1YnRyZWVXcml0ZV8oUGF0aC5FbXB0eSwgdGhpcy53cml0ZVRyZWVfLCBub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGhcbiAgICogQHBhcmFtIHshSW1tdXRhYmxlVHJlZS48IU5vZGU+fSB3cml0ZVRyZWVcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGFwcGx5U3VidHJlZVdyaXRlXyA9IGZ1bmN0aW9uKFxuICAgIHJlbGF0aXZlUGF0aDogUGF0aCxcbiAgICB3cml0ZVRyZWU6IEltbXV0YWJsZVRyZWU8Tm9kZT4sXG4gICAgbm9kZTogTm9kZVxuICApOiBOb2RlIHtcbiAgICBpZiAod3JpdGVUcmVlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIFNpbmNlIHRoZXJlIGEgd3JpdGUgaXMgYWx3YXlzIGEgbGVhZiwgd2UncmUgZG9uZSBoZXJlXG4gICAgICByZXR1cm4gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIHdyaXRlVHJlZS52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwcmlvcml0eVdyaXRlID0gbnVsbDtcbiAgICAgIHdyaXRlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uKGNoaWxkS2V5LCBjaGlsZFRyZWUpIHtcbiAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgIC8vIEFwcGx5IHByaW9yaXRpZXMgYXQgdGhlIGVuZCBzbyB3ZSBkb24ndCB1cGRhdGUgcHJpb3JpdGllcyBmb3IgZWl0aGVyIGVtcHR5IG5vZGVzIG9yIGZvcmdldFxuICAgICAgICAgIC8vIHRvIGFwcGx5IHByaW9yaXRpZXMgdG8gZW1wdHkgbm9kZXMgdGhhdCBhcmUgbGF0ZXIgZmlsbGVkXG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgY2hpbGRUcmVlLnZhbHVlICE9PSBudWxsLFxuICAgICAgICAgICAgJ1ByaW9yaXR5IHdyaXRlcyBtdXN0IGFsd2F5cyBiZSBsZWFmIG5vZGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgcHJpb3JpdHlXcml0ZSA9IGNoaWxkVHJlZS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gQ29tcG91bmRXcml0ZS5hcHBseVN1YnRyZWVXcml0ZV8oXG4gICAgICAgICAgICByZWxhdGl2ZVBhdGguY2hpbGQoY2hpbGRLZXkpLFxuICAgICAgICAgICAgY2hpbGRUcmVlLFxuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJpb3JpdHkgd3JpdGUsIHdlIG9ubHkgYXBwbHkgaXQgaWYgdGhlIG5vZGUgaXMgbm90IGVtcHR5XG4gICAgICBpZiAoIW5vZGUuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKS5pc0VtcHR5KCkgJiYgcHJpb3JpdHlXcml0ZSAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGguY2hpbGQoJy5wcmlvcml0eScpLCBwcmlvcml0eVdyaXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBmaW5kS2V5LCBmb3JFYWNoLCBzYWZlR2V0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRpb25FcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBDb21wb3VuZFdyaXRlIH0gZnJvbSAnLi9Db21wb3VuZFdyaXRlJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuL3NuYXAvQ2hpbGRyZW5Ob2RlJztcbmltcG9ydCB7IE5hbWVkTm9kZSwgTm9kZSB9IGZyb20gJy4vc25hcC9Ob2RlJztcbmltcG9ydCB7IENhY2hlTm9kZSB9IGZyb20gJy4vdmlldy9DYWNoZU5vZGUnO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuL3NuYXAvaW5kZXhlcy9JbmRleCc7XG5cbi8qKlxuICogRGVmaW5lcyBhIHNpbmdsZSB1c2VyLWluaXRpYXRlZCB3cml0ZSBvcGVyYXRpb24uIE1heSBiZSB0aGUgcmVzdWx0IG9mIGEgc2V0KCksIHRyYW5zYWN0aW9uKCksIG9yIHVwZGF0ZSgpIGNhbGwuIEluXG4gKiB0aGUgY2FzZSBvZiBhIHNldCgpIG9yIHRyYW5zYWN0aW9uLCBzbmFwIHdpbCBiZSBub24tbnVsbC4gIEluIHRoZSBjYXNlIG9mIGFuIHVwZGF0ZSgpLCBjaGlsZHJlbiB3aWxsIGJlIG5vbi1udWxsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdyaXRlUmVjb3JkIHtcbiAgd3JpdGVJZDogbnVtYmVyO1xuICBwYXRoOiBQYXRoO1xuICBzbmFwPzogTm9kZSB8IG51bGw7XG4gIGNoaWxkcmVuPzogeyBbazogc3RyaW5nXTogTm9kZSB9IHwgbnVsbDtcbiAgdmlzaWJsZTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBXcml0ZVRyZWUgdHJhY2tzIGFsbCBwZW5kaW5nIHVzZXItaW5pdGlhdGVkIHdyaXRlcyBhbmQgaGFzIG1ldGhvZHMgdG8gY2FsY3VsYXRlIHRoZSByZXN1bHQgb2YgbWVyZ2luZyB0aGVtXG4gKiB3aXRoIHVuZGVybHlpbmcgc2VydmVyIGRhdGEgKHRvIGNyZWF0ZSBcImV2ZW50IGNhY2hlXCIgZGF0YSkuICBQZW5kaW5nIHdyaXRlcyBhcmUgYWRkZWQgd2l0aCBhZGRPdmVyd3JpdGUoKVxuICogYW5kIGFkZE1lcmdlKCksIGFuZCByZW1vdmVkIHdpdGggcmVtb3ZlV3JpdGUoKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRlVHJlZSB7XG4gIC8qKlxuICAgKiBBIHRyZWUgdHJhY2tpbmcgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhbGwgdmlzaWJsZSB3cml0ZXMuICBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdHJhbnNhY3Rpb25zIHdpdGhcbiAgICogYXBwbHlMb2NhbGx5PWZhbHNlIG9yIHdyaXRlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IHNoYWRvd2VkIGJ5IG90aGVyIHdyaXRlcy5cbiAgICpcbiAgICogQHR5cGUgeyFDb21wb3VuZFdyaXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSB2aXNpYmxlV3JpdGVzXzogQ29tcG91bmRXcml0ZSA9IENvbXBvdW5kV3JpdGUuRW1wdHk7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBhbGwgcGVuZGluZyB3cml0ZXMsIHJlZ2FyZGxlc3Mgb2YgdmlzaWJpbGl0eSBhbmQgc2hhZG93ZWQtbmVzcy4gIFVzZWQgdG8gY2FsY3VsYXRlIGFyYml0cmFyeVxuICAgKiBzZXRzIG9mIHRoZSBjaGFuZ2VkIGRhdGEsIHN1Y2ggYXMgaGlkZGVuIHdyaXRlcyAoZnJvbSB0cmFuc2FjdGlvbnMpIG9yIGNoYW5nZXMgd2l0aCBjZXJ0YWluIHdyaXRlcyBleGNsdWRlZCAoYWxzb1xuICAgKiB1c2VkIGJ5IHRyYW5zYWN0aW9ucykuXG4gICAqXG4gICAqIEB0eXBlIHshQXJyYXkuPCFXcml0ZVJlY29yZD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFsbFdyaXRlc186IFdyaXRlUmVjb3JkW10gPSBbXTtcblxuICBwcml2YXRlIGxhc3RXcml0ZUlkXyA9IC0xO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgV3JpdGVUcmVlUmVmIGZvciB0aGUgZ2l2ZW4gcGF0aC4gRm9yIHVzZSB3aXRoIGEgbmV3IHN5bmMgcG9pbnQgYXQgdGhlIGdpdmVuIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHJldHVybiB7IVdyaXRlVHJlZVJlZn1cbiAgICovXG4gIGNoaWxkV3JpdGVzKHBhdGg6IFBhdGgpOiBXcml0ZVRyZWVSZWYge1xuICAgIHJldHVybiBuZXcgV3JpdGVUcmVlUmVmKHBhdGgsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCBhIG5ldyBvdmVyd3JpdGUgZnJvbSB1c2VyIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHshTm9kZX0gc25hcFxuICAgKiBAcGFyYW0geyFudW1iZXJ9IHdyaXRlSWRcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdmlzaWJsZSBUaGlzIGlzIHNldCB0byBmYWxzZSBieSBzb21lIHRyYW5zYWN0aW9ucy4gSXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gZXZlbnQgY2FjaGVzXG4gICAqL1xuICBhZGRPdmVyd3JpdGUocGF0aDogUGF0aCwgc25hcDogTm9kZSwgd3JpdGVJZDogbnVtYmVyLCB2aXNpYmxlPzogYm9vbGVhbikge1xuICAgIGFzc2VydChcbiAgICAgIHdyaXRlSWQgPiB0aGlzLmxhc3RXcml0ZUlkXyxcbiAgICAgICdTdGFja2luZyBhbiBvbGRlciB3cml0ZSBvbiB0b3Agb2YgbmV3ZXIgb25lcydcbiAgICApO1xuICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmFsbFdyaXRlc18ucHVzaCh7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgc25hcDogc25hcCxcbiAgICAgIHdyaXRlSWQ6IHdyaXRlSWQsXG4gICAgICB2aXNpYmxlOiB2aXNpYmxlXG4gICAgfSk7XG5cbiAgICBpZiAodmlzaWJsZSkge1xuICAgICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IHRoaXMudmlzaWJsZVdyaXRlc18uYWRkV3JpdGUocGF0aCwgc25hcCk7XG4gICAgfVxuICAgIHRoaXMubGFzdFdyaXRlSWRfID0gd3JpdGVJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmQgYSBuZXcgbWVyZ2UgZnJvbSB1c2VyIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gd3JpdGVJZFxuICAgKi9cbiAgYWRkTWVyZ2UoXG4gICAgcGF0aDogUGF0aCxcbiAgICBjaGFuZ2VkQ2hpbGRyZW46IHsgW2s6IHN0cmluZ106IE5vZGUgfSxcbiAgICB3cml0ZUlkOiBudW1iZXJcbiAgKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgd3JpdGVJZCA+IHRoaXMubGFzdFdyaXRlSWRfLFxuICAgICAgJ1N0YWNraW5nIGFuIG9sZGVyIG1lcmdlIG9uIHRvcCBvZiBuZXdlciBvbmVzJ1xuICAgICk7XG4gICAgdGhpcy5hbGxXcml0ZXNfLnB1c2goe1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIGNoaWxkcmVuOiBjaGFuZ2VkQ2hpbGRyZW4sXG4gICAgICB3cml0ZUlkOiB3cml0ZUlkLFxuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IHRoaXMudmlzaWJsZVdyaXRlc18uYWRkV3JpdGVzKHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XG4gICAgdGhpcy5sYXN0V3JpdGVJZF8gPSB3cml0ZUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gd3JpdGVJZFxuICAgKiBAcmV0dXJuIHs/V3JpdGVSZWNvcmR9XG4gICAqL1xuICBnZXRXcml0ZSh3cml0ZUlkOiBudW1iZXIpOiBXcml0ZVJlY29yZCB8IG51bGwge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbGxXcml0ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWNvcmQgPSB0aGlzLmFsbFdyaXRlc19baV07XG4gICAgICBpZiAocmVjb3JkLndyaXRlSWQgPT09IHdyaXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgd3JpdGUgKGVpdGhlciBhbiBvdmVyd3JpdGUgb3IgbWVyZ2UpIHRoYXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGFja25vd2xlZGdlIGJ5IHRoZSBzZXJ2ZXIuIFJlY2FsY3VsYXRlc1xuICAgKiB0aGUgdHJlZSBpZiBuZWNlc3NhcnkuICBXZSByZXR1cm4gdHJ1ZSBpZiBpdCBtYXkgaGF2ZSBiZWVuIHZpc2libGUsIG1lYW5pbmcgdmlld3MgbmVlZCB0byByZWV2YWx1YXRlLlxuICAgKlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IHdyaXRlSWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgd3JpdGUgbWF5IGhhdmUgYmVlbiB2aXNpYmxlIChtZWFuaW5nIHdlJ2xsIG5lZWQgdG8gcmVldmFsdWF0ZSAvIHJhaXNlXG4gICAqIGV2ZW50cyBhcyBhIHJlc3VsdCkuXG4gICAqL1xuICByZW1vdmVXcml0ZSh3cml0ZUlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBOb3RlOiBkaXNhYmxpbmcgdGhpcyBjaGVjay4gSXQgY291bGQgYmUgYSB0cmFuc2FjdGlvbiB0aGF0IHByZWVtcHRlZCBhbm90aGVyIHRyYW5zYWN0aW9uLCBhbmQgdGh1cyB3YXMgYXBwbGllZFxuICAgIC8vIG91dCBvZiBvcmRlci5cbiAgICAvL2NvbnN0IHZhbGlkQ2xlYXIgPSByZXZlcnQgfHwgdGhpcy5hbGxXcml0ZXNfLmxlbmd0aCA9PT0gMCB8fCB3cml0ZUlkIDw9IHRoaXMuYWxsV3JpdGVzX1swXS53cml0ZUlkO1xuICAgIC8vYXNzZXJ0KHZhbGlkQ2xlYXIsIFwiRWl0aGVyIHdlIGRvbid0IGhhdmUgdGhpcyB3cml0ZSwgb3IgaXQncyB0aGUgZmlyc3Qgb25lIGluIHRoZSBxdWV1ZVwiKTtcblxuICAgIGNvbnN0IGlkeCA9IHRoaXMuYWxsV3JpdGVzXy5maW5kSW5kZXgoZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHMud3JpdGVJZCA9PT0gd3JpdGVJZDtcbiAgICB9KTtcbiAgICBhc3NlcnQoaWR4ID49IDAsICdyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLicpO1xuICAgIGNvbnN0IHdyaXRlVG9SZW1vdmUgPSB0aGlzLmFsbFdyaXRlc19baWR4XTtcbiAgICB0aGlzLmFsbFdyaXRlc18uc3BsaWNlKGlkeCwgMSk7XG5cbiAgICBsZXQgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IHdyaXRlVG9SZW1vdmUudmlzaWJsZTtcbiAgICBsZXQgcmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMgPSBmYWxzZTtcblxuICAgIGxldCBpID0gdGhpcy5hbGxXcml0ZXNfLmxlbmd0aCAtIDE7XG5cbiAgICB3aGlsZSAocmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSAmJiBpID49IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRXcml0ZSA9IHRoaXMuYWxsV3JpdGVzX1tpXTtcbiAgICAgIGlmIChjdXJyZW50V3JpdGUudmlzaWJsZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaSA+PSBpZHggJiZcbiAgICAgICAgICB0aGlzLnJlY29yZENvbnRhaW5zUGF0aF8oY3VycmVudFdyaXRlLCB3cml0ZVRvUmVtb3ZlLnBhdGgpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFRoZSByZW1vdmVkIHdyaXRlIHdhcyBjb21wbGV0ZWx5IHNoYWRvd2VkIGJ5IGEgc3Vic2VxdWVudCB3cml0ZS5cbiAgICAgICAgICByZW1vdmVkV3JpdGVXYXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAod3JpdGVUb1JlbW92ZS5wYXRoLmNvbnRhaW5zKGN1cnJlbnRXcml0ZS5wYXRoKSkge1xuICAgICAgICAgIC8vIEVpdGhlciB3ZSdyZSBjb3ZlcmluZyBzb21lIHdyaXRlcyBvciB0aGV5J3JlIGNvdmVyaW5nIHBhcnQgb2YgdXMgKGRlcGVuZGluZyBvbiB3aGljaCBjYW1lIGZpcnN0KS5cbiAgICAgICAgICByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICB9XG5cbiAgICBpZiAoIXJlbW92ZWRXcml0ZVdhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzKSB7XG4gICAgICAvLyBUaGVyZSdzIHNvbWUgc2hhZG93aW5nIGdvaW5nIG9uLiBKdXN0IHJlYnVpbGQgdGhlIHZpc2libGUgd3JpdGVzIGZyb20gc2NyYXRjaC5cbiAgICAgIHRoaXMucmVzZXRUcmVlXygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gc2hhZG93aW5nLiAgV2UgY2FuIHNhZmVseSBqdXN0IHJlbW92ZSB0aGUgd3JpdGUocykgZnJvbSB2aXNpYmxlV3JpdGVzLlxuICAgICAgaWYgKHdyaXRlVG9SZW1vdmUuc25hcCkge1xuICAgICAgICB0aGlzLnZpc2libGVXcml0ZXNfID0gdGhpcy52aXNpYmxlV3JpdGVzXy5yZW1vdmVXcml0ZShcbiAgICAgICAgICB3cml0ZVRvUmVtb3ZlLnBhdGhcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gd3JpdGVUb1JlbW92ZS5jaGlsZHJlbjtcbiAgICAgICAgZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IHRoaXMudmlzaWJsZVdyaXRlc18ucmVtb3ZlV3JpdGUoXG4gICAgICAgICAgICB3cml0ZVRvUmVtb3ZlLnBhdGguY2hpbGQoY2hpbGROYW1lKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvbXBsZXRlIHNuYXBzaG90IGZvciB0aGUgZ2l2ZW4gcGF0aCBpZiB0aGVyZSdzIHZpc2libGUgd3JpdGUgZGF0YSBhdCB0aGF0IHBhdGgsIGVsc2UgbnVsbC5cbiAgICogTm8gc2VydmVyIGRhdGEgaXMgY29uc2lkZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIGdldENvbXBsZXRlV3JpdGVEYXRhKHBhdGg6IFBhdGgpOiBOb2RlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMudmlzaWJsZVdyaXRlc18uZ2V0Q29tcGxldGVOb2RlKHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhbmQgYW4gb3B0aW9uYWwgc2V0IG9mIGNvbnN0cmFpbnRzIChleGNsdWRlIHNvbWUgc2V0cywgaW5jbHVkZSBoaWRkZW5cbiAgICogd3JpdGVzKSwgYXR0ZW1wdCB0byBjYWxjdWxhdGUgYSBjb21wbGV0ZSBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVTZXJ2ZXJDYWNoZVxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gd3JpdGVJZHNUb0V4Y2x1ZGUgQW4gb3B0aW9uYWwgc2V0IHRvIGJlIGV4Y2x1ZGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVIaWRkZW5Xcml0ZXMgRGVmYXVsdHMgdG8gZmFsc2UsIHdoZXRoZXIgb3Igbm90IHRvIGxheWVyIG9uIHdyaXRlcyB3aXRoIHZpc2libGUgc2V0IHRvIGZhbHNlXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgY2FsY0NvbXBsZXRlRXZlbnRDYWNoZShcbiAgICB0cmVlUGF0aDogUGF0aCxcbiAgICBjb21wbGV0ZVNlcnZlckNhY2hlOiBOb2RlIHwgbnVsbCxcbiAgICB3cml0ZUlkc1RvRXhjbHVkZT86IG51bWJlcltdLFxuICAgIGluY2x1ZGVIaWRkZW5Xcml0ZXM/OiBib29sZWFuXG4gICk6IE5vZGUgfCBudWxsIHtcbiAgICBpZiAoIXdyaXRlSWRzVG9FeGNsdWRlICYmICFpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XG4gICAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5nZXRDb21wbGV0ZU5vZGUodHJlZVBhdGgpO1xuICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2hhZG93aW5nTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHN1Yk1lcmdlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5jaGlsZENvbXBvdW5kV3JpdGUodHJlZVBhdGgpO1xuICAgICAgICBpZiAoc3ViTWVyZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgY29tcGxldGVTZXJ2ZXJDYWNoZSA9PSBudWxsICYmXG4gICAgICAgICAgIXN1Yk1lcmdlLmhhc0NvbXBsZXRlV3JpdGUoUGF0aC5FbXB0eSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gV2Ugd291bGRuJ3QgaGF2ZSBhIGNvbXBsZXRlIHNuYXBzaG90LCBzaW5jZSB0aGVyZSdzIG5vIHVuZGVybHlpbmcgZGF0YSBhbmQgbm8gY29tcGxldGUgc2hhZG93XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJlZENhY2hlID0gY29tcGxldGVTZXJ2ZXJDYWNoZSB8fCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICByZXR1cm4gc3ViTWVyZ2UuYXBwbHkobGF5ZXJlZENhY2hlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZXJnZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHRyZWVQYXRoKTtcbiAgICAgIGlmICghaW5jbHVkZUhpZGRlbldyaXRlcyAmJiBtZXJnZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGNhY2hlIGlzIG51bGwsIGFuZCB3ZSBkb24ndCBoYXZlIGEgY29tcGxldGUgY2FjaGUsIHdlIG5lZWQgdG8gcmV0dXJuIG51bGxcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpbmNsdWRlSGlkZGVuV3JpdGVzICYmXG4gICAgICAgICAgY29tcGxldGVTZXJ2ZXJDYWNoZSA9PSBudWxsICYmXG4gICAgICAgICAgIW1lcmdlLmhhc0NvbXBsZXRlV3JpdGUoUGF0aC5FbXB0eSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gZnVuY3Rpb24od3JpdGU6IFdyaXRlUmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAod3JpdGUudmlzaWJsZSB8fCBpbmNsdWRlSGlkZGVuV3JpdGVzKSAmJlxuICAgICAgICAgICAgICAoIXdyaXRlSWRzVG9FeGNsdWRlIHx8XG4gICAgICAgICAgICAgICAgIX53cml0ZUlkc1RvRXhjbHVkZS5pbmRleE9mKHdyaXRlLndyaXRlSWQpKSAmJlxuICAgICAgICAgICAgICAod3JpdGUucGF0aC5jb250YWlucyh0cmVlUGF0aCkgfHwgdHJlZVBhdGguY29udGFpbnMod3JpdGUucGF0aCkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgbWVyZ2VBdFBhdGggPSBXcml0ZVRyZWUubGF5ZXJUcmVlXyhcbiAgICAgICAgICAgIHRoaXMuYWxsV3JpdGVzXyxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHRyZWVQYXRoXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBsYXllcmVkQ2FjaGUgPSBjb21wbGV0ZVNlcnZlckNhY2hlIHx8IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICAgIHJldHVybiBtZXJnZUF0UGF0aC5hcHBseShsYXllcmVkQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdpdGggb3B0aW9uYWwsIHVuZGVybHlpbmcgc2VydmVyIGRhdGEsIGF0dGVtcHQgdG8gcmV0dXJuIGEgY2hpbGRyZW4gbm9kZSBvZiBjaGlsZHJlbiB0aGF0IHdlIGhhdmUgY29tcGxldGUgZGF0YSBmb3IuXG4gICAqIFVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmlld3MsIHRvIHByZS1maWxsIHRoZWlyIGNvbXBsZXRlIGV2ZW50IGNoaWxkcmVuIHNuYXBzaG90LlxuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSB0cmVlUGF0aFxuICAgKiBAcGFyYW0gez9DaGlsZHJlbk5vZGV9IGNvbXBsZXRlU2VydmVyQ2hpbGRyZW5cbiAgICogQHJldHVybiB7IUNoaWxkcmVuTm9kZX1cbiAgICovXG4gIGNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4oXG4gICAgdHJlZVBhdGg6IFBhdGgsXG4gICAgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbjogQ2hpbGRyZW5Ob2RlIHwgbnVsbFxuICApIHtcbiAgICBsZXQgY29tcGxldGVDaGlsZHJlbiA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFIGFzIE5vZGU7XG4gICAgY29uc3QgdG9wTGV2ZWxTZXQgPSB0aGlzLnZpc2libGVXcml0ZXNfLmdldENvbXBsZXRlTm9kZSh0cmVlUGF0aCk7XG4gICAgaWYgKHRvcExldmVsU2V0KSB7XG4gICAgICBpZiAoIXRvcExldmVsU2V0LmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAvLyB3ZSdyZSBzaGFkb3dpbmcgZXZlcnl0aGluZy4gUmV0dXJuIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgdG9wTGV2ZWxTZXQuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbihcbiAgICAgICAgICBjaGlsZE5hbWUsXG4gICAgICAgICAgY2hpbGRTbmFwXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKFxuICAgICAgICAgICAgY2hpbGROYW1lLFxuICAgICAgICAgICAgY2hpbGRTbmFwXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcbiAgICB9IGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcbiAgICAgIC8vIExheWVyIGFueSBjaGlsZHJlbiB3ZSBoYXZlIG9uIHRvcCBvZiB0aGlzXG4gICAgICAvLyBXZSBrbm93IHdlIGRvbid0IGhhdmUgYSB0b3AtbGV2ZWwgc2V0LCBzbyBqdXN0IGVudW1lcmF0ZSBleGlzdGluZyBjaGlsZHJlblxuICAgICAgY29uc3QgbWVyZ2UgPSB0aGlzLnZpc2libGVXcml0ZXNfLmNoaWxkQ29tcG91bmRXcml0ZSh0cmVlUGF0aCk7XG4gICAgICBjb21wbGV0ZVNlcnZlckNoaWxkcmVuLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24oXG4gICAgICAgIGNoaWxkTmFtZSxcbiAgICAgICAgY2hpbGROb2RlXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG1lcmdlXG4gICAgICAgICAgLmNoaWxkQ29tcG91bmRXcml0ZShuZXcgUGF0aChjaGlsZE5hbWUpKVxuICAgICAgICAgIC5hcHBseShjaGlsZE5vZGUpO1xuICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChcbiAgICAgICAgICBjaGlsZE5hbWUsXG4gICAgICAgICAgbm9kZVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICAvLyBBZGQgYW55IGNvbXBsZXRlIGNoaWxkcmVuIHdlIGhhdmUgZnJvbSB0aGUgc2V0XG4gICAgICBtZXJnZS5nZXRDb21wbGV0ZUNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbihuYW1lZE5vZGUpIHtcbiAgICAgICAgY29tcGxldGVDaGlsZHJlbiA9IGNvbXBsZXRlQ2hpbGRyZW4udXBkYXRlSW1tZWRpYXRlQ2hpbGQoXG4gICAgICAgICAgbmFtZWROb2RlLm5hbWUsXG4gICAgICAgICAgbmFtZWROb2RlLm5vZGVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlQ2hpbGRyZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gbGF5ZXIgb24gdG9wIG9mLiBMYXllciBvbiBhbnkgY2hpbGRyZW4gd2UgaGF2ZVxuICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbiByZXR1cm4gYW4gZW1wdHkgc25hcCBpZiB3ZSBoYXZlIGEgZGVmaW5lZCBkZWxldGVcbiAgICAgIGNvbnN0IG1lcmdlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5jaGlsZENvbXBvdW5kV3JpdGUodHJlZVBhdGgpO1xuICAgICAgbWVyZ2UuZ2V0Q29tcGxldGVDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24obmFtZWROb2RlKSB7XG4gICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKFxuICAgICAgICAgIG5hbWVkTm9kZS5uYW1lLFxuICAgICAgICAgIG5hbWVkTm9kZS5ub2RlXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGF0IHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCwgaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlXG4gICAqIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxuICAgKlxuICAgKiBQb3NzaWJpbGl0aWVzOlxuICAgKlxuICAgKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcbiAgICpcbiAgICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxuICAgKlxuICAgKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50c1xuICAgKlxuICAgKiBFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3RcbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICogQHBhcmFtIHshUGF0aH0gY2hpbGRQYXRoXG4gICAqIEBwYXJhbSB7P05vZGV9IGV4aXN0aW5nRXZlbnRTbmFwXG4gICAqIEBwYXJhbSB7P05vZGV9IGV4aXN0aW5nU2VydmVyU25hcFxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIGNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUoXG4gICAgdHJlZVBhdGg6IFBhdGgsXG4gICAgY2hpbGRQYXRoOiBQYXRoLFxuICAgIGV4aXN0aW5nRXZlbnRTbmFwOiBOb2RlIHwgbnVsbCxcbiAgICBleGlzdGluZ1NlcnZlclNuYXA6IE5vZGUgfCBudWxsXG4gICk6IE5vZGUgfCBudWxsIHtcbiAgICBhc3NlcnQoXG4gICAgICBleGlzdGluZ0V2ZW50U25hcCB8fCBleGlzdGluZ1NlcnZlclNuYXAsXG4gICAgICAnRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0J1xuICAgICk7XG4gICAgY29uc3QgcGF0aCA9IHRyZWVQYXRoLmNoaWxkKGNoaWxkUGF0aCk7XG4gICAgaWYgKHRoaXMudmlzaWJsZVdyaXRlc18uaGFzQ29tcGxldGVXcml0ZShwYXRoKSkge1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBjYW4gcHJvYmFibHkgZ3VhcmFudGVlIHRoYXQgd2UncmUgaW4gY2FzZSAyLCBtZWFuaW5nIG5vIGV2ZW50c1xuICAgICAgLy8gTWF5IG5lZWQgdG8gY2hlY2sgdmlzaWJpbGl0eSB3aGlsZSBkb2luZyB0aGUgZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoIGNhbGxcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjb21wbGV0ZSBzaGFkb3dpbmcuIFdlJ3JlIGVpdGhlciBwYXJ0aWFsbHkgc2hhZG93aW5nIG9yIG5vdCBzaGFkb3dpbmcgYXQgYWxsLlxuICAgICAgY29uc3QgY2hpbGRNZXJnZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHBhdGgpO1xuICAgICAgaWYgKGNoaWxkTWVyZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIFdlJ3JlIG5vdCBzaGFkb3dpbmcgYXQgYWxsLiBDYXNlIDFcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VydmVyU25hcC5nZXRDaGlsZChjaGlsZFBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBtb3JlIGVmZmljaWVudCBpZiB0aGUgc2VydmVyTm9kZSArIHVwZGF0ZXMgZG9lc24ndCBjaGFuZ2UgdGhlIGV2ZW50U25hcFxuICAgICAgICAvLyBIb3dldmVyIHRoaXMgaXMgdHJpY2t5IHRvIGZpbmQgb3V0LCBzaW5jZSB1c2VyIHVwZGF0ZXMgZG9uJ3QgbmVjZXNzYXJ5IGNoYW5nZSB0aGUgc2VydmVyXG4gICAgICAgIC8vIHNuYXAsIGUuZy4gcHJpb3JpdHkgdXBkYXRlcyBvbiBlbXB0eSBub2Rlcywgb3IgZGVlcCBkZWxldGVzLiBBbm90aGVyIHNwZWNpYWwgY2FzZSBpcyBpZiB0aGUgc2VydmVyXG4gICAgICAgIC8vIGFkZHMgbm9kZXMsIGJ1dCBkb2Vzbid0IGNoYW5nZSBhbnkgZXhpc3Rpbmcgd3JpdGVzLiBJdCBpcyB0aGVyZWZvcmUgbm90IGVub3VnaCB0b1xuICAgICAgICAvLyBvbmx5IGNoZWNrIGlmIHRoZSB1cGRhdGVzIGNoYW5nZSB0aGUgc2VydmVyTm9kZS5cbiAgICAgICAgLy8gTWF5YmUgY2hlY2sgaWYgdGhlIG1lcmdlIHRyZWUgY29udGFpbnMgdGhlc2Ugc3BlY2lhbCBjYXNlcyBhbmQgb25seSBkbyBhIGZ1bGwgb3ZlcndyaXRlIGluIHRoYXQgY2FzZT9cbiAgICAgICAgcmV0dXJuIGNoaWxkTWVyZ2UuYXBwbHkoZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldENoaWxkKGNoaWxkUGF0aCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cbiAgICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHRyZWVQYXRoXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY2hpbGRLZXlcbiAgICogQHBhcmFtIHshQ2FjaGVOb2RlfSBleGlzdGluZ1NlcnZlclNuYXBcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBjYWxjQ29tcGxldGVDaGlsZChcbiAgICB0cmVlUGF0aDogUGF0aCxcbiAgICBjaGlsZEtleTogc3RyaW5nLFxuICAgIGV4aXN0aW5nU2VydmVyU25hcDogQ2FjaGVOb2RlXG4gICk6IE5vZGUgfCBudWxsIHtcbiAgICBjb25zdCBwYXRoID0gdHJlZVBhdGguY2hpbGQoY2hpbGRLZXkpO1xuICAgIGNvbnN0IHNoYWRvd2luZ05vZGUgPSB0aGlzLnZpc2libGVXcml0ZXNfLmdldENvbXBsZXRlTm9kZShwYXRoKTtcbiAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc2hhZG93aW5nTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4aXN0aW5nU2VydmVyU25hcC5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTWVyZ2UgPSB0aGlzLnZpc2libGVXcml0ZXNfLmNoaWxkQ29tcG91bmRXcml0ZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkTWVyZ2UuYXBwbHkoXG4gICAgICAgICAgZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9kZSBpZiB0aGVyZSBpcyBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBmb3IgdGhpcyBwYXRoLiBNb3JlIHNwZWNpZmljYWxseSwgaWYgdGhlcmUgaXMgYSB3cml0ZSBhdFxuICAgKiBhIGhpZ2hlciBwYXRoLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBjaGlsZCBvZiB0aGF0IHdyaXRlIHJlbGF0aXZlIHRvIHRoZSB3cml0ZSBhbmQgdGhpcyBwYXRoLlxuICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gd3JpdGUgYXQgdGhpcyBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgc2hhZG93aW5nV3JpdGUocGF0aDogUGF0aCk6IE5vZGUgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy52aXNpYmxlV3JpdGVzXy5nZXRDb21wbGV0ZU5vZGUocGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB3aGVuIHByb2Nlc3NpbmcgY2hpbGQgcmVtb3ZlIGV2ZW50cyBvbiBhIHF1ZXJ5LiBJZiB3ZSBjYW4sIHdlIHB1bGwgaW4gY2hpbGRyZW4gdGhhdCB3ZXJlIG91dHNpZGVcbiAgICogdGhlIHdpbmRvdywgYnV0IG1heSBub3cgYmUgaW4gdGhlIHdpbmRvdy5cbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVTZXJ2ZXJEYXRhXG4gICAqIEBwYXJhbSB7IU5hbWVkTm9kZX0gc3RhcnRQb3N0XG4gICAqIEBwYXJhbSB7IW51bWJlcn0gY291bnRcbiAgICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlXG4gICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleFxuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFOYW1lZE5vZGU+fVxuICAgKi9cbiAgY2FsY0luZGV4ZWRTbGljZShcbiAgICB0cmVlUGF0aDogUGF0aCxcbiAgICBjb21wbGV0ZVNlcnZlckRhdGE6IE5vZGUgfCBudWxsLFxuICAgIHN0YXJ0UG9zdDogTmFtZWROb2RlLFxuICAgIGNvdW50OiBudW1iZXIsXG4gICAgcmV2ZXJzZTogYm9vbGVhbixcbiAgICBpbmRleDogSW5kZXhcbiAgKTogTmFtZWROb2RlW10ge1xuICAgIGxldCB0b0l0ZXJhdGU6IE5vZGU7XG4gICAgY29uc3QgbWVyZ2UgPSB0aGlzLnZpc2libGVXcml0ZXNfLmNoaWxkQ29tcG91bmRXcml0ZSh0cmVlUGF0aCk7XG4gICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IG1lcmdlLmdldENvbXBsZXRlTm9kZShQYXRoLkVtcHR5KTtcbiAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XG4gICAgICB0b0l0ZXJhdGUgPSBzaGFkb3dpbmdOb2RlO1xuICAgIH0gZWxzZSBpZiAoY29tcGxldGVTZXJ2ZXJEYXRhICE9IG51bGwpIHtcbiAgICAgIHRvSXRlcmF0ZSA9IG1lcmdlLmFwcGx5KGNvbXBsZXRlU2VydmVyRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGNoaWxkcmVuIHRvIGl0ZXJhdGUgb25cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdG9JdGVyYXRlID0gdG9JdGVyYXRlLndpdGhJbmRleChpbmRleCk7XG4gICAgaWYgKCF0b0l0ZXJhdGUuaXNFbXB0eSgpICYmICF0b0l0ZXJhdGUuaXNMZWFmTm9kZSgpKSB7XG4gICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgY29uc3QgY21wID0gaW5kZXguZ2V0Q29tcGFyZSgpO1xuICAgICAgY29uc3QgaXRlciA9IHJldmVyc2VcbiAgICAgICAgPyAodG9JdGVyYXRlIGFzIENoaWxkcmVuTm9kZSkuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4KVxuICAgICAgICA6ICh0b0l0ZXJhdGUgYXMgQ2hpbGRyZW5Ob2RlKS5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBpbmRleCk7XG4gICAgICBsZXQgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgd2hpbGUgKG5leHQgJiYgbm9kZXMubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgICAgaWYgKGNtcChuZXh0LCBzdGFydFBvc3QpICE9PSAwKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshV3JpdGVSZWNvcmR9IHdyaXRlUmVjb3JkXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVjb3JkQ29udGFpbnNQYXRoXyh3cml0ZVJlY29yZDogV3JpdGVSZWNvcmQsIHBhdGg6IFBhdGgpOiBib29sZWFuIHtcbiAgICBpZiAod3JpdGVSZWNvcmQuc25hcCkge1xuICAgICAgcmV0dXJuIHdyaXRlUmVjb3JkLnBhdGguY29udGFpbnMocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZpbmRLZXkgY2FuIHJldHVybiB1bmRlZmluZWQsIHNvIHVzZSAhISB0byBjb2VyY2UgdG8gYm9vbGVhblxuICAgICAgcmV0dXJuICEhZmluZEtleSh3cml0ZVJlY29yZC5jaGlsZHJlbiwgZnVuY3Rpb24oXG4gICAgICAgIGNoaWxkU25hcDogTm9kZSxcbiAgICAgICAgY2hpbGROYW1lOiBzdHJpbmdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gd3JpdGVSZWNvcmQucGF0aC5jaGlsZChjaGlsZE5hbWUpLmNvbnRhaW5zKHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlLWxheWVyIHRoZSB3cml0ZXMgYW5kIG1lcmdlcyBpbnRvIGEgdHJlZSBzbyB3ZSBjYW4gZWZmaWNpZW50bHkgY2FsY3VsYXRlIGV2ZW50IHNuYXBzaG90c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSByZXNldFRyZWVfKCkge1xuICAgIHRoaXMudmlzaWJsZVdyaXRlc18gPSBXcml0ZVRyZWUubGF5ZXJUcmVlXyhcbiAgICAgIHRoaXMuYWxsV3JpdGVzXyxcbiAgICAgIFdyaXRlVHJlZS5EZWZhdWx0RmlsdGVyXyxcbiAgICAgIFBhdGguRW1wdHlcbiAgICApO1xuICAgIGlmICh0aGlzLmFsbFdyaXRlc18ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5sYXN0V3JpdGVJZF8gPSB0aGlzLmFsbFdyaXRlc19bdGhpcy5hbGxXcml0ZXNfLmxlbmd0aCAtIDFdLndyaXRlSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdFdyaXRlSWRfID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGZpbHRlciB1c2VkIHdoZW4gY29uc3RydWN0aW5nIHRoZSB0cmVlLiBLZWVwIGV2ZXJ5dGhpbmcgdGhhdCdzIHZpc2libGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVdyaXRlUmVjb3JkfSB3cml0ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgRGVmYXVsdEZpbHRlcl8od3JpdGU6IFdyaXRlUmVjb3JkKSB7XG4gICAgcmV0dXJuIHdyaXRlLnZpc2libGU7XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZC4gR2l2ZW4gYW4gYXJyYXkgb2YgV3JpdGVSZWNvcmRzLCBhIGZpbHRlciBmb3Igd2hpY2ggb25lcyB0byBpbmNsdWRlLCBhbmQgYSBwYXRoLCBjb25zdHJ1Y3QgdGhlIHRyZWUgb2ZcbiAgICogZXZlbnQgZGF0YSBhdCB0aGF0IHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7IUFycmF5LjwhV3JpdGVSZWNvcmQ+fSB3cml0ZXNcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oIVdyaXRlUmVjb3JkKTpib29sZWFufSBmaWx0ZXJcbiAgICogQHBhcmFtIHshUGF0aH0gdHJlZVJvb3RcbiAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBsYXllclRyZWVfKFxuICAgIHdyaXRlczogV3JpdGVSZWNvcmRbXSxcbiAgICBmaWx0ZXI6ICh3OiBXcml0ZVJlY29yZCkgPT4gYm9vbGVhbixcbiAgICB0cmVlUm9vdDogUGF0aFxuICApOiBDb21wb3VuZFdyaXRlIHtcbiAgICBsZXQgY29tcG91bmRXcml0ZSA9IENvbXBvdW5kV3JpdGUuRW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cml0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHdyaXRlID0gd3JpdGVzW2ldO1xuICAgICAgLy8gVGhlb3J5LCBhIGxhdGVyIHNldCB3aWxsIGVpdGhlcjpcbiAgICAgIC8vIGEpIGFib3J0IGEgcmVsZXZhbnQgdHJhbnNhY3Rpb24sIHNvIG5vIG5lZWQgdG8gd29ycnkgYWJvdXQgZXhjbHVkaW5nIGl0IGZyb20gY2FsY3VsYXRpbmcgdGhhdCB0cmFuc2FjdGlvblxuICAgICAgLy8gYikgbm90IGJlIHJlbGV2YW50IHRvIGEgdHJhbnNhY3Rpb24gKHNlcGFyYXRlIGJyYW5jaCksIHNvIGFnYWluIHdpbGwgbm90IGFmZmVjdCB0aGUgZGF0YSBmb3IgdGhhdCB0cmFuc2FjdGlvblxuICAgICAgaWYgKGZpbHRlcih3cml0ZSkpIHtcbiAgICAgICAgY29uc3Qgd3JpdGVQYXRoID0gd3JpdGUucGF0aDtcbiAgICAgICAgbGV0IHJlbGF0aXZlUGF0aDtcbiAgICAgICAgaWYgKHdyaXRlLnNuYXApIHtcbiAgICAgICAgICBpZiAodHJlZVJvb3QuY29udGFpbnMod3JpdGVQYXRoKSkge1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gUGF0aC5yZWxhdGl2ZVBhdGgodHJlZVJvb3QsIHdyaXRlUGF0aCk7XG4gICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZShyZWxhdGl2ZVBhdGgsIHdyaXRlLnNuYXApO1xuICAgICAgICAgIH0gZWxzZSBpZiAod3JpdGVQYXRoLmNvbnRhaW5zKHRyZWVSb290KSkge1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gUGF0aC5yZWxhdGl2ZVBhdGgod3JpdGVQYXRoLCB0cmVlUm9vdCk7XG4gICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZShcbiAgICAgICAgICAgICAgUGF0aC5FbXB0eSxcbiAgICAgICAgICAgICAgd3JpdGUuc25hcC5nZXRDaGlsZChyZWxhdGl2ZVBhdGgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBvdmVybGFwIGJldHdlZW4gcm9vdCBwYXRoIGFuZCB3cml0ZSBwYXRoLCBpZ25vcmUgd3JpdGVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod3JpdGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAodHJlZVJvb3QuY29udGFpbnMod3JpdGVQYXRoKSkge1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gUGF0aC5yZWxhdGl2ZVBhdGgodHJlZVJvb3QsIHdyaXRlUGF0aCk7XG4gICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZXMoXG4gICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCxcbiAgICAgICAgICAgICAgd3JpdGUuY2hpbGRyZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3cml0ZVBhdGguY29udGFpbnModHJlZVJvb3QpKSB7XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBQYXRoLnJlbGF0aXZlUGF0aCh3cml0ZVBhdGgsIHRyZWVSb290KTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlLmFkZFdyaXRlcyhcbiAgICAgICAgICAgICAgICBQYXRoLkVtcHR5LFxuICAgICAgICAgICAgICAgIHdyaXRlLmNoaWxkcmVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNhZmVHZXQod3JpdGUuY2hpbGRyZW4sIHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpKTtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgZXhpc3RzIGEgY2hpbGQgaW4gdGhpcyBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgcm9vdCBwYXRoXG4gICAgICAgICAgICAgICAgY29uc3QgZGVlcE5vZGUgPSBjaGlsZC5nZXRDaGlsZChyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSk7XG4gICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGUuYWRkV3JpdGUoUGF0aC5FbXB0eSwgZGVlcE5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG92ZXJsYXAgYmV0d2VlbiByb290IHBhdGggYW5kIHdyaXRlIHBhdGgsIGlnbm9yZSB3cml0ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignV3JpdGVSZWNvcmQgc2hvdWxkIGhhdmUgLnNuYXAgb3IgLmNoaWxkcmVuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIFdyaXRlVHJlZVJlZiB3cmFwcyBhIFdyaXRlVHJlZSBhbmQgYSBwYXRoLCBmb3IgY29udmVuaWVudCBhY2Nlc3MgdG8gYSBwYXJ0aWN1bGFyIHN1YnRyZWUuICBBbGwgb2YgdGhlIG1ldGhvZHNcbiAqIGp1c3QgcHJveHkgdG8gdGhlIHVuZGVybHlpbmcgV3JpdGVUcmVlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgV3JpdGVUcmVlUmVmIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoaXMgcGFydGljdWxhciB3cml0ZSB0cmVlIHJlZi4gVXNlZCBmb3IgY2FsbGluZyBtZXRob2RzIG9uIHdyaXRlVHJlZV8gd2hpbGUgZXhwb3NpbmcgYSBzaW1wbGVyXG4gICAqIGludGVyZmFjZSB0byBjYWxsZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7IVBhdGh9XG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdFxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSB0cmVlUGF0aF86IFBhdGg7XG5cbiAgLyoqXG4gICAqICogQSByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCB0cmVlIG9mIHdyaXRlIGRhdGEuIEFsbCBtZXRob2RzIGFyZSBwYXNzLXRocm91Z2ggdG8gdGhlIHRyZWUsIGJ1dCB3aXRoIHRoZSBhcHByb3ByaWF0ZVxuICAgKiBwYXRoIHByZWZpeGVkLlxuICAgKlxuICAgKiBUaGlzIGxldHMgdXMgbWFrZSBjaGVhcCByZWZlcmVuY2VzIHRvIHBvaW50cyBpbiB0aGUgdHJlZSBmb3Igc3luYyBwb2ludHMgd2l0aG91dCBoYXZpbmcgdG8gY29weSBhbmQgbWFpbnRhaW4gYWxsIG9mXG4gICAqIHRoZSBkYXRhLlxuICAgKlxuICAgKiBAdHlwZSB7IVdyaXRlVHJlZX1cbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0XG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHdyaXRlVHJlZV86IFdyaXRlVHJlZTtcblxuICAvKipcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0geyFXcml0ZVRyZWV9IHdyaXRlVHJlZVxuICAgKi9cbiAgY29uc3RydWN0b3IocGF0aDogUGF0aCwgd3JpdGVUcmVlOiBXcml0ZVRyZWUpIHtcbiAgICB0aGlzLnRyZWVQYXRoXyA9IHBhdGg7XG4gICAgdGhpcy53cml0ZVRyZWVfID0gd3JpdGVUcmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHBvc3NpYmxlLCByZXR1cm5zIGEgY29tcGxldGUgZXZlbnQgY2FjaGUsIHVzaW5nIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGlmIHBvc3NpYmxlLiBJbiBhZGRpdGlvbiwgY2FuIGJlIHVzZWRcbiAgICogdG8gZ2V0IGEgY2FjaGUgdGhhdCBpbmNsdWRlcyBoaWRkZW4gd3JpdGVzLCBhbmQgZXhjbHVkZXMgYXJiaXRyYXJ5IHdyaXRlcy4gTm90ZSB0aGF0IGN1c3RvbWl6aW5nIHRoZSByZXR1cm5lZCBub2RlXG4gICAqIGNhbiBsZWFkIHRvIGEgbW9yZSBleHBlbnNpdmUgY2FsY3VsYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyQ2FjaGVcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IHdyaXRlSWRzVG9FeGNsdWRlIE9wdGlvbmFsIHdyaXRlcyB0byBleGNsdWRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbmNsdWRlSGlkZGVuV3JpdGVzIERlZmF1bHRzIHRvIGZhbHNlLCB3aGV0aGVyIG9yIG5vdCB0byBsYXllciBvbiB3cml0ZXMgd2l0aCB2aXNpYmxlIHNldCB0byBmYWxzZVxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIGNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUoXG4gICAgY29tcGxldGVTZXJ2ZXJDYWNoZTogTm9kZSB8IG51bGwsXG4gICAgd3JpdGVJZHNUb0V4Y2x1ZGU/OiBudW1iZXJbXSxcbiAgICBpbmNsdWRlSGlkZGVuV3JpdGVzPzogYm9vbGVhblxuICApOiBOb2RlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlXy5jYWxjQ29tcGxldGVFdmVudENhY2hlKFxuICAgICAgdGhpcy50cmVlUGF0aF8sXG4gICAgICBjb21wbGV0ZVNlcnZlckNhY2hlLFxuICAgICAgd3JpdGVJZHNUb0V4Y2x1ZGUsXG4gICAgICBpbmNsdWRlSGlkZGVuV3JpdGVzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBwb3NzaWJsZSwgcmV0dXJucyBhIGNoaWxkcmVuIG5vZGUgY29udGFpbmluZyBhbGwgb2YgdGhlIGNvbXBsZXRlIGNoaWxkcmVuIHdlIGhhdmUgZGF0YSBmb3IuIFRoZSByZXR1cm5lZCBkYXRhIGlzIGFcbiAgICogbWl4IG9mIHRoZSBnaXZlbiBzZXJ2ZXIgZGF0YSBhbmQgd3JpdGUgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHs/Q2hpbGRyZW5Ob2RlfSBjb21wbGV0ZVNlcnZlckNoaWxkcmVuXG4gICAqIEByZXR1cm4geyFDaGlsZHJlbk5vZGV9XG4gICAqL1xuICBjYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKFxuICAgIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW46IENoaWxkcmVuTm9kZSB8IG51bGxcbiAgKTogQ2hpbGRyZW5Ob2RlIHtcbiAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLmNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4oXG4gICAgICB0aGlzLnRyZWVQYXRoXyxcbiAgICAgIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW5cbiAgICApIGFzIENoaWxkcmVuTm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGF0IGVpdGhlciB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBoYXMgdXBkYXRlZCBvciB0aGUgb3V0c3RhbmRpbmcgd3JpdGVzIGhhdmUgdXBkYXRlZCwgZGV0ZXJtaW5lIHdoYXQsXG4gICAqIGlmIGFueXRoaW5nLCBuZWVkcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBldmVudCBjYWNoZS5cbiAgICpcbiAgICogUG9zc2liaWxpdGllczpcbiAgICpcbiAgICogMS4gTm8gd3JpdGVzIGFyZSBzaGFkb3dpbmcuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkLCB0aGUgc25hcCB0byBiZSBhcHBsaWVkIGNvbWVzIGZyb20gdGhlIHNlcnZlciBkYXRhXG4gICAqXG4gICAqIDIuIFNvbWUgd3JpdGUgaXMgY29tcGxldGVseSBzaGFkb3dpbmcuIE5vIGV2ZW50cyB0byBiZSByYWlzZWRcbiAgICpcbiAgICogMy4gSXMgcGFydGlhbGx5IHNoYWRvd2VkLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZFxuICAgKlxuICAgKiBFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3QsIHRoaXMgaXMgdmFsaWRhdGVkIHZpYSBhbiBhc3NlcnRcbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0gez9Ob2RlfSBleGlzdGluZ0V2ZW50U25hcFxuICAgKiBAcGFyYW0gez9Ob2RlfSBleGlzdGluZ1NlcnZlclNuYXBcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBjYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKFxuICAgIHBhdGg6IFBhdGgsXG4gICAgZXhpc3RpbmdFdmVudFNuYXA6IE5vZGUgfCBudWxsLFxuICAgIGV4aXN0aW5nU2VydmVyU25hcDogTm9kZSB8IG51bGxcbiAgKTogTm9kZSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV8uY2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZShcbiAgICAgIHRoaXMudHJlZVBhdGhfLFxuICAgICAgcGF0aCxcbiAgICAgIGV4aXN0aW5nRXZlbnRTbmFwLFxuICAgICAgZXhpc3RpbmdTZXJ2ZXJTbmFwXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9kZSBpZiB0aGVyZSBpcyBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBmb3IgdGhpcyBwYXRoLiBNb3JlIHNwZWNpZmljYWxseSwgaWYgdGhlcmUgaXMgYSB3cml0ZSBhdFxuICAgKiBhIGhpZ2hlciBwYXRoLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBjaGlsZCBvZiB0aGF0IHdyaXRlIHJlbGF0aXZlIHRvIHRoZSB3cml0ZSBhbmQgdGhpcyBwYXRoLlxuICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gd3JpdGUgYXQgdGhpcyBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgc2hhZG93aW5nV3JpdGUocGF0aDogUGF0aCk6IE5vZGUgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLnNoYWRvd2luZ1dyaXRlKHRoaXMudHJlZVBhdGhfLmNoaWxkKHBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdoZW4gcHJvY2Vzc2luZyBjaGlsZCByZW1vdmUgZXZlbnRzIG9uIGEgcXVlcnkuIElmIHdlIGNhbiwgd2UgcHVsbCBpbiBjaGlsZHJlbiB0aGF0IHdlcmUgb3V0c2lkZVxuICAgKiB0aGUgd2luZG93LCBidXQgbWF5IG5vdyBiZSBpbiB0aGUgd2luZG93XG4gICAqXG4gICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyRGF0YVxuICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IHN0YXJ0UG9zdFxuICAgKiBAcGFyYW0geyFudW1iZXJ9IGNvdW50XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZVxuICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhcbiAgICogQHJldHVybiB7IUFycmF5LjwhTmFtZWROb2RlPn1cbiAgICovXG4gIGNhbGNJbmRleGVkU2xpY2UoXG4gICAgY29tcGxldGVTZXJ2ZXJEYXRhOiBOb2RlIHwgbnVsbCxcbiAgICBzdGFydFBvc3Q6IE5hbWVkTm9kZSxcbiAgICBjb3VudDogbnVtYmVyLFxuICAgIHJldmVyc2U6IGJvb2xlYW4sXG4gICAgaW5kZXg6IEluZGV4XG4gICk6IE5hbWVkTm9kZVtdIHtcbiAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLmNhbGNJbmRleGVkU2xpY2UoXG4gICAgICB0aGlzLnRyZWVQYXRoXyxcbiAgICAgIGNvbXBsZXRlU2VydmVyRGF0YSxcbiAgICAgIHN0YXJ0UG9zdCxcbiAgICAgIGNvdW50LFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIGluZGV4XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cbiAgICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY2hpbGRLZXlcbiAgICogQHBhcmFtIHshQ2FjaGVOb2RlfSBleGlzdGluZ1NlcnZlckNhY2hlXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgY2FsY0NvbXBsZXRlQ2hpbGQoXG4gICAgY2hpbGRLZXk6IHN0cmluZyxcbiAgICBleGlzdGluZ1NlcnZlckNhY2hlOiBDYWNoZU5vZGVcbiAgKTogTm9kZSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV8uY2FsY0NvbXBsZXRlQ2hpbGQoXG4gICAgICB0aGlzLnRyZWVQYXRoXyxcbiAgICAgIGNoaWxkS2V5LFxuICAgICAgZXhpc3RpbmdTZXJ2ZXJDYWNoZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgV3JpdGVUcmVlUmVmIGZvciBhIGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGROYW1lXG4gICAqIEByZXR1cm4geyFXcml0ZVRyZWVSZWZ9XG4gICAqL1xuICBjaGlsZChjaGlsZE5hbWU6IHN0cmluZyk6IFdyaXRlVHJlZVJlZiB7XG4gICAgcmV0dXJuIG5ldyBXcml0ZVRyZWVSZWYodGhpcy50cmVlUGF0aF8uY2hpbGQoY2hpbGROYW1lKSwgdGhpcy53cml0ZVRyZWVfKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGVycm9yRm9yU2VydmVyQ29kZSB9IGZyb20gJy4vdXRpbC91dGlsJztcbmltcG9ydCB7IEFja1VzZXJXcml0ZSB9IGZyb20gJy4vb3BlcmF0aW9uL0Fja1VzZXJXcml0ZSc7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuL3NuYXAvQ2hpbGRyZW5Ob2RlJztcbmltcG9ydCB7IGZvckVhY2gsIHNhZmVHZXQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBJbW11dGFibGVUcmVlIH0gZnJvbSAnLi91dGlsL0ltbXV0YWJsZVRyZWUnO1xuaW1wb3J0IHsgTGlzdGVuQ29tcGxldGUgfSBmcm9tICcuL29wZXJhdGlvbi9MaXN0ZW5Db21wbGV0ZSc7XG5pbXBvcnQgeyBNZXJnZSB9IGZyb20gJy4vb3BlcmF0aW9uL01lcmdlJztcbmltcG9ydCB7IE9wZXJhdGlvbiwgT3BlcmF0aW9uU291cmNlIH0gZnJvbSAnLi9vcGVyYXRpb24vT3BlcmF0aW9uJztcbmltcG9ydCB7IE92ZXJ3cml0ZSB9IGZyb20gJy4vb3BlcmF0aW9uL092ZXJ3cml0ZSc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgU3luY1BvaW50IH0gZnJvbSAnLi9TeW5jUG9pbnQnO1xuaW1wb3J0IHsgV3JpdGVUcmVlLCBXcml0ZVRyZWVSZWYgfSBmcm9tICcuL1dyaXRlVHJlZSc7XG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gJy4uL2FwaS9RdWVyeSc7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9zbmFwL05vZGUnO1xuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL3ZpZXcvRXZlbnQnO1xuaW1wb3J0IHsgRXZlbnRSZWdpc3RyYXRpb24gfSBmcm9tICcuL3ZpZXcvRXZlbnRSZWdpc3RyYXRpb24nO1xuaW1wb3J0IHsgVmlldyB9IGZyb20gJy4vdmlldy9WaWV3JztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBzdGFydExpc3RlbmluZzogZnVuY3Rpb24oXG4gKiAgICAgIVF1ZXJ5LFxuICogICAgID9udW1iZXIsXG4gKiAgICAgZnVuY3Rpb24oKTpzdHJpbmcsXG4gKiAgICAgZnVuY3Rpb24oIXN0cmluZywgKik6IUFycmF5LjwhRXZlbnQ+XG4gKiAgICk6IUFycmF5LjwhRXZlbnQ+LFxuICpcbiAqICAgc3RvcExpc3RlbmluZzogZnVuY3Rpb24oIVF1ZXJ5LCA/bnVtYmVyKVxuICogfX1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0ZW5Qcm92aWRlciB7XG4gIHN0YXJ0TGlzdGVuaW5nKFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICB0YWc6IG51bWJlciB8IG51bGwsXG4gICAgaGFzaEZuOiAoKSA9PiBzdHJpbmcsXG4gICAgb25Db21wbGV0ZTogKGE6IHN0cmluZywgYj86IGFueSkgPT4gRXZlbnRbXVxuICApOiBFdmVudFtdO1xuXG4gIHN0b3BMaXN0ZW5pbmcoYTogUXVlcnksIGI6IG51bWJlciB8IG51bGwpOiB2b2lkO1xufVxuXG4vKipcbiAqIFN5bmNUcmVlIGlzIHRoZSBjZW50cmFsIGNsYXNzIGZvciBtYW5hZ2luZyBldmVudCBjYWxsYmFjayByZWdpc3RyYXRpb24sIGRhdGEgY2FjaGluZywgdmlld3NcbiAqIChxdWVyeSBwcm9jZXNzaW5nKSwgYW5kIGV2ZW50IGdlbmVyYXRpb24uICBUaGVyZSBhcmUgdHlwaWNhbGx5IHR3byBTeW5jVHJlZSBpbnN0YW5jZXMgZm9yXG4gKiBlYWNoIFJlcG8sIG9uZSBmb3IgdGhlIG5vcm1hbCBGaXJlYmFzZSBkYXRhLCBhbmQgb25lIGZvciB0aGUgLmluZm8gZGF0YS5cbiAqXG4gKiBJdCBoYXMgYSBudW1iZXIgb2YgcmVzcG9uc2liaWxpdGllcywgaW5jbHVkaW5nOlxuICogIC0gVHJhY2tpbmcgYWxsIHVzZXIgZXZlbnQgY2FsbGJhY2tzIChyZWdpc3RlcmVkIHZpYSBhZGRFdmVudFJlZ2lzdHJhdGlvbigpIGFuZCByZW1vdmVFdmVudFJlZ2lzdHJhdGlvbigpKS5cbiAqICAtIEFwcGx5aW5nIGFuZCBjYWNoaW5nIGRhdGEgY2hhbmdlcyBmb3IgdXNlciBzZXQoKSwgdHJhbnNhY3Rpb24oKSwgYW5kIHVwZGF0ZSgpIGNhbGxzXG4gKiAgICAoYXBwbHlVc2VyT3ZlcndyaXRlKCksIGFwcGx5VXNlck1lcmdlKCkpLlxuICogIC0gQXBwbHlpbmcgYW5kIGNhY2hpbmcgZGF0YSBjaGFuZ2VzIGZvciBzZXJ2ZXIgZGF0YSBjaGFuZ2VzIChhcHBseVNlcnZlck92ZXJ3cml0ZSgpLFxuICogICAgYXBwbHlTZXJ2ZXJNZXJnZSgpKS5cbiAqICAtIEdlbmVyYXRpbmcgdXNlci1mYWNpbmcgZXZlbnRzIGZvciBzZXJ2ZXIgYW5kIHVzZXIgY2hhbmdlcyAoYWxsIG9mIHRoZSBhcHBseSogbWV0aG9kc1xuICogICAgcmV0dXJuIHRoZSBzZXQgb2YgZXZlbnRzIHRoYXQgbmVlZCB0byBiZSByYWlzZWQgYXMgYSByZXN1bHQpLlxuICogIC0gTWFpbnRhaW5pbmcgdGhlIGFwcHJvcHJpYXRlIHNldCBvZiBzZXJ2ZXIgbGlzdGVucyB0byBlbnN1cmUgd2UgYXJlIGFsd2F5cyBzdWJzY3JpYmVkXG4gKiAgICB0byB0aGUgY29ycmVjdCBzZXQgb2YgcGF0aHMgYW5kIHF1ZXJpZXMgdG8gc2F0aXNmeSB0aGUgY3VycmVudCBzZXQgb2YgdXNlciBldmVudFxuICogICAgY2FsbGJhY2tzIChsaXN0ZW5zIGFyZSBzdGFydGVkL3N0b3BwZWQgdXNpbmcgdGhlIHByb3ZpZGVkIGxpc3RlblByb3ZpZGVyKS5cbiAqXG4gKiBOT1RFOiBBbHRob3VnaCBTeW5jVHJlZSB0cmFja3MgZXZlbnQgY2FsbGJhY2tzIGFuZCBjYWxjdWxhdGVzIGV2ZW50cyB0byByYWlzZSwgdGhlIGFjdHVhbFxuICogZXZlbnRzIGFyZSByZXR1cm5lZCB0byB0aGUgY2FsbGVyIHJhdGhlciB0aGFuIHJhaXNlZCBzeW5jaHJvbm91c2x5LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgU3luY1RyZWUge1xuICAvKipcbiAgICogVHJlZSBvZiBTeW5jUG9pbnRzLiAgVGhlcmUncyBhIFN5bmNQb2ludCBhdCBhbnkgbG9jYXRpb24gdGhhdCBoYXMgMSBvciBtb3JlIHZpZXdzLlxuICAgKiBAdHlwZSB7IUltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzeW5jUG9pbnRUcmVlXzogSW1tdXRhYmxlVHJlZTxTeW5jUG9pbnQ+ID0gSW1tdXRhYmxlVHJlZS5FbXB0eTtcblxuICAvKipcbiAgICogQSB0cmVlIG9mIGFsbCBwZW5kaW5nIHVzZXIgd3JpdGVzICh1c2VyLWluaXRpYXRlZCBzZXQoKSdzLCB0cmFuc2FjdGlvbigpJ3MsIHVwZGF0ZSgpJ3MsIGV0Yy4pLlxuICAgKiBAdHlwZSB7IVdyaXRlVHJlZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcGVuZGluZ1dyaXRlVHJlZV8gPSBuZXcgV3JpdGVUcmVlKCk7XG5cbiAgcHJpdmF0ZSB0YWdUb1F1ZXJ5TWFwXzogeyBbazogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgcHJpdmF0ZSBxdWVyeVRvVGFnTWFwXzogeyBbazogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcblxuICAvKipcbiAgICogQHBhcmFtIHshTGlzdGVuUHJvdmlkZXJ9IGxpc3RlblByb3ZpZGVyXyBVc2VkIGJ5IFN5bmNUcmVlIHRvIHN0YXJ0IC8gc3RvcCBsaXN0ZW5pbmdcbiAgICogICB0byBzZXJ2ZXIgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbGlzdGVuUHJvdmlkZXJfOiBMaXN0ZW5Qcm92aWRlcikge31cblxuICAvKipcbiAgICogQXBwbHkgdGhlIGRhdGEgY2hhbmdlcyBmb3IgYSB1c2VyLWdlbmVyYXRlZCBzZXQoKSBvciB0cmFuc2FjdGlvbigpIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHshTm9kZX0gbmV3RGF0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gd3JpdGVJZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB2aXNpYmxlXG4gICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgKi9cbiAgYXBwbHlVc2VyT3ZlcndyaXRlKFxuICAgIHBhdGg6IFBhdGgsXG4gICAgbmV3RGF0YTogTm9kZSxcbiAgICB3cml0ZUlkOiBudW1iZXIsXG4gICAgdmlzaWJsZT86IGJvb2xlYW5cbiAgKTogRXZlbnRbXSB7XG4gICAgLy8gUmVjb3JkIHBlbmRpbmcgd3JpdGUuXG4gICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5hZGRPdmVyd3JpdGUocGF0aCwgbmV3RGF0YSwgd3JpdGVJZCwgdmlzaWJsZSk7XG5cbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKFxuICAgICAgICBuZXcgT3ZlcndyaXRlKE9wZXJhdGlvblNvdXJjZS5Vc2VyLCBwYXRoLCBuZXdEYXRhKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgdGhlIGRhdGEgZnJvbSBhIHVzZXItZ2VuZXJhdGVkIHVwZGF0ZSgpIGNhbGxcbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgIU5vZGU+fSBjaGFuZ2VkQ2hpbGRyZW5cbiAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgKi9cbiAgYXBwbHlVc2VyTWVyZ2UoXG4gICAgcGF0aDogUGF0aCxcbiAgICBjaGFuZ2VkQ2hpbGRyZW46IHsgW2s6IHN0cmluZ106IE5vZGUgfSxcbiAgICB3cml0ZUlkOiBudW1iZXJcbiAgKTogRXZlbnRbXSB7XG4gICAgLy8gUmVjb3JkIHBlbmRpbmcgbWVyZ2UuXG4gICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5hZGRNZXJnZShwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xuXG4gICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKFxuICAgICAgbmV3IE1lcmdlKE9wZXJhdGlvblNvdXJjZS5Vc2VyLCBwYXRoLCBjaGFuZ2VUcmVlKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWNrbm93bGVkZ2UgYSBwZW5kaW5nIHVzZXIgd3JpdGUgdGhhdCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYXBwbHlVc2VyT3ZlcndyaXRlKCkgb3IgYXBwbHlVc2VyTWVyZ2UoKS5cbiAgICpcbiAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJldmVydCBUcnVlIGlmIHRoZSBnaXZlbiB3cml0ZSBmYWlsZWQgYW5kIG5lZWRzIHRvIGJlIHJldmVydGVkXG4gICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgKi9cbiAgYWNrVXNlcldyaXRlKHdyaXRlSWQ6IG51bWJlciwgcmV2ZXJ0OiBib29sZWFuID0gZmFsc2UpIHtcbiAgICBjb25zdCB3cml0ZSA9IHRoaXMucGVuZGluZ1dyaXRlVHJlZV8uZ2V0V3JpdGUod3JpdGVJZCk7XG4gICAgY29uc3QgbmVlZFRvUmVldmFsdWF0ZSA9IHRoaXMucGVuZGluZ1dyaXRlVHJlZV8ucmVtb3ZlV3JpdGUod3JpdGVJZCk7XG4gICAgaWYgKCFuZWVkVG9SZWV2YWx1YXRlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBhZmZlY3RlZFRyZWUgPSBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgaWYgKHdyaXRlLnNuYXAgIT0gbnVsbCkge1xuICAgICAgICAvLyBvdmVyd3JpdGVcbiAgICAgICAgYWZmZWN0ZWRUcmVlID0gYWZmZWN0ZWRUcmVlLnNldChQYXRoLkVtcHR5LCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckVhY2god3JpdGUuY2hpbGRyZW4sIGZ1bmN0aW9uKHBhdGhTdHJpbmc6IHN0cmluZywgbm9kZTogTm9kZSkge1xuICAgICAgICAgIGFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZS5zZXQobmV3IFBhdGgocGF0aFN0cmluZyksIG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhcbiAgICAgICAgbmV3IEFja1VzZXJXcml0ZSh3cml0ZS5wYXRoLCBhZmZlY3RlZFRyZWUsIHJldmVydClcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLi5cbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0geyFOb2RlfSBuZXdEYXRhXG4gICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgKi9cbiAgYXBwbHlTZXJ2ZXJPdmVyd3JpdGUocGF0aDogUGF0aCwgbmV3RGF0YTogTm9kZSk6IEV2ZW50W10ge1xuICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhcbiAgICAgIG5ldyBPdmVyd3JpdGUoT3BlcmF0aW9uU291cmNlLlNlcnZlciwgcGF0aCwgbmV3RGF0YSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhTm9kZT59IGNoYW5nZWRDaGlsZHJlblxuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICovXG4gIGFwcGx5U2VydmVyTWVyZ2UoXG4gICAgcGF0aDogUGF0aCxcbiAgICBjaGFuZ2VkQ2hpbGRyZW46IHsgW2s6IHN0cmluZ106IE5vZGUgfVxuICApOiBFdmVudFtdIHtcbiAgICBjb25zdCBjaGFuZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oXG4gICAgICBuZXcgTWVyZ2UoT3BlcmF0aW9uU291cmNlLlNlcnZlciwgcGF0aCwgY2hhbmdlVHJlZSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgbGlzdGVuIGNvbXBsZXRlIGZvciBhIHF1ZXJ5XG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAqL1xuICBhcHBseUxpc3RlbkNvbXBsZXRlKHBhdGg6IFBhdGgpOiBFdmVudFtdIHtcbiAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oXG4gICAgICBuZXcgTGlzdGVuQ29tcGxldGUoT3BlcmF0aW9uU291cmNlLlNlcnZlciwgcGF0aClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHshTm9kZX0gc25hcFxuICAgKiBAcGFyYW0geyFudW1iZXJ9IHRhZ1xuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICovXG4gIGFwcGx5VGFnZ2VkUXVlcnlPdmVyd3JpdGUocGF0aDogUGF0aCwgc25hcDogTm9kZSwgdGFnOiBudW1iZXIpOiBFdmVudFtdIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IHRoaXMucXVlcnlLZXlGb3JUYWdfKHRhZyk7XG4gICAgaWYgKHF1ZXJ5S2V5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHIgPSBTeW5jVHJlZS5wYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XG4gICAgICBjb25zdCBxdWVyeVBhdGggPSByLnBhdGgsXG4gICAgICAgIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XG4gICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBQYXRoLnJlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xuICAgICAgY29uc3Qgb3AgPSBuZXcgT3ZlcndyaXRlKFxuICAgICAgICBPcGVyYXRpb25Tb3VyY2UuZm9yU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksXG4gICAgICAgIHJlbGF0aXZlUGF0aCxcbiAgICAgICAgc25hcFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhxdWVyeVBhdGgsIG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUXVlcnkgbXVzdCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IHNlcnZlciBkYXRhIHRvIGJlIG1lcmdlZCBpbiBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gdGFnXG4gICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgKi9cbiAgYXBwbHlUYWdnZWRRdWVyeU1lcmdlKFxuICAgIHBhdGg6IFBhdGgsXG4gICAgY2hhbmdlZENoaWxkcmVuOiB7IFtrOiBzdHJpbmddOiBOb2RlIH0sXG4gICAgdGFnOiBudW1iZXJcbiAgKTogRXZlbnRbXSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSB0aGlzLnF1ZXJ5S2V5Rm9yVGFnXyh0YWcpO1xuICAgIGlmIChxdWVyeUtleSkge1xuICAgICAgY29uc3QgciA9IFN5bmNUcmVlLnBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcbiAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHIucGF0aCxcbiAgICAgICAgcXVlcnlJZCA9IHIucXVlcnlJZDtcbiAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IFBhdGgucmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XG4gICAgICBjb25zdCBjaGFuZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XG4gICAgICBjb25zdCBvcCA9IG5ldyBNZXJnZShcbiAgICAgICAgT3BlcmF0aW9uU291cmNlLmZvclNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLFxuICAgICAgICByZWxhdGl2ZVBhdGgsXG4gICAgICAgIGNoYW5nZVRyZWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVRhZ2dlZE9wZXJhdGlvbl8ocXVlcnlQYXRoLCBvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgcmVtb3ZlZCB0aGUgcXVlcnkuIE5vIGJpZyBkZWFsLCBpZ25vcmUgdGhlIHVwZGF0ZVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIGxpc3RlbiBjb21wbGV0ZSBmb3IgYSB0YWdnZWQgcXVlcnlcbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0geyFudW1iZXJ9IHRhZ1xuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICovXG4gIGFwcGx5VGFnZ2VkTGlzdGVuQ29tcGxldGUocGF0aDogUGF0aCwgdGFnOiBudW1iZXIpOiBFdmVudFtdIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IHRoaXMucXVlcnlLZXlGb3JUYWdfKHRhZyk7XG4gICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICBjb25zdCByID0gU3luY1RyZWUucGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpO1xuICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLFxuICAgICAgICBxdWVyeUlkID0gci5xdWVyeUlkO1xuICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gUGF0aC5yZWxhdGl2ZVBhdGgocXVlcnlQYXRoLCBwYXRoKTtcbiAgICAgIGNvbnN0IG9wID0gbmV3IExpc3RlbkNvbXBsZXRlKFxuICAgICAgICBPcGVyYXRpb25Tb3VyY2UuZm9yU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksXG4gICAgICAgIHJlbGF0aXZlUGF0aFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhxdWVyeVBhdGgsIG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UndmUgYWxyZWFkeSByZW1vdmVkIHRoZSBxdWVyeS4gTm8gYmlnIGRlYWwsIGlnbm9yZSB0aGUgdXBkYXRlXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBjYWxsYmFjayBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS5cbiAgICpcbiAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAqIEBwYXJhbSB7IUV2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvblxuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICovXG4gIGFkZEV2ZW50UmVnaXN0cmF0aW9uKFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICBldmVudFJlZ2lzdHJhdGlvbjogRXZlbnRSZWdpc3RyYXRpb25cbiAgKTogRXZlbnRbXSB7XG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5LnBhdGg7XG5cbiAgICBsZXQgc2VydmVyQ2FjaGU6IE5vZGUgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ID0gZmFsc2U7XG4gICAgLy8gQW55IGNvdmVyaW5nIHdyaXRlcyB3aWxsIG5lY2Vzc2FyaWx5IGJlIGF0IHRoZSByb290LCBzbyByZWFsbHkgYWxsIHdlIG5lZWQgdG8gZmluZCBpcyB0aGUgc2VydmVyIGNhY2hlLlxuICAgIC8vIENvbnNpZGVyIG9wdGltaXppbmcgdGhpcyBvbmNlIHRoZXJlJ3MgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiB3aGF0IGFjdHVhbCBiZWhhdmlvciB3aWxsIGJlLlxuICAgIHRoaXMuc3luY1BvaW50VHJlZV8uZm9yZWFjaE9uUGF0aChwYXRoLCBmdW5jdGlvbihwYXRoVG9TeW5jUG9pbnQsIHNwKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBQYXRoLnJlbGF0aXZlUGF0aChwYXRoVG9TeW5jUG9pbnQsIHBhdGgpO1xuICAgICAgc2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZSB8fCBzcC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKHJlbGF0aXZlUGF0aCk7XG4gICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxuICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgfHwgc3AuaGFzQ29tcGxldGVWaWV3KCk7XG4gICAgfSk7XG4gICAgbGV0IHN5bmNQb2ludCA9IHRoaXMuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xuICAgIGlmICghc3luY1BvaW50KSB7XG4gICAgICBzeW5jUG9pbnQgPSBuZXcgU3luY1BvaW50KCk7XG4gICAgICB0aGlzLnN5bmNQb2ludFRyZWVfID0gdGhpcy5zeW5jUG9pbnRUcmVlXy5zZXQocGF0aCwgc3luY1BvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ID1cbiAgICAgICAgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3IHx8IHN5bmNQb2ludC5oYXNDb21wbGV0ZVZpZXcoKTtcbiAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUgfHwgc3luY1BvaW50LmdldENvbXBsZXRlU2VydmVyQ2FjaGUoUGF0aC5FbXB0eSk7XG4gICAgfVxuXG4gICAgbGV0IHNlcnZlckNhY2hlQ29tcGxldGU7XG4gICAgaWYgKHNlcnZlckNhY2hlICE9IG51bGwpIHtcbiAgICAgIHNlcnZlckNhY2hlQ29tcGxldGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJ2ZXJDYWNoZUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICBzZXJ2ZXJDYWNoZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgY29uc3Qgc3VidHJlZSA9IHRoaXMuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcbiAgICAgIHN1YnRyZWUuZm9yZWFjaENoaWxkKGZ1bmN0aW9uKGNoaWxkTmFtZSwgY2hpbGRTeW5jUG9pbnQpIHtcbiAgICAgICAgY29uc3QgY29tcGxldGVDYWNoZSA9IGNoaWxkU3luY1BvaW50LmdldENvbXBsZXRlU2VydmVyQ2FjaGUoUGF0aC5FbXB0eSk7XG4gICAgICAgIGlmIChjb21wbGV0ZUNhY2hlKSB7XG4gICAgICAgICAgc2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChcbiAgICAgICAgICAgIGNoaWxkTmFtZSxcbiAgICAgICAgICAgIGNvbXBsZXRlQ2FjaGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB2aWV3QWxyZWFkeUV4aXN0cyA9IHN5bmNQb2ludC52aWV3RXhpc3RzRm9yUXVlcnkocXVlcnkpO1xuICAgIGlmICghdmlld0FscmVhZHlFeGlzdHMgJiYgIXF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gdHJhY2sgYSB0YWcgZm9yIHRoaXMgcXVlcnlcbiAgICAgIGNvbnN0IHF1ZXJ5S2V5ID0gU3luY1RyZWUubWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XG4gICAgICBhc3NlcnQoXG4gICAgICAgICEocXVlcnlLZXkgaW4gdGhpcy5xdWVyeVRvVGFnTWFwXyksXG4gICAgICAgICdWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZydcbiAgICAgICk7XG4gICAgICBjb25zdCB0YWcgPSBTeW5jVHJlZS5nZXROZXh0UXVlcnlUYWdfKCk7XG4gICAgICB0aGlzLnF1ZXJ5VG9UYWdNYXBfW3F1ZXJ5S2V5XSA9IHRhZztcbiAgICAgIC8vIENvZXJjZSB0byBzdHJpbmcgdG8gYXZvaWQgc3BhcnNlIGFycmF5cy5cbiAgICAgIHRoaXMudGFnVG9RdWVyeU1hcF9bJ18nICsgdGFnXSA9IHF1ZXJ5S2V5O1xuICAgIH1cbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHRoaXMucGVuZGluZ1dyaXRlVHJlZV8uY2hpbGRXcml0ZXMocGF0aCk7XG4gICAgbGV0IGV2ZW50cyA9IHN5bmNQb2ludC5hZGRFdmVudFJlZ2lzdHJhdGlvbihcbiAgICAgIHF1ZXJ5LFxuICAgICAgZXZlbnRSZWdpc3RyYXRpb24sXG4gICAgICB3cml0ZXNDYWNoZSxcbiAgICAgIHNlcnZlckNhY2hlLFxuICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZVxuICAgICk7XG4gICAgaWYgKCF2aWV3QWxyZWFkeUV4aXN0cyAmJiAhZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3KSB7XG4gICAgICBjb25zdCB2aWV3IC8qKiBAdHlwZSAhVmlldyAqLyA9IHN5bmNQb2ludC52aWV3Rm9yUXVlcnkocXVlcnkpO1xuICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdCh0aGlzLnNldHVwTGlzdGVuZXJfKHF1ZXJ5LCB2aWV3KSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGNhbGxiYWNrKHMpLlxuICAgKlxuICAgKiBJZiBxdWVyeSBpcyB0aGUgZGVmYXVsdCBxdWVyeSwgd2UnbGwgY2hlY2sgYWxsIHF1ZXJpZXMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRSZWdpc3RyYXRpb24uXG4gICAqIElmIGV2ZW50UmVnaXN0cmF0aW9uIGlzIG51bGwsIHdlJ2xsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5L3F1ZXJpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgKiBAcGFyYW0gez9FdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb24gSWYgbnVsbCwgYWxsIGNhbGxiYWNrcyBhcmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtIHtFcnJvcj19IGNhbmNlbEVycm9yIElmIGEgY2FuY2VsRXJyb3IgaXMgcHJvdmlkZWQsIGFwcHJvcHJpYXRlIGNhbmNlbCBldmVudHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBDYW5jZWwgZXZlbnRzLCBpZiBjYW5jZWxFcnJvciB3YXMgcHJvdmlkZWQuXG4gICAqL1xuICByZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihcbiAgICBxdWVyeTogUXVlcnksXG4gICAgZXZlbnRSZWdpc3RyYXRpb246IEV2ZW50UmVnaXN0cmF0aW9uIHwgbnVsbCxcbiAgICBjYW5jZWxFcnJvcj86IEVycm9yXG4gICk6IEV2ZW50W10ge1xuICAgIC8vIEZpbmQgdGhlIHN5bmNQb2ludCBmaXJzdC4gVGhlbiBkZWFsIHdpdGggd2hldGhlciBvciBub3QgaXQgaGFzIG1hdGNoaW5nIGxpc3RlbmVyc1xuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5wYXRoO1xuICAgIGNvbnN0IG1heWJlU3luY1BvaW50ID0gdGhpcy5zeW5jUG9pbnRUcmVlXy5nZXQocGF0aCk7XG4gICAgbGV0IGNhbmNlbEV2ZW50czogRXZlbnRbXSA9IFtdO1xuICAgIC8vIEEgcmVtb3ZhbCBvbiBhIGRlZmF1bHQgcXVlcnkgYWZmZWN0cyBhbGwgcXVlcmllcyBhdCB0aGF0IGxvY2F0aW9uLiBBIHJlbW92YWwgb24gYW4gaW5kZXhlZCBxdWVyeSwgZXZlbiBvbmUgd2l0aG91dFxuICAgIC8vIG90aGVyIHF1ZXJ5IGNvbnN0cmFpbnRzLCBkb2VzICpub3QqIGFmZmVjdCBhbGwgcXVlcmllcyBhdCB0aGF0IGxvY2F0aW9uLiBTbyB0aGlzIGNoZWNrIG11c3QgYmUgZm9yICdkZWZhdWx0JywgYW5kXG4gICAgLy8gbm90IGxvYWRzQWxsRGF0YSgpLlxuICAgIGlmIChcbiAgICAgIG1heWJlU3luY1BvaW50ICYmXG4gICAgICAocXVlcnkucXVlcnlJZGVudGlmaWVyKCkgPT09ICdkZWZhdWx0JyB8fFxuICAgICAgICBtYXliZVN5bmNQb2ludC52aWV3RXhpc3RzRm9yUXVlcnkocXVlcnkpKVxuICAgICkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7e3JlbW92ZWQ6ICFBcnJheS48IVF1ZXJ5PiwgZXZlbnRzOiAhQXJyYXkuPCFFdmVudD59fVxuICAgICAgICovXG4gICAgICBjb25zdCByZW1vdmVkQW5kRXZlbnRzID0gbWF5YmVTeW5jUG9pbnQucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBldmVudFJlZ2lzdHJhdGlvbixcbiAgICAgICAgY2FuY2VsRXJyb3JcbiAgICAgICk7XG4gICAgICBpZiAobWF5YmVTeW5jUG9pbnQuaXNFbXB0eSgpKSB7XG4gICAgICAgIHRoaXMuc3luY1BvaW50VHJlZV8gPSB0aGlzLnN5bmNQb2ludFRyZWVfLnJlbW92ZShwYXRoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbW92ZWQgPSByZW1vdmVkQW5kRXZlbnRzLnJlbW92ZWQ7XG4gICAgICBjYW5jZWxFdmVudHMgPSByZW1vdmVkQW5kRXZlbnRzLmV2ZW50cztcbiAgICAgIC8vIFdlIG1heSBoYXZlIGp1c3QgcmVtb3ZlZCBvbmUgb2YgbWFueSBsaXN0ZW5lcnMgYW5kIGNhbiBzaG9ydC1jaXJjdWl0IHRoaXMgd2hvbGUgcHJvY2Vzc1xuICAgICAgLy8gV2UgbWF5IGFsc28gbm90IGhhdmUgcmVtb3ZlZCBhIGRlZmF1bHQgbGlzdGVuZXIsIGluIHdoaWNoIGNhc2UgYWxsIG9mIHRoZSBkZXNjZW5kYW50IGxpc3RlbmVycyBzaG91bGQgYWxyZWFkeSBiZVxuICAgICAgLy8gcHJvcGVybHkgc2V0IHVwLlxuICAgICAgLy9cbiAgICAgIC8vIFNpbmNlIGluZGV4ZWQgcXVlcmllcyBjYW4gc2hhZG93IGlmIHRoZXkgZG9uJ3QgaGF2ZSBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgY2hlY2sgZm9yIGxvYWRzQWxsRGF0YSgpLCBpbnN0ZWFkIG9mXG4gICAgICAvLyBxdWVyeUlkID09PSAnZGVmYXVsdCdcbiAgICAgIGNvbnN0IHJlbW92aW5nRGVmYXVsdCA9XG4gICAgICAgIC0xICE9PVxuICAgICAgICByZW1vdmVkLmZpbmRJbmRleChmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICAgIHJldHVybiBxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpO1xuICAgICAgICB9KTtcbiAgICAgIGNvbnN0IGNvdmVyZWQgPSB0aGlzLnN5bmNQb2ludFRyZWVfLmZpbmRPblBhdGgocGF0aCwgZnVuY3Rpb24oXG4gICAgICAgIHJlbGF0aXZlUGF0aCxcbiAgICAgICAgcGFyZW50U3luY1BvaW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFN5bmNQb2ludC5oYXNDb21wbGV0ZVZpZXcoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0ICYmICFjb3ZlcmVkKSB7XG4gICAgICAgIGNvbnN0IHN1YnRyZWUgPSB0aGlzLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBwb3RlbnRpYWxseSBjaGlsZCBsaXN0ZW5lcnMuIERldGVybWluZSB3aGF0IGlmIGFueSBsaXN0ZW5zIHdlIG5lZWQgdG8gc2VuZCBiZWZvcmUgZXhlY3V0aW5nIHRoZVxuICAgICAgICAvLyByZW1vdmFsXG4gICAgICAgIGlmICghc3VidHJlZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGZvbGQgb3ZlciBvdXIgc3VidHJlZSBhbmQgY29sbGVjdCB0aGUgbGlzdGVuZXJzIHRvIHNlbmRcbiAgICAgICAgICBjb25zdCBuZXdWaWV3cyA9IHRoaXMuY29sbGVjdERpc3RpbmN0Vmlld3NGb3JTdWJUcmVlXyhzdWJ0cmVlKTtcblxuICAgICAgICAgIC8vIE9rLCB3ZSd2ZSBjb2xsZWN0ZWQgYWxsIHRoZSBsaXN0ZW5zIHdlIG5lZWQuIFNldCB0aGVtIHVwLlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Vmlld3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXdWaWV3c1tpXSxcbiAgICAgICAgICAgICAgbmV3UXVlcnkgPSB2aWV3LmdldFF1ZXJ5KCk7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuY3JlYXRlTGlzdGVuZXJGb3JWaWV3Xyh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKFxuICAgICAgICAgICAgICBTeW5jVHJlZS5xdWVyeUZvckxpc3RlbmluZ18obmV3UXVlcnkpLFxuICAgICAgICAgICAgICB0aGlzLnRhZ0ZvclF1ZXJ5XyhuZXdRdWVyeSksXG4gICAgICAgICAgICAgIGxpc3RlbmVyLmhhc2hGbixcbiAgICAgICAgICAgICAgbGlzdGVuZXIub25Db21wbGV0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBub3RoaW5nIGJlbG93IHVzLCBzbyBub3RoaW5nIHdlIG5lZWQgdG8gc3RhcnQgbGlzdGVuaW5nIG9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIHJlbW92ZWQgYW55dGhpbmcgYW5kIHdlJ3JlIG5vdCBjb3ZlcmVkIGJ5IGEgaGlnaGVyIHVwIGxpc3Rlbiwgd2UgbmVlZCB0byBzdG9wIGxpc3RlbmluZyBvbiB0aGlzIHF1ZXJ5XG4gICAgICAvLyBUaGUgYWJvdmUgYmxvY2sgaGFzIHVzIGNvdmVyZWQgaW4gdGVybXMgb2YgbWFraW5nIHN1cmUgd2UncmUgc2V0IHVwIG9uIGxpc3RlbnMgbG93ZXIgaW4gdGhlIHRyZWUuXG4gICAgICAvLyBBbHNvLCBub3RlIHRoYXQgaWYgd2UgaGF2ZSBhIGNhbmNlbEVycm9yLCBpdCdzIGFscmVhZHkgYmVlbiByZW1vdmVkIGF0IHRoZSBwcm92aWRlciBsZXZlbC5cbiAgICAgIGlmICghY292ZXJlZCAmJiByZW1vdmVkLmxlbmd0aCA+IDAgJiYgIWNhbmNlbEVycm9yKSB7XG4gICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYSBkZWZhdWx0LCB0aGVuIHdlIHdlcmVuJ3QgbGlzdGVuaW5nIG9uIGFueSBvZiB0aGUgb3RoZXIgcXVlcmllcyBoZXJlLiBKdXN0IGNhbmNlbCB0aGUgb25lXG4gICAgICAgIC8vIGRlZmF1bHQuIE90aGVyd2lzZSwgd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggYW5kIGNhbmNlbCBlYWNoIGluZGl2aWR1YWwgcXVlcnlcbiAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCkge1xuICAgICAgICAgIC8vIFdlIGRvbid0IHRhZyBkZWZhdWx0IGxpc3RlbmVyc1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRUYWc6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoXG4gICAgICAgICAgICBTeW5jVHJlZS5xdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpLFxuICAgICAgICAgICAgZGVmYXVsdFRhZ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKChxdWVyeVRvUmVtb3ZlOiBRdWVyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFnVG9SZW1vdmUgPSB0aGlzLnF1ZXJ5VG9UYWdNYXBfW1xuICAgICAgICAgICAgICBTeW5jVHJlZS5tYWtlUXVlcnlLZXlfKHF1ZXJ5VG9SZW1vdmUpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5Qcm92aWRlcl8uc3RvcExpc3RlbmluZyhcbiAgICAgICAgICAgICAgU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9SZW1vdmUpLFxuICAgICAgICAgICAgICB0YWdUb1JlbW92ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTm93LCBjbGVhciBhbGwgb2YgdGhlIHRhZ3Mgd2UncmUgdHJhY2tpbmcgZm9yIHRoZSByZW1vdmVkIGxpc3RlbnNcbiAgICAgIHRoaXMucmVtb3ZlVGFnc18ocmVtb3ZlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vLW9wLCB0aGlzIGxpc3RlbmVyIG11c3QndmUgYmVlbiBhbHJlYWR5IHJlbW92ZWRcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbEV2ZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29tcGxldGUgY2FjaGUsIGlmIHdlIGhhdmUgb25lLCBvZiB0aGUgZGF0YSBhdCBhIHBhcnRpY3VsYXIgcGF0aC4gVGhlIGxvY2F0aW9uIG11c3QgaGF2ZSBhIGxpc3RlbmVyIGFib3ZlXG4gICAqIGl0LCBidXQgYXMgdGhpcyBpcyBvbmx5IHVzZWQgYnkgdHJhbnNhY3Rpb24gY29kZSwgdGhhdCBzaG91bGQgYWx3YXlzIGJlIHRoZSBjYXNlIGFueXdheXMuXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgKmluY2x1ZGUqIGhpZGRlbiB3cml0ZXMgZnJvbSB0cmFuc2FjdGlvbiB3aXRoIGFwcGx5TG9jYWxseSBzZXQgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggdG8gdGhlIGRhdGEgd2Ugd2FudFxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gd3JpdGVJZHNUb0V4Y2x1ZGUgQSBzcGVjaWZpYyBzZXQgdG8gYmUgZXhjbHVkZWRcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBjYWxjQ29tcGxldGVFdmVudENhY2hlKFxuICAgIHBhdGg6IFBhdGgsXG4gICAgd3JpdGVJZHNUb0V4Y2x1ZGU/OiBudW1iZXJbXVxuICApOiBOb2RlIHwgbnVsbCB7XG4gICAgY29uc3QgaW5jbHVkZUhpZGRlblNldHMgPSB0cnVlO1xuICAgIGNvbnN0IHdyaXRlVHJlZSA9IHRoaXMucGVuZGluZ1dyaXRlVHJlZV87XG4gICAgY29uc3Qgc2VydmVyQ2FjaGUgPSB0aGlzLnN5bmNQb2ludFRyZWVfLmZpbmRPblBhdGgocGF0aCwgZnVuY3Rpb24oXG4gICAgICBwYXRoU29GYXIsXG4gICAgICBzeW5jUG9pbnRcbiAgICApIHtcbiAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IFBhdGgucmVsYXRpdmVQYXRoKHBhdGhTb0ZhciwgcGF0aCk7XG4gICAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKHJlbGF0aXZlUGF0aCk7XG4gICAgICBpZiAoc2VydmVyQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlckNhY2hlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB3cml0ZVRyZWUuY2FsY0NvbXBsZXRlRXZlbnRDYWNoZShcbiAgICAgIHBhdGgsXG4gICAgICBzZXJ2ZXJDYWNoZSxcbiAgICAgIHdyaXRlSWRzVG9FeGNsdWRlLFxuICAgICAgaW5jbHVkZUhpZGRlblNldHNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgY29sbGFwc2VzIG11bHRpcGxlIHVuZmlsdGVyZWQgdmlld3MgaW50byBhIHNpbmdsZSB2aWV3LCBzaW5jZSB3ZSBvbmx5IG5lZWQgYSBzaW5nbGVcbiAgICogbGlzdGVuZXIgZm9yIHRoZW0uXG4gICAqXG4gICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fSBzdWJ0cmVlXG4gICAqIEByZXR1cm4geyFBcnJheS48IVZpZXc+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjb2xsZWN0RGlzdGluY3RWaWV3c0ZvclN1YlRyZWVfKFxuICAgIHN1YnRyZWU6IEltbXV0YWJsZVRyZWU8U3luY1BvaW50PlxuICApOiBWaWV3W10ge1xuICAgIHJldHVybiBzdWJ0cmVlLmZvbGQ8Vmlld1tdPihcbiAgICAgIChyZWxhdGl2ZVBhdGgsIG1heWJlQ2hpbGRTeW5jUG9pbnQsIGNoaWxkTWFwKSA9PiB7XG4gICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50ICYmIG1heWJlQ2hpbGRTeW5jUG9pbnQuaGFzQ29tcGxldGVWaWV3KCkpIHtcbiAgICAgICAgICBjb25zdCBjb21wbGV0ZVZpZXcgPSBtYXliZUNoaWxkU3luY1BvaW50LmdldENvbXBsZXRlVmlldygpO1xuICAgICAgICAgIHJldHVybiBbY29tcGxldGVWaWV3XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBjb21wbGV0ZSB2aWV3IGhlcmUsIGZsYXR0ZW4gYW55IGRlZXBlciBsaXN0ZW5zIGludG8gYW4gYXJyYXlcbiAgICAgICAgICBsZXQgdmlld3M6IFZpZXdbXSA9IFtdO1xuICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XG4gICAgICAgICAgICB2aWV3cyA9IG1heWJlQ2hpbGRTeW5jUG9pbnQuZ2V0UXVlcnlWaWV3cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3JFYWNoKGNoaWxkTWFwLCBmdW5jdGlvbihrZXk6IHN0cmluZywgY2hpbGRWaWV3czogVmlld1tdKSB7XG4gICAgICAgICAgICB2aWV3cyA9IHZpZXdzLmNvbmNhdChjaGlsZFZpZXdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdmlld3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5LjwhUXVlcnk+fSBxdWVyaWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZVRhZ3NfKHF1ZXJpZXM6IFF1ZXJ5W10pIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHF1ZXJpZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeSA9IHF1ZXJpZXNbal07XG4gICAgICBpZiAoIXJlbW92ZWRRdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpKSB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGEgdGFnIGZvciB0aGlzXG4gICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeUtleSA9IFN5bmNUcmVlLm1ha2VRdWVyeUtleV8ocmVtb3ZlZFF1ZXJ5KTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFF1ZXJ5VGFnID0gdGhpcy5xdWVyeVRvVGFnTWFwX1tyZW1vdmVkUXVlcnlLZXldO1xuICAgICAgICBkZWxldGUgdGhpcy5xdWVyeVRvVGFnTWFwX1tyZW1vdmVkUXVlcnlLZXldO1xuICAgICAgICBkZWxldGUgdGhpcy50YWdUb1F1ZXJ5TWFwX1snXycgKyByZW1vdmVkUXVlcnlUYWddO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGEgcXVlcnkgdG8gYSBxdWVyeSB3ZSBzZW5kIHRoZSBzZXJ2ZXIgZm9yIGxpc3RlbmluZ1xuICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICogQHJldHVybiB7IVF1ZXJ5fSBUaGUgbm9ybWFsaXplZCBxdWVyeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgcXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5OiBRdWVyeSk6IFF1ZXJ5IHtcbiAgICBpZiAoXG4gICAgICBxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpICYmXG4gICAgICAhcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5pc0RlZmF1bHQoKVxuICAgICkge1xuICAgICAgLy8gV2UgdHJlYXQgcXVlcmllcyB0aGF0IGxvYWQgYWxsIGRhdGEgYXMgZGVmYXVsdCBxdWVyaWVzXG4gICAgICAvLyBDYXN0IGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHJlZigpIHRlY2huaWNhbGx5IHJldHVybnMgRmlyZWJhc2Ugd2hpY2ggaXMgYWN0dWFsbHkgZmIuYXBpLkZpcmViYXNlIHdoaWNoIGluaGVyaXRzXG4gICAgICAvLyBmcm9tIFF1ZXJ5XG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHshUXVlcnl9ICovIHF1ZXJ5LmdldFJlZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhIGdpdmVuIG5ldyBsaXN0ZW4sIG1hbmFnZSB0aGUgZGUtZHVwbGljYXRpb24gb2Ygb3V0c3RhbmRpbmcgc3Vic2NyaXB0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAqIEBwYXJhbSB7IVZpZXd9IHZpZXdcbiAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBUaGlzIG1ldGhvZCBjYW4gcmV0dXJuIGV2ZW50cyB0byBzdXBwb3J0IHN5bmNocm9ub3VzIGRhdGEgc291cmNlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cExpc3RlbmVyXyhxdWVyeTogUXVlcnksIHZpZXc6IFZpZXcpOiBFdmVudFtdIHtcbiAgICBjb25zdCBwYXRoID0gcXVlcnkucGF0aDtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ0ZvclF1ZXJ5XyhxdWVyeSk7XG4gICAgY29uc3QgbGlzdGVuZXIgPSB0aGlzLmNyZWF0ZUxpc3RlbmVyRm9yVmlld18odmlldyk7XG5cbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmxpc3RlblByb3ZpZGVyXy5zdGFydExpc3RlbmluZyhcbiAgICAgIFN5bmNUcmVlLnF1ZXJ5Rm9yTGlzdGVuaW5nXyhxdWVyeSksXG4gICAgICB0YWcsXG4gICAgICBsaXN0ZW5lci5oYXNoRm4sXG4gICAgICBsaXN0ZW5lci5vbkNvbXBsZXRlXG4gICAgKTtcblxuICAgIGNvbnN0IHN1YnRyZWUgPSB0aGlzLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XG4gICAgLy8gVGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlIGhhcyBvdXIgcXVlcnkuIFdlJ3JlIGhlcmUgYmVjYXVzZSB3ZSBkZWZpbml0ZWx5IG5lZWQgdG8gc2VuZCBhIGxpc3RlbiBmb3IgdGhhdCwgYnV0IHdlXG4gICAgLy8gbWF5IG5lZWQgdG8gc2hhZG93IG90aGVyIGxpc3RlbnMgYXMgd2VsbC5cbiAgICBpZiAodGFnKSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgICFzdWJ0cmVlLnZhbHVlLmhhc0NvbXBsZXRlVmlldygpLFxuICAgICAgICBcIklmIHdlJ3JlIGFkZGluZyBhIHF1ZXJ5LCBpdCBzaG91bGRuJ3QgYmUgc2hhZG93ZWRcIlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2hhZG93IGV2ZXJ5dGhpbmcgYXQgb3IgYmVsb3cgdGhpcyBsb2NhdGlvbiwgdGhpcyBpcyBhIGRlZmF1bHQgbGlzdGVuZXIuXG4gICAgICBjb25zdCBxdWVyaWVzVG9TdG9wID0gc3VidHJlZS5mb2xkPFF1ZXJ5W10+KGZ1bmN0aW9uKFxuICAgICAgICByZWxhdGl2ZVBhdGgsXG4gICAgICAgIG1heWJlQ2hpbGRTeW5jUG9pbnQsXG4gICAgICAgIGNoaWxkTWFwXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFyZWxhdGl2ZVBhdGguaXNFbXB0eSgpICYmXG4gICAgICAgICAgbWF5YmVDaGlsZFN5bmNQb2ludCAmJlxuICAgICAgICAgIG1heWJlQ2hpbGRTeW5jUG9pbnQuaGFzQ29tcGxldGVWaWV3KClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIFttYXliZUNoaWxkU3luY1BvaW50LmdldENvbXBsZXRlVmlldygpLmdldFF1ZXJ5KCldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGRlZmF1bHQgbGlzdGVuZXIgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIHF1ZXJpZXMgaW50byBhbiBhcnJheVxuICAgICAgICAgIGxldCBxdWVyaWVzOiBRdWVyeVtdID0gW107XG4gICAgICAgICAgaWYgKG1heWJlQ2hpbGRTeW5jUG9pbnQpIHtcbiAgICAgICAgICAgIHF1ZXJpZXMgPSBxdWVyaWVzLmNvbmNhdChcbiAgICAgICAgICAgICAgbWF5YmVDaGlsZFN5bmNQb2ludC5nZXRRdWVyeVZpZXdzKCkubWFwKHZpZXcgPT4gdmlldy5nZXRRdWVyeSgpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yRWFjaChjaGlsZE1hcCwgZnVuY3Rpb24oa2V5OiBzdHJpbmcsIGNoaWxkUXVlcmllczogUXVlcnlbXSkge1xuICAgICAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMuY29uY2F0KGNoaWxkUXVlcmllcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWVyaWVzVG9TdG9wLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5VG9TdG9wID0gcXVlcmllc1RvU3RvcFtpXTtcbiAgICAgICAgdGhpcy5saXN0ZW5Qcm92aWRlcl8uc3RvcExpc3RlbmluZyhcbiAgICAgICAgICBTeW5jVHJlZS5xdWVyeUZvckxpc3RlbmluZ18ocXVlcnlUb1N0b3ApLFxuICAgICAgICAgIHRoaXMudGFnRm9yUXVlcnlfKHF1ZXJ5VG9TdG9wKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7IVZpZXd9IHZpZXdcbiAgICogQHJldHVybiB7e2hhc2hGbjogZnVuY3Rpb24oKSwgb25Db21wbGV0ZTogZnVuY3Rpb24oIXN0cmluZywgKil9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVMaXN0ZW5lckZvclZpZXdfKFxuICAgIHZpZXc6IFZpZXdcbiAgKTogeyBoYXNoRm4oKTogc3RyaW5nOyBvbkNvbXBsZXRlKGE6IHN0cmluZywgYj86IGFueSk6IEV2ZW50W10gfSB7XG4gICAgY29uc3QgcXVlcnkgPSB2aWV3LmdldFF1ZXJ5KCk7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdGb3JRdWVyeV8ocXVlcnkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc2hGbjogKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZSA9IHZpZXcuZ2V0U2VydmVyQ2FjaGUoKSB8fCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmhhc2goKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoc3RhdHVzOiBzdHJpbmcpOiBFdmVudFtdID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xuICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5VGFnZ2VkTGlzdGVuQ29tcGxldGUocXVlcnkucGF0aCwgdGFnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlMaXN0ZW5Db21wbGV0ZShxdWVyeS5wYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgYSBsaXN0ZW4gZmFpbGVkLCBraWxsIGFsbCBvZiB0aGUgbGlzdGVuZXJzIGhlcmUsIG5vdCBqdXN0IHRoZSBvbmUgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBuZWVkIHRvIGJlIHNjb3BlZCB0byBqdXN0IHRoaXMgbGlzdGVuZXIgaWYgd2UgY2hhbmdlIHBlcm1pc3Npb25zIG9uIGZpbHRlcmVkIGNoaWxkcmVuXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckZvclNlcnZlckNvZGUoc3RhdHVzLCBxdWVyeSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIC8qZXZlbnRSZWdpc3RyYXRpb24qLyBudWxsLFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHF1ZXJ5LCBjb21wdXRlcyBhIFwicXVlcnlLZXlcIiBzdWl0YWJsZSBmb3IgdXNlIGluIG91ciBxdWVyeVRvVGFnTWFwXy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIG1ha2VRdWVyeUtleV8ocXVlcnk6IFF1ZXJ5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gcXVlcnkucGF0aC50b1N0cmluZygpICsgJyQnICsgcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBxdWVyeUtleSAoY3JlYXRlZCBieSBtYWtlUXVlcnlLZXkpLCBwYXJzZSBpdCBiYWNrIGludG8gYSBwYXRoIGFuZCBxdWVyeUlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHF1ZXJ5S2V5XG4gICAqIEByZXR1cm4ge3txdWVyeUlkOiAhc3RyaW5nLCBwYXRoOiAhUGF0aH19XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBwYXJzZVF1ZXJ5S2V5XyhcbiAgICBxdWVyeUtleTogc3RyaW5nXG4gICk6IHsgcXVlcnlJZDogc3RyaW5nOyBwYXRoOiBQYXRoIH0ge1xuICAgIGNvbnN0IHNwbGl0SW5kZXggPSBxdWVyeUtleS5pbmRleE9mKCckJyk7XG4gICAgYXNzZXJ0KFxuICAgICAgc3BsaXRJbmRleCAhPT0gLTEgJiYgc3BsaXRJbmRleCA8IHF1ZXJ5S2V5Lmxlbmd0aCAtIDEsXG4gICAgICAnQmFkIHF1ZXJ5S2V5LidcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBxdWVyeUlkOiBxdWVyeUtleS5zdWJzdHIoc3BsaXRJbmRleCArIDEpLFxuICAgICAgcGF0aDogbmV3IFBhdGgocXVlcnlLZXkuc3Vic3RyKDAsIHNwbGl0SW5kZXgpKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBxdWVyeSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHRhZywgaWYgd2UgaGF2ZSBvbmVcbiAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcXVlcnlLZXlGb3JUYWdfKHRhZzogbnVtYmVyKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMudGFnVG9RdWVyeU1hcF9bJ18nICsgdGFnXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRhZyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHF1ZXJ5LlxuICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICogQHJldHVybiB7P251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgdGFnRm9yUXVlcnlfKHF1ZXJ5OiBRdWVyeSk6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gU3luY1RyZWUubWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XG4gICAgcmV0dXJuIHNhZmVHZXQodGhpcy5xdWVyeVRvVGFnTWFwXywgcXVlcnlLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyB0cmFja2VyIGZvciBuZXh0IHF1ZXJ5IHRhZy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIG5leHRRdWVyeVRhZ18gPSAxO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgYWNjZXNzb3IgZm9yIHF1ZXJ5IHRhZ3MuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldE5leHRRdWVyeVRhZ18oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gU3luY1RyZWUubmV4dFF1ZXJ5VGFnXysrO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0byBhcHBseSB0YWdnZWQgb3BlcmF0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0geyFQYXRofSBxdWVyeVBhdGhcbiAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhcHBseVRhZ2dlZE9wZXJhdGlvbl8oXG4gICAgcXVlcnlQYXRoOiBQYXRoLFxuICAgIG9wZXJhdGlvbjogT3BlcmF0aW9uXG4gICk6IEV2ZW50W10ge1xuICAgIGNvbnN0IHN5bmNQb2ludCA9IHRoaXMuc3luY1BvaW50VHJlZV8uZ2V0KHF1ZXJ5UGF0aCk7XG4gICAgYXNzZXJ0KHN5bmNQb2ludCwgXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO1xuICAgIGNvbnN0IHdyaXRlc0NhY2hlID0gdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5jaGlsZFdyaXRlcyhxdWVyeVBhdGgpO1xuICAgIHJldHVybiBzeW5jUG9pbnQuYXBwbHlPcGVyYXRpb24oXG4gICAgICBvcGVyYXRpb24sXG4gICAgICB3cml0ZXNDYWNoZSxcbiAgICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgdmlzaXRzIGFsbCBkZXNjZW5kYW50IGFuZCBhbmNlc3RvciBTeW5jUG9pbnRzLCBhcHBseWluZyB0aGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBOT1RFUzpcbiAgICogLSBEZXNjZW5kYW50IFN5bmNQb2ludHMgd2lsbCBiZSB2aXNpdGVkIGZpcnN0IChzaW5jZSB3ZSByYWlzZSBldmVudHMgZGVwdGgtZmlyc3QpLlxuXG4gICAqIC0gV2UgY2FsbCBhcHBseU9wZXJhdGlvbigpIG9uIGVhY2ggU3luY1BvaW50IHBhc3NpbmcgdGhyZWUgdGhpbmdzOlxuICAgKiAgIDEuIEEgdmVyc2lvbiBvZiB0aGUgT3BlcmF0aW9uIHRoYXQgaGFzIGJlZW4gbWFkZSByZWxhdGl2ZSB0byB0aGUgU3luY1BvaW50IGxvY2F0aW9uLlxuICAgKiAgIDIuIEEgV3JpdGVUcmVlUmVmIG9mIGFueSB3cml0ZXMgd2UgaGF2ZSBjYWNoZWQgYXQgdGhlIFN5bmNQb2ludCBsb2NhdGlvbi5cbiAgICogICAzLiBBIHNuYXBzaG90IE5vZGUgd2l0aCBjYWNoZWQgc2VydmVyIGRhdGEsIGlmIHdlIGhhdmUgaXQuXG5cbiAgICogLSBXZSBjb25jYXRlbmF0ZSBhbGwgb2YgdGhlIGV2ZW50cyByZXR1cm5lZCBieSBlYWNoIFN5bmNQb2ludCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSB7IU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKG9wZXJhdGlvbjogT3BlcmF0aW9uKTogRXZlbnRbXSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25IZWxwZXJfKFxuICAgICAgb3BlcmF0aW9uLFxuICAgICAgdGhpcy5zeW5jUG9pbnRUcmVlXyxcbiAgICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbCxcbiAgICAgIHRoaXMucGVuZGluZ1dyaXRlVHJlZV8uY2hpbGRXcml0ZXMoUGF0aC5FbXB0eSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzX1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyFPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fSBzeW5jUG9pbnRUcmVlXG4gICAqIEBwYXJhbSB7P05vZGV9IHNlcnZlckNhY2hlXG4gICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgKi9cbiAgcHJpdmF0ZSBhcHBseU9wZXJhdGlvbkhlbHBlcl8oXG4gICAgb3BlcmF0aW9uOiBPcGVyYXRpb24sXG4gICAgc3luY1BvaW50VHJlZTogSW1tdXRhYmxlVHJlZTxTeW5jUG9pbnQ+LFxuICAgIHNlcnZlckNhY2hlOiBOb2RlIHwgbnVsbCxcbiAgICB3cml0ZXNDYWNoZTogV3JpdGVUcmVlUmVmXG4gICk6IEV2ZW50W10ge1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uRGVzY2VuZGFudHNIZWxwZXJfKFxuICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgIHN5bmNQb2ludFRyZWUsXG4gICAgICAgIHNlcnZlckNhY2hlLFxuICAgICAgICB3cml0ZXNDYWNoZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3luY1BvaW50ID0gc3luY1BvaW50VHJlZS5nZXQoUGF0aC5FbXB0eSk7XG5cbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxuICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcbiAgICAgICAgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnQuZ2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShQYXRoLkVtcHR5KTtcbiAgICAgIH1cblxuICAgICAgbGV0IGV2ZW50czogRXZlbnRbXSA9IFtdO1xuICAgICAgY29uc3QgY2hpbGROYW1lID0gb3BlcmF0aW9uLnBhdGguZ2V0RnJvbnQoKTtcbiAgICAgIGNvbnN0IGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XG4gICAgICBjb25zdCBjaGlsZFRyZWUgPSBzeW5jUG9pbnRUcmVlLmNoaWxkcmVuLmdldChjaGlsZE5hbWUpO1xuICAgICAgaWYgKGNoaWxkVHJlZSAmJiBjaGlsZE9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcbiAgICAgICAgICA/IHNlcnZlckNhY2hlLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IGNoaWxkV3JpdGVzQ2FjaGUgPSB3cml0ZXNDYWNoZS5jaGlsZChjaGlsZE5hbWUpO1xuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KFxuICAgICAgICAgIHRoaXMuYXBwbHlPcGVyYXRpb25IZWxwZXJfKFxuICAgICAgICAgICAgY2hpbGRPcGVyYXRpb24sXG4gICAgICAgICAgICBjaGlsZFRyZWUsXG4gICAgICAgICAgICBjaGlsZFNlcnZlckNhY2hlLFxuICAgICAgICAgICAgY2hpbGRXcml0ZXNDYWNoZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN5bmNQb2ludCkge1xuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KFxuICAgICAgICAgIHN5bmNQb2ludC5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlIGhlbHBlciBmb3IgYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7IU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7SW1tdXRhYmxlVHJlZS48IVN5bmNQb2ludD59IHN5bmNQb2ludFRyZWVcbiAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGVcbiAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAqL1xuICBwcml2YXRlIGFwcGx5T3BlcmF0aW9uRGVzY2VuZGFudHNIZWxwZXJfKFxuICAgIG9wZXJhdGlvbjogT3BlcmF0aW9uLFxuICAgIHN5bmNQb2ludFRyZWU6IEltbXV0YWJsZVRyZWU8U3luY1BvaW50PixcbiAgICBzZXJ2ZXJDYWNoZTogTm9kZSB8IG51bGwsXG4gICAgd3JpdGVzQ2FjaGU6IFdyaXRlVHJlZVJlZlxuICApOiBFdmVudFtdIHtcbiAgICBjb25zdCBzeW5jUG9pbnQgPSBzeW5jUG9pbnRUcmVlLmdldChQYXRoLkVtcHR5KTtcblxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxuICAgIGlmIChzZXJ2ZXJDYWNoZSA9PSBudWxsICYmIHN5bmNQb2ludCAhPSBudWxsKSB7XG4gICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKFBhdGguRW1wdHkpO1xuICAgIH1cblxuICAgIGxldCBldmVudHM6IEV2ZW50W10gPSBbXTtcbiAgICBzeW5jUG9pbnRUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcbiAgICAgICAgPyBzZXJ2ZXJDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGNvbnN0IGNoaWxkV3JpdGVzQ2FjaGUgPSB3cml0ZXNDYWNoZS5jaGlsZChjaGlsZE5hbWUpO1xuICAgICAgY29uc3QgY2hpbGRPcGVyYXRpb24gPSBvcGVyYXRpb24ub3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKTtcbiAgICAgIGlmIChjaGlsZE9wZXJhdGlvbikge1xuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KFxuICAgICAgICAgIHRoaXMuYXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8oXG4gICAgICAgICAgICBjaGlsZE9wZXJhdGlvbixcbiAgICAgICAgICAgIGNoaWxkVHJlZSxcbiAgICAgICAgICAgIGNoaWxkU2VydmVyQ2FjaGUsXG4gICAgICAgICAgICBjaGlsZFdyaXRlc0NhY2hlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHN5bmNQb2ludCkge1xuICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChcbiAgICAgICAgc3luY1BvaW50LmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ2hpbGRyZW5Ob2RlIH0gZnJvbSAnLi9zbmFwL0NoaWxkcmVuTm9kZSc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vc25hcC9Ob2RlJztcblxuLyoqXG4gKiBNdXRhYmxlIG9iamVjdCB3aGljaCBiYXNpY2FsbHkganVzdCBzdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIFwibGF0ZXN0XCIgaW1tdXRhYmxlIHNuYXBzaG90LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgU25hcHNob3RIb2xkZXIge1xuICBwcml2YXRlIHJvb3ROb2RlXzogTm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuXG4gIGdldE5vZGUocGF0aDogUGF0aCk6IE5vZGUge1xuICAgIHJldHVybiB0aGlzLnJvb3ROb2RlXy5nZXRDaGlsZChwYXRoKTtcbiAgfVxuXG4gIHVwZGF0ZVNuYXBzaG90KHBhdGg6IFBhdGgsIG5ld1NuYXBzaG90Tm9kZTogTm9kZSkge1xuICAgIHRoaXMucm9vdE5vZGVfID0gdGhpcy5yb290Tm9kZV8udXBkYXRlQ2hpbGQocGF0aCwgbmV3U25hcHNob3ROb2RlKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpcmViYXNlQXBwIH0gZnJvbSAnQGZpcmViYXNlL2FwcC10eXBlcyc7XG5pbXBvcnQgeyBGaXJlYmFzZUF1dGhUb2tlbkRhdGEgfSBmcm9tICdAZmlyZWJhc2UvYXBwLXR5cGVzL3ByaXZhdGUnO1xuaW1wb3J0IHsgbG9nLCB3YXJuIH0gZnJvbSAnLi91dGlsL3V0aWwnO1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGFyb3VuZCBGaXJlYmFzZUFwcCdzIHRva2VuIGZldGNoaW5nIGNhcGFiaWxpdGllcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhUb2tlblByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZpcmViYXNlQXBwfSBhcHBfXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwcF86IEZpcmViYXNlQXBwKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlUmVmcmVzaFxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxGaXJlYmFzZUF1dGhUb2tlbkRhdGE+fVxuICAgKi9cbiAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoOiBib29sZWFuKTogUHJvbWlzZTxGaXJlYmFzZUF1dGhUb2tlbkRhdGE+IHtcbiAgICByZXR1cm4gdGhpcy5hcHBfWydJTlRFUk5BTCddWydnZXRUb2tlbiddKGZvcmNlUmVmcmVzaCkudGhlbihcbiAgICAgIG51bGwsXG4gICAgICAvLyAuY2F0Y2hcbiAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIC8vIFRPRE86IE5lZWQgdG8gZmlndXJlIG91dCBhbGwgdGhlIGNhc2VzIHRoaXMgaXMgcmFpc2VkIGFuZCB3aGV0aGVyXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgc2Vuc2UuXG4gICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSAnYXV0aC90b2tlbi1ub3QtaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgbG9nKCdHb3QgYXV0aC90b2tlbi1ub3QtaW5pdGlhbGl6ZWQgZXJyb3IuICBUcmVhdGluZyBhcyBudWxsIHRva2VuLicpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcjogKHRva2VuOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkKSB7XG4gICAgLy8gVE9ETzogV2UgbWlnaHQgd2FudCB0byB3cmFwIHRoZSBsaXN0ZW5lciBhbmQgY2FsbCBpdCB3aXRoIG5vIGFyZ3MgdG9cbiAgICAvLyBhdm9pZCBhIGxlYWt5IGFic3RyYWN0aW9uLCBidXQgdGhhdCBtYWtlcyByZW1vdmluZyB0aGUgbGlzdGVuZXIgaGFyZGVyLlxuICAgIHRoaXMuYXBwX1snSU5URVJOQUwnXVsnYWRkQXV0aFRva2VuTGlzdGVuZXInXShsaXN0ZW5lcik7XG4gIH1cblxuICByZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyOiAodG9rZW46IHN0cmluZyB8IG51bGwpID0+IHZvaWQpIHtcbiAgICB0aGlzLmFwcF9bJ0lOVEVSTkFMJ11bJ3JlbW92ZUF1dGhUb2tlbkxpc3RlbmVyJ10obGlzdGVuZXIpO1xuICB9XG5cbiAgbm90aWZ5Rm9ySW52YWxpZFRva2VuKCkge1xuICAgIGxldCBlcnJvck1lc3NhZ2UgPVxuICAgICAgJ1Byb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGUgYXBwIG5hbWVkIFwiJyArXG4gICAgICB0aGlzLmFwcF8ubmFtZSArXG4gICAgICAnXCIgYXJlIGludmFsaWQuIFRoaXMgdXN1YWxseSBpbmRpY2F0ZXMgeW91ciBhcHAgd2FzIG5vdCAnICtcbiAgICAgICdpbml0aWFsaXplZCBjb3JyZWN0bHkuICc7XG4gICAgaWYgKCdjcmVkZW50aWFsJyBpbiB0aGlzLmFwcF8ub3B0aW9ucykge1xuICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICdNYWtlIHN1cmUgdGhlIFwiY3JlZGVudGlhbFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcbiAgICAgICAgJ2lzIGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgXCJkYXRhYmFzZVVSTFwiIGFuZCBpcyBmcm9tIHRoZSBjb3JyZWN0ICcgK1xuICAgICAgICAncHJvamVjdC4nO1xuICAgIH0gZWxzZSBpZiAoJ3NlcnZpY2VBY2NvdW50JyBpbiB0aGlzLmFwcF8ub3B0aW9ucykge1xuICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICdNYWtlIHN1cmUgdGhlIFwic2VydmljZUFjY291bnRcIiBwcm9wZXJ0eSBwcm92aWRlZCB0byBpbml0aWFsaXplQXBwKCkgJyArXG4gICAgICAgICdpcyBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIFwiZGF0YWJhc2VVUkxcIiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCAnICtcbiAgICAgICAgJ3Byb2plY3QuJztcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICdNYWtlIHN1cmUgdGhlIFwiYXBpS2V5XCIgYW5kIFwiZGF0YWJhc2VVUkxcIiBwcm9wZXJ0aWVzIHByb3ZpZGVkIHRvICcgK1xuICAgICAgICAnaW5pdGlhbGl6ZUFwcCgpIG1hdGNoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgZm9yIHlvdXIgYXBwIGF0ICcgK1xuICAgICAgICAnaHR0cHM6Ly9jb25zb2xlLmZpcmViYXNlLmdvb2dsZS5jb20vLic7XG4gICAgfVxuICAgIHdhcm4oZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGRlZXBDb3B5IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgY29udGFpbnMgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qKlxuICogVHJhY2tzIGEgY29sbGVjdGlvbiBvZiBzdGF0cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRzQ29sbGVjdGlvbiB7XG4gIHByaXZhdGUgY291bnRlcnNfOiB7IFtrOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xuXG4gIGluY3JlbWVudENvdW50ZXIobmFtZTogc3RyaW5nLCBhbW91bnQ6IG51bWJlciA9IDEpIHtcbiAgICBpZiAoIWNvbnRhaW5zKHRoaXMuY291bnRlcnNfLCBuYW1lKSkgdGhpcy5jb3VudGVyc19bbmFtZV0gPSAwO1xuXG4gICAgdGhpcy5jb3VudGVyc19bbmFtZV0gKz0gYW1vdW50O1xuICB9XG5cbiAgZ2V0KCkge1xuICAgIHJldHVybiBkZWVwQ29weSh0aGlzLmNvdW50ZXJzXyk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBTdGF0c0NvbGxlY3Rpb24gfSBmcm9tICcuL1N0YXRzQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBSZXBvSW5mbyB9IGZyb20gJy4uL1JlcG9JbmZvJztcblxuZXhwb3J0IGNsYXNzIFN0YXRzTWFuYWdlciB7XG4gIHByaXZhdGUgc3RhdGljIGNvbGxlY3Rpb25zXzogeyBbazogc3RyaW5nXTogU3RhdHNDb2xsZWN0aW9uIH0gPSB7fTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVwb3J0ZXJzXzogeyBbazogc3RyaW5nXTogYW55IH0gPSB7fTtcblxuICBzdGF0aWMgZ2V0Q29sbGVjdGlvbihyZXBvSW5mbzogUmVwb0luZm8pOiBTdGF0c0NvbGxlY3Rpb24ge1xuICAgIGNvbnN0IGhhc2hTdHJpbmcgPSByZXBvSW5mby50b1N0cmluZygpO1xuXG4gICAgaWYgKCF0aGlzLmNvbGxlY3Rpb25zX1toYXNoU3RyaW5nXSkge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uc19baGFzaFN0cmluZ10gPSBuZXcgU3RhdHNDb2xsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNfW2hhc2hTdHJpbmddO1xuICB9XG5cbiAgc3RhdGljIGdldE9yQ3JlYXRlUmVwb3J0ZXI8VD4oXG4gICAgcmVwb0luZm86IFJlcG9JbmZvLFxuICAgIGNyZWF0b3JGdW5jdGlvbjogKCkgPT4gVFxuICApOiBUIHtcbiAgICBjb25zdCBoYXNoU3RyaW5nID0gcmVwb0luZm8udG9TdHJpbmcoKTtcblxuICAgIGlmICghdGhpcy5yZXBvcnRlcnNfW2hhc2hTdHJpbmddKSB7XG4gICAgICB0aGlzLnJlcG9ydGVyc19baGFzaFN0cmluZ10gPSBjcmVhdG9yRnVuY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXBvcnRlcnNfW2hhc2hTdHJpbmddO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgY2xvbmUsIGZvckVhY2ggfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBTdGF0c0NvbGxlY3Rpb24gfSBmcm9tICcuL1N0YXRzQ29sbGVjdGlvbic7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgY2FsbCB0byBnZXQgc3RhdHMuXG4gKlxuICogQHBhcmFtIGNvbGxlY3Rpb25fIFRoZSBjb2xsZWN0aW9uIHRvIFwibGlzdGVuXCIgdG8uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRzTGlzdGVuZXIge1xuICBwcml2YXRlIGxhc3RfOiB7IFtrOiBzdHJpbmddOiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29sbGVjdGlvbl86IFN0YXRzQ29sbGVjdGlvbikge31cblxuICBnZXQoKTogeyBbazogc3RyaW5nXTogbnVtYmVyIH0ge1xuICAgIGNvbnN0IG5ld1N0YXRzID0gdGhpcy5jb2xsZWN0aW9uXy5nZXQoKTtcblxuICAgIGNvbnN0IGRlbHRhOiB0eXBlb2YgbmV3U3RhdHMgPSBjbG9uZShuZXdTdGF0cyk7XG4gICAgaWYgKHRoaXMubGFzdF8pIHtcbiAgICAgIGZvckVhY2godGhpcy5sYXN0XywgKHN0YXQ6IHN0cmluZywgdmFsdWU6IG51bWJlcikgPT4ge1xuICAgICAgICBkZWx0YVtzdGF0XSA9IGRlbHRhW3N0YXRdIC0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5sYXN0XyA9IG5ld1N0YXRzO1xuXG4gICAgcmV0dXJuIGRlbHRhO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgY29udGFpbnMsIGZvckVhY2ggfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcgfSBmcm9tICcuLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgU3RhdHNMaXN0ZW5lciB9IGZyb20gJy4vU3RhdHNMaXN0ZW5lcic7XG5pbXBvcnQgeyBTdGF0c0NvbGxlY3Rpb24gfSBmcm9tICcuL1N0YXRzQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBTZXJ2ZXJBY3Rpb25zIH0gZnJvbSAnLi4vU2VydmVyQWN0aW9ucyc7XG5cbi8vIEFzc3VtaW5nIHNvbWUgYXBwcyBtYXkgaGF2ZSBhIHNob3J0IGFtb3VudCBvZiB0aW1lIG9uIHBhZ2UsIGFuZCBhIGJ1bGsgb2YgZmlyZWJhc2Ugb3BlcmF0aW9ucyBwcm9iYWJseVxuLy8gaGFwcGVuIG9uIHBhZ2UgbG9hZCwgd2UgdHJ5IHRvIHJlcG9ydCBvdXIgZmlyc3Qgc2V0IG9mIHN0YXRzIHByZXR0eSBxdWlja2x5LCBidXQgd2Ugd2FpdCBhdCBsZWFzdCAxMFxuLy8gc2Vjb25kcyB0byB0cnkgdG8gZW5zdXJlIHRoZSBGaXJlYmFzZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIC8gc2V0dGxlZC5cbmNvbnN0IEZJUlNUX1NUQVRTX01JTl9USU1FID0gMTAgKiAxMDAwO1xuY29uc3QgRklSU1RfU1RBVFNfTUFYX1RJTUUgPSAzMCAqIDEwMDA7XG5cbi8vIFdlJ2xsIGNvbnRpbnVlIHRvIHJlcG9ydCBzdGF0cyBvbiBhdmVyYWdlIGV2ZXJ5IDUgbWludXRlcy5cbmNvbnN0IFJFUE9SVF9TVEFUU19JTlRFUlZBTCA9IDUgKiA2MCAqIDEwMDA7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0c1JlcG9ydGVyIHtcbiAgcHJpdmF0ZSBzdGF0c0xpc3RlbmVyXzogU3RhdHNMaXN0ZW5lcjtcbiAgcHJpdmF0ZSBzdGF0c1RvUmVwb3J0XzogeyBbazogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSBzZXJ2ZXJfXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uOiBTdGF0c0NvbGxlY3Rpb24sIHByaXZhdGUgc2VydmVyXzogU2VydmVyQWN0aW9ucykge1xuICAgIHRoaXMuc3RhdHNMaXN0ZW5lcl8gPSBuZXcgU3RhdHNMaXN0ZW5lcihjb2xsZWN0aW9uKTtcblxuICAgIGNvbnN0IHRpbWVvdXQgPVxuICAgICAgRklSU1RfU1RBVFNfTUlOX1RJTUUgK1xuICAgICAgKEZJUlNUX1NUQVRTX01BWF9USU1FIC0gRklSU1RfU1RBVFNfTUlOX1RJTUUpICogTWF0aC5yYW5kb20oKTtcbiAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcodGhpcy5yZXBvcnRTdGF0c18uYmluZCh0aGlzKSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XG4gIH1cblxuICBpbmNsdWRlU3RhdChzdGF0OiBzdHJpbmcpIHtcbiAgICB0aGlzLnN0YXRzVG9SZXBvcnRfW3N0YXRdID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVwb3J0U3RhdHNfKCkge1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0c0xpc3RlbmVyXy5nZXQoKTtcbiAgICBjb25zdCByZXBvcnRlZFN0YXRzOiB0eXBlb2Ygc3RhdHMgPSB7fTtcbiAgICBsZXQgaGF2ZVN0YXRzVG9SZXBvcnQgPSBmYWxzZTtcblxuICAgIGZvckVhY2goc3RhdHMsIChzdGF0OiBzdHJpbmcsIHZhbHVlOiBudW1iZXIpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA+IDAgJiYgY29udGFpbnModGhpcy5zdGF0c1RvUmVwb3J0Xywgc3RhdCkpIHtcbiAgICAgICAgcmVwb3J0ZWRTdGF0c1tzdGF0XSA9IHZhbHVlO1xuICAgICAgICBoYXZlU3RhdHNUb1JlcG9ydCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoaGF2ZVN0YXRzVG9SZXBvcnQpIHtcbiAgICAgIHRoaXMuc2VydmVyXy5yZXBvcnRTdGF0cyhyZXBvcnRlZFN0YXRzKTtcbiAgICB9XG5cbiAgICAvLyBxdWV1ZSBvdXIgbmV4dCBydW4uXG4gICAgc2V0VGltZW91dE5vbkJsb2NraW5nKFxuICAgICAgdGhpcy5yZXBvcnRTdGF0c18uYmluZCh0aGlzKSxcbiAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIgKiBSRVBPUlRfU1RBVFNfSU5URVJWQUwpXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgbG9nLCBsb2dnZXIsIGV4Y2VwdGlvbkd1YXJkIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi9FdmVudCc7XG5cbi8qKlxuICogVGhlIGV2ZW50IHF1ZXVlIHNlcnZlcyBhIGZldyBwdXJwb3NlczpcbiAqIDEuIEl0IGVuc3VyZXMgd2UgbWFpbnRhaW4gZXZlbnQgb3JkZXIgaW4gdGhlIGZhY2Ugb2YgZXZlbnQgY2FsbGJhY2tzIGRvaW5nIG9wZXJhdGlvbnMgdGhhdCByZXN1bHQgaW4gbW9yZVxuICogICAgZXZlbnRzIGJlaW5nIHF1ZXVlZC5cbiAqIDIuIHJhaXNlUXVldWVkRXZlbnRzKCkgaGFuZGxlcyBiZWluZyBjYWxsZWQgcmVlbnRyYW50bHkgbmljZWx5LiAgVGhhdCBpcywgaWYgaW4gdGhlIGNvdXJzZSBvZiByYWlzaW5nIGV2ZW50cyxcbiAqICAgIHJhaXNlUXVldWVkRXZlbnRzKCkgaXMgY2FsbGVkIGFnYWluLCB0aGUgXCJpbm5lclwiIGNhbGwgd2lsbCBwaWNrIHVwIHJhaXNpbmcgZXZlbnRzIHdoZXJlIHRoZSBcIm91dGVyXCIgY2FsbFxuICogICAgbGVmdCBvZmYsIGVuc3VyaW5nIHRoYXQgdGhlIGV2ZW50cyBhcmUgc3RpbGwgcmFpc2VkIHN5bmNocm9ub3VzbHkgYW5kIGluIG9yZGVyLlxuICogMy4gWW91IGNhbiB1c2UgcmFpc2VFdmVudHNBdFBhdGggYW5kIHJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGggdG8gZW5zdXJlIG9ubHkgcmVsZXZhbnQgcHJldmlvdXNseS1xdWV1ZWRcbiAqICAgIGV2ZW50cyBhcmUgcmFpc2VkIHN5bmNocm9ub3VzbHkuXG4gKlxuICogTk9URTogVGhpcyBjYW4gYWxsIGdvIGF3YXkgaWYvd2hlbiB3ZSBtb3ZlIHRvIGFzeW5jIGV2ZW50cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50UXVldWUge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFBcnJheS48RXZlbnRMaXN0Pn1cbiAgICovXG4gIHByaXZhdGUgZXZlbnRMaXN0c186IEV2ZW50TGlzdFtdID0gW107XG5cbiAgLyoqXG4gICAqIFRyYWNrcyByZWN1cnNpb24gZGVwdGggb2YgcmFpc2VRdWV1ZWRFdmVudHNfLCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7IW51bWJlcn1cbiAgICovXG4gIHByaXZhdGUgcmVjdXJzaW9uRGVwdGhfID0gMDtcblxuICAvKipcbiAgICogQHBhcmFtIHshQXJyYXkuPEV2ZW50Pn0gZXZlbnREYXRhTGlzdCBUaGUgbmV3IGV2ZW50cyB0byBxdWV1ZS5cbiAgICovXG4gIHF1ZXVlRXZlbnRzKGV2ZW50RGF0YUxpc3Q6IEV2ZW50W10pIHtcbiAgICAvLyBXZSBncm91cCBldmVudHMgYnkgcGF0aCwgc3RvcmluZyB0aGVtIGluIGEgc2luZ2xlIEV2ZW50TGlzdCwgdG8gbWFrZSBpdCBlYXNpZXIgdG8gc2tpcCBvdmVyIHRoZW0gcXVpY2tseS5cbiAgICBsZXQgY3Vyckxpc3QgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnREYXRhTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnREYXRhID0gZXZlbnREYXRhTGlzdFtpXTtcbiAgICAgIGNvbnN0IGV2ZW50UGF0aCA9IGV2ZW50RGF0YS5nZXRQYXRoKCk7XG4gICAgICBpZiAoY3Vyckxpc3QgIT09IG51bGwgJiYgIWV2ZW50UGF0aC5lcXVhbHMoY3Vyckxpc3QuZ2V0UGF0aCgpKSkge1xuICAgICAgICB0aGlzLmV2ZW50TGlzdHNfLnB1c2goY3Vyckxpc3QpO1xuICAgICAgICBjdXJyTGlzdCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyTGlzdCA9PT0gbnVsbCkge1xuICAgICAgICBjdXJyTGlzdCA9IG5ldyBFdmVudExpc3QoZXZlbnRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgY3Vyckxpc3QuYWRkKGV2ZW50RGF0YSk7XG4gICAgfVxuICAgIGlmIChjdXJyTGlzdCkge1xuICAgICAgdGhpcy5ldmVudExpc3RzXy5wdXNoKGN1cnJMaXN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUXVldWVzIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBzeW5jaHJvbm91c2x5IHJhaXNlcyBhbGwgZXZlbnRzIChpbmNsdWRpbmcgcHJldmlvdXNseSBxdWV1ZWQgb25lcylcbiAgICogZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICpcbiAgICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBuZXcgZXZlbnRzIGFyZSBhbGwgZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxuICAgKiBAcGFyYW0geyFBcnJheS48RXZlbnQ+fSBldmVudERhdGFMaXN0IFRoZSBuZXcgZXZlbnRzIHRvIHJhaXNlLlxuICAgKi9cbiAgcmFpc2VFdmVudHNBdFBhdGgocGF0aDogUGF0aCwgZXZlbnREYXRhTGlzdDogRXZlbnRbXSkge1xuICAgIHRoaXMucXVldWVFdmVudHMoZXZlbnREYXRhTGlzdCk7XG4gICAgdGhpcy5yYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlXygoZXZlbnRQYXRoOiBQYXRoKSA9PlxuICAgICAgZXZlbnRQYXRoLmVxdWFscyhwYXRoKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUXVldWVzIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBzeW5jaHJvbm91c2x5IHJhaXNlcyBhbGwgZXZlbnRzIChpbmNsdWRpbmcgcHJldmlvdXNseSBxdWV1ZWQgb25lcykgZm9yXG4gICAqIGxvY2F0aW9ucyByZWxhdGVkIHRvIHRoZSBzcGVjaWZpZWQgY2hhbmdlIHBhdGggKGkuZS4gYWxsIGFuY2VzdG9ycyBhbmQgZGVzY2VuZGFudHMpLlxuICAgKlxuICAgKiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIG5ldyBldmVudHMgYXJlIGFsbCByZWxhdGVkIChhbmNlc3RvciBvciBkZXNjZW5kYW50KSB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7IVBhdGh9IGNoYW5nZWRQYXRoIFRoZSBwYXRoIHRvIHJhaXNlIGV2ZW50cyBmb3IuXG4gICAqIEBwYXJhbSB7IUFycmF5LjwhRXZlbnQ+fSBldmVudERhdGFMaXN0IFRoZSBldmVudHMgdG8gcmFpc2VcbiAgICovXG4gIHJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoY2hhbmdlZFBhdGg6IFBhdGgsIGV2ZW50RGF0YUxpc3Q6IEV2ZW50W10pIHtcbiAgICB0aGlzLnF1ZXVlRXZlbnRzKGV2ZW50RGF0YUxpc3QpO1xuXG4gICAgdGhpcy5yYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlXygoZXZlbnRQYXRoOiBQYXRoKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRQYXRoLmNvbnRhaW5zKGNoYW5nZWRQYXRoKSB8fCBjaGFuZ2VkUGF0aC5jb250YWlucyhldmVudFBhdGgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFQYXRoKTpib29sZWFufSBwcmVkaWNhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZV8oXG4gICAgcHJlZGljYXRlOiAocGF0aDogUGF0aCkgPT4gYm9vbGVhblxuICApIHtcbiAgICB0aGlzLnJlY3Vyc2lvbkRlcHRoXysrO1xuXG4gICAgbGV0IHNlbnRBbGwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ldmVudExpc3RzXy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnRMaXN0ID0gdGhpcy5ldmVudExpc3RzX1tpXTtcbiAgICAgIGlmIChldmVudExpc3QpIHtcbiAgICAgICAgY29uc3QgZXZlbnRQYXRoID0gZXZlbnRMaXN0LmdldFBhdGgoKTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShldmVudFBhdGgpKSB7XG4gICAgICAgICAgdGhpcy5ldmVudExpc3RzX1tpXS5yYWlzZSgpO1xuICAgICAgICAgIHRoaXMuZXZlbnRMaXN0c19baV0gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbnRBbGwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZW50QWxsKSB7XG4gICAgICB0aGlzLmV2ZW50TGlzdHNfID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5yZWN1cnNpb25EZXB0aF8tLTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRMaXN0IHtcbiAgLyoqXG4gICAqIEB0eXBlIHshQXJyYXkuPEV2ZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgZXZlbnRzXzogRXZlbnRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcGF0aF86IFBhdGgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudERhdGFcbiAgICovXG4gIGFkZChldmVudERhdGE6IEV2ZW50KSB7XG4gICAgdGhpcy5ldmVudHNfLnB1c2goZXZlbnREYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBsaXN0IGFuZCByYWlzZXMgZWFjaCBldmVudFxuICAgKi9cbiAgcmFpc2UoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmV2ZW50c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IHRoaXMuZXZlbnRzX1tpXTtcbiAgICAgIGlmIChldmVudERhdGEgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5ldmVudHNfW2ldID0gbnVsbDtcbiAgICAgICAgY29uc3QgZXZlbnRGbiA9IGV2ZW50RGF0YS5nZXRFdmVudFJ1bm5lcigpO1xuICAgICAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgICAgbG9nKCdldmVudDogJyArIGV2ZW50RGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBleGNlcHRpb25HdWFyZChldmVudEZuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IVBhdGh9XG4gICAqL1xuICBnZXRQYXRoKCk6IFBhdGgge1xuICAgIHJldHVybiB0aGlzLnBhdGhfO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gYmUgdXNlZCBpZiB5b3Ugd2FudCB0byBlbWl0IGV2ZW50cy4gQ2FsbCB0aGUgY29uc3RydWN0b3Igd2l0aFxuICogdGhlIHNldCBvZiBhbGxvd2VkIGV2ZW50IG5hbWVzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBsaXN0ZW5lcnNfOiB7XG4gICAgW2V2ZW50VHlwZTogc3RyaW5nXTogQXJyYXk8e1xuICAgICAgY2FsbGJhY2soLi4uYXJnczogYW55W10pOiB2b2lkO1xuICAgICAgY29udGV4dDogYW55O1xuICAgIH0+O1xuICB9ID0ge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBhbGxvd2VkRXZlbnRzX1xuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhbGxvd2VkRXZlbnRzXzogQXJyYXk8c3RyaW5nPikge1xuICAgIGFzc2VydChcbiAgICAgIEFycmF5LmlzQXJyYXkoYWxsb3dlZEV2ZW50c18pICYmIGFsbG93ZWRFdmVudHNfLmxlbmd0aCA+IDAsXG4gICAgICAnUmVxdWlyZXMgYSBub24tZW1wdHkgYXJyYXknXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBiZSBvdmVycmlkZGVuIGJ5IGRlcml2ZWQgY2xhc3NlcyBpbiBvcmRlciB0byBmaXJlIGFuIGluaXRpYWwgZXZlbnQgd2hlblxuICAgKiBzb21lYm9keSBzdWJzY3JpYmVzIGZvciBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGV2ZW50VHlwZVxuICAgKiBAcmV0dXJuIHtBcnJheS48Kj59IEFycmF5IG9mIHBhcmFtZXRlcnMgdG8gdHJpZ2dlciBpbml0aWFsIGV2ZW50IHdpdGguXG4gICAqL1xuICBhYnN0cmFjdCBnZXRJbml0aWFsRXZlbnQoZXZlbnRUeXBlOiBzdHJpbmcpOiBhbnlbXTtcblxuICAvKipcbiAgICogVG8gYmUgY2FsbGVkIGJ5IGRlcml2ZWQgY2xhc3NlcyB0byB0cmlnZ2VyIGV2ZW50cy5cbiAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGVcbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJnc1xuICAgKi9cbiAgcHJvdGVjdGVkIHRyaWdnZXIoZXZlbnRUeXBlOiBzdHJpbmcsIC4uLnZhcl9hcmdzOiBhbnlbXSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdKSkge1xuICAgICAgLy8gQ2xvbmUgdGhlIGxpc3QsIHNpbmNlIGNhbGxiYWNrcyBjb3VsZCBhZGQvcmVtb3ZlIGxpc3RlbmVycy5cbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFsuLi50aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXV07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsYmFjay5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgdmFyX2FyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uKGV2ZW50VHlwZTogc3RyaW5nLCBjYWxsYmFjazogKGE6IGFueSkgPT4gdm9pZCwgY29udGV4dDogYW55KSB7XG4gICAgdGhpcy52YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKTtcbiAgICB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xuICAgIHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdLnB1c2goeyBjYWxsYmFjaywgY29udGV4dCB9KTtcblxuICAgIGNvbnN0IGV2ZW50RGF0YSA9IHRoaXMuZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSk7XG4gICAgaWYgKGV2ZW50RGF0YSkge1xuICAgICAgY2FsbGJhY2suYXBwbHkoY29udGV4dCwgZXZlbnREYXRhKTtcbiAgICB9XG4gIH1cblxuICBvZmYoZXZlbnRUeXBlOiBzdHJpbmcsIGNhbGxiYWNrOiAoYTogYW55KSA9PiB2b2lkLCBjb250ZXh0OiBhbnkpIHtcbiAgICB0aGlzLnZhbGlkYXRlRXZlbnRUeXBlXyhldmVudFR5cGUpO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2sgJiZcbiAgICAgICAgKCFjb250ZXh0IHx8IGNvbnRleHQgPT09IGxpc3RlbmVyc1tpXS5jb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlRXZlbnRUeXBlXyhldmVudFR5cGU6IHN0cmluZykge1xuICAgIGFzc2VydChcbiAgICAgIHRoaXMuYWxsb3dlZEV2ZW50c18uZmluZChmdW5jdGlvbihldCkge1xuICAgICAgICByZXR1cm4gZXQgPT09IGV2ZW50VHlwZTtcbiAgICAgIH0pLFxuICAgICAgJ1Vua25vd24gZXZlbnQ6ICcgKyBldmVudFR5cGVcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5kZWNsYXJlIGNvbnN0IGRvY3VtZW50OiBhbnk7XG5cbi8qKlxuICogQGV4dGVuZHMge0V2ZW50RW1pdHRlcn1cbiAqL1xuZXhwb3J0IGNsYXNzIFZpc2liaWxpdHlNb25pdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSB2aXNpYmxlXzogYm9vbGVhbjtcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgcmV0dXJuIG5ldyBWaXNpYmlsaXR5TW9uaXRvcigpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoWyd2aXNpYmxlJ10pO1xuICAgIGxldCBoaWRkZW46IHN0cmluZztcbiAgICBsZXQgdmlzaWJpbGl0eUNoYW5nZTogc3RyaW5nO1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudFsnaGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE9wZXJhIDEyLjEwIGFuZCBGaXJlZm94IDE4IGFuZCBsYXRlciBzdXBwb3J0XG4gICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgIGhpZGRlbiA9ICdoaWRkZW4nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ21vekhpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICBoaWRkZW4gPSAnbW96SGlkZGVuJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wydtc0hpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21zdmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgIGhpZGRlbiA9ICdtc0hpZGRlbic7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnd2Via2l0SGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluaXRpYWxseSwgd2UgYWx3YXlzIGFzc3VtZSB3ZSBhcmUgdmlzaWJsZS4gVGhpcyBlbnN1cmVzIHRoYXQgaW4gYnJvd3NlcnNcbiAgICAvLyB3aXRob3V0IHBhZ2UgdmlzaWJpbGl0eSBzdXBwb3J0IG9yIGluIGNhc2VzIHdoZXJlIHdlIGFyZSBuZXZlciB2aXNpYmxlXG4gICAgLy8gKGUuZy4gY2hyb21lIGV4dGVuc2lvbiksIHdlIGFjdCBhcyBpZiB3ZSBhcmUgdmlzaWJsZSwgaS5lLiBkb24ndCBkZWxheVxuICAgIC8vIHJlY29ubmVjdHNcbiAgICB0aGlzLnZpc2libGVfID0gdHJ1ZTtcblxuICAgIGlmICh2aXNpYmlsaXR5Q2hhbmdlKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmlzaWJsZSA9ICFkb2N1bWVudFtoaWRkZW5dO1xuICAgICAgICAgIGlmICh2aXNpYmxlICE9PSB0aGlzLnZpc2libGVfKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVfID0gdmlzaWJsZTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndmlzaWJsZScsIHZpc2libGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAqIEByZXR1cm4ge0FycmF5Ljxib29sZWFuPn1cbiAgICovXG4gIGdldEluaXRpYWxFdmVudChldmVudFR5cGU6IHN0cmluZyk6IGJvb2xlYW5bXSB7XG4gICAgYXNzZXJ0KGV2ZW50VHlwZSA9PT0gJ3Zpc2libGUnLCAnVW5rbm93biBldmVudCB0eXBlOiAnICsgZXZlbnRUeXBlKTtcbiAgICByZXR1cm4gW3RoaXMudmlzaWJsZV9dO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgaXNNb2JpbGVDb3Jkb3ZhIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcbiAqIE1vbml0b3JzIG9ubGluZSBzdGF0ZSAoYXMgcmVwb3J0ZWQgYnkgd2luZG93Lm9ubGluZS9vZmZsaW5lIGV2ZW50cykuXG4gKlxuICogVGhlIGV4cGVjdGF0aW9uIGlzIHRoYXQgdGhpcyBjb3VsZCBoYXZlIG1hbnkgZmFsc2UgcG9zaXRpdmVzICh0aGlua3Mgd2UgYXJlIG9ubGluZVxuICogd2hlbiB3ZSdyZSBub3QpLCBidXQgbm8gZmFsc2UgbmVnYXRpdmVzLiAgU28gd2UgY2FuIHNhZmVseSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZW5cbiAqIHdlIGRlZmluaXRlbHkgY2Fubm90IHJlYWNoIHRoZSBpbnRlcm5ldC5cbiAqXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfVxuICovXG5leHBvcnQgY2xhc3MgT25saW5lTW9uaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgb25saW5lXyA9IHRydWU7XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgIHJldHVybiBuZXcgT25saW5lTW9uaXRvcigpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoWydvbmxpbmUnXSk7XG5cbiAgICAvLyBXZSd2ZSBoYWQgcmVwZWF0ZWQgY29tcGxhaW50cyB0aGF0IENvcmRvdmEgYXBwcyBjYW4gZ2V0IHN0dWNrIFwib2ZmbGluZVwiLCBlLmcuXG4gICAgLy8gaHR0cHM6Ly9mb3J1bS5pb25pY2ZyYW1ld29yay5jb20vdC9maXJlYmFzZS1jb25uZWN0aW9uLWlzLWxvc3QtYW5kLW5ldmVyLWNvbWUtYmFjay80MzgxMFxuICAgIC8vIEl0IHdvdWxkIHNlZW0gdGhhdCB0aGUgJ29ubGluZScgZXZlbnQgZG9lcyBub3QgYWx3YXlzIGZpcmUgY29uc2lzdGVudGx5LiBTbyB3ZSBkaXNhYmxlIGl0XG4gICAgLy8gZm9yIENvcmRvdmEuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICFpc01vYmlsZUNvcmRvdmEoKVxuICAgICkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdvbmxpbmUnLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLm9ubGluZV8pIHtcbiAgICAgICAgICAgIHRoaXMub25saW5lXyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29ubGluZScsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnb2ZmbGluZScsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5vbmxpbmVfKSB7XG4gICAgICAgICAgICB0aGlzLm9ubGluZV8gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignb25saW5lJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAqIEByZXR1cm4ge0FycmF5Ljxib29sZWFuPn1cbiAgICovXG4gIGdldEluaXRpYWxFdmVudChldmVudFR5cGU6IHN0cmluZyk6IGJvb2xlYW5bXSB7XG4gICAgYXNzZXJ0KGV2ZW50VHlwZSA9PT0gJ29ubGluZScsICdVbmtub3duIGV2ZW50IHR5cGU6ICcgKyBldmVudFR5cGUpO1xuICAgIHJldHVybiBbdGhpcy5vbmxpbmVfXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY3VycmVudGx5T25saW5lKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm9ubGluZV87XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBleGNlcHRpb25HdWFyZCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC91dGlsJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGVuc3VyZXMgdGhlIHBhY2tldHMgZnJvbSB0aGUgc2VydmVyIGFycml2ZSBpbiBvcmRlclxuICogVGhpcyBjbGFzcyB0YWtlcyBkYXRhIGZyb20gdGhlIHNlcnZlciBhbmQgZW5zdXJlcyBpdCBnZXRzIHBhc3NlZCBpbnRvIHRoZSBjYWxsYmFja3MgaW4gb3JkZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIFBhY2tldFJlY2VpdmVyIHtcbiAgcGVuZGluZ1Jlc3BvbnNlczogYW55W10gPSBbXTtcbiAgY3VycmVudFJlc3BvbnNlTnVtID0gMDtcbiAgY2xvc2VBZnRlclJlc3BvbnNlID0gLTE7XG4gIG9uQ2xvc2U6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gb25NZXNzYWdlX1xuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvbk1lc3NhZ2VfOiAoYTogT2JqZWN0KSA9PiB2b2lkKSB7fVxuXG4gIGNsb3NlQWZ0ZXIocmVzcG9uc2VOdW06IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IHJlc3BvbnNlTnVtO1xuICAgIHRoaXMub25DbG9zZSA9IGNhbGxiYWNrO1xuICAgIGlmICh0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA8IHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKSB7XG4gICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVhY2ggbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXIgY29tZXMgd2l0aCBhIHJlc3BvbnNlIG51bWJlciwgYW5kIGFuIGFycmF5IG9mIGRhdGEuIFRoZSByZXNwb25zZU51bWJlclxuICAgKiBhbGxvd3MgdXMgdG8gZW5zdXJlIHRoYXQgd2UgcHJvY2VzcyB0aGVtIGluIHRoZSByaWdodCBvcmRlciwgc2luY2Ugd2UgY2FuJ3QgYmUgZ3VhcmFudGVlZCB0aGF0IGFsbFxuICAgKiBicm93c2VycyB3aWxsIHJlc3BvbmQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHJlcXVlc3RzIHdlIHNlbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlcXVlc3ROdW1cbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICAgKi9cbiAgaGFuZGxlUmVzcG9uc2UocmVxdWVzdE51bTogbnVtYmVyLCBkYXRhOiBhbnlbXSkge1xuICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlc1tyZXF1ZXN0TnVtXSA9IGRhdGE7XG4gICAgd2hpbGUgKHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV0pIHtcbiAgICAgIGNvbnN0IHRvUHJvY2VzcyA9IHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV07XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVzcG9uc2VzW3RoaXMuY3VycmVudFJlc3BvbnNlTnVtXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9Qcm9jZXNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0b1Byb2Nlc3NbaV0pIHtcbiAgICAgICAgICBleGNlcHRpb25HdWFyZCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZV8odG9Qcm9jZXNzW2ldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VycmVudFJlc3BvbnNlTnVtID09PSB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5vbkNsb3NlKSB7XG4gICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5vbkNsb3NlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKys7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgZXhlY3V0ZVdoZW5ET01SZWFkeSxcbiAgaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0LFxuICBpc1dpbmRvd3NTdG9yZUFwcCxcbiAgbG9nLFxuICBsb2dXcmFwcGVyLFxuICBMVUlER2VuZXJhdG9yLFxuICBzcGxpdFN0cmluZ0J5U2l6ZVxufSBmcm9tICcuLi9jb3JlL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBDb3VudGVkU2V0IH0gZnJvbSAnLi4vY29yZS91dGlsL0NvdW50ZWRTZXQnO1xuaW1wb3J0IHsgU3RhdHNNYW5hZ2VyIH0gZnJvbSAnLi4vY29yZS9zdGF0cy9TdGF0c01hbmFnZXInO1xuaW1wb3J0IHsgUGFja2V0UmVjZWl2ZXIgfSBmcm9tICcuL3BvbGxpbmcvUGFja2V0UmVjZWl2ZXInO1xuaW1wb3J0IHtcbiAgRk9SR0VfRE9NQUlOLFxuICBGT1JHRV9SRUYsXG4gIExBU1RfU0VTU0lPTl9QQVJBTSxcbiAgTE9OR19QT0xMSU5HLFxuICBQUk9UT0NPTF9WRVJTSU9OLFxuICBSRUZFUkVSX1BBUkFNLFxuICBUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTSxcbiAgVkVSU0lPTl9QQVJBTVxufSBmcm9tICcuL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBiYXNlNjRFbmNvZGUsIHN0cmluZ2lmeSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGlzTm9kZVNkayB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gJy4vVHJhbnNwb3J0JztcbmltcG9ydCB7IFJlcG9JbmZvIH0gZnJvbSAnLi4vY29yZS9SZXBvSW5mbyc7XG5pbXBvcnQgeyBTdGF0c0NvbGxlY3Rpb24gfSBmcm9tICcuLi9jb3JlL3N0YXRzL1N0YXRzQ29sbGVjdGlvbic7XG5cbi8vIFVSTCBxdWVyeSBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCBsb25ncG9sbGluZ1xuZXhwb3J0IGNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NUQVJUX1BBUkFNID0gJ3N0YXJ0JztcbmV4cG9ydCBjb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DTE9TRV9DT01NQU5EID0gJ2Nsb3NlJztcbmV4cG9ydCBjb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DT01NQU5EX0NCX05BTUUgPSAncExQQ29tbWFuZCc7XG5leHBvcnQgY29uc3QgRklSRUJBU0VfTE9OR1BPTExfREFUQV9DQl9OQU1FID0gJ3BSVExQQ0InO1xuZXhwb3J0IGNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNID0gJ2lkJztcbmV4cG9ydCBjb25zdCBGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTSA9ICdwdyc7XG5leHBvcnQgY29uc3QgRklSRUJBU0VfTE9OR1BPTExfU0VSSUFMX1BBUkFNID0gJ3Nlcic7XG5leHBvcnQgY29uc3QgRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU0gPSAnY2InO1xuZXhwb3J0IGNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRfTlVNX1BBUkFNID0gJ3NlZyc7XG5leHBvcnQgY29uc3QgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVFNfSU5fUEFDS0VUID0gJ3RzJztcbmV4cG9ydCBjb25zdCBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNID0gJ2QnO1xuZXhwb3J0IGNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUEFSQU0gPSAnZGlzY29ubic7XG5leHBvcnQgY29uc3QgRklSRUJBU0VfTE9OR1BPTExfRElTQ09OTl9GUkFNRV9SRVFVRVNUX1BBUkFNID0gJ2RmcmFtZSc7XG5cbi8vRGF0YSBzaXplIGNvbnN0YW50cy5cbi8vVE9ETzogUGVyZjogdGhlIG1heGltdW0gbGVuZ3RoIGFjdHVhbGx5IGRpZmZlcnMgZnJvbSBicm93c2VyIHRvIGJyb3dzZXIuXG4vLyBXZSBzaG91bGQgY2hlY2sgd2hhdCBicm93c2VyIHdlJ3JlIG9uIGFuZCBzZXQgYWNjb3JkaW5nbHkuXG5jb25zdCBNQVhfVVJMX0RBVEFfU0laRSA9IDE4NzA7XG5jb25zdCBTRUdfSEVBREVSX1NJWkUgPSAzMDsgLy9pZTogJnNlZz04Mjk5MjM0JnRzPTk4MjM4OTEyMyZkPVxuY29uc3QgTUFYX1BBWUxPQURfU0laRSA9IE1BWF9VUkxfREFUQV9TSVpFIC0gU0VHX0hFQURFUl9TSVpFO1xuXG4vKipcbiAqIEtlZXBhbGl2ZSBwZXJpb2RcbiAqIHNlbmQgYSBmcmVzaCByZXF1ZXN0IGF0IG1pbmltdW0gZXZlcnkgMjUgc2Vjb25kcy4gT3BlcmEgaGFzIGEgbWF4aW11bSByZXF1ZXN0XG4gKiBsZW5ndGggb2YgMzAgc2Vjb25kcyB0aGF0IHdlIGNhbid0IGV4Y2VlZC5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwgPSAyNTAwMDtcblxuLyoqXG4gKiBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSBhYm9ydGluZyBhIGxvbmctcG9sbGluZyBjb25uZWN0aW9uIGF0dGVtcHQuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IExQX0NPTk5FQ1RfVElNRU9VVCA9IDMwMDAwO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBhIHNpbmdsZSBsb25nLXBvbGxpbmcgY29ubmVjdGlvbi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtUcmFuc3BvcnR9XG4gKi9cbmV4cG9ydCBjbGFzcyBCcm93c2VyUG9sbENvbm5lY3Rpb24gaW1wbGVtZW50cyBUcmFuc3BvcnQge1xuICBieXRlc1NlbnQgPSAwO1xuICBieXRlc1JlY2VpdmVkID0gMDtcbiAgdXJsRm46IChwYXJhbXM6IG9iamVjdCkgPT4gc3RyaW5nO1xuICBzY3JpcHRUYWdIb2xkZXI6IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyO1xuICBteURpc2Nvbm5GcmFtZTogSFRNTElGcmFtZUVsZW1lbnQ7XG4gIGN1clNlZ21lbnROdW06IG51bWJlcjtcbiAgbXlQYWNrZXRPcmRlcmVyOiBQYWNrZXRSZWNlaXZlcjtcbiAgaWQ6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgcHJpdmF0ZSBsb2dfOiAoLi4uYTogYW55W10pID0+IHZvaWQ7XG4gIHByaXZhdGUgc3RhdHNfOiBTdGF0c0NvbGxlY3Rpb247XG4gIHByaXZhdGUgZXZlckNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgcHJpdmF0ZSBpc0Nsb3NlZF86IGJvb2xlYW47XG4gIHByaXZhdGUgY29ubmVjdFRpbWVvdXRUaW1lcl86IG51bWJlciB8IG51bGw7XG4gIHByaXZhdGUgb25EaXNjb25uZWN0XzogKChhPzogYm9vbGVhbikgPT4gdm9pZCkgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29ubklkIEFuIGlkZW50aWZpZXIgZm9yIHRoaXMgY29ubmVjdGlvbiwgdXNlZCBmb3IgbG9nZ2luZ1xuICAgKiBAcGFyYW0ge1JlcG9JbmZvfSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbmlkIGlmIHdlIGFyZSByZWNvbm5lY3RpbmcgZm9yIGFuIGV4aXN0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQgc2Vzc2lvblxuICAgKiBAcGFyYW0ge3N0cmluZz19ICBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlIFBlcnNpc3RlbnRDb25uZWN0aW9uIGhhcyBhbHJlYWR5IGNyZWF0ZWQgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uIHByZXZpb3VzbHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjb25uSWQ6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVwb0luZm86IFJlcG9JbmZvLFxuICAgIHB1YmxpYyB0cmFuc3BvcnRTZXNzaW9uSWQ/OiBzdHJpbmcsXG4gICAgcHVibGljIGxhc3RTZXNzaW9uSWQ/OiBzdHJpbmdcbiAgKSB7XG4gICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcihjb25uSWQpO1xuICAgIHRoaXMuc3RhdHNfID0gU3RhdHNNYW5hZ2VyLmdldENvbGxlY3Rpb24ocmVwb0luZm8pO1xuICAgIHRoaXMudXJsRm4gPSAocGFyYW1zOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSkgPT5cbiAgICAgIHJlcG9JbmZvLmNvbm5lY3Rpb25VUkwoTE9OR19QT0xMSU5HLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KX0gb25NZXNzYWdlIENhbGxiYWNrIHdoZW4gbWVzc2FnZXMgYXJyaXZlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gb25EaXNjb25uZWN0IENhbGxiYWNrIHdpdGggY29ubmVjdGlvbiBsb3N0LlxuICAgKi9cbiAgb3Blbihvbk1lc3NhZ2U6IChtc2c6IE9iamVjdCkgPT4gdm9pZCwgb25EaXNjb25uZWN0OiAoYT86IGJvb2xlYW4pID0+IHZvaWQpIHtcbiAgICB0aGlzLmN1clNlZ21lbnROdW0gPSAwO1xuICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG9uRGlzY29ubmVjdDtcbiAgICB0aGlzLm15UGFja2V0T3JkZXJlciA9IG5ldyBQYWNrZXRSZWNlaXZlcihvbk1lc3NhZ2UpO1xuICAgIHRoaXMuaXNDbG9zZWRfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmxvZ18oJ1RpbWVkIG91dCB0cnlpbmcgdG8gY29ubmVjdC4nKTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciB0aGUgaG9zdCBjYWNoZVxuICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xuICAgIH0sIE1hdGguZmxvb3IoTFBfQ09OTkVDVF9USU1FT1VUKSkgYXMgYW55O1xuXG4gICAgLy8gRW5zdXJlIHdlIGRlbGF5IHRoZSBjcmVhdGlvbiBvZiB0aGUgaWZyYW1lIHVudGlsIHRoZSBET00gaXMgbG9hZGVkLlxuICAgIGV4ZWN1dGVXaGVuRE9NUmVhZHkoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNDbG9zZWRfKSByZXR1cm47XG5cbiAgICAgIC8vU2V0IHVwIGEgY2FsbGJhY2sgdGhhdCBnZXRzIHRyaWdnZXJlZCBvbmNlIGEgY29ubmVjdGlvbiBpcyBzZXQgdXAuXG4gICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlciA9IG5ldyBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlcihcbiAgICAgICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBbY29tbWFuZCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNF0gPSBhcmdzO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50SW5jb21pbmdCeXRlc18oYXJncyk7XG4gICAgICAgICAgaWYgKCF0aGlzLnNjcmlwdFRhZ0hvbGRlcikgcmV0dXJuOyAvLyB3ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24uXG5cbiAgICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSB0cnVlO1xuICAgICAgICAgIGlmIChjb21tYW5kID09IEZJUkVCQVNFX0xPTkdQT0xMX1NUQVJUX1BBUkFNKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gYXJnMTtcbiAgICAgICAgICAgIHRoaXMucGFzc3dvcmQgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gRklSRUJBU0VfTE9OR1BPTExfQ0xPU0VfQ09NTUFORCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY2xlYXIgdGhlIGhvc3QgY2FjaGUuIFdlIGdvdCBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciwgc28gd2Uga25vdyBpdCdzIHJlYWNoYWJsZVxuICAgICAgICAgICAgaWYgKGFyZzEpIHtcbiAgICAgICAgICAgICAgLy8gV2UgYXJlbid0IGV4cGVjdGluZyBhbnkgbW9yZSBkYXRhIChvdGhlciB0aGFuIHdoYXQgdGhlIHNlcnZlcidzIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2Ygc2VuZGluZyB1c1xuICAgICAgICAgICAgICAvLyB0aHJvdWdoIG91ciBhbHJlYWR5IG9wZW4gcG9sbHMpLCBzbyBkb24ndCBzZW5kIGFueSBtb3JlLlxuICAgICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAvLyBhcmcxIGluIHRoaXMgY2FzZSBpcyB0aGUgbGFzdCByZXNwb25zZSBudW1iZXIgc2VudCBieSB0aGUgc2VydmVyLiBXZSBzaG91bGQgdHJ5IHRvIHJlY2VpdmVcbiAgICAgICAgICAgICAgLy8gYWxsIG9mIHRoZSByZXNwb25zZXMgdXAgdG8gdGhpcyBvbmUgYmVmb3JlIGNsb3NpbmdcbiAgICAgICAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIuY2xvc2VBZnRlcihhcmcxLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBjb21tYW5kIHJlY2VpdmVkOiAnICsgY29tbWFuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIGNvbnN0IFtwTiwgZGF0YV0gPSBhcmdzO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50SW5jb21pbmdCeXRlc18oYXJncyk7XG4gICAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIuaGFuZGxlUmVzcG9uc2UocE4sIGRhdGEpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy51cmxGblxuICAgICAgKTtcblxuICAgICAgLy9TZW5kIHRoZSBpbml0aWFsIHJlcXVlc3QgdG8gY29ubmVjdC4gVGhlIHNlcmlhbCBudW1iZXIgaXMgc2ltcGx5IHRvIGtlZXAgdGhlIGJyb3dzZXIgZnJvbSBwdWxsaW5nIHByZXZpb3VzIHJlc3VsdHNcbiAgICAgIC8vZnJvbSBjYWNoZS5cbiAgICAgIGNvbnN0IHVybFBhcmFtczogeyBbazogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIH0gPSB7fTtcbiAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTV0gPSAndCc7XG4gICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfU0VSSUFMX1BBUkFNXSA9IE1hdGguZmxvb3IoXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDBcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5zY3JpcHRUYWdIb2xkZXIudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyKVxuICAgICAgICB1cmxQYXJhbXNbXG4gICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU1cbiAgICAgICAgXSA9IHRoaXMuc2NyaXB0VGFnSG9sZGVyLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcjtcbiAgICAgIHVybFBhcmFtc1tWRVJTSU9OX1BBUkFNXSA9IFBST1RPQ09MX1ZFUlNJT047XG4gICAgICBpZiAodGhpcy50cmFuc3BvcnRTZXNzaW9uSWQpIHtcbiAgICAgICAgdXJsUGFyYW1zW1RSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IHRoaXMudHJhbnNwb3J0U2Vzc2lvbklkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGFzdFNlc3Npb25JZCkge1xuICAgICAgICB1cmxQYXJhbXNbTEFTVF9TRVNTSU9OX1BBUkFNXSA9IHRoaXMubGFzdFNlc3Npb25JZDtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgIWlzTm9kZVNkaygpICYmXG4gICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgbG9jYXRpb24uaHJlZiAmJlxuICAgICAgICBsb2NhdGlvbi5ocmVmLmluZGV4T2YoRk9SR0VfRE9NQUlOKSAhPT0gLTFcbiAgICAgICkge1xuICAgICAgICB1cmxQYXJhbXNbUkVGRVJFUl9QQVJBTV0gPSBGT1JHRV9SRUY7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25uZWN0VVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xuICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW5nIHZpYSBsb25nLXBvbGwgdG8gJyArIGNvbm5lY3RVUkwpO1xuICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuYWRkVGFnKGNvbm5lY3RVUkwsICgpID0+IHtcbiAgICAgICAgLyogZG8gbm90aGluZyAqL1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCB0aGlzIHdoZW4gYSBoYW5kc2hha2UgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgYW5kIHdlIHdhbnQgdG8gY29uc2lkZXIgdGhlIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWRcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLnN0YXJ0TG9uZ1BvbGwodGhpcy5pZCwgdGhpcy5wYXNzd29yZCk7XG4gICAgdGhpcy5hZGREaXNjb25uZWN0UGluZ0ZyYW1lKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZm9yY2VBbGxvd186IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBsb25nIHBvbGxpbmcgdG8gYmUgY29uc2lkZXJlZCBhcyBhIHBvdGVudGlhbCB0cmFuc3BvcnRcbiAgICovXG4gIHN0YXRpYyBmb3JjZUFsbG93KCkge1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93XyA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBmb3JjZURpc2FsbG93XzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRm9yY2VzIGxvbmdwb2xsaW5nIHRvIG5vdCBiZSBjb25zaWRlcmVkIGFzIGEgcG90ZW50aWFsIHRyYW5zcG9ydFxuICAgKi9cbiAgc3RhdGljIGZvcmNlRGlzYWxsb3coKSB7XG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFN0YXRpYyBtZXRob2QsIHVzZSBzdHJpbmcgbGl0ZXJhbCBzbyBpdCBjYW4gYmUgYWNjZXNzZWQgaW4gYSBnZW5lcmljIHdheVxuICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgLy8gTk9URTogSW4gUmVhY3QtTmF0aXZlIHRoZXJlJ3Mgbm9ybWFsbHkgbm8gJ2RvY3VtZW50JywgYnV0IGlmIHlvdSBkZWJ1ZyBhIFJlYWN0LU5hdGl2ZSBhcHAgaW5cbiAgICAvLyB0aGUgQ2hyb21lIGRlYnVnZ2VyLCAnZG9jdW1lbnQnIGlzIGRlZmluZWQsIGJ1dCBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzIG51bGwgKDIwMTUvMDYvMDgpLlxuICAgIHJldHVybiAoXG4gICAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18gfHxcbiAgICAgICghQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfICYmXG4gICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPSBudWxsICYmXG4gICAgICAgICFpc0Nocm9tZUV4dGVuc2lvbkNvbnRlbnRTY3JpcHQoKSAmJlxuICAgICAgICAhaXNXaW5kb3dzU3RvcmVBcHAoKSAmJlxuICAgICAgICAhaXNOb2RlU2RrKCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOby1vcCBmb3IgcG9sbGluZ1xuICAgKi9cbiAgbWFya0Nvbm5lY3Rpb25IZWFsdGh5KCkge31cblxuICAvKipcbiAgICogU3RvcHMgcG9sbGluZyBhbmQgY2xlYW5zIHVwIHRoZSBpZnJhbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc2h1dGRvd25fKCkge1xuICAgIHRoaXMuaXNDbG9zZWRfID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnNjcmlwdFRhZ0hvbGRlcikge1xuICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuY2xvc2UoKTtcbiAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICAvL3JlbW92ZSB0aGUgZGlzY29ubmVjdCBmcmFtZSwgd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIFhIUiBjYWxsIHRvIHRoZSBzZXJ2ZXIgdG8gdGVsbCBpdCB3ZSdyZSBsZWF2aW5nLlxuICAgIGlmICh0aGlzLm15RGlzY29ubkZyYW1lKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubXlEaXNjb25uRnJhbWUpO1xuICAgICAgdGhpcy5teURpc2Nvbm5GcmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKTtcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGlzIHRyYW5zcG9ydCBpcyBjbG9zZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgb25DbG9zZWRfKCkge1xuICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcbiAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgY2xvc2luZyBpdHNlbGYnKTtcbiAgICAgIHRoaXMuc2h1dGRvd25fKCk7XG5cbiAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdF8pIHtcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKHRoaXMuZXZlckNvbm5lY3RlZF8pO1xuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlcm5hbC1mYWNpbmcgY2xvc2UgaGFuZGxlci4gUmVhbFRpbWUgaGFzIHJlcXVlc3RlZCB3ZSBzaHV0IGRvd24uIEtpbGwgb3VyIGNvbm5lY3Rpb24gYW5kIHRlbGwgdGhlIHNlcnZlclxuICAgKiB0aGF0IHdlJ3ZlIGxlZnQuXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XG4gICAgICB0aGlzLmxvZ18oJ0xvbmdwb2xsIGlzIGJlaW5nIGNsb3NlZC4nKTtcbiAgICAgIHRoaXMuc2h1dGRvd25fKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgdGhlIEpTT04gb2JqZWN0IGRvd24gdG8gdGhlIHNlcnZlci4gSXQgd2lsbCBuZWVkIHRvIGJlIHN0cmluZ2lmaWVkLCBiYXNlNjQgZW5jb2RlZCwgYW5kIHRoZW5cbiAgICogYnJva2VuIGludG8gY2h1bmtzIChzaW5jZSBVUkxzIGhhdmUgYSBzbWFsbCBtYXhpbXVtIGxlbmd0aCkuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YSBUaGUgSlNPTiBkYXRhIHRvIHRyYW5zbWl0LlxuICAgKi9cbiAgc2VuZChkYXRhOiBPYmplY3QpIHtcbiAgICBjb25zdCBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xuICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xuICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XG5cbiAgICAvL2ZpcnN0LCBsZXRzIGdldCB0aGUgYmFzZTY0LWVuY29kZWQgZGF0YVxuICAgIGNvbnN0IGJhc2U2NGRhdGEgPSBiYXNlNjRFbmNvZGUoZGF0YVN0cik7XG5cbiAgICAvL1dlIGNhbiBvbmx5IGZpdCBhIGNlcnRhaW4gYW1vdW50IGluIGVhY2ggVVJMLCBzbyB3ZSBuZWVkIHRvIHNwbGl0IHRoaXMgcmVxdWVzdFxuICAgIC8vdXAgaW50byBtdWx0aXBsZSBwaWVjZXMgaWYgaXQgZG9lc24ndCBmaXQgaW4gb25lIHJlcXVlc3QuXG4gICAgY29uc3QgZGF0YVNlZ3MgPSBzcGxpdFN0cmluZ0J5U2l6ZShiYXNlNjRkYXRhLCBNQVhfUEFZTE9BRF9TSVpFKTtcblxuICAgIC8vRW5xdWV1ZSBlYWNoIHNlZ21lbnQgZm9yIHRyYW5zbWlzc2lvbi4gV2UgYXNzaWduIGVhY2ggY2h1bmsgYSBzZXF1ZW50aWFsIElEIGFuZCBhIHRvdGFsIG51bWJlclxuICAgIC8vb2Ygc2VnbWVudHMgc28gdGhhdCB3ZSBjYW4gcmVhc3NlbWJsZSB0aGUgcGFja2V0IG9uIHRoZSBzZXJ2ZXIuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhU2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuZW5xdWV1ZVNlZ21lbnQoXG4gICAgICAgIHRoaXMuY3VyU2VnbWVudE51bSxcbiAgICAgICAgZGF0YVNlZ3MubGVuZ3RoLFxuICAgICAgICBkYXRhU2Vnc1tpXVxuICAgICAgKTtcbiAgICAgIHRoaXMuY3VyU2VnbWVudE51bSsrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGhvdyB3ZSBub3RpZnkgdGhlIHNlcnZlciB0aGF0IHdlJ3JlIGxlYXZpbmcuXG4gICAqIFdlIGFyZW4ndCBhYmxlIHRvIHNlbmQgcmVxdWVzdHMgd2l0aCBESFRNTCBvbiBhIHdpbmRvdyBjbG9zZSBldmVudCwgYnV0IHdlIGNhblxuICAgKiB0cmlnZ2VyIFhIUiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzIChldmVyeXRoaW5nIGJ1dCBPcGVyYSBiYXNpY2FsbHkpLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGlkXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcHdcbiAgICovXG4gIGFkZERpc2Nvbm5lY3RQaW5nRnJhbWUoaWQ6IHN0cmluZywgcHc6IHN0cmluZykge1xuICAgIGlmIChpc05vZGVTZGsoKSkgcmV0dXJuO1xuICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjb25zdCB1cmxQYXJhbXM6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTV0gPSAndCc7XG4gICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IGlkO1xuICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSBwdztcbiAgICB0aGlzLm15RGlzY29ubkZyYW1lLnNyYyA9IHRoaXMudXJsRm4odXJsUGFyYW1zKTtcbiAgICB0aGlzLm15RGlzY29ubkZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubXlEaXNjb25uRnJhbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gdHJhY2sgdGhlIGJ5dGVzIHJlY2VpdmVkIGJ5IHRoaXMgY2xpZW50XG4gICAqIEBwYXJhbSB7Kn0gYXJnc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBpbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzOiBhbnkpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGFuIGFubm95aW5nIHBlcmYgaGl0IGp1c3QgdG8gdHJhY2sgdGhlIG51bWJlciBvZiBpbmNvbWluZyBieXRlcy4gIE1heWJlIGl0IHNob3VsZCBiZSBvcHQtaW4uXG4gICAgY29uc3QgYnl0ZXNSZWNlaXZlZCA9IHN0cmluZ2lmeShhcmdzKS5sZW5ndGg7XG4gICAgdGhpcy5ieXRlc1JlY2VpdmVkICs9IGJ5dGVzUmVjZWl2ZWQ7XG4gICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfcmVjZWl2ZWQnLCBieXRlc1JlY2VpdmVkKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGcmFtZUVsZW1lbnQgZXh0ZW5kcyBIVE1MSUZyYW1lRWxlbWVudCB7XG4gIGRvYzogRG9jdW1lbnQ7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYW4gaWZyYW1lIHRoYXQgaXMgdXNlZCBhcyBhIGxvbmctcG9sbGluZyBzY3JpcHQgaG9sZGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGNsYXNzIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyIHtcbiAgLy9XZSBtYWludGFpbiBhIGNvdW50IG9mIGFsbCBvZiB0aGUgb3V0c3RhbmRpbmcgcmVxdWVzdHMsIGJlY2F1c2UgaWYgd2UgaGF2ZSB0b28gbWFueSBhY3RpdmUgYXQgb25jZSBpdCBjYW4gY2F1c2VcbiAgLy9wcm9ibGVtcyBpbiBzb21lIGJyb3dzZXJzLlxuICAvKipcbiAgICogQHR5cGUge0NvdW50ZWRTZXQuPG51bWJlciwgbnVtYmVyPn1cbiAgICovXG4gIG91dHN0YW5kaW5nUmVxdWVzdHMgPSBuZXcgQ291bnRlZFNldDxudW1iZXIsIG51bWJlcj4oKTtcblxuICAvL0EgcXVldWUgb2YgdGhlIHBlbmRpbmcgc2VnbWVudHMgd2FpdGluZyBmb3IgdHJhbnNtaXNzaW9uIHRvIHRoZSBzZXJ2ZXIuXG4gIHBlbmRpbmdTZWdzOiB7IHNlZzogbnVtYmVyOyB0czogbnVtYmVyOyBkOiBhbnkgfVtdID0gW107XG5cbiAgLy9BIHNlcmlhbCBudW1iZXIuIFdlIHVzZSB0aGlzIGZvciB0d28gdGhpbmdzOlxuICAvLyAxKSBBIHdheSB0byBlbnN1cmUgdGhlIGJyb3dzZXIgZG9lc24ndCBjYWNoZSByZXNwb25zZXMgdG8gcG9sbHNcbiAgLy8gMikgQSB3YXkgdG8gbWFrZSB0aGUgc2VydmVyIGF3YXJlIHdoZW4gbG9uZy1wb2xscyBhcnJpdmUgaW4gYSBkaWZmZXJlbnQgb3JkZXIgdGhhbiB3ZSBzdGFydGVkIHRoZW0uIFRoZVxuICAvLyAgICBzZXJ2ZXIgbmVlZHMgdG8gcmVsZWFzZSBib3RoIHBvbGxzIGluIHRoaXMgY2FzZSBvciBpdCB3aWxsIGNhdXNlIHByb2JsZW1zIGluIE9wZXJhIHNpbmNlIE9wZXJhIGNhbiBvbmx5IGV4ZWN1dGVcbiAgLy8gICAgSlNPTlAgY29kZSBpbiB0aGUgb3JkZXIgaXQgd2FzIGFkZGVkIHRvIHRoZSBpZnJhbWUuXG4gIGN1cnJlbnRTZXJpYWwgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xuXG4gIC8vIFRoaXMgZ2V0cyBzZXQgdG8gZmFsc2Ugd2hlbiB3ZSdyZSBcImNsb3NpbmcgZG93blwiIHRoZSBjb25uZWN0aW9uIChlLmcuIHdlJ3JlIHN3aXRjaGluZyB0cmFuc3BvcnRzIGJ1dCB0aGVyZSdzIHN0aWxsXG4gIC8vIGluY29taW5nIGRhdGEgZnJvbSB0aGUgc2VydmVyIHRoYXQgd2UncmUgd2FpdGluZyBmb3IpLlxuICBzZW5kTmV3UG9sbHMgPSB0cnVlO1xuXG4gIHVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcjogbnVtYmVyO1xuICBteUlGcmFtZTogSUZyYW1lRWxlbWVudDtcbiAgYWxpdmU6IGJvb2xlYW47XG4gIG15SUQ6IHN0cmluZztcbiAgbXlQVzogc3RyaW5nO1xuICBjb21tYW5kQ0I6IChjb21tYW5kOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkO1xuICBvbk1lc3NhZ2VDQjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gY29tbWFuZENCIC0gVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIGNvbnRyb2wgY29tbWFuZHMgYXJlIHJlY2V2aWVkIGZyb20gdGhlIHNlcnZlci5cbiAgICogQHBhcmFtIG9uTWVzc2FnZUNCIC0gVGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHJlc3BvbnNlcyBhcnJpdmUgZnJvbSB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0gb25EaXNjb25uZWN0IC0gVGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgdGFnIGhvbGRlciBpcyBjbG9zZWRcbiAgICogQHBhcmFtIHVybEZuIC0gQSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBVUkwgb2YgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNvbW1hbmRDQjogKGNvbW1hbmQ6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IHZvaWQsXG4gICAgb25NZXNzYWdlQ0I6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCxcbiAgICBwdWJsaWMgb25EaXNjb25uZWN0OiAoKSA9PiB2b2lkLFxuICAgIHB1YmxpYyB1cmxGbjogKGE6IG9iamVjdCkgPT4gc3RyaW5nXG4gICkge1xuICAgIGlmICghaXNOb2RlU2RrKCkpIHtcbiAgICAgIC8vRWFjaCBzY3JpcHQgaG9sZGVyIHJlZ2lzdGVycyBhIGNvdXBsZSBvZiB1bmlxdWVseSBuYW1lZCBjYWxsYmFja3Mgd2l0aCB0aGUgd2luZG93LiBUaGVzZSBhcmUgY2FsbGVkIGZyb20gdGhlXG4gICAgICAvL2lmcmFtZXMgd2hlcmUgd2UgcHV0IHRoZSBsb25nLXBvbGxpbmcgc2NyaXB0IHRhZ3MuIFdlIGhhdmUgdHdvIGNhbGxiYWNrczpcbiAgICAgIC8vICAgMSkgQ29tbWFuZCBDYWxsYmFjayAtIFRyaWdnZXJlZCBmb3IgY29udHJvbCBpc3N1ZXMsIGxpa2Ugc3RhcnRpbmcgYSBjb25uZWN0aW9uLlxuICAgICAgLy8gICAyKSBNZXNzYWdlIENhbGxiYWNrIC0gVHJpZ2dlcmVkIHdoZW4gbmV3IGRhdGEgYXJyaXZlcy5cbiAgICAgIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyID0gTFVJREdlbmVyYXRvcigpO1xuICAgICAgKHdpbmRvdyBhcyBhbnkpW1xuICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9DT01NQU5EX0NCX05BTUUgKyB0aGlzLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllclxuICAgICAgXSA9IGNvbW1hbmRDQjtcbiAgICAgICh3aW5kb3cgYXMgYW55KVtcbiAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfREFUQV9DQl9OQU1FICsgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXJcbiAgICAgIF0gPSBvbk1lc3NhZ2VDQjtcblxuICAgICAgLy9DcmVhdGUgYW4gaWZyYW1lIGZvciB1cyB0byBhZGQgc2NyaXB0IHRhZ3MgdG8uXG4gICAgICB0aGlzLm15SUZyYW1lID0gRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIuY3JlYXRlSUZyYW1lXygpO1xuXG4gICAgICAvLyBTZXQgdGhlIGlmcmFtZSdzIGNvbnRlbnRzLlxuICAgICAgbGV0IHNjcmlwdCA9ICcnO1xuICAgICAgLy8gaWYgd2Ugc2V0IGEgamF2YXNjcmlwdCB1cmwsIGl0J3MgSUUgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZSBkb2N1bWVudCBkb21haW4uIFRoZSBqYXZhc2NyaXB0IHVybCBpcyBzdWZmaWNpZW50XG4gICAgICAvLyBmb3IgaWU5LCBidXQgaWU4IG5lZWRzIHRvIGRvIGl0IGFnYWluIGluIHRoZSBkb2N1bWVudCBpdHNlbGYuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubXlJRnJhbWUuc3JjICYmXG4gICAgICAgIHRoaXMubXlJRnJhbWUuc3JjLnN1YnN0cigwLCAnamF2YXNjcmlwdDonLmxlbmd0aCkgPT09ICdqYXZhc2NyaXB0OidcbiAgICAgICkge1xuICAgICAgICBjb25zdCBjdXJyZW50RG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xuICAgICAgICBzY3JpcHQgPSAnPHNjcmlwdD5kb2N1bWVudC5kb21haW49XCInICsgY3VycmVudERvbWFpbiArICdcIjs8L3NjcmlwdD4nO1xuICAgICAgfVxuICAgICAgY29uc3QgaWZyYW1lQ29udGVudHMgPSAnPGh0bWw+PGJvZHk+JyArIHNjcmlwdCArICc8L2JvZHk+PC9odG1sPic7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5vcGVuKCk7XG4gICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLndyaXRlKGlmcmFtZUNvbnRlbnRzKTtcbiAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuY2xvc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nKCdmcmFtZSB3cml0aW5nIGV4Y2VwdGlvbicpO1xuICAgICAgICBpZiAoZS5zdGFjaykge1xuICAgICAgICAgIGxvZyhlLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBsb2coZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWFuZENCID0gY29tbWFuZENCO1xuICAgICAgdGhpcy5vbk1lc3NhZ2VDQiA9IG9uTWVzc2FnZUNCO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFYWNoIGJyb3dzZXIgaGFzIGl0cyBvd24gZnVubnkgd2F5IHRvIGhhbmRsZSBpZnJhbWVzLiBIZXJlIHdlIG11c2ggdGhlbSBhbGwgdG9nZXRoZXIgaW50byBvbmUgb2JqZWN0IHRoYXQgSSBjYW5cbiAgICogYWN0dWFsbHkgdXNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlSUZyYW1lXygpOiBJRnJhbWVFbGVtZW50IHtcbiAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKSBhcyBJRnJhbWVFbGVtZW50O1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gaW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnQgaW5zaWRlIHRoZSBpZnJhbWVcbiAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIG1vZGlmaWVkIGluIElFLCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IsIGFuZCB3ZSBuZWVkIHRvIHNldCB0aGVcbiAgICAgICAgLy8gZG9tYWluIG9mIHRoZSBpZnJhbWUncyBkb2N1bWVudCBtYW51YWxseS4gV2UgY2FuIGRvIHRoaXMgdmlhIGEgamF2YXNjcmlwdDogdXJsIGFzIHRoZSBzcmMgYXR0cmlidXRlXG4gICAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHdlIG11c3QgZG8gdGhpcyAqYWZ0ZXIqIHRoZSBpZnJhbWUgaGFzIGJlZW4gYXBwZW5kZWQgdG8gdGhlIHBhZ2UuIE90aGVyd2lzZSBpdCBkb2Vzbid0IHdvcmsuXG4gICAgICAgIGNvbnN0IGEgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgLy8gQXBvbG9naWVzIGZvciB0aGUgbG9nLXNwYW0sIEkgbmVlZCB0byBkbyBzb21ldGhpbmcgdG8ga2VlcCBjbG9zdXJlIGZyb20gb3B0aW1pemluZyBvdXQgdGhlIGFzc2lnbm1lbnQgYWJvdmUuXG4gICAgICAgICAgbG9nKCdObyBJRSBkb21haW4gc2V0dGluZyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGRvY3VtZW50LmRvbWFpbjtcbiAgICAgICAgaWZyYW1lLnNyYyA9XG4gICAgICAgICAgXCJqYXZhc2NyaXB0OnZvaWQoKGZ1bmN0aW9uKCl7ZG9jdW1lbnQub3BlbigpO2RvY3VtZW50LmRvbWFpbj0nXCIgK1xuICAgICAgICAgIGRvbWFpbiArXG4gICAgICAgICAgXCInO2RvY3VtZW50LmNsb3NlKCk7fSkoKSlcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTG9uZ1BvbGxDb25uZWN0aW9uIGF0dGVtcHRzIHRvIGRlbGF5IGluaXRpYWxpemF0aW9uIHVudGlsIHRoZSBkb2N1bWVudCBpcyByZWFkeSwgc28gaG9wZWZ1bGx5IHRoaXNcbiAgICAgIC8vIG5ldmVyIGdldHMgaGl0LlxuICAgICAgdGhyb3cgJ0RvY3VtZW50IGJvZHkgaGFzIG5vdCBpbml0aWFsaXplZC4gV2FpdCB0byBpbml0aWFsaXplIEZpcmViYXNlIHVudGlsIGFmdGVyIHRoZSBkb2N1bWVudCBpcyByZWFkeS4nO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgZG9jdW1lbnQgb2YgdGhlIGlmcmFtZSBpbiBhIGJyb3dzZXItc3BlY2lmaWMgd2F5LlxuICAgIGlmIChpZnJhbWUuY29udGVudERvY3VtZW50KSB7XG4gICAgICAoaWZyYW1lIGFzIGFueSkuZG9jID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudDsgLy8gRmlyZWZveCwgT3BlcmEsIFNhZmFyaVxuICAgIH0gZWxzZSBpZiAoaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgIChpZnJhbWUgYXMgYW55KS5kb2MgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsgLy8gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICB9IGVsc2UgaWYgKChpZnJhbWUgYXMgYW55KS5kb2N1bWVudCkge1xuICAgICAgKGlmcmFtZSBhcyBhbnkpLmRvYyA9IChpZnJhbWUgYXMgYW55KS5kb2N1bWVudDsgLy9vdGhlcnM/XG4gICAgfVxuXG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYWxsIG91dHN0YW5kaW5nIHF1ZXJpZXMgYW5kIHJlbW92ZSB0aGUgZnJhbWUuXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICAvL01hcmsgdGhpcyBpZnJhbWUgYXMgZGVhZCwgc28gbm8gbmV3IHJlcXVlc3RzIGFyZSBzZW50LlxuICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLm15SUZyYW1lKSB7XG4gICAgICAvL1dlIGhhdmUgdG8gYWN0dWFsbHkgcmVtb3ZlIGFsbCBvZiB0aGUgaHRtbCBpbnNpZGUgdGhpcyBpZnJhbWUgYmVmb3JlIHJlbW92aW5nIGl0IGZyb20gdGhlXG4gICAgICAvL3dpbmRvdywgb3IgSUUgd2lsbCBjb250aW51ZSBsb2FkaW5nIGFuZCBleGVjdXRpbmcgdGhlIHNjcmlwdCB0YWdzIHdlJ3ZlIGFscmVhZHkgYWRkZWQsIHdoaWNoXG4gICAgICAvL2NhbiBsZWFkIHRvIHNvbWUgZXJyb3JzIGJlaW5nIHRocm93bi4gU2V0dGluZyBpbm5lckhUTUwgc2VlbXMgdG8gYmUgdGhlIGVhc2llc3Qgd2F5IHRvIGRvIHRoaXMuXG4gICAgICB0aGlzLm15SUZyYW1lLmRvYy5ib2R5LmlubmVySFRNTCA9ICcnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm15SUZyYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm15SUZyYW1lKTtcbiAgICAgICAgICB0aGlzLm15SUZyYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTm9kZVNkaygpICYmIHRoaXMubXlJRCkge1xuICAgICAgY29uc3QgdXJsUGFyYW1zOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUEFSQU1dID0gJ3QnO1xuICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IHRoaXMubXlJRDtcbiAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSB0aGlzLm15UFc7XG4gICAgICBjb25zdCB0aGVVUkwgPSB0aGlzLnVybEZuKHVybFBhcmFtcyk7XG4gICAgICAoRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIgYXMgYW55KS5ub2RlUmVzdFJlcXVlc3QodGhlVVJMKTtcbiAgICB9XG5cbiAgICAvLyBQcm90ZWN0IGZyb20gYmVpbmcgY2FsbGVkIHJlY3Vyc2l2ZWx5LlxuICAgIGNvbnN0IG9uRGlzY29ubmVjdCA9IHRoaXMub25EaXNjb25uZWN0O1xuICAgIGlmIChvbkRpc2Nvbm5lY3QpIHtcbiAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcbiAgICAgIG9uRGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY3R1YWxseSBzdGFydCB0aGUgbG9uZy1wb2xsaW5nIHNlc3Npb24gYnkgYWRkaW5nIHRoZSBmaXJzdCBzY3JpcHQgdGFnKHMpIHRvIHRoZSBpZnJhbWUuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBUaGUgSUQgb2YgdGhpcyBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcHcgLSBUaGUgcGFzc3dvcmQgZm9yIHRoaXMgY29ubmVjdGlvblxuICAgKi9cbiAgc3RhcnRMb25nUG9sbChpZDogc3RyaW5nLCBwdzogc3RyaW5nKSB7XG4gICAgdGhpcy5teUlEID0gaWQ7XG4gICAgdGhpcy5teVBXID0gcHc7XG4gICAgdGhpcy5hbGl2ZSA9IHRydWU7XG5cbiAgICAvL3NlbmQgdGhlIGluaXRpYWwgcmVxdWVzdC4gSWYgdGhlcmUgYXJlIHJlcXVlc3RzIHF1ZXVlZCwgbWFrZSBzdXJlIHRoYXQgd2UgdHJhbnNtaXQgYXMgbWFueSBhcyB3ZSBhcmUgY3VycmVudGx5IGFibGUgdG8uXG4gICAgd2hpbGUgKHRoaXMubmV3UmVxdWVzdF8oKSkge31cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGNhbGxlZCBhbnkgdGltZSBzb21lb25lIG1pZ2h0IHdhbnQgYSBzY3JpcHQgdGFnIHRvIGJlIGFkZGVkLiBJdCBhZGRzIGEgc2NyaXB0IHRhZyB3aGVuIHRoZXJlIGFyZW4ndFxuICAgKiB0b28gbWFueSBvdXRzdGFuZGluZyByZXF1ZXN0cyBhbmQgd2UgYXJlIHN0aWxsIGFsaXZlLlxuICAgKlxuICAgKiBJZiB0aGVyZSBhcmUgb3V0c3RhbmRpbmcgcGFja2V0IHNlZ21lbnRzIHRvIHNlbmQsIGl0IHNlbmRzIG9uZS4gSWYgdGhlcmUgYXJlbid0LCBpdCBzZW5kcyBhIGxvbmctcG9sbCBhbnl3YXlzIGlmXG4gICAqIG5lZWRlZC5cbiAgICovXG4gIHByaXZhdGUgbmV3UmVxdWVzdF8oKSB7XG4gICAgLy8gV2Uga2VlcCBvbmUgb3V0c3RhbmRpbmcgcmVxdWVzdCBvcGVuIGFsbCB0aGUgdGltZSB0byByZWNlaXZlIGRhdGEsIGJ1dCBpZiB3ZSBuZWVkIHRvIHNlbmQgZGF0YVxuICAgIC8vIChwZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB0aGVuIHdlIGNyZWF0ZSBhIG5ldyByZXF1ZXN0IHRvIHNlbmQgdGhlIGRhdGEuICBUaGUgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseVxuICAgIC8vIGNsb3NlIHRoZSBvbGQgcmVxdWVzdC5cbiAgICBpZiAoXG4gICAgICB0aGlzLmFsaXZlICYmXG4gICAgICB0aGlzLnNlbmROZXdQb2xscyAmJlxuICAgICAgdGhpcy5vdXRzdGFuZGluZ1JlcXVlc3RzLmNvdW50KCkgPCAodGhpcy5wZW5kaW5nU2Vncy5sZW5ndGggPiAwID8gMiA6IDEpXG4gICAgKSB7XG4gICAgICAvL2NvbnN0cnVjdCBvdXIgdXJsXG4gICAgICB0aGlzLmN1cnJlbnRTZXJpYWwrKztcbiAgICAgIGNvbnN0IHVybFBhcmFtczogeyBbazogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIH0gPSB7fTtcbiAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTV0gPSB0aGlzLm15SUQ7XG4gICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU1dID0gdGhpcy5teVBXO1xuICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTV0gPSB0aGlzLmN1cnJlbnRTZXJpYWw7XG4gICAgICBsZXQgdGhlVVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xuICAgICAgLy9Ob3cgYWRkIGFzIG11Y2ggZGF0YSBhcyB3ZSBjYW4uXG4gICAgICBsZXQgY3VyRGF0YVN0cmluZyA9ICcnO1xuICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICB3aGlsZSAodGhpcy5wZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vZmlyc3QsIGxldHMgc2VlIGlmIHRoZSBuZXh0IHNlZ21lbnQgd2lsbCBmaXQuXG4gICAgICAgIGNvbnN0IG5leHRTZWcgPSB0aGlzLnBlbmRpbmdTZWdzWzBdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbmV4dFNlZy5kLmxlbmd0aCArIFNFR19IRUFERVJfU0laRSArIGN1ckRhdGFTdHJpbmcubGVuZ3RoIDw9XG4gICAgICAgICAgTUFYX1VSTF9EQVRBX1NJWkVcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy9ncmVhdCwgdGhlIHNlZ21lbnQgd2lsbCBmaXQuIExldHMgYXBwZW5kIGl0LlxuICAgICAgICAgIGNvbnN0IHRoZVNlZyA9IHRoaXMucGVuZGluZ1NlZ3Muc2hpZnQoKTtcbiAgICAgICAgICBjdXJEYXRhU3RyaW5nID1cbiAgICAgICAgICAgIGN1ckRhdGFTdHJpbmcgK1xuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgIEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRfTlVNX1BBUkFNICtcbiAgICAgICAgICAgIGkgK1xuICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgIHRoZVNlZy5zZWcgK1xuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgIEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRTX0lOX1BBQ0tFVCArXG4gICAgICAgICAgICBpICtcbiAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICB0aGVTZWcudHMgK1xuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgIEZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfUEFSQU0gK1xuICAgICAgICAgICAgaSArXG4gICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgdGhlU2VnLmQ7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoZVVSTCA9IHRoZVVSTCArIGN1ckRhdGFTdHJpbmc7XG4gICAgICB0aGlzLmFkZExvbmdQb2xsVGFnXyh0aGVVUkwsIHRoaXMuY3VycmVudFNlcmlhbCk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXVlIGEgcGFja2V0IGZvciB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cbiAgICogQHBhcmFtIHNlZ251bSAtIEEgc2VxdWVudGlhbCBpZCBmb3IgdGhpcyBwYWNrZXQgc2VnbWVudCB1c2VkIGZvciByZWFzc2VtYmx5XG4gICAqIEBwYXJhbSB0b3RhbHNlZ3MgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGFja2V0XG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgZm9yIHRoaXMgc2VnbWVudC5cbiAgICovXG4gIGVucXVldWVTZWdtZW50KHNlZ251bTogbnVtYmVyLCB0b3RhbHNlZ3M6IG51bWJlciwgZGF0YTogYW55KSB7XG4gICAgLy9hZGQgdGhpcyB0byB0aGUgcXVldWUgb2Ygc2VnbWVudHMgdG8gc2VuZC5cbiAgICB0aGlzLnBlbmRpbmdTZWdzLnB1c2goeyBzZWc6IHNlZ251bSwgdHM6IHRvdGFsc2VncywgZDogZGF0YSB9KTtcblxuICAgIC8vc2VuZCB0aGUgZGF0YSBpbW1lZGlhdGVseSBpZiB0aGVyZSBpc24ndCBhbHJlYWR5IGRhdGEgYmVpbmcgdHJhbnNtaXR0ZWQsIHVubGVzc1xuICAgIC8vc3RhcnRMb25nUG9sbCBoYXNuJ3QgYmVlbiBjYWxsZWQgeWV0LlxuICAgIGlmICh0aGlzLmFsaXZlKSB7XG4gICAgICB0aGlzLm5ld1JlcXVlc3RfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNjcmlwdCB0YWcgZm9yIGEgcmVndWxhciBsb25nLXBvbGwgcmVxdWVzdC5cbiAgICogQHBhcmFtIHshc3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBzY3JpcHQgdGFnLlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IHNlcmlhbCAtIFRoZSBzZXJpYWwgbnVtYmVyIG9mIHRoZSByZXF1ZXN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhZGRMb25nUG9sbFRhZ18odXJsOiBzdHJpbmcsIHNlcmlhbDogbnVtYmVyKSB7XG4gICAgLy9yZW1lbWJlciB0aGF0IHdlIHNlbnQgdGhpcyByZXF1ZXN0LlxuICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5hZGQoc2VyaWFsLCAxKTtcblxuICAgIGNvbnN0IGRvTmV3UmVxdWVzdCA9ICgpID0+IHtcbiAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5yZW1vdmUoc2VyaWFsKTtcbiAgICAgIHRoaXMubmV3UmVxdWVzdF8oKTtcbiAgICB9O1xuXG4gICAgLy8gSWYgdGhpcyByZXF1ZXN0IGRvZXNuJ3QgcmV0dXJuIG9uIGl0cyBvd24gYWNjb3JkIChieSB0aGUgc2VydmVyIHNlbmRpbmcgdXMgc29tZSBkYXRhKSwgd2UnbGxcbiAgICAvLyBjcmVhdGUgYSBuZXcgb25lIGFmdGVyIHRoZSBLRUVQQUxJVkUgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBrZWVwIGEgZnJlc2ggcmVxdWVzdCBvcGVuLlxuICAgIGNvbnN0IGtlZXBhbGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgZG9OZXdSZXF1ZXN0LFxuICAgICAgTWF0aC5mbG9vcihLRUVQQUxJVkVfUkVRVUVTVF9JTlRFUlZBTClcbiAgICApO1xuXG4gICAgY29uc3QgcmVhZHlTdGF0ZUNCID0gKCkgPT4ge1xuICAgICAgLy8gUmVxdWVzdCBjb21wbGV0ZWQuICBDYW5jZWwgdGhlIGtlZXBhbGl2ZS5cbiAgICAgIGNsZWFyVGltZW91dChrZWVwYWxpdmVUaW1lb3V0KTtcblxuICAgICAgLy8gVHJpZ2dlciBhIG5ldyByZXF1ZXN0IHNvIHdlIGNhbiBjb250aW51ZSByZWNlaXZpbmcgZGF0YS5cbiAgICAgIGRvTmV3UmVxdWVzdCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZFRhZyh1cmwsIHJlYWR5U3RhdGVDQik7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGFyYml0cmFyeSBzY3JpcHQgdGFnIHRvIHRoZSBpZnJhbWUuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdXJsIC0gVGhlIFVSTCBmb3IgdGhlIHNjcmlwdCB0YWcgc291cmNlLlxuICAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBsb2FkQ0IgLSBBIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCBvbmNlIHRoZSBzY3JpcHQgaGFzIGxvYWRlZC5cbiAgICovXG4gIGFkZFRhZyh1cmw6IHN0cmluZywgbG9hZENCOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKGlzTm9kZVNkaygpKSB7XG4gICAgICAodGhpcyBhcyBhbnkpLmRvTm9kZUxvbmdQb2xsKHVybCwgbG9hZENCKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gaWYgd2UncmUgYWxyZWFkeSBjbG9zZWQsIGRvbid0IGFkZCB0aGlzIHBvbGxcbiAgICAgICAgICBpZiAoIXRoaXMuc2VuZE5ld1BvbGxzKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgbmV3U2NyaXB0ID0gdGhpcy5teUlGcmFtZS5kb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgbmV3U2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgICBuZXdTY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgIG5ld1NjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IChuZXdTY3JpcHQgYXMgYW55KS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHJzdGF0ZSA9IChuZXdTY3JpcHQgYXMgYW55KS5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgaWYgKCFyc3RhdGUgfHwgcnN0YXRlID09PSAnbG9hZGVkJyB8fCByc3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IChuZXdTY3JpcHQgYXMgYW55KS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAobmV3U2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBuZXdTY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXdTY3JpcHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxvYWRDQigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3U2NyaXB0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2coJ0xvbmctcG9sbCBzY3JpcHQgZmFpbGVkIHRvIGxvYWQ6ICcgKyB1cmwpO1xuICAgICAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLmJvZHkuYXBwZW5kQ2hpbGQobmV3U2NyaXB0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBtYWtlIHRoaXMgZXJyb3IgdmlzaWJsZSBzb21laG93XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGguZmxvb3IoMSkpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFJlcG9JbmZvIH0gZnJvbSAnLi4vY29yZS9SZXBvSW5mbyc7XG5cbmRlY2xhcmUgY29uc3QgTW96V2ViU29ja2V0OiBhbnk7XG5cbmltcG9ydCBmaXJlYmFzZSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGxvZ1dyYXBwZXIsIHNwbGl0U3RyaW5nQnlTaXplIH0gZnJvbSAnLi4vY29yZS91dGlsL3V0aWwnO1xuaW1wb3J0IHsgU3RhdHNNYW5hZ2VyIH0gZnJvbSAnLi4vY29yZS9zdGF0cy9TdGF0c01hbmFnZXInO1xuaW1wb3J0IHtcbiAgRk9SR0VfRE9NQUlOLFxuICBGT1JHRV9SRUYsXG4gIExBU1RfU0VTU0lPTl9QQVJBTSxcbiAgUFJPVE9DT0xfVkVSU0lPTixcbiAgUkVGRVJFUl9QQVJBTSxcbiAgVFJBTlNQT1JUX1NFU1NJT05fUEFSQU0sXG4gIFZFUlNJT05fUEFSQU0sXG4gIFdFQlNPQ0tFVFxufSBmcm9tICcuL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBDT05TVEFOVFMgYXMgRU5WX0NPTlNUQU5UUyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFBlcnNpc3RlbnRTdG9yYWdlIH0gZnJvbSAnLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2UnO1xuaW1wb3J0IHsganNvbkV2YWwsIHN0cmluZ2lmeSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGlzTm9kZVNkayB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gJy4vVHJhbnNwb3J0JztcbmltcG9ydCB7IFN0YXRzQ29sbGVjdGlvbiB9IGZyb20gJy4uL2NvcmUvc3RhdHMvU3RhdHNDb2xsZWN0aW9uJztcblxuY29uc3QgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFID0gMTYzODQ7XG5jb25zdCBXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMID0gNDUwMDA7XG5cbmxldCBXZWJTb2NrZXRJbXBsID0gbnVsbDtcbmlmICh0eXBlb2YgTW96V2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICBXZWJTb2NrZXRJbXBsID0gTW96V2ViU29ja2V0O1xufSBlbHNlIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICBXZWJTb2NrZXRJbXBsID0gV2ViU29ja2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0V2ViU29ja2V0SW1wbChpbXBsKSB7XG4gIFdlYlNvY2tldEltcGwgPSBpbXBsO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB3ZWJzb2NrZXQgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtUcmFuc3BvcnR9XG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJTb2NrZXRDb25uZWN0aW9uIGltcGxlbWVudHMgVHJhbnNwb3J0IHtcbiAga2VlcGFsaXZlVGltZXI6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBmcmFtZXM6IHN0cmluZ1tdIHwgbnVsbCA9IG51bGw7XG4gIHRvdGFsRnJhbWVzID0gMDtcbiAgYnl0ZXNTZW50ID0gMDtcbiAgYnl0ZXNSZWNlaXZlZCA9IDA7XG4gIGNvbm5VUkw6IHN0cmluZztcbiAgb25EaXNjb25uZWN0OiAoYT86IGJvb2xlYW4pID0+IHZvaWQ7XG4gIG9uTWVzc2FnZTogKG1zZzogT2JqZWN0KSA9PiB2b2lkO1xuICBteVNvY2s6IGFueSB8IG51bGw7XG4gIHByaXZhdGUgbG9nXzogKC4uLmE6IGFueVtdKSA9PiB2b2lkO1xuICBwcml2YXRlIHN0YXRzXzogU3RhdHNDb2xsZWN0aW9uO1xuICBwcml2YXRlIGV2ZXJDb25uZWN0ZWRfOiBib29sZWFuO1xuICBwcml2YXRlIGlzQ2xvc2VkXzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbm5JZCBpZGVudGlmaWVyIGZvciB0aGlzIHRyYW5zcG9ydFxuICAgKiBAcGFyYW0ge1JlcG9JbmZvfSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIHdlYnNvY2tldCBlbmRwb2ludC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZyB0byBhbiBleGlzdGluZyB0cmFuc3BvcnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY29ubmVjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGNvbm5JZDogc3RyaW5nLFxuICAgIHJlcG9JbmZvOiBSZXBvSW5mbyxcbiAgICB0cmFuc3BvcnRTZXNzaW9uSWQ/OiBzdHJpbmcsXG4gICAgbGFzdFNlc3Npb25JZD86IHN0cmluZ1xuICApIHtcbiAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKHRoaXMuY29ubklkKTtcbiAgICB0aGlzLnN0YXRzXyA9IFN0YXRzTWFuYWdlci5nZXRDb2xsZWN0aW9uKHJlcG9JbmZvKTtcbiAgICB0aGlzLmNvbm5VUkwgPSBXZWJTb2NrZXRDb25uZWN0aW9uLmNvbm5lY3Rpb25VUkxfKFxuICAgICAgcmVwb0luZm8sXG4gICAgICB0cmFuc3BvcnRTZXNzaW9uSWQsXG4gICAgICBsYXN0U2Vzc2lvbklkXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlcG9JbmZvfSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIHdlYnNvY2tldCBlbmRwb2ludC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZyB0byBhbiBleGlzdGluZyB0cmFuc3BvcnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY29ubmVjdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNvbm5lY3Rpb24gdXJsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBjb25uZWN0aW9uVVJMXyhcbiAgICByZXBvSW5mbzogUmVwb0luZm8sXG4gICAgdHJhbnNwb3J0U2Vzc2lvbklkPzogc3RyaW5nLFxuICAgIGxhc3RTZXNzaW9uSWQ/OiBzdHJpbmdcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCB1cmxQYXJhbXM6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgdXJsUGFyYW1zW1ZFUlNJT05fUEFSQU1dID0gUFJPVE9DT0xfVkVSU0lPTjtcblxuICAgIGlmIChcbiAgICAgICFpc05vZGVTZGsoKSAmJlxuICAgICAgdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgbG9jYXRpb24uaHJlZiAmJlxuICAgICAgbG9jYXRpb24uaHJlZi5pbmRleE9mKEZPUkdFX0RPTUFJTikgIT09IC0xXG4gICAgKSB7XG4gICAgICB1cmxQYXJhbXNbUkVGRVJFUl9QQVJBTV0gPSBGT1JHRV9SRUY7XG4gICAgfVxuICAgIGlmICh0cmFuc3BvcnRTZXNzaW9uSWQpIHtcbiAgICAgIHVybFBhcmFtc1tUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTV0gPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XG4gICAgfVxuICAgIGlmIChsYXN0U2Vzc2lvbklkKSB7XG4gICAgICB1cmxQYXJhbXNbTEFTVF9TRVNTSU9OX1BBUkFNXSA9IGxhc3RTZXNzaW9uSWQ7XG4gICAgfVxuICAgIHJldHVybiByZXBvSW5mby5jb25uZWN0aW9uVVJMKFdFQlNPQ0tFVCwgdXJsUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gb25NZXNzYWdlIENhbGxiYWNrIHdoZW4gbWVzc2FnZXMgYXJyaXZlXG4gICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgQ2FsbGJhY2sgd2l0aCBjb25uZWN0aW9uIGxvc3QuXG4gICAqL1xuICBvcGVuKG9uTWVzc2FnZTogKG1zZzogT2JqZWN0KSA9PiB2b2lkLCBvbkRpc2Nvbm5lY3Q6IChhPzogYm9vbGVhbikgPT4gdm9pZCkge1xuICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xuICAgIHRoaXMub25NZXNzYWdlID0gb25NZXNzYWdlO1xuXG4gICAgdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGluZyB0byAnICsgdGhpcy5jb25uVVJMKTtcblxuICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZmFpbHVyZSB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlLlxuICAgIFBlcnNpc3RlbnRTdG9yYWdlLnNldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnLCB0cnVlKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcbiAgICAgICAgY29uc3QgZGV2aWNlID0gRU5WX0NPTlNUQU5UUy5OT0RFX0FETUlOID8gJ0FkbWluTm9kZScgOiAnTm9kZSc7XG4gICAgICAgIC8vIFVBIEZvcm1hdDogRmlyZWJhc2UvPHdpcmVfcHJvdG9jb2w+LzxzZGtfdmVyc2lvbj4vPHBsYXRmb3JtPi88ZGV2aWNlPlxuICAgICAgICBjb25zdCBvcHRpb25zOiB7IFtrOiBzdHJpbmddOiBvYmplY3QgfSA9IHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IGBGaXJlYmFzZS8ke1BST1RPQ09MX1ZFUlNJT059LyR7XG4gICAgICAgICAgICAgIGZpcmViYXNlLlNES19WRVJTSU9OXG4gICAgICAgICAgICB9LyR7cHJvY2Vzcy5wbGF0Zm9ybX0vJHtkZXZpY2V9YFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQbHVtYiBhcHByb3ByaWF0ZSBodHRwX3Byb3h5IGVudmlyb25tZW50IHZhcmlhYmxlIGludG8gZmF5ZS13ZWJzb2NrZXQgaWYgaXQgZXhpc3RzLlxuICAgICAgICBjb25zdCBlbnYgPSBwcm9jZXNzWydlbnYnXTtcbiAgICAgICAgY29uc3QgcHJveHkgPVxuICAgICAgICAgIHRoaXMuY29ublVSTC5pbmRleE9mKCd3c3M6Ly8nKSA9PSAwXG4gICAgICAgICAgICA/IGVudlsnSFRUUFNfUFJPWFknXSB8fCBlbnZbJ2h0dHBzX3Byb3h5J11cbiAgICAgICAgICAgIDogZW52WydIVFRQX1BST1hZJ10gfHwgZW52WydodHRwX3Byb3h5J107XG5cbiAgICAgICAgaWYgKHByb3h5KSB7XG4gICAgICAgICAgb3B0aW9uc1sncHJveHknXSA9IHsgb3JpZ2luOiBwcm94eSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5teVNvY2sgPSBuZXcgV2ViU29ja2V0SW1wbCh0aGlzLmNvbm5VUkwsIFtdLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubXlTb2NrID0gbmV3IFdlYlNvY2tldEltcGwodGhpcy5jb25uVVJMKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZ18oJ0Vycm9yIGluc3RhbnRpYXRpbmcgV2ViU29ja2V0LicpO1xuICAgICAgY29uc3QgZXJyb3IgPSBlLm1lc3NhZ2UgfHwgZS5kYXRhO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nXyhlcnJvcik7XG4gICAgICB9XG4gICAgICB0aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubXlTb2NrLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3RlZC4nKTtcbiAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSB0cnVlO1xuICAgIH07XG5cbiAgICB0aGlzLm15U29jay5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGlvbiB3YXMgZGlzY29ubmVjdGVkLicpO1xuICAgICAgdGhpcy5teVNvY2sgPSBudWxsO1xuICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcbiAgICB9O1xuXG4gICAgdGhpcy5teVNvY2sub25tZXNzYWdlID0gKG06IG9iamVjdCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ0ZyYW1lKG0pO1xuICAgIH07XG5cbiAgICB0aGlzLm15U29jay5vbmVycm9yID0gKGU6IGFueSkgPT4ge1xuICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XG4gICAgICBjb25zdCBlcnJvciA9IGUubWVzc2FnZSB8fCBlLmRhdGE7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dfKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub25DbG9zZWRfKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOby1vcCBmb3Igd2Vic29ja2V0cywgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIGNvbmZpcm1lZCBhcyBvcGVuXG4gICAqL1xuICBzdGFydCgpIHt9XG5cbiAgc3RhdGljIGZvcmNlRGlzYWxsb3dfOiBCb29sZWFuO1xuXG4gIHN0YXRpYyBmb3JjZURpc2FsbG93KCkge1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gPSB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICAgIGxldCBpc09sZEFuZHJvaWQgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAgICAgY29uc3Qgb2xkQW5kcm9pZFJlZ2V4ID0gL0FuZHJvaWQgKFswLTldezAsfVxcLlswLTldezAsfSkvO1xuICAgICAgY29uc3Qgb2xkQW5kcm9pZE1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChvbGRBbmRyb2lkUmVnZXgpO1xuICAgICAgaWYgKG9sZEFuZHJvaWRNYXRjaCAmJiBvbGRBbmRyb2lkTWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAocGFyc2VGbG9hdChvbGRBbmRyb2lkTWF0Y2hbMV0pIDwgNC40KSB7XG4gICAgICAgICAgaXNPbGRBbmRyb2lkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAhaXNPbGRBbmRyb2lkICYmXG4gICAgICBXZWJTb2NrZXRJbXBsICE9PSBudWxsICYmXG4gICAgICAhV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93X1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIHJlc3BvbnNlIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgY29ubmVjdGlvbiBcImhlYWx0aHkuXCJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyByZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5ID0gMjtcblxuICAvKipcbiAgICogVGltZSB0byB3YWl0IGZvciB0aGUgY29ubmVjdGlvbiB0ZSBiZWNvbWUgaGVhbHRoeSBiZWZvcmUgZ2l2aW5nIHVwLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGhlYWx0aHlUaW1lb3V0ID0gMzAwMDA7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBwcmV2aW91c2x5IGZhaWxlZCB0byBjb25uZWN0IHdpdGggdGhpcyB0cmFuc3BvcnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgcHJldmlvdXNseUZhaWxlZCgpOiBib29sZWFuIHtcbiAgICAvLyBJZiBvdXIgcGVyc2lzdGVudCBzdG9yYWdlIGlzIGFjdHVhbGx5IG9ubHkgaW4tbWVtb3J5IHN0b3JhZ2UsXG4gICAgLy8gd2UgZGVmYXVsdCB0byBhc3N1bWluZyB0aGF0IGl0IHByZXZpb3VzbHkgZmFpbGVkIHRvIGJlIHNhZmUuXG4gICAgcmV0dXJuIChcbiAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLmlzSW5NZW1vcnlTdG9yYWdlIHx8XG4gICAgICBQZXJzaXN0ZW50U3RvcmFnZS5nZXQoJ3ByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlJykgPT09IHRydWVcbiAgICApO1xuICB9XG5cbiAgbWFya0Nvbm5lY3Rpb25IZWFsdGh5KCkge1xuICAgIFBlcnNpc3RlbnRTdG9yYWdlLnJlbW92ZSgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKTtcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kRnJhbWVfKGRhdGE6IHN0cmluZykge1xuICAgIHRoaXMuZnJhbWVzLnB1c2goZGF0YSk7XG4gICAgaWYgKHRoaXMuZnJhbWVzLmxlbmd0aCA9PSB0aGlzLnRvdGFsRnJhbWVzKSB7XG4gICAgICBjb25zdCBmdWxsTWVzcyA9IHRoaXMuZnJhbWVzLmpvaW4oJycpO1xuICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xuICAgICAgY29uc3QganNvbk1lc3MgPSBqc29uRXZhbChmdWxsTWVzcykgYXMgb2JqZWN0O1xuXG4gICAgICAvL2hhbmRsZSB0aGUgbWVzc2FnZVxuICAgICAgdGhpcy5vbk1lc3NhZ2UoanNvbk1lc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJhbWVDb3VudCBUaGUgbnVtYmVyIG9mIGZyYW1lcyB3ZSBhcmUgZXhwZWN0aW5nIGZyb20gdGhlIHNlcnZlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBoYW5kbGVOZXdGcmFtZUNvdW50XyhmcmFtZUNvdW50OiBudW1iZXIpIHtcbiAgICB0aGlzLnRvdGFsRnJhbWVzID0gZnJhbWVDb3VudDtcbiAgICB0aGlzLmZyYW1lcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHBhcnNlIGEgZnJhbWUgY291bnQgb3V0IG9mIHNvbWUgdGV4dC4gSWYgaXQgY2FuJ3QsIGFzc3VtZXMgYSB2YWx1ZSBvZiAxXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gZGF0YVxuICAgKiBAcmV0dXJuIHs/U3RyaW5nfSBBbnkgcmVtYWluaW5nIGRhdGEgdG8gYmUgcHJvY2Vzcywgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGV4dHJhY3RGcmFtZUNvdW50XyhkYXRhOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBhc3NlcnQodGhpcy5mcmFtZXMgPT09IG51bGwsICdXZSBhbHJlYWR5IGhhdmUgYSBmcmFtZSBidWZmZXInKTtcbiAgICAvLyBUT0RPOiBUaGUgc2VydmVyIGlzIG9ubHkgc3VwcG9zZWQgdG8gc2VuZCB1cCB0byA5OTk5IGZyYW1lcyAoaS5lLiBsZW5ndGggPD0gNCksIGJ1dCB0aGF0IGlzbid0IGJlaW5nIGVuZm9yY2VkXG4gICAgLy8gY3VycmVudGx5LiAgU28gYWxsb3dpbmcgbGFyZ2VyIGZyYW1lIGNvdW50cyAobGVuZ3RoIDw9IDYpLiAgU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wL3NlYXJjaC84Njg4NTk4OTk4MzgwLzgyMzc2MDgwNDI1MDhcbiAgICBpZiAoZGF0YS5sZW5ndGggPD0gNikge1xuICAgICAgY29uc3QgZnJhbWVDb3VudCA9IE51bWJlcihkYXRhKTtcbiAgICAgIGlmICghaXNOYU4oZnJhbWVDb3VudCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXdGcmFtZUNvdW50XyhmcmFtZUNvdW50KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlTmV3RnJhbWVDb3VudF8oMSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhIHdlYnNvY2tldCBmcmFtZSB0aGF0IGhhcyBhcnJpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICogQHBhcmFtIG1lc3MgVGhlIGZyYW1lIGRhdGFcbiAgICovXG4gIGhhbmRsZUluY29taW5nRnJhbWUobWVzczogeyBbazogc3RyaW5nXTogYW55IH0pIHtcbiAgICBpZiAodGhpcy5teVNvY2sgPT09IG51bGwpIHJldHVybjsgLy8gQ2hyb21lIGFwcGFyZW50bHkgZGVsaXZlcnMgaW5jb21pbmcgcGFja2V0cyBldmVuIGFmdGVyIHdlIC5jbG9zZSgpIHRoZSBjb25uZWN0aW9uIHNvbWV0aW1lcy5cbiAgICBjb25zdCBkYXRhID0gbWVzc1snZGF0YSddIGFzIHN0cmluZztcbiAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfcmVjZWl2ZWQnLCBkYXRhLmxlbmd0aCk7XG5cbiAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XG5cbiAgICBpZiAodGhpcy5mcmFtZXMgIT09IG51bGwpIHtcbiAgICAgIC8vIHdlJ3JlIGJ1ZmZlcmluZ1xuICAgICAgdGhpcy5hcHBlbmRGcmFtZV8oZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRyeSB0byBwYXJzZSBvdXQgYSBmcmFtZSBjb3VudCwgb3RoZXJ3aXNlLCBhc3N1bWUgMSBhbmQgcHJvY2VzcyBpdFxuICAgICAgY29uc3QgcmVtYWluaW5nRGF0YSA9IHRoaXMuZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpO1xuICAgICAgaWYgKHJlbWFpbmluZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8ocmVtYWluaW5nRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIEpTT04gb2JqZWN0IHRvIHRyYW5zbWl0XG4gICAqL1xuICBzZW5kKGRhdGE6IE9iamVjdCkge1xuICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcblxuICAgIGNvbnN0IGRhdGFTdHIgPSBzdHJpbmdpZnkoZGF0YSk7XG4gICAgdGhpcy5ieXRlc1NlbnQgKz0gZGF0YVN0ci5sZW5ndGg7XG4gICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfc2VudCcsIGRhdGFTdHIubGVuZ3RoKTtcblxuICAgIC8vV2UgY2FuIG9ubHkgZml0IGEgY2VydGFpbiBhbW91bnQgaW4gZWFjaCB3ZWJzb2NrZXQgZnJhbWUsIHNvIHdlIG5lZWQgdG8gc3BsaXQgdGhpcyByZXF1ZXN0XG4gICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cblxuICAgIGNvbnN0IGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoZGF0YVN0ciwgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFKTtcblxuICAgIC8vU2VuZCB0aGUgbGVuZ3RoIGhlYWRlclxuICAgIGlmIChkYXRhU2Vncy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnNlbmRTdHJpbmdfKFN0cmluZyhkYXRhU2Vncy5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvL1NlbmQgdGhlIGFjdHVhbCBkYXRhIGluIHNlZ21lbnRzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc2VuZFN0cmluZ18oZGF0YVNlZ3NbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2h1dGRvd25fKCkge1xuICAgIHRoaXMuaXNDbG9zZWRfID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5rZWVwYWxpdmVUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcbiAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm15U29jaykge1xuICAgICAgdGhpcy5teVNvY2suY2xvc2UoKTtcbiAgICAgIHRoaXMubXlTb2NrID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uQ2xvc2VkXygpIHtcbiAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XG4gICAgICB0aGlzLmxvZ18oJ1dlYlNvY2tldCBpcyBjbG9zaW5nIGl0c2VsZicpO1xuICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcblxuICAgICAgLy8gc2luY2UgdGhpcyBpcyBhbiBpbnRlcm5hbCBjbG9zZSwgdHJpZ2dlciB0aGUgY2xvc2UgbGlzdGVuZXJcbiAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdCkge1xuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCh0aGlzLmV2ZXJDb25uZWN0ZWRfKTtcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlcm5hbC1mYWNpbmcgY2xvc2UgaGFuZGxlci5cbiAgICogQ2xvc2UgdGhlIHdlYnNvY2tldCBhbmQga2lsbCB0aGUgY29ubmVjdGlvbi5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcbiAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGJlaW5nIGNsb3NlZCcpO1xuICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogS2lsbCB0aGUgY3VycmVudCBrZWVwYWxpdmUgdGltZXIgYW5kIHN0YXJ0IGEgbmV3IG9uZSwgdG8gZW5zdXJlIHRoYXQgaXQgYWx3YXlzIGZpcmVzIE4gc2Vjb25kcyBhZnRlclxuICAgKiB0aGUgbGFzdCBhY3Rpdml0eS5cbiAgICovXG4gIHJlc2V0S2VlcEFsaXZlKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVUaW1lcik7XG4gICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIC8vSWYgdGhlcmUgaGFzIGJlZW4gbm8gd2Vic29ja2V0IGFjdGl2aXR5IGZvciBhIHdoaWxlLCBzZW5kIGEgbm8tb3BcbiAgICAgIGlmICh0aGlzLm15U29jaykge1xuICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKCcwJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XG4gICAgfSwgTWF0aC5mbG9vcihXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMKSkgYXMgYW55O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBzdHJpbmcgb3ZlciB0aGUgd2Vic29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBzZW5kLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZW5kU3RyaW5nXyhzdHI6IHN0cmluZykge1xuICAgIC8vIEZpcmVmb3ggc2VlbXMgdG8gc29tZXRpbWVzIHRocm93IGV4Y2VwdGlvbnMgKE5TX0VSUk9SX1VORVhQRUNURUQpIGZyb20gd2Vic29ja2V0IC5zZW5kKClcbiAgICAvLyBjYWxscyBmb3Igc29tZSB1bmtub3duIHJlYXNvbi4gIFdlIHRyZWF0IHRoZXNlIGFzIGFuIGVycm9yIGFuZCBkaXNjb25uZWN0LlxuICAgIC8vIFNlZSBodHRwczovL2FwcC5hc2FuYS5jb20vMC81ODkyNjExMTQwMjI5Mi82ODAyMTM0MDI1MDQxMFxuICAgIHRyeSB7XG4gICAgICB0aGlzLm15U29jay5zZW5kKHN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dfKFxuICAgICAgICAnRXhjZXB0aW9uIHRocm93biBmcm9tIFdlYlNvY2tldC5zZW5kKCk6JyxcbiAgICAgICAgZS5tZXNzYWdlIHx8IGUuZGF0YSxcbiAgICAgICAgJ0Nsb3NpbmcgY29ubmVjdGlvbi4nXG4gICAgICApO1xuICAgICAgc2V0VGltZW91dCh0aGlzLm9uQ2xvc2VkXy5iaW5kKHRoaXMpLCAwKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBCcm93c2VyUG9sbENvbm5lY3Rpb24gfSBmcm9tICcuL0Jyb3dzZXJQb2xsQ29ubmVjdGlvbic7XG5pbXBvcnQgeyBXZWJTb2NrZXRDb25uZWN0aW9uIH0gZnJvbSAnLi9XZWJTb2NrZXRDb25uZWN0aW9uJztcbmltcG9ydCB7IHdhcm4sIGVhY2ggfSBmcm9tICcuLi9jb3JlL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBUcmFuc3BvcnRDb25zdHJ1Y3RvciB9IGZyb20gJy4vVHJhbnNwb3J0JztcbmltcG9ydCB7IFJlcG9JbmZvIH0gZnJvbSAnLi4vY29yZS9SZXBvSW5mbyc7XG5cbi8qKlxuICogQ3VycmVudGx5IHNpbXBsaXN0aWMsIHRoaXMgY2xhc3MgbWFuYWdlcyB3aGF0IHRyYW5zcG9ydCBhIENvbm5lY3Rpb24gc2hvdWxkIHVzZSBhdCB2YXJpb3VzIHN0YWdlcyBvZiBpdHNcbiAqIGxpZmVjeWNsZS5cbiAqXG4gKiBJdCBzdGFydHMgd2l0aCBsb25ncG9sbGluZyBpbiBhIGJyb3dzZXIsIGFuZCBodHRwcG9sbGluZyBvbiBub2RlLiBJdCB0aGVuIHVwZ3JhZGVzIHRvIHdlYnNvY2tldHMgaWZcbiAqIHRoZXkgYXJlIGF2YWlsYWJsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNwb3J0TWFuYWdlciB7XG4gIHByaXZhdGUgdHJhbnNwb3J0c186IFRyYW5zcG9ydENvbnN0cnVjdG9yW107XG5cbiAgLyoqXG4gICAqIEBjb25zdFxuICAgKiBAdHlwZSB7IUFycmF5LjxmdW5jdGlvbihuZXc6VHJhbnNwb3J0LCBzdHJpbmcsIFJlcG9JbmZvLCBzdHJpbmc9KT59XG4gICAqL1xuICBzdGF0aWMgZ2V0IEFMTF9UUkFOU1BPUlRTKCkge1xuICAgIHJldHVybiBbQnJvd3NlclBvbGxDb25uZWN0aW9uLCBXZWJTb2NrZXRDb25uZWN0aW9uXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm8gTWV0YWRhdGEgYXJvdW5kIHRoZSBuYW1lc3BhY2Ugd2UncmUgY29ubmVjdGluZyB0b1xuICAgKi9cbiAgY29uc3RydWN0b3IocmVwb0luZm86IFJlcG9JbmZvKSB7XG4gICAgdGhpcy5pbml0VHJhbnNwb3J0c18ocmVwb0luZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mb1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBpbml0VHJhbnNwb3J0c18ocmVwb0luZm86IFJlcG9JbmZvKSB7XG4gICAgY29uc3QgaXNXZWJTb2NrZXRzQXZhaWxhYmxlOiBib29sZWFuID1cbiAgICAgIFdlYlNvY2tldENvbm5lY3Rpb24gJiYgV2ViU29ja2V0Q29ubmVjdGlvblsnaXNBdmFpbGFibGUnXSgpO1xuICAgIGxldCBpc1NraXBQb2xsQ29ubmVjdGlvbiA9XG4gICAgICBpc1dlYlNvY2tldHNBdmFpbGFibGUgJiYgIVdlYlNvY2tldENvbm5lY3Rpb24ucHJldmlvdXNseUZhaWxlZCgpO1xuXG4gICAgaWYgKHJlcG9JbmZvLndlYlNvY2tldE9ubHkpIHtcbiAgICAgIGlmICghaXNXZWJTb2NrZXRzQXZhaWxhYmxlKVxuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwid3NzOi8vIFVSTCB1c2VkLCBidXQgYnJvd3NlciBpc24ndCBrbm93biB0byBzdXBwb3J0IHdlYnNvY2tldHMuICBUcnlpbmcgYW55d2F5LlwiXG4gICAgICAgICk7XG5cbiAgICAgIGlzU2tpcFBvbGxDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNTa2lwUG9sbENvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0c18gPSBbV2ViU29ja2V0Q29ubmVjdGlvbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydHMgPSAodGhpcy50cmFuc3BvcnRzXyA9IFtdIGFzIFRyYW5zcG9ydENvbnN0cnVjdG9yW10pO1xuICAgICAgZWFjaChcbiAgICAgICAgVHJhbnNwb3J0TWFuYWdlci5BTExfVFJBTlNQT1JUUyxcbiAgICAgICAgKGk6IG51bWJlciwgdHJhbnNwb3J0OiBUcmFuc3BvcnRDb25zdHJ1Y3RvcikgPT4ge1xuICAgICAgICAgIGlmICh0cmFuc3BvcnQgJiYgdHJhbnNwb3J0Wydpc0F2YWlsYWJsZSddKCkpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlRyYW5zcG9ydCwgIXN0cmluZywgIVJlcG9JbmZvLCBzdHJpbmc9LCBzdHJpbmc9KX0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGVcbiAgICogaW5pdGlhbCB0cmFuc3BvcnQgdG8gdXNlXG4gICAqL1xuICBpbml0aWFsVHJhbnNwb3J0KCk6IFRyYW5zcG9ydENvbnN0cnVjdG9yIHtcbiAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb24obmV3OlRyYW5zcG9ydCwgZnVuY3Rpb24oKSxmdW5jdGlvbigpLCBzdHJpbmc9KX0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgbmV4dFxuICAgKiB0cmFuc3BvcnQsIG9yIG51bGxcbiAgICovXG4gIHVwZ3JhZGVUcmFuc3BvcnQoKTogVHJhbnNwb3J0Q29uc3RydWN0b3IgfCBudWxsIHtcbiAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgZXJyb3IsXG4gIGxvZ1dyYXBwZXIsXG4gIHJlcXVpcmVLZXksXG4gIHNldFRpbWVvdXROb25CbG9ja2luZyxcbiAgd2FyblxufSBmcm9tICcuLi9jb3JlL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBQZXJzaXN0ZW50U3RvcmFnZSB9IGZyb20gJy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdlJztcbmltcG9ydCB7IFBST1RPQ09MX1ZFUlNJT04gfSBmcm9tICcuL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBUcmFuc3BvcnRNYW5hZ2VyIH0gZnJvbSAnLi9UcmFuc3BvcnRNYW5hZ2VyJztcbmltcG9ydCB7IFJlcG9JbmZvIH0gZnJvbSAnLi4vY29yZS9SZXBvSW5mbyc7XG5pbXBvcnQgeyBUcmFuc3BvcnQsIFRyYW5zcG9ydENvbnN0cnVjdG9yIH0gZnJvbSAnLi9UcmFuc3BvcnQnO1xuXG4vLyBBYm9ydCB1cGdyYWRlIGF0dGVtcHQgaWYgaXQgdGFrZXMgbG9uZ2VyIHRoYW4gNjBzLlxuY29uc3QgVVBHUkFERV9USU1FT1VUID0gNjAwMDA7XG5cbi8vIEZvciBzb21lIHRyYW5zcG9ydHMgKFdlYlNvY2tldHMpLCB3ZSBuZWVkIHRvIFwidmFsaWRhdGVcIiB0aGUgdHJhbnNwb3J0IGJ5IGV4Y2hhbmdpbmcgYSBmZXcgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy5cbi8vIElmIHdlIGhhdmVuJ3Qgc2VudCBlbm91Z2ggcmVxdWVzdHMgd2l0aGluIDVzLCB3ZSdsbCBzdGFydCBzZW5kaW5nIG5vb3AgcGluZyByZXF1ZXN0cy5cbmNvbnN0IERFTEFZX0JFRk9SRV9TRU5ESU5HX0VYVFJBX1JFUVVFU1RTID0gNTAwMDtcblxuLy8gSWYgdGhlIGluaXRpYWwgZGF0YSBzZW50IHRyaWdnZXJzIGEgbG90IG9mIGJhbmR3aWR0aCAoaS5lLiBpdCdzIGEgbGFyZ2UgcHV0IG9yIGEgbGlzdGVuIGZvciBhIGxhcmdlIGFtb3VudCBvZiBkYXRhKVxuLy8gdGhlbiB3ZSBtYXkgbm90IGJlIGFibGUgdG8gZXhjaGFuZ2Ugb3VyIHBpbmcvcG9uZyByZXF1ZXN0cyB3aXRoaW4gdGhlIGhlYWx0aHkgdGltZW91dC4gIFNvIGlmIHdlIHJlYWNoIHRoZSB0aW1lb3V0XG4vLyBidXQgd2UndmUgc2VudC9yZWNlaXZlZCBlbm91Z2ggYnl0ZXMsIHdlIGRvbid0IGNhbmNlbCB0aGUgY29ubmVjdGlvbi5cbmNvbnN0IEJZVEVTX1NFTlRfSEVBTFRIWV9PVkVSUklERSA9IDEwICogMTAyNDtcbmNvbnN0IEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUgPSAxMDAgKiAxMDI0O1xuXG5jb25zdCBlbnVtIFJlYWx0aW1lU3RhdGUge1xuICBDT05ORUNUSU5HLFxuICBDT05ORUNURUQsXG4gIERJU0NPTk5FQ1RFRFxufVxuXG5jb25zdCBNRVNTQUdFX1RZUEUgPSAndCc7XG5jb25zdCBNRVNTQUdFX0RBVEEgPSAnZCc7XG5jb25zdCBDT05UUk9MX1NIVVRET1dOID0gJ3MnO1xuY29uc3QgQ09OVFJPTF9SRVNFVCA9ICdyJztcbmNvbnN0IENPTlRST0xfRVJST1IgPSAnZSc7XG5jb25zdCBDT05UUk9MX1BPTkcgPSAnbyc7XG5jb25zdCBTV0lUQ0hfQUNLID0gJ2EnO1xuY29uc3QgRU5EX1RSQU5TTUlTU0lPTiA9ICduJztcbmNvbnN0IFBJTkcgPSAncCc7XG5cbmNvbnN0IFNFUlZFUl9IRUxMTyA9ICdoJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWwtdGltZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgdXNpbmcgd2hpY2hldmVyIG1ldGhvZCB3b3Jrc1xuICogYmVzdCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY2xhc3MgQ29ubmVjdGlvbiB7XG4gIGNvbm5lY3Rpb25Db3VudCA9IDA7XG4gIHBlbmRpbmdEYXRhTWVzc2FnZXM6IGFueVtdID0gW107XG4gIHNlc3Npb25JZDogc3RyaW5nO1xuXG4gIHByaXZhdGUgY29ubl86IFRyYW5zcG9ydDtcbiAgcHJpdmF0ZSBoZWFsdGh5VGltZW91dF86IG51bWJlcjtcbiAgcHJpdmF0ZSBpc0hlYWx0aHlfOiBib29sZWFuO1xuICBwcml2YXRlIGxvZ186ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBwcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfOiBudW1iZXI7XG4gIHByaXZhdGUgcnhfOiBUcmFuc3BvcnQ7XG4gIHByaXZhdGUgc2Vjb25kYXJ5Q29ubl86IFRyYW5zcG9ydDtcbiAgcHJpdmF0ZSBzZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF86IG51bWJlcjtcbiAgcHJpdmF0ZSBzdGF0ZV8gPSBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkc7XG4gIHByaXZhdGUgdHJhbnNwb3J0TWFuYWdlcl86IFRyYW5zcG9ydE1hbmFnZXI7XG4gIHByaXZhdGUgdHhfOiBUcmFuc3BvcnQ7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBhbiBpZCBmb3IgdGhpcyBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mb18gLSB0aGUgaW5mbyBmb3IgdGhlIGVuZHBvaW50IHRvIGNvbm5lY3QgdG9cbiAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpfSBvbk1lc3NhZ2VfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgc2VydmVyLXB1c2ggbWVzc2FnZSBhcnJpdmVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBzdHJpbmcpfSBvblJlYWR5XyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGlzIGNvbm5lY3Rpb24gaXMgcmVhZHkgdG8gc2VuZCBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBvbkRpc2Nvbm5lY3RfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgY29ubmVjdGlvbiB3YXMgbG9zdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyl9IG9uS2lsbF8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGhhcyBwZXJtYW5lbnRseSBzaHV0IGRvd24uXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbGFzdFNlc3Npb25JZCAtIGxhc3Qgc2Vzc2lvbiBpZCBpbiBwZXJzaXN0ZW50IGNvbm5lY3Rpb24uIGlzIHVzZWQgdG8gY2xlYW4gdXAgb2xkIHNlc3Npb24gaW4gcmVhbC10aW1lIHNlcnZlclxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGlkOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZXBvSW5mb186IFJlcG9JbmZvLFxuICAgIHByaXZhdGUgb25NZXNzYWdlXzogKGE6IE9iamVjdCkgPT4gdm9pZCxcbiAgICBwcml2YXRlIG9uUmVhZHlfOiAoYTogbnVtYmVyLCBiOiBzdHJpbmcpID0+IHZvaWQsXG4gICAgcHJpdmF0ZSBvbkRpc2Nvbm5lY3RfOiAoKSA9PiB2b2lkLFxuICAgIHByaXZhdGUgb25LaWxsXzogKGE6IHN0cmluZykgPT4gdm9pZCxcbiAgICBwdWJsaWMgbGFzdFNlc3Npb25JZD86IHN0cmluZ1xuICApIHtcbiAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdjOicgKyB0aGlzLmlkICsgJzonKTtcbiAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfID0gbmV3IFRyYW5zcG9ydE1hbmFnZXIocmVwb0luZm9fKTtcbiAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gY3JlYXRlZCcpO1xuICAgIHRoaXMuc3RhcnRfKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGEgY29ubmVjdGlvbiBhdHRlbXB0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXJ0XygpIHtcbiAgICBjb25zdCBjb25uID0gdGhpcy50cmFuc3BvcnRNYW5hZ2VyXy5pbml0aWFsVHJhbnNwb3J0KCk7XG4gICAgdGhpcy5jb25uXyA9IG5ldyBjb25uKFxuICAgICAgdGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksXG4gICAgICB0aGlzLnJlcG9JbmZvXyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMubGFzdFNlc3Npb25JZFxuICAgICk7XG5cbiAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXG4gICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cbiAgICB0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPSBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcblxuICAgIGNvbnN0IG9uTWVzc2FnZVJlY2VpdmVkID0gdGhpcy5jb25uUmVjZWl2ZXJfKHRoaXMuY29ubl8pO1xuICAgIGNvbnN0IG9uQ29ubmVjdGlvbkxvc3QgPSB0aGlzLmRpc2Nvbm5SZWNlaXZlcl8odGhpcy5jb25uXyk7XG4gICAgdGhpcy50eF8gPSB0aGlzLmNvbm5fO1xuICAgIHRoaXMucnhfID0gdGhpcy5jb25uXztcbiAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcbiAgICB0aGlzLmlzSGVhbHRoeV8gPSBmYWxzZTtcblxuICAgIC8qXG4gICAgICogRmlyZWZveCBkb2Vzbid0IGxpa2Ugd2hlbiBjb2RlIGZyb20gb25lIGlmcmFtZSB0cmllcyB0byBjcmVhdGUgYW5vdGhlciBpZnJhbWUgYnkgd2F5IG9mIHRoZSBwYXJlbnQgZnJhbWUuXG4gICAgICogVGhpcyBjYW4gb2NjdXIgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdCwgaS5lLiB3ZSBndWVzc2VkIHdyb25nIG9uIHdoYXQgc2VydmVyIHRvIGNvbm5lY3QgdG8gYW5kIHJlY2VpdmVkIGEgcmVzZXQuXG4gICAgICogU29tZWhvdywgc2V0VGltZW91dCBzZWVtcyB0byBtYWtlIHRoaXMgb2suIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlIGZyb20gYSBzZWN1cml0eSBwZXJzcGVjdGl2ZSwgc2luY2UgeW91IHNob3VsZFxuICAgICAqIHN0aWxsIGhhdmUgdGhlIGNvbnRleHQgb2YgeW91ciBvcmlnaW5hdGluZyBmcmFtZS5cbiAgICAgKi9cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIHRoaXMuY29ubl8gZ2V0cyBzZXQgdG8gbnVsbCBpbiBzb21lIG9mIHRoZSB0ZXN0cy4gQ2hlY2sgdG8gbWFrZSBzdXJlIGl0IHN0aWxsIGV4aXN0cyBiZWZvcmUgdXNpbmcgaXRcbiAgICAgIHRoaXMuY29ubl8gJiYgdGhpcy5jb25uXy5vcGVuKG9uTWVzc2FnZVJlY2VpdmVkLCBvbkNvbm5lY3Rpb25Mb3N0KTtcbiAgICB9LCBNYXRoLmZsb29yKDApKTtcblxuICAgIGNvbnN0IGhlYWx0aHlUaW1lb3V0X21zID0gY29ublsnaGVhbHRoeVRpbWVvdXQnXSB8fCAwO1xuICAgIGlmIChoZWFsdGh5VGltZW91dF9tcyA+IDApIHtcbiAgICAgIHRoaXMuaGVhbHRoeVRpbWVvdXRfID0gc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcbiAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5Xykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuY29ubl8gJiZcbiAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNSZWNlaXZlZCA+IEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMubG9nXyhcbiAgICAgICAgICAgICAgJ0Nvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgcmVjZWl2ZWQgJyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uXy5ieXRlc1JlY2VpdmVkICtcbiAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0aGlzLmNvbm5fICYmXG4gICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzU2VudCA+IEJZVEVTX1NFTlRfSEVBTFRIWV9PVkVSUklERVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5sb2dfKFxuICAgICAgICAgICAgICAnQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyBzZW50ICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNTZW50ICtcbiAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTGVhdmluZyBjb25uZWN0aW9uIGFsaXZlLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCB3YW50IHRvIG1hcmsgaXQgaGVhbHRoeSwgc2luY2Ugd2UgaGF2ZSBubyBndWFyYW50ZWUgdGhhdCB0aGUgYnl0ZXMgaGF2ZSBtYWRlIGl0IHRvXG4gICAgICAgICAgICAvLyB0aGUgc2VydmVyLlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Nsb3NpbmcgdW5oZWFsdGh5IGNvbm5lY3Rpb24gYWZ0ZXIgdGltZW91dC4nKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGguZmxvb3IoaGVhbHRoeVRpbWVvdXRfbXMpKSBhcyBhbnk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIG5leHRUcmFuc3BvcnRJZF8oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2M6JyArIHRoaXMuaWQgKyAnOicgKyB0aGlzLmNvbm5lY3Rpb25Db3VudCsrO1xuICB9XG5cbiAgcHJpdmF0ZSBkaXNjb25uUmVjZWl2ZXJfKGNvbm4pIHtcbiAgICByZXR1cm4gZXZlckNvbm5lY3RlZCA9PiB7XG4gICAgICBpZiAoY29ubiA9PT0gdGhpcy5jb25uXykge1xuICAgICAgICB0aGlzLm9uQ29ubmVjdGlvbkxvc3RfKGV2ZXJDb25uZWN0ZWQpO1xuICAgICAgfSBlbHNlIGlmIChjb25uID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XG4gICAgICAgIHRoaXMubG9nXygnU2Vjb25kYXJ5IGNvbm5lY3Rpb24gbG9zdC4nKTtcbiAgICAgICAgdGhpcy5vblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dfKCdjbG9zaW5nIGFuIG9sZCBjb25uZWN0aW9uJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgY29ublJlY2VpdmVyXyhjb25uOiBUcmFuc3BvcnQpIHtcbiAgICByZXR1cm4gKG1lc3NhZ2U6IG9iamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGVfICE9IFJlYWx0aW1lU3RhdGUuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgIGlmIChjb25uID09PSB0aGlzLnJ4Xykge1xuICAgICAgICAgIHRoaXMub25QcmltYXJ5TWVzc2FnZVJlY2VpdmVkXyhtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25uID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XG4gICAgICAgICAgdGhpcy5vblNlY29uZGFyeU1lc3NhZ2VSZWNlaXZlZF8obWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dfKCdtZXNzYWdlIG9uIG9sZCBjb25uZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhTXNnIEFuIGFyYml0cmFyeSBkYXRhIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXG4gICAqL1xuICBzZW5kUmVxdWVzdChkYXRhTXNnOiBvYmplY3QpIHtcbiAgICAvLyB3cmFwIGluIGEgZGF0YSBtZXNzYWdlIGVudmVsb3BlIGFuZCBzZW5kIGl0IG9uXG4gICAgY29uc3QgbXNnID0geyB0OiAnZCcsIGQ6IGRhdGFNc2cgfTtcbiAgICB0aGlzLnNlbmREYXRhXyhtc2cpO1xuICB9XG5cbiAgdHJ5Q2xlYW51cENvbm5lY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fICYmIHRoaXMucnhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XG4gICAgICB0aGlzLmxvZ18oXG4gICAgICAgICdjbGVhbmluZyB1cCBhbmQgcHJvbW90aW5nIGEgY29ubmVjdGlvbjogJyArIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY29ubklkXG4gICAgICApO1xuICAgICAgdGhpcy5jb25uXyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XG4gICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcbiAgICAgIC8vIHRoZSBzZXJ2ZXIgd2lsbCBzaHV0ZG93biB0aGUgb2xkIGNvbm5lY3Rpb25cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uU2Vjb25kYXJ5Q29udHJvbF8oY29udHJvbERhdGE6IHsgW2s6IHN0cmluZ106IGFueSB9KSB7XG4gICAgaWYgKE1FU1NBR0VfVFlQRSBpbiBjb250cm9sRGF0YSkge1xuICAgICAgY29uc3QgY21kID0gY29udHJvbERhdGFbTUVTU0FHRV9UWVBFXSBhcyBzdHJpbmc7XG4gICAgICBpZiAoY21kID09PSBTV0lUQ0hfQUNLKSB7XG4gICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcbiAgICAgIH0gZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1JFU0VUKSB7XG4gICAgICAgIC8vIE1vc3QgbGlrZWx5IHRoZSBzZXNzaW9uIHdhc24ndCB2YWxpZC4gQWJhbmRvbiB0aGUgc3dpdGNoIGF0dGVtcHRcbiAgICAgICAgdGhpcy5sb2dfKCdHb3QgYSByZXNldCBvbiBzZWNvbmRhcnksIGNsb3NpbmcgaXQnKTtcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xuICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFscmVhZHkgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGZvciBzb21ldGhpbmcsIHRoYW4gd2UgbmVlZCB0byBmdWxseSBjbG9zZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy50eF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8gfHxcbiAgICAgICAgICB0aGlzLnJ4XyA9PT0gdGhpcy5zZWNvbmRhcnlDb25uX1xuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcbiAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBzZWNvbmRhcnkuJyk7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5UmVzcG9uc2VzUmVxdWlyZWRfLS07XG4gICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uU2Vjb25kYXJ5TWVzc2FnZVJlY2VpdmVkXyhwYXJzZWREYXRhOiBvYmplY3QpIHtcbiAgICBjb25zdCBsYXllcjogc3RyaW5nID0gcmVxdWlyZUtleSgndCcsIHBhcnNlZERhdGEpO1xuICAgIGNvbnN0IGRhdGE6IGFueSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcbiAgICBpZiAobGF5ZXIgPT0gJ2MnKSB7XG4gICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29udHJvbF8oZGF0YSk7XG4gICAgfSBlbHNlIGlmIChsYXllciA9PSAnZCcpIHtcbiAgICAgIC8vIGdvdCBhIGRhdGEgbWVzc2FnZSwgYnV0IHdlJ3JlIHN0aWxsIHNlY29uZCBjb25uZWN0aW9uLiBOZWVkIHRvIGJ1ZmZlciBpdCB1cFxuICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzLnB1c2goZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcm90b2NvbCBsYXllcjogJyArIGxheWVyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCkge1xuICAgIGlmICh0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XG4gICAgICB0aGlzLmxvZ18oJ1NlY29uZGFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuJyk7XG4gICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xuICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcbiAgICAgIHRoaXMucHJvY2VlZFdpdGhVcGdyYWRlXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZW5kIGEgcGluZyB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cbiAgICAgIHRoaXMubG9nXygnc2VuZGluZyBwaW5nIG9uIHNlY29uZGFyeS4nKTtcbiAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uc2VuZCh7IHQ6ICdjJywgZDogeyB0OiBQSU5HLCBkOiB7fSB9IH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvY2VlZFdpdGhVcGdyYWRlXygpIHtcbiAgICAvLyB0ZWxsIHRoaXMgY29ubmVjdGlvbiB0byBjb25zaWRlciBpdHNlbGYgb3BlblxuICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uc3RhcnQoKTtcbiAgICAvLyBzZW5kIGFja1xuICAgIHRoaXMubG9nXygnc2VuZGluZyBjbGllbnQgYWNrIG9uIHNlY29uZGFyeScpO1xuICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uc2VuZCh7IHQ6ICdjJywgZDogeyB0OiBTV0lUQ0hfQUNLLCBkOiB7fSB9IH0pO1xuXG4gICAgLy8gc2VuZCBlbmQgcGFja2V0IG9uIHByaW1hcnkgdHJhbnNwb3J0LCBzd2l0Y2ggdG8gc2VuZGluZyBvbiB0aGlzIG9uZVxuICAgIC8vIGNhbiByZWNlaXZlIG9uIHRoaXMgb25lLCBidWZmZXIgcmVzcG9uc2VzIHVudGlsIGVuZCByZWNlaXZlZCBvbiBwcmltYXJ5IHRyYW5zcG9ydFxuICAgIHRoaXMubG9nXygnRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XG4gICAgdGhpcy5jb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IEVORF9UUkFOU01JU1NJT04sIGQ6IHt9IH0gfSk7XG4gICAgdGhpcy50eF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xuXG4gICAgdGhpcy50cnlDbGVhbnVwQ29ubmVjdGlvbigpO1xuICB9XG5cbiAgcHJpdmF0ZSBvblByaW1hcnlNZXNzYWdlUmVjZWl2ZWRfKHBhcnNlZERhdGE6IHsgW2s6IHN0cmluZ106IGFueSB9KSB7XG4gICAgLy8gTXVzdCByZWZlciB0byBwYXJzZWREYXRhIHByb3BlcnRpZXMgaW4gcXVvdGVzLCBzbyBjbG9zdXJlIGRvZXNuJ3QgdG91Y2ggdGhlbS5cbiAgICBjb25zdCBsYXllcjogc3RyaW5nID0gcmVxdWlyZUtleSgndCcsIHBhcnNlZERhdGEpO1xuICAgIGNvbnN0IGRhdGE6IGFueSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcbiAgICBpZiAobGF5ZXIgPT0gJ2MnKSB7XG4gICAgICB0aGlzLm9uQ29udHJvbF8oZGF0YSk7XG4gICAgfSBlbHNlIGlmIChsYXllciA9PSAnZCcpIHtcbiAgICAgIHRoaXMub25EYXRhTWVzc2FnZV8oZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlOiBhbnkpIHtcbiAgICB0aGlzLm9uUHJpbWFyeVJlc3BvbnNlXygpO1xuXG4gICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgd2l0aCBkYXRhIG1lc3NhZ2VzLCBqdXN0IGtpY2sgdGhlbSB1cCBhIGxldmVsXG4gICAgdGhpcy5vbk1lc3NhZ2VfKG1lc3NhZ2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBvblByaW1hcnlSZXNwb25zZV8oKSB7XG4gICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcbiAgICAgIHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXy0tO1xuICAgICAgaWYgKHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XG4gICAgICAgIHRoaXMubG9nXygnUHJpbWFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuJyk7XG4gICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XG4gICAgICAgIHRoaXMuY29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkNvbnRyb2xfKGNvbnRyb2xEYXRhOiB7IFtrOiBzdHJpbmddOiBhbnkgfSkge1xuICAgIGNvbnN0IGNtZDogc3RyaW5nID0gcmVxdWlyZUtleShNRVNTQUdFX1RZUEUsIGNvbnRyb2xEYXRhKTtcbiAgICBpZiAoTUVTU0FHRV9EQVRBIGluIGNvbnRyb2xEYXRhKSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gY29udHJvbERhdGFbTUVTU0FHRV9EQVRBXTtcbiAgICAgIGlmIChjbWQgPT09IFNFUlZFUl9IRUxMTykge1xuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlXyhwYXlsb2FkKTtcbiAgICAgIH0gZWxzZSBpZiAoY21kID09PSBFTkRfVFJBTlNNSVNTSU9OKSB7XG4gICAgICAgIHRoaXMubG9nXygncmVjdmQgZW5kIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XG4gICAgICAgIHRoaXMucnhfID0gdGhpcy5zZWNvbmRhcnlDb25uXztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YU1lc3NhZ2VfKHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcbiAgICAgIH0gZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1NIVVRET1dOKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIHByZXZpb3VzbHkgdGhlICdvbktpbGwnIGNhbGxiYWNrIHBhc3NlZCB0byB0aGUgbG93ZXItbGV2ZWwgY29ubmVjdGlvblxuICAgICAgICAvLyBwYXlsb2FkIGluIHRoaXMgY2FzZSBpcyB0aGUgcmVhc29uIGZvciB0aGUgc2h1dGRvd24uIEdlbmVyYWxseSBhIGh1bWFuLXJlYWRhYmxlIGVycm9yXG4gICAgICAgIHRoaXMub25Db25uZWN0aW9uU2h1dGRvd25fKHBheWxvYWQpO1xuICAgICAgfSBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcbiAgICAgICAgLy8gcGF5bG9hZCBpbiB0aGlzIGNhc2UgaXMgdGhlIGhvc3Qgd2Ugc2hvdWxkIGNvbnRhY3RcbiAgICAgICAgdGhpcy5vblJlc2V0XyhwYXlsb2FkKTtcbiAgICAgIH0gZWxzZSBpZiAoY21kID09PSBDT05UUk9MX0VSUk9SKSB7XG4gICAgICAgIGVycm9yKCdTZXJ2ZXIgRXJyb3I6ICcgKyBwYXlsb2FkKTtcbiAgICAgIH0gZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcbiAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBwcmltYXJ5LicpO1xuICAgICAgICB0aGlzLm9uUHJpbWFyeVJlc3BvbnNlXygpO1xuICAgICAgICB0aGlzLnNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignVW5rbm93biBjb250cm9sIHBhY2tldCBjb21tYW5kOiAnICsgY21kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBUaGUgaGFuZHNoYWtlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIG9uSGFuZHNoYWtlXyhoYW5kc2hha2U6IHtcbiAgICB0czogbnVtYmVyO1xuICAgIHY6IHN0cmluZztcbiAgICBoOiBzdHJpbmc7XG4gICAgczogc3RyaW5nO1xuICB9KSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gaGFuZHNoYWtlLnRzO1xuICAgIGNvbnN0IHZlcnNpb24gPSBoYW5kc2hha2UudjtcbiAgICBjb25zdCBob3N0ID0gaGFuZHNoYWtlLmg7XG4gICAgdGhpcy5zZXNzaW9uSWQgPSBoYW5kc2hha2UucztcbiAgICB0aGlzLnJlcG9JbmZvXy51cGRhdGVIb3N0KGhvc3QpO1xuICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgY2xvc2VkIHRoZSBjb25uZWN0aW9uLCB0aGVuIGRvbid0IGJvdGhlciB0cnlpbmcgdG8gcHJvZ3Jlc3MgZnVydGhlclxuICAgIGlmICh0aGlzLnN0YXRlXyA9PSBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRoaXMuY29ubl8uc3RhcnQoKTtcbiAgICAgIHRoaXMub25Db25uZWN0aW9uRXN0YWJsaXNoZWRfKHRoaXMuY29ubl8sIHRpbWVzdGFtcCk7XG4gICAgICBpZiAoUFJPVE9DT0xfVkVSU0lPTiAhPT0gdmVyc2lvbikge1xuICAgICAgICB3YXJuKCdQcm90b2NvbCB2ZXJzaW9uIG1pc21hdGNoIGRldGVjdGVkJyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBkbyB3ZSB3YW50IHRvIHVwZ3JhZGU/IHdoZW4/IG1heWJlIGEgZGVsYXk/XG4gICAgICB0aGlzLnRyeVN0YXJ0VXBncmFkZV8oKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyeVN0YXJ0VXBncmFkZV8oKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMudHJhbnNwb3J0TWFuYWdlcl8udXBncmFkZVRyYW5zcG9ydCgpO1xuICAgIGlmIChjb25uKSB7XG4gICAgICB0aGlzLnN0YXJ0VXBncmFkZV8oY29ubik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGFydFVwZ3JhZGVfKGNvbm46IFRyYW5zcG9ydENvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG5ldyBjb25uKFxuICAgICAgdGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksXG4gICAgICB0aGlzLnJlcG9JbmZvXyxcbiAgICAgIHRoaXMuc2Vzc2lvbklkXG4gICAgKTtcbiAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXG4gICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cbiAgICB0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9XG4gICAgICBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcblxuICAgIGNvbnN0IG9uTWVzc2FnZSA9IHRoaXMuY29ublJlY2VpdmVyXyh0aGlzLnNlY29uZGFyeUNvbm5fKTtcbiAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLmRpc2Nvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XG4gICAgdGhpcy5zZWNvbmRhcnlDb25uXy5vcGVuKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KTtcblxuICAgIC8vIElmIHdlIGhhdmVuJ3Qgc3VjY2Vzc2Z1bGx5IHVwZ3JhZGVkIGFmdGVyIFVQR1JBREVfVElNRU9VVCwgZ2l2ZSB1cCBhbmQga2lsbCB0aGUgc2Vjb25kYXJ5LlxuICAgIHNldFRpbWVvdXROb25CbG9ja2luZygoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zZWNvbmRhcnlDb25uXykge1xuICAgICAgICB0aGlzLmxvZ18oJ1RpbWVkIG91dCB0cnlpbmcgdG8gdXBncmFkZS4nKTtcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sIE1hdGguZmxvb3IoVVBHUkFERV9USU1FT1VUKSk7XG4gIH1cblxuICBwcml2YXRlIG9uUmVzZXRfKGhvc3Q6IHN0cmluZykge1xuICAgIHRoaXMubG9nXygnUmVzZXQgcGFja2V0IHJlY2VpdmVkLiAgTmV3IGhvc3Q6ICcgKyBob3N0KTtcbiAgICB0aGlzLnJlcG9JbmZvXy51cGRhdGVIb3N0KGhvc3QpO1xuICAgIC8vIFRPRE86IGlmIHdlJ3JlIGFscmVhZHkgXCJjb25uZWN0ZWRcIiwgd2UgbmVlZCB0byB0cmlnZ2VyIGEgZGlzY29ubmVjdCBhdCB0aGUgbmV4dCBsYXllciB1cC5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydCByZXNldHMgYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBlc3RhYmxpc2hlZFxuICAgIGlmICh0aGlzLnN0YXRlXyA9PT0gUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xvc2Ugd2hhdGV2ZXIgY29ubmVjdGlvbnMgd2UgaGF2ZSBvcGVuIGFuZCBzdGFydCBhZ2Fpbi5cbiAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcbiAgICAgIHRoaXMuc3RhcnRfKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8oY29ubjogVHJhbnNwb3J0LCB0aW1lc3RhbXA6IG51bWJlcikge1xuICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4nKTtcbiAgICB0aGlzLmNvbm5fID0gY29ubjtcbiAgICB0aGlzLnN0YXRlXyA9IFJlYWx0aW1lU3RhdGUuQ09OTkVDVEVEO1xuXG4gICAgaWYgKHRoaXMub25SZWFkeV8pIHtcbiAgICAgIHRoaXMub25SZWFkeV8odGltZXN0YW1wLCB0aGlzLnNlc3Npb25JZCk7XG4gICAgICB0aGlzLm9uUmVhZHlfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJZiBhZnRlciA1IHNlY29uZHMgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB0byB0aGUgc2VydmVyIHRvIGdldCB0aGUgY29ubmVjdGlvbiBoZWFsdGh5LFxuICAgIC8vIHNlbmQgc29tZSBwaW5ncy5cbiAgICBpZiAodGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID09PSAwKSB7XG4gICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xuICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZW5kUGluZ09uUHJpbWFyeUlmTmVjZXNzYXJ5XygpO1xuICAgICAgfSwgTWF0aC5mbG9vcihERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUykpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKSB7XG4gICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gaXNuJ3QgY29uc2lkZXJlZCBoZWFsdGh5IHlldCwgd2UnbGwgc2VuZCBhIG5vb3AgcGluZyBwYWNrZXQgcmVxdWVzdC5cbiAgICBpZiAoIXRoaXMuaXNIZWFsdGh5XyAmJiB0aGlzLnN0YXRlXyA9PT0gUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgIHRoaXMubG9nXygnc2VuZGluZyBwaW5nIG9uIHByaW1hcnkuJyk7XG4gICAgICB0aGlzLnNlbmREYXRhXyh7IHQ6ICdjJywgZDogeyB0OiBQSU5HLCBkOiB7fSB9IH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25TZWNvbmRhcnlDb25uZWN0aW9uTG9zdF8oKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XG4gICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XG4gICAgaWYgKHRoaXMudHhfID09PSBjb25uIHx8IHRoaXMucnhfID09PSBjb25uKSB7XG4gICAgICAvLyB3ZSBhcmUgcmVseWluZyBvbiB0aGlzIGNvbm5lY3Rpb24gYWxyZWFkeSBpbiBzb21lIGNhcGFjaXR5LiBUaGVyZWZvcmUsIGEgZmFpbHVyZSBpcyByZWFsXG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXZlckNvbm5lY3RlZCBXaGV0aGVyIG9yIG5vdCB0aGUgY29ubmVjdGlvbiBldmVyIHJlYWNoZWQgYSBzZXJ2ZXIuIFVzZWQgdG8gZGV0ZXJtaW5lIGlmXG4gICAqIHdlIHNob3VsZCBmbHVzaCB0aGUgaG9zdCBjYWNoZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBvbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5jb25uXyA9IG51bGw7XG5cbiAgICAvLyBOT1RFOiBJRiB5b3UncmUgc2VlaW5nIGEgRmlyZWZveCBlcnJvciBmb3IgdGhpcyBsaW5lLCBJIHRoaW5rIGl0IG1pZ2h0IGJlIGJlY2F1c2UgaXQncyBnZXR0aW5nXG4gICAgLy8gY2FsbGVkIG9uIHdpbmRvdyBjbG9zZSBhbmQgUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HIGlzIG5vIGxvbmdlciBkZWZpbmVkLiAgSnVzdCBhIGd1ZXNzLlxuICAgIGlmICghZXZlckNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlXyA9PT0gUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICB0aGlzLmxvZ18oJ1JlYWx0aW1lIGNvbm5lY3Rpb24gZmFpbGVkLicpO1xuICAgICAgLy8gU2luY2Ugd2UgZmFpbGVkIHRvIGNvbm5lY3QgYXQgYWxsLCBjbGVhciBhbnkgY2FjaGVkIGVudHJ5IGZvciB0aGlzIG5hbWVzcGFjZSBpbiBjYXNlIHRoZSBtYWNoaW5lIHdlbnQgYXdheVxuICAgICAgaWYgKHRoaXMucmVwb0luZm9fLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XG4gICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnJlbW92ZSgnaG9zdDonICsgdGhpcy5yZXBvSW5mb18uaG9zdCk7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBpbnRlcm5hbCBob3N0IHRvIHdoYXQgd2Ugd291bGQgc2hvdyB0aGUgdXNlciwgaS5lLiA8bnM+LmZpcmViYXNlaW8uY29tXG4gICAgICAgIHRoaXMucmVwb0luZm9fLmludGVybmFsSG9zdCA9IHRoaXMucmVwb0luZm9fLmhvc3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlXyA9PT0gUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBsb3N0LicpO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIG9uQ29ubmVjdGlvblNodXRkb3duXyhyZWFzb246IHN0cmluZykge1xuICAgIHRoaXMubG9nXygnQ29ubmVjdGlvbiBzaHV0ZG93biBjb21tYW5kIHJlY2VpdmVkLiBTaHV0dGluZyBkb3duLi4uJyk7XG5cbiAgICBpZiAodGhpcy5vbktpbGxfKSB7XG4gICAgICB0aGlzLm9uS2lsbF8ocmVhc29uKTtcbiAgICAgIHRoaXMub25LaWxsXyA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB3YW50IHRvIGZpcmUgb25EaXNjb25uZWN0IChraWxsIGlzIGEgZGlmZmVyZW50IGNhc2UpLFxuICAgIC8vIHNvIGNsZWFyIHRoZSBjYWxsYmFjay5cbiAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZW5kRGF0YV8oZGF0YTogb2JqZWN0KSB7XG4gICAgaWYgKHRoaXMuc3RhdGVfICE9PSBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgdGhyb3cgJ0Nvbm5lY3Rpb24gaXMgbm90IGNvbm5lY3RlZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHhfLnNlbmQoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGlzIGNvbm5lY3Rpb24sIGNhbGxpbmcgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVfICE9PSBSZWFsdGltZVN0YXRlLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgdGhpcy5sb2dfKCdDbG9zaW5nIHJlYWx0aW1lIGNvbm5lY3Rpb24uJyk7XG4gICAgICB0aGlzLnN0YXRlXyA9IFJlYWx0aW1lU3RhdGUuRElTQ09OTkVDVEVEO1xuXG4gICAgICB0aGlzLmNsb3NlQ29ubmVjdGlvbnNfKCk7XG5cbiAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdF8pIHtcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKCk7XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNsb3NlQ29ubmVjdGlvbnNfKCkge1xuICAgIHRoaXMubG9nXygnU2h1dHRpbmcgZG93biBhbGwgY29ubmVjdGlvbnMnKTtcbiAgICBpZiAodGhpcy5jb25uXykge1xuICAgICAgdGhpcy5jb25uXy5jbG9zZSgpO1xuICAgICAgdGhpcy5jb25uXyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcbiAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhlYWx0aHlUaW1lb3V0Xykge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhbHRoeVRpbWVvdXRfKTtcbiAgICAgIHRoaXMuaGVhbHRoeVRpbWVvdXRfID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gJy4uL2FwaS9RdWVyeSc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGRlZmluaW5nIHRoZSBzZXQgb2YgYWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgYWdhaW5zdCB0aGUgRmlyZWJhc2Ugc2VydmVyXG4gKiAoYmFzaWNhbGx5IGNvcnJlc3BvbmRzIHRvIG91ciB3aXJlIHByb3RvY29sKS5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTZXJ2ZXJBY3Rpb25zIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6c3RyaW5nfSBjdXJyZW50SGFzaEZuXG4gICAqIEBwYXJhbSB7P251bWJlcn0gdGFnXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCAqKX0gb25Db21wbGV0ZVxuICAgKi9cbiAgYWJzdHJhY3QgbGlzdGVuKFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICBjdXJyZW50SGFzaEZuOiAoKSA9PiBzdHJpbmcsXG4gICAgdGFnOiBudW1iZXIgfCBudWxsLFxuICAgIG9uQ29tcGxldGU6IChhOiBzdHJpbmcsIGI6IGFueSkgPT4gdm9pZFxuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBsaXN0ZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgKiBAcGFyYW0gez9udW1iZXJ9IHRhZ1xuICAgKi9cbiAgYWJzdHJhY3QgdW5saXN0ZW4ocXVlcnk6IFF1ZXJ5LCB0YWc6IG51bWJlciB8IG51bGwpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZyk9fSBvbkNvbXBsZXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaGFzaFxuICAgKi9cbiAgcHV0KFxuICAgIHBhdGhTdHJpbmc6IHN0cmluZyxcbiAgICBkYXRhOiBhbnksXG4gICAgb25Db21wbGV0ZT86IChhOiBzdHJpbmcsIGI6IHN0cmluZykgPT4gdm9pZCxcbiAgICBoYXNoPzogc3RyaW5nXG4gICkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCA/c3RyaW5nKX0gb25Db21wbGV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZz19IGhhc2hcbiAgICovXG4gIG1lcmdlKFxuICAgIHBhdGhTdHJpbmc6IHN0cmluZyxcbiAgICBkYXRhOiBhbnksXG4gICAgb25Db21wbGV0ZTogKGE6IHN0cmluZywgYjogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZCxcbiAgICBoYXNoPzogc3RyaW5nXG4gICkge31cblxuICAvKipcbiAgICogUmVmcmVzaGVzIHRoZSBhdXRoIHRva2VuIGZvciB0aGUgY3VycmVudCBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuXG4gICAqL1xuICByZWZyZXNoQXV0aFRva2VuKHRva2VuOiBzdHJpbmcpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nKT19IG9uQ29tcGxldGVcbiAgICovXG4gIG9uRGlzY29ubmVjdFB1dChcbiAgICBwYXRoU3RyaW5nOiBzdHJpbmcsXG4gICAgZGF0YTogYW55LFxuICAgIG9uQ29tcGxldGU/OiAoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IHZvaWRcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZyk9fSBvbkNvbXBsZXRlXG4gICAqL1xuICBvbkRpc2Nvbm5lY3RNZXJnZShcbiAgICBwYXRoU3RyaW5nOiBzdHJpbmcsXG4gICAgZGF0YTogYW55LFxuICAgIG9uQ29tcGxldGU/OiAoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IHZvaWRcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nKT19IG9uQ29tcGxldGVcbiAgICovXG4gIG9uRGlzY29ubmVjdENhbmNlbChcbiAgICBwYXRoU3RyaW5nOiBzdHJpbmcsXG4gICAgb25Db21wbGV0ZT86IChhOiBzdHJpbmcsIGI6IHN0cmluZykgPT4gdm9pZFxuICApIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICo+fSBzdGF0c1xuICAgKi9cbiAgcmVwb3J0U3RhdHMoc3RhdHM6IHsgW2s6IHN0cmluZ106IGFueSB9KSB7fVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBmaXJlYmFzZSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IGZvckVhY2gsIGNvbnRhaW5zLCBpc0VtcHR5LCBnZXRDb3VudCwgc2FmZUdldCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGVycm9yLCBsb2csIGxvZ1dyYXBwZXIsIHdhcm4sIE9iamVjdFRvVW5pcXVlS2V5IH0gZnJvbSAnLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vdXRpbC9QYXRoJztcbmltcG9ydCB7IFZpc2liaWxpdHlNb25pdG9yIH0gZnJvbSAnLi91dGlsL1Zpc2liaWxpdHlNb25pdG9yJztcbmltcG9ydCB7IE9ubGluZU1vbml0b3IgfSBmcm9tICcuL3V0aWwvT25saW5lTW9uaXRvcic7XG5pbXBvcnQgeyBpc0FkbWluLCBpc1ZhbGlkRm9ybWF0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJy4uL3JlYWx0aW1lL0Nvbm5lY3Rpb24nO1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgaXNNb2JpbGVDb3Jkb3ZhLCBpc1JlYWN0TmF0aXZlLCBpc05vZGVTZGsgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBTZXJ2ZXJBY3Rpb25zIH0gZnJvbSAnLi9TZXJ2ZXJBY3Rpb25zJztcbmltcG9ydCB7IEF1dGhUb2tlblByb3ZpZGVyIH0gZnJvbSAnLi9BdXRoVG9rZW5Qcm92aWRlcic7XG5pbXBvcnQgeyBSZXBvSW5mbyB9IGZyb20gJy4vUmVwb0luZm8nO1xuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuLi9hcGkvUXVlcnknO1xuXG5jb25zdCBSRUNPTk5FQ1RfTUlOX0RFTEFZID0gMTAwMDtcbmNvbnN0IFJFQ09OTkVDVF9NQVhfREVMQVlfREVGQVVMVCA9IDYwICogNSAqIDEwMDA7IC8vIDUgbWludXRlcyBpbiBtaWxsaXNlY29uZHMgKENhc2U6IDE4NTgpXG5jb25zdCBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlMgPSAzMCAqIDEwMDA7IC8vIDMwIHNlY29uZHMgZm9yIGFkbWluIGNsaWVudHMgKGxpa2VseSB0byBiZSBhIGJhY2tlbmQgc2VydmVyKVxuY29uc3QgUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIgPSAxLjM7XG5jb25zdCBSRUNPTk5FQ1RfREVMQVlfUkVTRVRfVElNRU9VVCA9IDMwMDAwOyAvLyBSZXNldCBkZWxheSBiYWNrIHRvIE1JTl9ERUxBWSBhZnRlciBiZWluZyBjb25uZWN0ZWQgZm9yIDMwc2VjLlxuY29uc3QgU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTiA9ICdzZXJ2ZXJfa2lsbCc7XG5cbi8vIElmIGF1dGggZmFpbHMgcmVwZWF0ZWRseSwgd2UnbGwgYXNzdW1lIHNvbWV0aGluZyBpcyB3cm9uZyBhbmQgbG9nIGEgd2FybmluZyAvIGJhY2sgb2ZmLlxuY29uc3QgSU5WQUxJRF9BVVRIX1RPS0VOX1RIUkVTSE9MRCA9IDM7XG5cbmludGVyZmFjZSBMaXN0ZW5TcGVjIHtcbiAgb25Db21wbGV0ZShzOiBzdHJpbmcsIHA/OiBhbnkpOiB2b2lkO1xuXG4gIGhhc2hGbigpOiBzdHJpbmc7XG5cbiAgcXVlcnk6IFF1ZXJ5O1xuICB0YWc6IG51bWJlciB8IG51bGw7XG59XG5cbmludGVyZmFjZSBPbkRpc2Nvbm5lY3RSZXF1ZXN0IHtcbiAgcGF0aFN0cmluZzogc3RyaW5nO1xuICBhY3Rpb246IHN0cmluZztcbiAgZGF0YTogYW55O1xuICBvbkNvbXBsZXRlPzogKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgT3V0c3RhbmRpbmdQdXQge1xuICBhY3Rpb246IHN0cmluZztcbiAgcmVxdWVzdDogT2JqZWN0O1xuICBxdWV1ZWQ/OiBib29sZWFuO1xuICBvbkNvbXBsZXRlOiAoYTogc3RyaW5nLCBiPzogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIEZpcmViYXNlIGNvbm5lY3Rpb24uICBBYnN0cmFjdHMgd2lyZSBwcm90b2NvbCBhbmQgaGFuZGxlcyByZWNvbm5lY3RpbmcuXG4gKlxuICogTk9URTogQWxsIEpTT04gb2JqZWN0cyBzZW50IHRvIHRoZSByZWFsdGltZSBjb25uZWN0aW9uIG11c3QgaGF2ZSBwcm9wZXJ0eSBuYW1lcyBlbmNsb3NlZFxuICogaW4gcXVvdGVzIHRvIG1ha2Ugc3VyZSB0aGUgY2xvc3VyZSBjb21waWxlciBkb2VzIG5vdCBtaW5pZnkgdGhlbS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBlcnNpc3RlbnRDb25uZWN0aW9uIGV4dGVuZHMgU2VydmVyQWN0aW9ucyB7XG4gIC8vIFVzZWQgZm9yIGRpYWdub3N0aWMgbG9nZ2luZy5cbiAgaWQgPSBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8rKztcbiAgcHJpdmF0ZSBsb2dfID0gbG9nV3JhcHBlcigncDonICsgdGhpcy5pZCArICc6Jyk7XG5cbiAgLyoqIEBwcml2YXRlIHtPYmplY3R9ICovXG4gIHByaXZhdGUgaW50ZXJydXB0UmVhc29uc186IHsgW3JlYXNvbjogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG4gIHByaXZhdGUgbGlzdGVuc186IHsgW3BhdGg6IHN0cmluZ106IHsgW3F1ZXJ5SWQ6IHN0cmluZ106IExpc3RlblNwZWMgfSB9ID0ge307XG4gIHByaXZhdGUgb3V0c3RhbmRpbmdQdXRzXzogT3V0c3RhbmRpbmdQdXRbXSA9IFtdO1xuICBwcml2YXRlIG91dHN0YW5kaW5nUHV0Q291bnRfID0gMDtcbiAgcHJpdmF0ZSBvbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfOiBPbkRpc2Nvbm5lY3RSZXF1ZXN0W10gPSBbXTtcbiAgcHJpdmF0ZSBjb25uZWN0ZWRfID0gZmFsc2U7XG4gIHByaXZhdGUgcmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcbiAgcHJpdmF0ZSBtYXhSZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUFYX0RFTEFZX0RFRkFVTFQ7XG4gIHByaXZhdGUgc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXzogKChhOiBPYmplY3QpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gIGxhc3RTZXNzaW9uSWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfG51bGx9ICovXG4gIHByaXZhdGUgZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXzogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICBwcml2YXRlIHZpc2libGVfOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gQmVmb3JlIHdlIGdldCBjb25uZWN0ZWQsIHdlIGtlZXAgYSBxdWV1ZSBvZiBwZW5kaW5nIG1lc3NhZ2VzIHRvIHNlbmQuXG4gIHByaXZhdGUgcmVxdWVzdENCSGFzaF86IHsgW2s6IG51bWJlcl06IChhOiBhbnkpID0+IHZvaWQgfSA9IHt9O1xuICBwcml2YXRlIHJlcXVlc3ROdW1iZXJfID0gMDtcblxuICAvKiogQHByaXZhdGUgez97XG4gICAqICAgc2VuZFJlcXVlc3QoT2JqZWN0KSxcbiAgICogICBjbG9zZSgpXG4gICAqIH19ICovXG4gIHByaXZhdGUgcmVhbHRpbWVfOiB7XG4gICAgc2VuZFJlcXVlc3QoYTogT2JqZWN0KTogdm9pZDtcbiAgICBjbG9zZSgpOiB2b2lkO1xuICB9IHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqIEBwcml2YXRlIHtzdHJpbmd8bnVsbH0gKi9cbiAgcHJpdmF0ZSBhdXRoVG9rZW5fOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBmb3JjZVRva2VuUmVmcmVzaF8gPSBmYWxzZTtcbiAgcHJpdmF0ZSBpbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcblxuICBwcml2YXRlIGZpcnN0Q29ubmVjdGlvbl8gPSB0cnVlO1xuICBwcml2YXRlIGxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBsYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV86IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgbmV4dFBlcnNpc3RlbnRDb25uZWN0aW9uSWRfID0gMDtcblxuICAvKipcbiAgICogQ291bnRlciBmb3IgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGNyZWF0ZWQuIE1haW5seSB1c2VkIGZvciB0YWdnaW5nIGluIHRoZSBsb2dzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBuZXh0Q29ubmVjdGlvbklkXyA9IDA7XG5cbiAgLyoqXG4gICAqIEBpbXBsZW1lbnRzIHtTZXJ2ZXJBY3Rpb25zfVxuICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm9fIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgKiwgYm9vbGVhbiwgP251bWJlcil9IG9uRGF0YVVwZGF0ZV8gQSBjYWxsYmFjayBmb3IgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSBvbkNvbm5lY3RTdGF0dXNfXG4gICAqIEBwYXJhbSBvblNlcnZlckluZm9VcGRhdGVfXG4gICAqIEBwYXJhbSBhdXRoVG9rZW5Qcm92aWRlcl9cbiAgICogQHBhcmFtIGF1dGhPdmVycmlkZV9cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVwb0luZm9fOiBSZXBvSW5mbyxcbiAgICBwcml2YXRlIG9uRGF0YVVwZGF0ZV86IChcbiAgICAgIGE6IHN0cmluZyxcbiAgICAgIGI6IGFueSxcbiAgICAgIGM6IGJvb2xlYW4sXG4gICAgICBkOiBudW1iZXIgfCBudWxsXG4gICAgKSA9PiB2b2lkLFxuICAgIHByaXZhdGUgb25Db25uZWN0U3RhdHVzXzogKGE6IGJvb2xlYW4pID0+IHZvaWQsXG4gICAgcHJpdmF0ZSBvblNlcnZlckluZm9VcGRhdGVfOiAoYTogYW55KSA9PiB2b2lkLFxuICAgIHByaXZhdGUgYXV0aFRva2VuUHJvdmlkZXJfOiBBdXRoVG9rZW5Qcm92aWRlcixcbiAgICBwcml2YXRlIGF1dGhPdmVycmlkZV8/OiBPYmplY3QgfCBudWxsXG4gICkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAoYXV0aE92ZXJyaWRlXyAmJiAhaXNOb2RlU2RrKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0F1dGggb3ZlcnJpZGUgc3BlY2lmaWVkIGluIG9wdGlvbnMsIGJ1dCBub3Qgc3VwcG9ydGVkIG9uIG5vbiBOb2RlLmpzIHBsYXRmb3JtcydcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcblxuICAgIFZpc2liaWxpdHlNb25pdG9yLmdldEluc3RhbmNlKCkub24oJ3Zpc2libGUnLCB0aGlzLm9uVmlzaWJsZV8sIHRoaXMpO1xuXG4gICAgaWYgKHJlcG9JbmZvXy5ob3N0LmluZGV4T2YoJ2ZibG9jYWwnKSA9PT0gLTEpIHtcbiAgICAgIE9ubGluZU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5vbignb25saW5lJywgdGhpcy5vbk9ubGluZV8sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGFjdGlvblxuICAgKiBAcGFyYW0geyp9IGJvZHlcbiAgICogQHBhcmFtIHtmdW5jdGlvbigqKT19IG9uUmVzcG9uc2VcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdGVjdGVkIHNlbmRSZXF1ZXN0KFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIGJvZHk6IGFueSxcbiAgICBvblJlc3BvbnNlPzogKGE6IGFueSkgPT4gdm9pZFxuICApIHtcbiAgICBjb25zdCBjdXJSZXFOdW0gPSArK3RoaXMucmVxdWVzdE51bWJlcl87XG5cbiAgICBjb25zdCBtc2cgPSB7IHI6IGN1clJlcU51bSwgYTogYWN0aW9uLCBiOiBib2R5IH07XG4gICAgdGhpcy5sb2dfKHN0cmluZ2lmeShtc2cpKTtcbiAgICBhc3NlcnQoXG4gICAgICB0aGlzLmNvbm5lY3RlZF8sXG4gICAgICBcInNlbmRSZXF1ZXN0IGNhbGwgd2hlbiB3ZSdyZSBub3QgY29ubmVjdGVkIG5vdCBhbGxvd2VkLlwiXG4gICAgKTtcbiAgICB0aGlzLnJlYWx0aW1lXy5zZW5kUmVxdWVzdChtc2cpO1xuICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfW2N1clJlcU51bV0gPSBvblJlc3BvbnNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgbGlzdGVuKFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICBjdXJyZW50SGFzaEZuOiAoKSA9PiBzdHJpbmcsXG4gICAgdGFnOiBudW1iZXIgfCBudWxsLFxuICAgIG9uQ29tcGxldGU6IChhOiBzdHJpbmcsIGI6IGFueSkgPT4gdm9pZFxuICApIHtcbiAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnlJZCk7XG4gICAgdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXSA9IHRoaXMubGlzdGVuc19bcGF0aFN0cmluZ10gfHwge307XG4gICAgYXNzZXJ0KFxuICAgICAgcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5pc0RlZmF1bHQoKSB8fFxuICAgICAgICAhcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5sb2Fkc0FsbERhdGEoKSxcbiAgICAgICdsaXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeSdcbiAgICApO1xuICAgIGFzc2VydChcbiAgICAgICF0aGlzLmxpc3RlbnNfW3BhdGhTdHJpbmddW3F1ZXJ5SWRdLFxuICAgICAgJ2xpc3RlbigpIGNhbGxlZCB0d2ljZSBmb3Igc2FtZSBwYXRoL3F1ZXJ5SWQuJ1xuICAgICk7XG4gICAgY29uc3QgbGlzdGVuU3BlYzogTGlzdGVuU3BlYyA9IHtcbiAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGUsXG4gICAgICBoYXNoRm46IGN1cnJlbnRIYXNoRm4sXG4gICAgICBxdWVyeTogcXVlcnksXG4gICAgICB0YWc6IHRhZ1xuICAgIH07XG4gICAgdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXVtxdWVyeUlkXSA9IGxpc3RlblNwZWM7XG5cbiAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyF7b25Db21wbGV0ZSgpLFxuICAgKiAgICAgICAgICAgaGFzaEZuKCk6IXN0cmluZyxcbiAgICogICAgICAgICAgIHF1ZXJ5OiAhUXVlcnksXG4gICAqICAgICAgICAgICB0YWc6ID9udW1iZXJ9fSBsaXN0ZW5TcGVjXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHNlbmRMaXN0ZW5fKGxpc3RlblNwZWM6IExpc3RlblNwZWMpIHtcbiAgICBjb25zdCBxdWVyeSA9IGxpc3RlblNwZWMucXVlcnk7XG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5sb2dfKCdMaXN0ZW4gb24gJyArIHBhdGhTdHJpbmcgKyAnIGZvciAnICsgcXVlcnlJZCk7XG4gICAgY29uc3QgcmVxOiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xuXG4gICAgY29uc3QgYWN0aW9uID0gJ3EnO1xuXG4gICAgLy8gT25seSBib3RoZXIgdG8gc2VuZCBxdWVyeSBpZiBpdCdzIG5vbi1kZWZhdWx0LlxuICAgIGlmIChsaXN0ZW5TcGVjLnRhZykge1xuICAgICAgcmVxWydxJ10gPSBxdWVyeS5xdWVyeU9iamVjdCgpO1xuICAgICAgcmVxWyd0J10gPSBsaXN0ZW5TcGVjLnRhZztcbiAgICB9XG5cbiAgICByZXFbLypoYXNoKi8gJ2gnXSA9IGxpc3RlblNwZWMuaGFzaEZuKCk7XG5cbiAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxLCAobWVzc2FnZTogeyBbazogc3RyaW5nXTogYW55IH0pID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQ6IGFueSA9IG1lc3NhZ2VbLypkYXRhKi8gJ2QnXTtcbiAgICAgIGNvbnN0IHN0YXR1czogc3RyaW5nID0gbWVzc2FnZVsvKnN0YXR1cyovICdzJ107XG5cbiAgICAgIC8vIHByaW50IHdhcm5pbmdzIGluIGFueSBjYXNlLi4uXG4gICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi53YXJuT25MaXN0ZW5XYXJuaW5nc18ocGF5bG9hZCwgcXVlcnkpO1xuXG4gICAgICBjb25zdCBjdXJyZW50TGlzdGVuU3BlYyA9XG4gICAgICAgIHRoaXMubGlzdGVuc19bcGF0aFN0cmluZ10gJiYgdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXVtxdWVyeUlkXTtcbiAgICAgIC8vIG9ubHkgdHJpZ2dlciBhY3Rpb25zIGlmIHRoZSBsaXN0ZW4gaGFzbid0IGJlZW4gcmVtb3ZlZCBhbmQgcmVhZGRlZFxuICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5TcGVjID09PSBsaXN0ZW5TcGVjKSB7XG4gICAgICAgIHRoaXMubG9nXygnbGlzdGVuIHJlc3BvbnNlJywgbWVzc2FnZSk7XG5cbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gJ29rJykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0ZW5TcGVjLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICBsaXN0ZW5TcGVjLm9uQ29tcGxldGUoc3RhdHVzLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxuICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHdhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkOiBhbnksIHF1ZXJ5OiBRdWVyeSkge1xuICAgIGlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiBjb250YWlucyhwYXlsb2FkLCAndycpKSB7XG4gICAgICBjb25zdCB3YXJuaW5ncyA9IHNhZmVHZXQocGF5bG9hZCwgJ3cnKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHdhcm5pbmdzKSAmJiB+d2FybmluZ3MuaW5kZXhPZignbm9faW5kZXgnKSkge1xuICAgICAgICBjb25zdCBpbmRleFNwZWMgPVxuICAgICAgICAgICdcIi5pbmRleE9uXCI6IFwiJyArXG4gICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgIC5nZXRRdWVyeVBhcmFtcygpXG4gICAgICAgICAgICAuZ2V0SW5kZXgoKVxuICAgICAgICAgICAgLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICdcIic7XG4gICAgICAgIGNvbnN0IGluZGV4UGF0aCA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVXNpbmcgYW4gdW5zcGVjaWZpZWQgaW5kZXguIFlvdXIgZGF0YSB3aWxsIGJlIGRvd25sb2FkZWQgYW5kIGAgK1xuICAgICAgICAgICAgYGZpbHRlcmVkIG9uIHRoZSBjbGllbnQuIENvbnNpZGVyIGFkZGluZyAke2luZGV4U3BlY30gYXQgYCArXG4gICAgICAgICAgICBgJHtpbmRleFBhdGh9IHRvIHlvdXIgc2VjdXJpdHkgcnVsZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICByZWZyZXNoQXV0aFRva2VuKHRva2VuOiBzdHJpbmcpIHtcbiAgICB0aGlzLmF1dGhUb2tlbl8gPSB0b2tlbjtcbiAgICB0aGlzLmxvZ18oJ0F1dGggdG9rZW4gcmVmcmVzaGVkJyk7XG4gICAgaWYgKHRoaXMuYXV0aFRva2VuXykge1xuICAgICAgdGhpcy50cnlBdXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy4gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgc2ltcGx5IGRlbGV0ZVxuICAgICAgLy90aGUgY3JlZGVudGlhbCBzbyB3ZSBkb250IGJlY29tZSBhdXRoZW50aWNhdGVkIG5leHQgdGltZSB3ZSBjb25uZWN0LlxuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCd1bmF1dGgnLCB7fSwgKCkgPT4ge30pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8odG9rZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY3JlZGVudGlhbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSByZWR1Y2VSZWNvbm5lY3REZWxheUlmQWRtaW5DcmVkZW50aWFsXyhjcmVkZW50aWFsOiBzdHJpbmcpIHtcbiAgICAvLyBOT1RFOiBUaGlzIGlzbid0IGludGVuZGVkIHRvIGJlIGJ1bGxldHByb29mIChhIG1hbGljaW91cyBkZXZlbG9wZXIgY2FuIGFsd2F5cyBqdXN0IG1vZGlmeSB0aGUgY2xpZW50KS5cbiAgICAvLyBBZGRpdGlvbmFsbHksIHdlIGRvbid0IGJvdGhlciByZXNldHRpbmcgdGhlIG1heCBkZWxheSBiYWNrIHRvIHRoZSBkZWZhdWx0IGlmIGF1dGggZmFpbHMgLyBleHBpcmVzLlxuICAgIGNvbnN0IGlzRmlyZWJhc2VTZWNyZXQgPSBjcmVkZW50aWFsICYmIGNyZWRlbnRpYWwubGVuZ3RoID09PSA0MDtcbiAgICBpZiAoaXNGaXJlYmFzZVNlY3JldCB8fCBpc0FkbWluKGNyZWRlbnRpYWwpKSB7XG4gICAgICB0aGlzLmxvZ18oXG4gICAgICAgICdBZG1pbiBhdXRoIGNyZWRlbnRpYWwgZGV0ZWN0ZWQuICBSZWR1Y2luZyBtYXggcmVjb25uZWN0IHRpbWUuJ1xuICAgICAgKTtcbiAgICAgIHRoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBhdXRoZW50aWNhdGUgd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuIElmIHRoZSBhdXRoZW50aWNhdGlvbiBhdHRlbXB0IGZhaWxzLCBpdCdzIHRyaWdnZXJlZCBsaWtlXG4gICAqIGEgYXV0aCByZXZva2VkICh0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQpLlxuICAgKi9cbiAgdHJ5QXV0aCgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0ZWRfICYmIHRoaXMuYXV0aFRva2VuXykge1xuICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmF1dGhUb2tlbl87XG4gICAgICBjb25zdCBhdXRoTWV0aG9kID0gaXNWYWxpZEZvcm1hdCh0b2tlbikgPyAnYXV0aCcgOiAnZ2F1dGgnO1xuICAgICAgY29uc3QgcmVxdWVzdERhdGE6IHsgW2s6IHN0cmluZ106IGFueSB9ID0geyBjcmVkOiB0b2tlbiB9O1xuICAgICAgaWYgKHRoaXMuYXV0aE92ZXJyaWRlXyA9PT0gbnVsbCkge1xuICAgICAgICByZXF1ZXN0RGF0YVsnbm9hdXRoJ10gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5hdXRoT3ZlcnJpZGVfID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXF1ZXN0RGF0YVsnYXV0aHZhciddID0gdGhpcy5hdXRoT3ZlcnJpZGVfO1xuICAgICAgfVxuICAgICAgdGhpcy5zZW5kUmVxdWVzdChhdXRoTWV0aG9kLCByZXF1ZXN0RGF0YSwgKHJlczogeyBbazogc3RyaW5nXTogYW55IH0pID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzOiBzdHJpbmcgPSByZXNbLypzdGF0dXMqLyAncyddO1xuICAgICAgICBjb25zdCBkYXRhOiBzdHJpbmcgPSByZXNbLypkYXRhKi8gJ2QnXSB8fCAnZXJyb3InO1xuXG4gICAgICAgIGlmICh0aGlzLmF1dGhUb2tlbl8gPT09IHRva2VuKSB7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlcnMgcmVjb25uZWN0IGFuZCBmb3JjZSByZWZyZXNoIGZvciBhdXRoIHRva2VuXG4gICAgICAgICAgICB0aGlzLm9uQXV0aFJldm9rZWRfKHN0YXR1cywgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHVubGlzdGVuKHF1ZXJ5OiBRdWVyeSwgdGFnOiBudW1iZXIgfCBudWxsKSB7XG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG5cbiAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcblxuICAgIGFzc2VydChcbiAgICAgIHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkuaXNEZWZhdWx0KCkgfHxcbiAgICAgICAgIXF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkubG9hZHNBbGxEYXRhKCksXG4gICAgICAndW5saXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeSdcbiAgICApO1xuICAgIGNvbnN0IGxpc3RlbiA9IHRoaXMucmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKTtcbiAgICBpZiAobGlzdGVuICYmIHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgdGhpcy5zZW5kVW5saXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5LnF1ZXJ5T2JqZWN0KCksIHRhZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZW5kVW5saXN0ZW5fKFxuICAgIHBhdGhTdHJpbmc6IHN0cmluZyxcbiAgICBxdWVyeUlkOiBzdHJpbmcsXG4gICAgcXVlcnlPYmo6IE9iamVjdCxcbiAgICB0YWc6IG51bWJlciB8IG51bGxcbiAgKSB7XG4gICAgdGhpcy5sb2dfKCdVbmxpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcblxuICAgIGNvbnN0IHJlcTogeyBbazogc3RyaW5nXTogYW55IH0gPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcbiAgICBjb25zdCBhY3Rpb24gPSAnbic7XG4gICAgLy8gT25seSBib3RoZXIgc2VuZGluZyBxdWVyeUlkIGlmIGl0J3Mgbm9uLWRlZmF1bHQuXG4gICAgaWYgKHRhZykge1xuICAgICAgcmVxWydxJ10gPSBxdWVyeU9iajtcbiAgICAgIHJlcVsndCddID0gdGFnO1xuICAgIH1cblxuICAgIHRoaXMuc2VuZFJlcXVlc3QoYWN0aW9uLCByZXEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBvbkRpc2Nvbm5lY3RQdXQoXG4gICAgcGF0aFN0cmluZzogc3RyaW5nLFxuICAgIGRhdGE6IGFueSxcbiAgICBvbkNvbXBsZXRlPzogKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiB2b2lkXG4gICkge1xuICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ28nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnB1c2goe1xuICAgICAgICBwYXRoU3RyaW5nLFxuICAgICAgICBhY3Rpb246ICdvJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb25Db21wbGV0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBvbkRpc2Nvbm5lY3RNZXJnZShcbiAgICBwYXRoU3RyaW5nOiBzdHJpbmcsXG4gICAgZGF0YTogYW55LFxuICAgIG9uQ29tcGxldGU/OiAoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IHZvaWRcbiAgKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0Xygnb20nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnB1c2goe1xuICAgICAgICBwYXRoU3RyaW5nLFxuICAgICAgICBhY3Rpb246ICdvbScsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9uQ29tcGxldGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgb25EaXNjb25uZWN0Q2FuY2VsKFxuICAgIHBhdGhTdHJpbmc6IHN0cmluZyxcbiAgICBvbkNvbXBsZXRlPzogKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiB2b2lkXG4gICkge1xuICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ29jJywgcGF0aFN0cmluZywgbnVsbCwgb25Db21wbGV0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcbiAgICAgICAgcGF0aFN0cmluZyxcbiAgICAgICAgYWN0aW9uOiAnb2MnLFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBvbkNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNlbmRPbkRpc2Nvbm5lY3RfKFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIHBhdGhTdHJpbmc6IHN0cmluZyxcbiAgICBkYXRhOiBhbnksXG4gICAgb25Db21wbGV0ZTogKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiB2b2lkXG4gICkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcsIC8qZGF0YSovIGQ6IGRhdGEgfTtcbiAgICB0aGlzLmxvZ18oJ29uRGlzY29ubmVjdCAnICsgYWN0aW9uLCByZXF1ZXN0KTtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxdWVzdCwgKHJlc3BvbnNlOiB7IFtrOiBzdHJpbmddOiBhbnkgfSkgPT4ge1xuICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBvbkNvbXBsZXRlKHJlc3BvbnNlWy8qc3RhdHVzKi8gJ3MnXSwgcmVzcG9uc2VbLyogZGF0YSAqLyAnZCddKTtcbiAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHB1dChcbiAgICBwYXRoU3RyaW5nOiBzdHJpbmcsXG4gICAgZGF0YTogYW55LFxuICAgIG9uQ29tcGxldGU/OiAoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IHZvaWQsXG4gICAgaGFzaD86IHN0cmluZ1xuICApIHtcbiAgICB0aGlzLnB1dEludGVybmFsKCdwJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIG1lcmdlKFxuICAgIHBhdGhTdHJpbmc6IHN0cmluZyxcbiAgICBkYXRhOiBhbnksXG4gICAgb25Db21wbGV0ZTogKGE6IHN0cmluZywgYjogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZCxcbiAgICBoYXNoPzogc3RyaW5nXG4gICkge1xuICAgIHRoaXMucHV0SW50ZXJuYWwoJ20nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKTtcbiAgfVxuXG4gIHB1dEludGVybmFsKFxuICAgIGFjdGlvbjogc3RyaW5nLFxuICAgIHBhdGhTdHJpbmc6IHN0cmluZyxcbiAgICBkYXRhOiBhbnksXG4gICAgb25Db21wbGV0ZTogKGE6IHN0cmluZywgYjogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZCxcbiAgICBoYXNoPzogc3RyaW5nXG4gICkge1xuICAgIGNvbnN0IHJlcXVlc3Q6IHsgW2s6IHN0cmluZ106IGFueSB9ID0ge1xuICAgICAgLypwYXRoKi8gcDogcGF0aFN0cmluZyxcbiAgICAgIC8qZGF0YSovIGQ6IGRhdGFcbiAgICB9O1xuXG4gICAgaWYgKGhhc2ggIT09IHVuZGVmaW5lZCkgcmVxdWVzdFsvKmhhc2gqLyAnaCddID0gaGFzaDtcblxuICAgIC8vIFRPRE86IE9ubHkga2VlcCB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgcHV0IGZvciBhIGdpdmVuIHBhdGg/XG4gICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLnB1c2goe1xuICAgICAgYWN0aW9uLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG9uQ29tcGxldGVcbiAgICB9KTtcblxuICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8rKztcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgdGhpcy5zZW5kUHV0XyhpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nXygnQnVmZmVyaW5nIHB1dDogJyArIHBhdGhTdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2VuZFB1dF8oaW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0uYWN0aW9uO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnJlcXVlc3Q7XG4gICAgY29uc3Qgb25Db21wbGV0ZSA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0ub25Db21wbGV0ZTtcbiAgICB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnF1ZXVlZCA9IHRoaXMuY29ubmVjdGVkXztcblxuICAgIHRoaXMuc2VuZFJlcXVlc3QoYWN0aW9uLCByZXF1ZXN0LCAobWVzc2FnZTogeyBbazogc3RyaW5nXTogYW55IH0pID0+IHtcbiAgICAgIHRoaXMubG9nXyhhY3Rpb24gKyAnIHJlc3BvbnNlJywgbWVzc2FnZSk7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdO1xuICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50Xy0tO1xuXG4gICAgICAvLyBDbGVhbiB1cCBhcnJheSBvY2Nhc2lvbmFsbHkuXG4gICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkge1xuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18gPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9uQ29tcGxldGUpXG4gICAgICAgIG9uQ29tcGxldGUobWVzc2FnZVsvKnN0YXR1cyovICdzJ10sIG1lc3NhZ2VbLyogZGF0YSAqLyAnZCddKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgcmVwb3J0U3RhdHMoc3RhdHM6IHsgW2s6IHN0cmluZ106IGFueSB9KSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgd2UganVzdCBkcm9wIHRoZSBzdGF0cy5cbiAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0geyAvKmNvdW50ZXJzKi8gYzogc3RhdHMgfTtcbiAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCByZXF1ZXN0KTtcblxuICAgICAgdGhpcy5zZW5kUmVxdWVzdCgvKnN0YXRzKi8gJ3MnLCByZXF1ZXN0LCByZXN1bHQgPT4ge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSByZXN1bHRbLypzdGF0dXMqLyAncyddO1xuICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSByZXN1bHRbLyogZGF0YSAqLyAnZCddO1xuICAgICAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCAnRXJyb3Igc2VuZGluZyBzdGF0czogJyArIGVycm9yUmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gbWVzc2FnZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlOiB7IFtrOiBzdHJpbmddOiBhbnkgfSkge1xuICAgIGlmICgncicgaW4gbWVzc2FnZSkge1xuICAgICAgLy8gdGhpcyBpcyBhIHJlc3BvbnNlXG4gICAgICB0aGlzLmxvZ18oJ2Zyb20gc2VydmVyOiAnICsgc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgIGNvbnN0IHJlcU51bSA9IG1lc3NhZ2VbJ3InXTtcbiAgICAgIGNvbnN0IG9uUmVzcG9uc2UgPSB0aGlzLnJlcXVlc3RDQkhhc2hfW3JlcU51bV07XG4gICAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXN0Q0JIYXNoX1tyZXFOdW1dO1xuICAgICAgICBvblJlc3BvbnNlKG1lc3NhZ2VbLypib2R5Ki8gJ2InXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnZXJyb3InIGluIG1lc3NhZ2UpIHtcbiAgICAgIHRocm93ICdBIHNlcnZlci1zaWRlIGVycm9yIGhhcyBvY2N1cnJlZDogJyArIG1lc3NhZ2VbJ2Vycm9yJ107XG4gICAgfSBlbHNlIGlmICgnYScgaW4gbWVzc2FnZSkge1xuICAgICAgLy8gYSBhbmQgYiBhcmUgYWN0aW9uIGFuZCBib2R5LCByZXNwZWN0aXZlbHlcbiAgICAgIHRoaXMub25EYXRhUHVzaF8obWVzc2FnZVsnYSddLCBtZXNzYWdlWydiJ10pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25EYXRhUHVzaF8oYWN0aW9uOiBzdHJpbmcsIGJvZHk6IHsgW2s6IHN0cmluZ106IGFueSB9KSB7XG4gICAgdGhpcy5sb2dfKCdoYW5kbGVTZXJ2ZXJNZXNzYWdlJywgYWN0aW9uLCBib2R5KTtcbiAgICBpZiAoYWN0aW9uID09PSAnZCcpXG4gICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8oXG4gICAgICAgIGJvZHlbLypwYXRoKi8gJ3AnXSxcbiAgICAgICAgYm9keVsvKmRhdGEqLyAnZCddLFxuICAgICAgICAvKmlzTWVyZ2UqLyBmYWxzZSxcbiAgICAgICAgYm9keVsndCddXG4gICAgICApO1xuICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ20nKVxuICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfKFxuICAgICAgICBib2R5Wy8qcGF0aCovICdwJ10sXG4gICAgICAgIGJvZHlbLypkYXRhKi8gJ2QnXSxcbiAgICAgICAgLyppc01lcmdlPSovIHRydWUsXG4gICAgICAgIGJvZHlbJ3QnXVxuICAgICAgKTtcbiAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdjJylcbiAgICAgIHRoaXMub25MaXN0ZW5SZXZva2VkXyhib2R5Wy8qcGF0aCovICdwJ10sIGJvZHlbLypxdWVyeSovICdxJ10pO1xuICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FjJylcbiAgICAgIHRoaXMub25BdXRoUmV2b2tlZF8oXG4gICAgICAgIGJvZHlbLypzdGF0dXMgY29kZSovICdzJ10sXG4gICAgICAgIGJvZHlbLyogZXhwbGFuYXRpb24gKi8gJ2QnXVxuICAgICAgKTtcbiAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzZCcpIHRoaXMub25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KTtcbiAgICBlbHNlXG4gICAgICBlcnJvcihcbiAgICAgICAgJ1VucmVjb2duaXplZCBhY3Rpb24gcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6ICcgK1xuICAgICAgICAgIHN0cmluZ2lmeShhY3Rpb24pICtcbiAgICAgICAgICAnXFxuQXJlIHlvdSB1c2luZyB0aGUgbGF0ZXN0IGNsaWVudD8nXG4gICAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBvblJlYWR5Xyh0aW1lc3RhbXA6IG51bWJlciwgc2Vzc2lvbklkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmxvZ18oJ2Nvbm5lY3Rpb24gcmVhZHknKTtcbiAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xuICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5oYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCk7XG4gICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgIGlmICh0aGlzLmZpcnN0Q29ubmVjdGlvbl8pIHtcbiAgICAgIHRoaXMuc2VuZENvbm5lY3RTdGF0c18oKTtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlU3RhdGVfKCk7XG4gICAgdGhpcy5maXJzdENvbm5lY3Rpb25fID0gZmFsc2U7XG4gICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfKHRydWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZUNvbm5lY3RfKHRpbWVvdXQ6IG51bWJlcikge1xuICAgIGFzc2VydChcbiAgICAgICF0aGlzLnJlYWx0aW1lXyxcbiAgICAgIFwiU2NoZWR1bGluZyBhIGNvbm5lY3Qgd2hlbiB3ZSdyZSBhbHJlYWR5IGNvbm5lY3RlZC9pbmc/XCJcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XG4gICAgfVxuXG4gICAgLy8gTk9URTogRXZlbiB3aGVuIHRpbWVvdXQgaXMgMCwgaXQncyBpbXBvcnRhbnQgdG8gZG8gYSBzZXRUaW1lb3V0IHRvIHdvcmsgYXJvdW5kIGFuIGluZnVyaWF0aW5nIFwiU2VjdXJpdHkgRXJyb3JcIiBpblxuICAgIC8vIEZpcmVmb3ggd2hlbiB0cnlpbmcgdG8gd3JpdGUgdG8gb3VyIGxvbmctcG9sbGluZyBpZnJhbWUgaW4gc29tZSBzY2VuYXJpb3MgKGUuZy4gRm9yZ2Ugb3Igb3VyIHVuaXQgdGVzdHMpLlxuXG4gICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xuICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uXygpO1xuICAgIH0sIE1hdGguZmxvb3IodGltZW91dCkpIGFzIGFueTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgb25WaXNpYmxlXyh2aXNpYmxlOiBib29sZWFuKSB7XG4gICAgLy8gTk9URTogVGFiYmluZyBhd2F5IGFuZCBiYWNrIHRvIGEgd2luZG93IHdpbGwgZGVmZWF0IG91ciByZWNvbm5lY3QgYmFja29mZiwgYnV0IEkgdGhpbmsgdGhhdCdzIGZpbmUuXG4gICAgaWYgKFxuICAgICAgdmlzaWJsZSAmJlxuICAgICAgIXRoaXMudmlzaWJsZV8gJiZcbiAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID09PSB0aGlzLm1heFJlY29ubmVjdERlbGF5X1xuICAgICkge1xuICAgICAgdGhpcy5sb2dfKCdXaW5kb3cgYmVjYW1lIHZpc2libGUuICBSZWR1Y2luZyBkZWxheS4nKTtcbiAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcblxuICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXykge1xuICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmlzaWJsZV8gPSB2aXNpYmxlO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk9ubGluZV8ob25saW5lOiBib29sZWFuKSB7XG4gICAgaWYgKG9ubGluZSkge1xuICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb25saW5lLicpO1xuICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xuICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXykge1xuICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9mZmxpbmUuICBLaWxsaW5nIGNvbm5lY3Rpb24uJyk7XG4gICAgICBpZiAodGhpcy5yZWFsdGltZV8pIHtcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uUmVhbHRpbWVEaXNjb25uZWN0XygpIHtcbiAgICB0aGlzLmxvZ18oJ2RhdGEgY2xpZW50IGRpc2Nvbm5lY3RlZCcpO1xuICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xuICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcblxuICAgIC8vIFNpbmNlIHdlIGRvbid0IGtub3cgaWYgb3VyIHNlbnQgdHJhbnNhY3Rpb25zIHN1Y2NlZWRlZCBvciBub3QsIHdlIG5lZWQgdG8gY2FuY2VsIHRoZW0uXG4gICAgdGhpcy5jYW5jZWxTZW50VHJhbnNhY3Rpb25zXygpO1xuXG4gICAgLy8gQ2xlYXIgb3V0IHRoZSBwZW5kaW5nIHJlcXVlc3RzLlxuICAgIHRoaXMucmVxdWVzdENCSGFzaF8gPSB7fTtcblxuICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdF8oKSkge1xuICAgICAgaWYgKCF0aGlzLnZpc2libGVfKSB7XG4gICAgICAgIHRoaXMubG9nXyhcIldpbmRvdyBpc24ndCB2aXNpYmxlLiAgRGVsYXlpbmcgcmVjb25uZWN0LlwiKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSB0aGlzLm1heFJlY29ubmVjdERlbGF5XztcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXykge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBiZWVuIGNvbm5lY3RlZCBsb25nIGVub3VnaCwgcmVzZXQgcmVjb25uZWN0IGRlbGF5IHRvIG1pbmltdW0uXG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID1cbiAgICAgICAgICBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfO1xuICAgICAgICBpZiAodGltZVNpbmNlTGFzdENvbm5lY3RTdWNjZWVkZWQgPiBSRUNPTk5FQ1RfREVMQVlfUkVTRVRfVElNRU9VVClcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENvbm5lY3RBdHRlbXB0ID1cbiAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfO1xuICAgICAgbGV0IHJlY29ubmVjdERlbGF5ID0gTWF0aC5tYXgoXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfIC0gdGltZVNpbmNlTGFzdENvbm5lY3RBdHRlbXB0XG4gICAgICApO1xuICAgICAgcmVjb25uZWN0RGVsYXkgPSBNYXRoLnJhbmRvbSgpICogcmVjb25uZWN0RGVsYXk7XG5cbiAgICAgIHRoaXMubG9nXygnVHJ5aW5nIHRvIHJlY29ubmVjdCBpbiAnICsgcmVjb25uZWN0RGVsYXkgKyAnbXMnKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XyhyZWNvbm5lY3REZWxheSk7XG5cbiAgICAgIC8vIEFkanVzdCByZWNvbm5lY3QgZGVsYXkgZm9yIG5leHQgdGltZS5cbiAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gTWF0aC5taW4oXG4gICAgICAgIHRoaXMubWF4UmVjb25uZWN0RGVsYXlfLFxuICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyAqIFJFQ09OTkVDVF9ERUxBWV9NVUxUSVBMSUVSXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18oZmFsc2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBlc3RhYmxpc2hDb25uZWN0aW9uXygpIHtcbiAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3RfKCkpIHtcbiAgICAgIHRoaXMubG9nXygnTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0Jyk7XG4gICAgICB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XG4gICAgICBjb25zdCBvbkRhdGFNZXNzYWdlID0gdGhpcy5vbkRhdGFNZXNzYWdlXy5iaW5kKHRoaXMpO1xuICAgICAgY29uc3Qgb25SZWFkeSA9IHRoaXMub25SZWFkeV8uYmluZCh0aGlzKTtcbiAgICAgIGNvbnN0IG9uRGlzY29ubmVjdCA9IHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBjb25uSWQgPSB0aGlzLmlkICsgJzonICsgUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8rKztcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uc3QgbGFzdFNlc3Npb25JZCA9IHRoaXMubGFzdFNlc3Npb25JZDtcbiAgICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgbGV0IGNvbm5lY3Rpb246IENvbm5lY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgICAgIGNvbnN0IGNsb3NlRm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZFJlcXVlc3RGbiA9IGZ1bmN0aW9uKG1zZzogT2JqZWN0KSB7XG4gICAgICAgIGFzc2VydChcbiAgICAgICAgICBjb25uZWN0aW9uLFxuICAgICAgICAgIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgICAgY29ubmVjdGlvbi5zZW5kUmVxdWVzdChtc2cpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5yZWFsdGltZV8gPSB7XG4gICAgICAgIGNsb3NlOiBjbG9zZUZuLFxuICAgICAgICBzZW5kUmVxdWVzdDogc2VuZFJlcXVlc3RGblxuICAgICAgfTtcblxuICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVRva2VuUmVmcmVzaF87XG4gICAgICB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXyA9IGZhbHNlO1xuXG4gICAgICAvLyBGaXJzdCBmZXRjaCBhdXRoIHRva2VuLCBhbmQgZXN0YWJsaXNoIGNvbm5lY3Rpb24gYWZ0ZXIgZmV0Y2hpbmcgdGhlIHRva2VuIHdhcyBzdWNjZXNzZnVsXG4gICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyX1xuICAgICAgICAuZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoIWNhbmNlbGVkKSB7XG4gICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkLiBDcmVhdGluZyBjb25uZWN0aW9uLicpO1xuICAgICAgICAgICAgc2VsZi5hdXRoVG9rZW5fID0gcmVzdWx0ICYmIHJlc3VsdC5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihcbiAgICAgICAgICAgICAgY29ubklkLFxuICAgICAgICAgICAgICBzZWxmLnJlcG9JbmZvXyxcbiAgICAgICAgICAgICAgb25EYXRhTWVzc2FnZSxcbiAgICAgICAgICAgICAgb25SZWFkeSxcbiAgICAgICAgICAgICAgb25EaXNjb25uZWN0LFxuICAgICAgICAgICAgICAvKiBvbktpbGw9ICovIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHdhcm4ocmVhc29uICsgJyAoJyArIHNlbGYucmVwb0luZm9fLnRvU3RyaW5nKCkgKyAnKScpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW50ZXJydXB0KFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsYXN0U2Vzc2lvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkIGJ1dCB3YXMgY2FuY2VsZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKG51bGwsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgc2VsZi5sb2dfKCdGYWlsZWQgdG8gZ2V0IHRva2VuOiAnICsgZXJyb3IpO1xuICAgICAgICAgIGlmICghY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGlmIChDT05TVEFOVFMuTk9ERV9BRE1JTikge1xuICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBhIGNyaXRpY2FsIGVycm9yIGZvciB0aGUgQWRtaW4gTm9kZS5qcyBTREssIHNvIGxvZyBhIHdhcm5pbmcuXG4gICAgICAgICAgICAgIC8vIEJ1dCBnZXRUb2tlbigpIG1heSBhbHNvIGp1c3QgaGF2ZSB0ZW1wb3JhcmlseSBmYWlsZWQsIHNvIHdlIHN0aWxsIHdhbnQgdG9cbiAgICAgICAgICAgICAgLy8gY29udGludWUgcmV0cnlpbmcuXG4gICAgICAgICAgICAgIHdhcm4oZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvc2VGbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAgICovXG4gIGludGVycnVwdChyZWFzb246IHN0cmluZykge1xuICAgIGxvZygnSW50ZXJydXB0aW5nIGNvbm5lY3Rpb24gZm9yIHJlYXNvbjogJyArIHJlYXNvbik7XG4gICAgdGhpcy5pbnRlcnJ1cHRSZWFzb25zX1tyZWFzb25dID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yZWFsdGltZV8pIHtcbiAgICAgIHRoaXMucmVhbHRpbWVfLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XG4gICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgIHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAgICovXG4gIHJlc3VtZShyZWFzb246IHN0cmluZykge1xuICAgIGxvZygnUmVzdW1pbmcgY29ubmVjdGlvbiBmb3IgcmVhc29uOiAnICsgcmVhc29uKTtcbiAgICBkZWxldGUgdGhpcy5pbnRlcnJ1cHRSZWFzb25zX1tyZWFzb25dO1xuICAgIGlmIChpc0VtcHR5KHRoaXMuaW50ZXJydXB0UmVhc29uc18pKSB7XG4gICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XG4gICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVRpbWVzdGFtcF8odGltZXN0YW1wOiBudW1iZXIpIHtcbiAgICBjb25zdCBkZWx0YSA9IHRpbWVzdGFtcCAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMub25TZXJ2ZXJJbmZvVXBkYXRlXyh7IHNlcnZlclRpbWVPZmZzZXQ6IGRlbHRhIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjYW5jZWxTZW50VHJhbnNhY3Rpb25zXygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHV0ID0gdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2ldO1xuICAgICAgaWYgKHB1dCAmJiAvKmhhc2gqLyAnaCcgaW4gcHV0LnJlcXVlc3QgJiYgcHV0LnF1ZXVlZCkge1xuICAgICAgICBpZiAocHV0Lm9uQ29tcGxldGUpIHB1dC5vbkNvbXBsZXRlKCdkaXNjb25uZWN0Jyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXTtcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50Xy0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cbiAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkgdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshc3RyaW5nfSBwYXRoU3RyaW5nXG4gICAqIEBwYXJhbSB7QXJyYXkuPCo+PX0gcXVlcnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgb25MaXN0ZW5SZXZva2VkXyhwYXRoU3RyaW5nOiBzdHJpbmcsIHF1ZXJ5PzogYW55W10pIHtcbiAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbiBhbmQgbWFudWZhY3R1cmUgYSBcInBlcm1pc3Npb25fZGVuaWVkXCIgZXJyb3IgZm9yIHRoZSBmYWlsZWQgbGlzdGVuLlxuICAgIGxldCBxdWVyeUlkO1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHF1ZXJ5SWQgPSAnZGVmYXVsdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5SWQgPSBxdWVyeS5tYXAocSA9PiBPYmplY3RUb1VuaXF1ZUtleShxKSkuam9pbignJCcpO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW4gPSB0aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XG4gICAgaWYgKGxpc3RlbiAmJiBsaXN0ZW4ub25Db21wbGV0ZSkgbGlzdGVuLm9uQ29tcGxldGUoJ3Blcm1pc3Npb25fZGVuaWVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshc3RyaW5nfSBwYXRoU3RyaW5nXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcXVlcnlJZFxuICAgKiBAcmV0dXJuIHt7cXVlcmllczpBcnJheS48UXVlcnk+LCBvbkNvbXBsZXRlOmZ1bmN0aW9uKHN0cmluZyl9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmc6IHN0cmluZywgcXVlcnlJZDogc3RyaW5nKTogTGlzdGVuU3BlYyB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFBhdGhTdHJpbmcgPSBuZXcgUGF0aChwYXRoU3RyaW5nKS50b1N0cmluZygpOyAvLyBub3JtYWxpemUgcGF0aC5cbiAgICBsZXQgbGlzdGVuO1xuICAgIGlmICh0aGlzLmxpc3RlbnNfW25vcm1hbGl6ZWRQYXRoU3RyaW5nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsaXN0ZW4gPSB0aGlzLmxpc3RlbnNfW25vcm1hbGl6ZWRQYXRoU3RyaW5nXVtxdWVyeUlkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbnNfW25vcm1hbGl6ZWRQYXRoU3RyaW5nXVtxdWVyeUlkXTtcbiAgICAgIGlmIChnZXRDb3VudCh0aGlzLmxpc3RlbnNfW25vcm1hbGl6ZWRQYXRoU3RyaW5nXSkgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuc19bbm9ybWFsaXplZFBhdGhTdHJpbmddO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbGwgbGlzdGVucyBmb3IgdGhpcyBwYXRoIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuICAgICAgbGlzdGVuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkF1dGhSZXZva2VkXyhzdGF0dXNDb2RlOiBzdHJpbmcsIGV4cGxhbmF0aW9uOiBzdHJpbmcpIHtcbiAgICBsb2coJ0F1dGggdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XG4gICAgdGhpcy5hdXRoVG9rZW5fID0gbnVsbDtcbiAgICB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXyA9IHRydWU7XG4gICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcbiAgICAgIC8vIFdlJ2xsIHdhaXQgYSBjb3VwbGUgdGltZXMgYmVmb3JlIGxvZ2dpbmcgdGhlIHdhcm5pbmcgLyBpbmNyZWFzaW5nIHRoZVxuICAgICAgLy8gcmV0cnkgcGVyaW9kIHNpbmNlIG9hdXRoIHRva2VucyB3aWxsIHJlcG9ydCBhcyBcImludmFsaWRcIiBpZiB0aGV5J3JlXG4gICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXG4gICAgICB0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8rKztcbiAgICAgIGlmICh0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPj0gSU5WQUxJRF9BVVRIX1RPS0VOX1RIUkVTSE9MRCkge1xuICAgICAgICAvLyBTZXQgYSBsb25nIHJlY29ubmVjdCBkZWxheSBiZWNhdXNlIHJlY292ZXJ5IGlzIHVubGlrZWx5XG4gICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xuXG4gICAgICAgIC8vIE5vdGlmeSB0aGUgYXV0aCB0b2tlbiBwcm92aWRlciB0aGF0IHRoZSB0b2tlbiBpcyBpbnZhbGlkLCB3aGljaCB3aWxsIGxvZ1xuICAgICAgICAvLyBhIHdhcm5pbmdcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8ubm90aWZ5Rm9ySW52YWxpZFRva2VuKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvblNlY3VyaXR5RGVidWdQYWNrZXRfKGJvZHk6IHsgW2s6IHN0cmluZ106IGFueSB9KSB7XG4gICAgaWYgKHRoaXMuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXykge1xuICAgICAgdGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfKGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJ21zZycgaW4gYm9keSkge1xuICAgICAgICBjb25zb2xlLmxvZygnRklSRUJBU0U6ICcgKyBib2R5Wydtc2cnXS5yZXBsYWNlKCdcXG4nLCAnXFxuRklSRUJBU0U6ICcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc3RvcmVTdGF0ZV8oKSB7XG4gICAgLy9SZS1hdXRoZW50aWNhdGUgb3Vyc2VsdmVzIGlmIHdlIGhhdmUgYSBjcmVkZW50aWFsIHN0b3JlZC5cbiAgICB0aGlzLnRyeUF1dGgoKTtcblxuICAgIC8vIFB1dHMgZGVwZW5kIG9uIGhhdmluZyByZWNlaXZlZCB0aGUgY29ycmVzcG9uZGluZyBkYXRhIHVwZGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIHRoZXkgY29tcGxldGUsIHNvIHdlIG11c3RcbiAgICAvLyBtYWtlIHN1cmUgdG8gc2VuZCBsaXN0ZW5zIGJlZm9yZSBwdXRzLlxuICAgIGZvckVhY2goXG4gICAgICB0aGlzLmxpc3RlbnNfLFxuICAgICAgKHBhdGhTdHJpbmc6IHN0cmluZywgcXVlcmllczogeyBba2V5OiBzdHJpbmddOiBMaXN0ZW5TcGVjIH0pID0+IHtcbiAgICAgICAgZm9yRWFjaChxdWVyaWVzLCAoa2V5OiBzdHJpbmcsIGxpc3RlblNwZWM6IExpc3RlblNwZWMpID0+IHtcbiAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0c19baV0pIHRoaXMuc2VuZFB1dF8oaSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8uc2hpZnQoKTtcbiAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oXG4gICAgICAgIHJlcXVlc3QuYWN0aW9uLFxuICAgICAgICByZXF1ZXN0LnBhdGhTdHJpbmcsXG4gICAgICAgIHJlcXVlc3QuZGF0YSxcbiAgICAgICAgcmVxdWVzdC5vbkNvbXBsZXRlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBjbGllbnQgc3RhdHMgZm9yIGZpcnN0IGNvbm5lY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc2VuZENvbm5lY3RTdGF0c18oKSB7XG4gICAgY29uc3Qgc3RhdHM6IHsgW2s6IHN0cmluZ106IG51bWJlciB9ID0ge307XG5cbiAgICBsZXQgY2xpZW50TmFtZSA9ICdqcyc7XG4gICAgaWYgKENPTlNUQU5UUy5OT0RFX0FETUlOKSB7XG4gICAgICBjbGllbnROYW1lID0gJ2FkbWluX25vZGUnO1xuICAgIH0gZWxzZSBpZiAoQ09OU1RBTlRTLk5PREVfQ0xJRU5UKSB7XG4gICAgICBjbGllbnROYW1lID0gJ25vZGUnO1xuICAgIH1cblxuICAgIHN0YXRzW1xuICAgICAgJ3Nkay4nICsgY2xpZW50TmFtZSArICcuJyArIGZpcmViYXNlLlNES19WRVJTSU9OLnJlcGxhY2UoL1xcLi9nLCAnLScpXG4gICAgXSA9IDE7XG5cbiAgICBpZiAoaXNNb2JpbGVDb3Jkb3ZhKCkpIHtcbiAgICAgIHN0YXRzWydmcmFtZXdvcmsuY29yZG92YSddID0gMTtcbiAgICB9IGVsc2UgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgc3RhdHNbJ2ZyYW1ld29yay5yZWFjdG5hdGl2ZSddID0gMTtcbiAgICB9XG4gICAgdGhpcy5yZXBvcnRTdGF0cyhzdGF0cyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc2hvdWxkUmVjb25uZWN0XygpOiBib29sZWFuIHtcbiAgICBjb25zdCBvbmxpbmUgPSBPbmxpbmVNb25pdG9yLmdldEluc3RhbmNlKCkuY3VycmVudGx5T25saW5lKCk7XG4gICAgcmV0dXJuIGlzRW1wdHkodGhpcy5pbnRlcnJ1cHRSZWFzb25zXykgJiYgb25saW5lO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgbG9nV3JhcHBlciwgd2FybiB9IGZyb20gJy4vdXRpbC91dGlsJztcbmltcG9ydCB7IGpzb25FdmFsIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgc2FmZUdldCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHF1ZXJ5c3RyaW5nIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgU2VydmVyQWN0aW9ucyB9IGZyb20gJy4vU2VydmVyQWN0aW9ucyc7XG5pbXBvcnQgeyBSZXBvSW5mbyB9IGZyb20gJy4vUmVwb0luZm8nO1xuaW1wb3J0IHsgQXV0aFRva2VuUHJvdmlkZXIgfSBmcm9tICcuL0F1dGhUb2tlblByb3ZpZGVyJztcbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSAnLi4vYXBpL1F1ZXJ5JztcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBTZXJ2ZXJBY3Rpb25zIHRoYXQgY29tbXVuaWNhdGVzIHdpdGggdGhlIHNlcnZlciB2aWEgUkVTVCByZXF1ZXN0cy5cbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGNyYXdsZXJzLCB3aGVyZSB3ZSBkb24ndCB3YW50IHRvIHNwaW4gdXAgYSBmdWxsXG4gKiBwZXJzaXN0ZW50IGNvbm5lY3Rpb24gKHVzaW5nIFdlYlNvY2tldHMgb3IgbG9uZy1wb2xsaW5nKVxuICovXG5leHBvcnQgY2xhc3MgUmVhZG9ubHlSZXN0Q2xpZW50IGV4dGVuZHMgU2VydmVyQWN0aW9ucyB7XG4gIHJlcG9ydFN0YXRzKHN0YXRzOiB7IFtrOiBzdHJpbmddOiBhbnkgfSk6IHZvaWQge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oLi4uWypdKX0gKi9cbiAgcHJpdmF0ZSBsb2dfOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQgPSBsb2dXcmFwcGVyKCdwOnJlc3Q6Jyk7XG5cbiAgLyoqXG4gICAqIFdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdG8gdHJhY2sgbGlzdGVucywgZXhjZXB0IHRvIHByZXZlbnQgdXMgY2FsbGluZyBhbiBvbkNvbXBsZXRlIGZvciBhIGxpc3RlblxuICAgKiB0aGF0J3MgYmVlbiByZW1vdmVkLiA6LS9cbiAgICpcbiAgICogQHByaXZhdGUgeyFPYmplY3QuPHN0cmluZywgIU9iamVjdD59XG4gICAqL1xuICBwcml2YXRlIGxpc3RlbnNfOiB7IFtrOiBzdHJpbmddOiBPYmplY3QgfSA9IHt9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICogQHBhcmFtIHs/bnVtYmVyPX0gdGFnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBnZXRMaXN0ZW5JZF8ocXVlcnk6IFF1ZXJ5LCB0YWc/OiBudW1iZXIgfCBudWxsKTogc3RyaW5nIHtcbiAgICBpZiAodGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAndGFnJCcgKyB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5pc0RlZmF1bHQoKSxcbiAgICAgICAgXCJzaG91bGQgaGF2ZSBhIHRhZyBpZiBpdCdzIG5vdCBhIGRlZmF1bHQgcXVlcnkuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gcXVlcnkucGF0aC50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm9fIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgKiwgYm9vbGVhbiwgP251bWJlcil9IG9uRGF0YVVwZGF0ZV8gQSBjYWxsYmFjayBmb3IgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7QXV0aFRva2VuUHJvdmlkZXJ9IGF1dGhUb2tlblByb3ZpZGVyX1xuICAgKiBAaW1wbGVtZW50cyB7U2VydmVyQWN0aW9uc31cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVwb0luZm9fOiBSZXBvSW5mbyxcbiAgICBwcml2YXRlIG9uRGF0YVVwZGF0ZV86IChcbiAgICAgIGE6IHN0cmluZyxcbiAgICAgIGI6IGFueSxcbiAgICAgIGM6IGJvb2xlYW4sXG4gICAgICBkOiBudW1iZXIgfCBudWxsXG4gICAgKSA9PiB2b2lkLFxuICAgIHByaXZhdGUgYXV0aFRva2VuUHJvdmlkZXJfOiBBdXRoVG9rZW5Qcm92aWRlclxuICApIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGxpc3RlbihcbiAgICBxdWVyeTogUXVlcnksXG4gICAgY3VycmVudEhhc2hGbjogKCkgPT4gc3RyaW5nLFxuICAgIHRhZzogbnVtYmVyIHwgbnVsbCxcbiAgICBvbkNvbXBsZXRlOiAoYTogc3RyaW5nLCBiOiBhbnkpID0+IHZvaWRcbiAgKSB7XG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICB0aGlzLmxvZ18oXG4gICAgICAnTGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKVxuICAgICk7XG5cbiAgICAvLyBNYXJrIHRoaXMgbGlzdGVuZXIgc28gd2UgY2FuIHRlbGwgaWYgaXQncyByZW1vdmVkLlxuICAgIGNvbnN0IGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcbiAgICBjb25zdCB0aGlzTGlzdGVuID0ge307XG4gICAgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF0gPSB0aGlzTGlzdGVuO1xuXG4gICAgY29uc3QgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzID0gcXVlcnlcbiAgICAgIC5nZXRRdWVyeVBhcmFtcygpXG4gICAgICAudG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzKCk7XG5cbiAgICB0aGlzLnJlc3RSZXF1ZXN0XyhcbiAgICAgIHBhdGhTdHJpbmcgKyAnLmpzb24nLFxuICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzLFxuICAgICAgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgbGV0IGRhdGEgPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGVycm9yID09PSA0MDQpIHtcbiAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICBlcnJvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8ocGF0aFN0cmluZywgZGF0YSwgLyppc01lcmdlPSovIGZhbHNlLCB0YWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNhZmVHZXQodGhpcy5saXN0ZW5zXywgbGlzdGVuSWQpID09PSB0aGlzTGlzdGVuKSB7XG4gICAgICAgICAgbGV0IHN0YXR1cztcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnb2snO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgPT0gNDAxKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAncGVybWlzc2lvbl9kZW5pZWQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAncmVzdF9lcnJvcjonICsgZXJyb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb25Db21wbGV0ZShzdGF0dXMsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICB1bmxpc3RlbihxdWVyeTogUXVlcnksIHRhZzogbnVtYmVyIHwgbnVsbCkge1xuICAgIGNvbnN0IGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcbiAgICBkZWxldGUgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF07XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcmVmcmVzaEF1dGhUb2tlbih0b2tlbjogc3RyaW5nKSB7XG4gICAgLy8gbm8tb3Agc2luY2Ugd2UganVzdCBhbHdheXMgY2FsbCBnZXRUb2tlbi5cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIFJFU1QgcmVxdWVzdCB0byB0aGUgZ2l2ZW4gcGF0aCwgd2l0aCB0aGUgcHJvdmlkZWQgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMsXG4gICAqIGFuZCBhbnkgYXV0aCBjcmVkZW50aWFscyB3ZSBoYXZlLlxuICAgKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICo+fSBxdWVyeVN0cmluZ1BhcmFtZXRlcnNcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP251bWJlciwgKj0pfSBjYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSByZXN0UmVxdWVzdF8oXG4gICAgcGF0aFN0cmluZzogc3RyaW5nLFxuICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyczogeyBbazogc3RyaW5nXTogYW55IH0gPSB7fSxcbiAgICBjYWxsYmFjazogKChhOiBudW1iZXIgfCBudWxsLCBiPzogYW55KSA9PiB2b2lkKSB8IG51bGxcbiAgKSB7XG4gICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzWydmb3JtYXQnXSA9ICdleHBvcnQnO1xuXG4gICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl9cbiAgICAgIC5nZXRUb2tlbigvKmZvcmNlUmVmcmVzaD0qLyBmYWxzZSlcbiAgICAgIC50aGVuKGF1dGhUb2tlbkRhdGEgPT4ge1xuICAgICAgICBjb25zdCBhdXRoVG9rZW4gPSBhdXRoVG9rZW5EYXRhICYmIGF1dGhUb2tlbkRhdGEuYWNjZXNzVG9rZW47XG4gICAgICAgIGlmIChhdXRoVG9rZW4pIHtcbiAgICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnNbJ2F1dGgnXSA9IGF1dGhUb2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVybCA9XG4gICAgICAgICAgKHRoaXMucmVwb0luZm9fLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICtcbiAgICAgICAgICB0aGlzLnJlcG9JbmZvXy5ob3N0ICtcbiAgICAgICAgICBwYXRoU3RyaW5nICtcbiAgICAgICAgICAnPycgK1xuICAgICAgICAgICducz0nICtcbiAgICAgICAgICB0aGlzLnJlcG9JbmZvXy5uYW1lc3BhY2UgK1xuICAgICAgICAgIHF1ZXJ5c3RyaW5nKHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyk7XG5cbiAgICAgICAgdGhpcy5sb2dfKCdTZW5kaW5nIFJFU1QgcmVxdWVzdCBmb3IgJyArIHVybCk7XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5sb2dfKFxuICAgICAgICAgICAgICAnUkVTVCBSZXNwb25zZSBmb3IgJyArIHVybCArICcgcmVjZWl2ZWQuIHN0YXR1czonLFxuICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAncmVzcG9uc2U6JyxcbiAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCByZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXMgPSBqc29uRXZhbCh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2UgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICB1cmwgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIDQwMSBhbmQgNDA0IGFyZSBleHBlY3RlZC5cbiAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDQwMSAmJiB4aHIuc3RhdHVzICE9PSA0MDQpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgJ0dvdCB1bnN1Y2Nlc3NmdWwgUkVTVCByZXNwb25zZSBmb3IgJyArXG4gICAgICAgICAgICAgICAgICAgIHVybCArXG4gICAgICAgICAgICAgICAgICAgICcgU3RhdHVzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIC8qYXN5bmNocm9ub3VzPSovIHRydWUpO1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBnZW5lcmF0ZVdpdGhWYWx1ZXMsXG4gIHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QsXG4gIHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZVxufSBmcm9tICcuL3V0aWwvU2VydmVyVmFsdWVzJztcbmltcG9ydCB7IG5vZGVGcm9tSlNPTiB9IGZyb20gJy4vc25hcC9ub2RlRnJvbUpTT04nO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vdXRpbC9QYXRoJztcbmltcG9ydCB7IFNwYXJzZVNuYXBzaG90VHJlZSB9IGZyb20gJy4vU3BhcnNlU25hcHNob3RUcmVlJztcbmltcG9ydCB7IFN5bmNUcmVlIH0gZnJvbSAnLi9TeW5jVHJlZSc7XG5pbXBvcnQgeyBTbmFwc2hvdEhvbGRlciB9IGZyb20gJy4vU25hcHNob3RIb2xkZXInO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgYmVpbmdDcmF3bGVkLCBlYWNoLCBleGNlcHRpb25HdWFyZCwgd2FybiwgbG9nIH0gZnJvbSAnLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgbWFwLCBmb3JFYWNoLCBpc0VtcHR5IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQXV0aFRva2VuUHJvdmlkZXIgfSBmcm9tICcuL0F1dGhUb2tlblByb3ZpZGVyJztcbmltcG9ydCB7IFN0YXRzTWFuYWdlciB9IGZyb20gJy4vc3RhdHMvU3RhdHNNYW5hZ2VyJztcbmltcG9ydCB7IFN0YXRzUmVwb3J0ZXIgfSBmcm9tICcuL3N0YXRzL1N0YXRzUmVwb3J0ZXInO1xuaW1wb3J0IHsgU3RhdHNMaXN0ZW5lciB9IGZyb20gJy4vc3RhdHMvU3RhdHNMaXN0ZW5lcic7XG5pbXBvcnQgeyBFdmVudFF1ZXVlIH0gZnJvbSAnLi92aWV3L0V2ZW50UXVldWUnO1xuaW1wb3J0IHsgUGVyc2lzdGVudENvbm5lY3Rpb24gfSBmcm9tICcuL1BlcnNpc3RlbnRDb25uZWN0aW9uJztcbmltcG9ydCB7IFJlYWRvbmx5UmVzdENsaWVudCB9IGZyb20gJy4vUmVhZG9ubHlSZXN0Q2xpZW50JztcbmltcG9ydCB7IEZpcmViYXNlQXBwIH0gZnJvbSAnQGZpcmViYXNlL2FwcC10eXBlcyc7XG5pbXBvcnQgeyBSZXBvSW5mbyB9IGZyb20gJy4vUmVwb0luZm8nO1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tICcuLi9hcGkvRGF0YWJhc2UnO1xuaW1wb3J0IHsgU2VydmVyQWN0aW9ucyB9IGZyb20gJy4vU2VydmVyQWN0aW9ucyc7XG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gJy4uL2FwaS9RdWVyeSc7XG5pbXBvcnQgeyBFdmVudFJlZ2lzdHJhdGlvbiB9IGZyb20gJy4vdmlldy9FdmVudFJlZ2lzdHJhdGlvbic7XG5pbXBvcnQgeyBTdGF0c0NvbGxlY3Rpb24gfSBmcm9tICcuL3N0YXRzL1N0YXRzQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vdmlldy9FdmVudCc7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9zbmFwL05vZGUnO1xuXG5jb25zdCBJTlRFUlJVUFRfUkVBU09OID0gJ3JlcG9faW50ZXJydXB0JztcblxuLyoqXG4gKiBBIGNvbm5lY3Rpb24gdG8gYSBzaW5nbGUgZGF0YSByZXBvc2l0b3J5LlxuICovXG5leHBvcnQgY2xhc3MgUmVwbyB7XG4gIGRhdGFVcGRhdGVDb3VudCA9IDA7XG4gIHByaXZhdGUgaW5mb1N5bmNUcmVlXzogU3luY1RyZWU7XG4gIHByaXZhdGUgc2VydmVyU3luY1RyZWVfOiBTeW5jVHJlZTtcblxuICBwcml2YXRlIHN0YXRzXzogU3RhdHNDb2xsZWN0aW9uO1xuICBwcml2YXRlIHN0YXRzTGlzdGVuZXJfOiBTdGF0c0xpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZXZlbnRRdWV1ZV8gPSBuZXcgRXZlbnRRdWV1ZSgpO1xuICBwcml2YXRlIG5leHRXcml0ZUlkXyA9IDE7XG4gIHByaXZhdGUgc2VydmVyXzogU2VydmVyQWN0aW9ucztcbiAgcHJpdmF0ZSBzdGF0c1JlcG9ydGVyXzogU3RhdHNSZXBvcnRlcjtcbiAgcHJpdmF0ZSB0cmFuc2FjdGlvbnNfaW5pdF86ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgaW5mb0RhdGFfOiBTbmFwc2hvdEhvbGRlcjtcbiAgcHJpdmF0ZSBhYm9ydFRyYW5zYWN0aW9uc186IChwYXRoOiBQYXRoKSA9PiBQYXRoO1xuICBwcml2YXRlIHJlcnVuVHJhbnNhY3Rpb25zXzogKGNoYW5nZWRQYXRoOiBQYXRoKSA9PiBQYXRoO1xuICBwcml2YXRlIGludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja186XG4gICAgfCAoKGE6IHN0cmluZywgYjogYW55KSA9PiB2b2lkKVxuICAgIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX19kYXRhYmFzZTogRGF0YWJhc2U7XG5cbiAgLy8gQSBsaXN0IG9mIGRhdGEgcGllY2VzIGFuZCBwYXRocyB0byBiZSBzZXQgd2hlbiB0aGlzIGNsaWVudCBkaXNjb25uZWN0cy5cbiAgcHJpdmF0ZSBvbkRpc2Nvbm5lY3RfID0gbmV3IFNwYXJzZVNuYXBzaG90VHJlZSgpO1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHNob3VsZCBiZSBAcHJpdmF0ZSBidXQgaXQncyB1c2VkIGJ5IHRlc3RfYWNjZXNzLmpzIGFuZCBpbnRlcm5hbC5qc1xuICAgKiBAdHlwZSB7P1BlcnNpc3RlbnRDb25uZWN0aW9ufVxuICAgKi9cbiAgcGVyc2lzdGVudENvbm5lY3Rpb25fOiBQZXJzaXN0ZW50Q29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm9fXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZXN0Q2xpZW50XG4gICAqIEBwYXJhbSB7IUZpcmViYXNlQXBwfSBhcHBcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZXBvSW5mb186IFJlcG9JbmZvLFxuICAgIGZvcmNlUmVzdENsaWVudDogYm9vbGVhbixcbiAgICBwdWJsaWMgYXBwOiBGaXJlYmFzZUFwcFxuICApIHtcbiAgICAvKiogQHR5cGUgeyFBdXRoVG9rZW5Qcm92aWRlcn0gKi9cbiAgICBjb25zdCBhdXRoVG9rZW5Qcm92aWRlciA9IG5ldyBBdXRoVG9rZW5Qcm92aWRlcihhcHApO1xuXG4gICAgdGhpcy5zdGF0c18gPSBTdGF0c01hbmFnZXIuZ2V0Q29sbGVjdGlvbihyZXBvSW5mb18pO1xuXG4gICAgaWYgKGZvcmNlUmVzdENsaWVudCB8fCBiZWluZ0NyYXdsZWQoKSkge1xuICAgICAgdGhpcy5zZXJ2ZXJfID0gbmV3IFJlYWRvbmx5UmVzdENsaWVudChcbiAgICAgICAgdGhpcy5yZXBvSW5mb18sXG4gICAgICAgIHRoaXMub25EYXRhVXBkYXRlXy5iaW5kKHRoaXMpLFxuICAgICAgICBhdXRoVG9rZW5Qcm92aWRlclxuICAgICAgKTtcblxuICAgICAgLy8gTWlub3IgaGFjazogRmlyZSBvbkNvbm5lY3QgaW1tZWRpYXRlbHksIHNpbmNlIHRoZXJlJ3Mgbm8gYWN0dWFsIGNvbm5lY3Rpb24uXG4gICAgICBzZXRUaW1lb3V0KHRoaXMub25Db25uZWN0U3RhdHVzXy5iaW5kKHRoaXMsIHRydWUpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXV0aE92ZXJyaWRlID0gYXBwLm9wdGlvbnNbJ2RhdGFiYXNlQXV0aFZhcmlhYmxlT3ZlcnJpZGUnXTtcbiAgICAgIC8vIFZhbGlkYXRlIGF1dGhPdmVycmlkZVxuICAgICAgaWYgKHR5cGVvZiBhdXRoT3ZlcnJpZGUgIT09ICd1bmRlZmluZWQnICYmIGF1dGhPdmVycmlkZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGF1dGhPdmVycmlkZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnT25seSBvYmplY3RzIGFyZSBzdXBwb3J0ZWQgZm9yIG9wdGlvbiBkYXRhYmFzZUF1dGhWYXJpYWJsZU92ZXJyaWRlJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdHJpbmdpZnkoYXV0aE92ZXJyaWRlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhdXRoT3ZlcnJpZGUgcHJvdmlkZWQ6ICcgKyBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXyA9IG5ldyBQZXJzaXN0ZW50Q29ubmVjdGlvbihcbiAgICAgICAgdGhpcy5yZXBvSW5mb18sXG4gICAgICAgIHRoaXMub25EYXRhVXBkYXRlXy5iaW5kKHRoaXMpLFxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18uYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfLmJpbmQodGhpcyksXG4gICAgICAgIGF1dGhUb2tlblByb3ZpZGVyLFxuICAgICAgICBhdXRoT3ZlcnJpZGVcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc2VydmVyXyA9IHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fO1xuICAgIH1cblxuICAgIGF1dGhUb2tlblByb3ZpZGVyLmFkZFRva2VuQ2hhbmdlTGlzdGVuZXIodG9rZW4gPT4ge1xuICAgICAgdGhpcy5zZXJ2ZXJfLnJlZnJlc2hBdXRoVG9rZW4odG9rZW4pO1xuICAgIH0pO1xuXG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgUmVwb3MgZm9yIHRoZSBzYW1lIHJlcG9JbmZvIChpLmUuIHRoZXJlIGFyZSBtdWx0aXBsZSBGaXJlYmFzZS5Db250ZXh0cyBiZWluZyB1c2VkKSxcbiAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gY3JlYXRlIG9uZSBTdGF0c1JlcG9ydGVyLiAgQXMgc3VjaCwgd2UnbGwgcmVwb3J0IHN0YXRzIG92ZXIgdGhlIGZpcnN0IFJlcG8gY3JlYXRlZC5cbiAgICB0aGlzLnN0YXRzUmVwb3J0ZXJfID0gU3RhdHNNYW5hZ2VyLmdldE9yQ3JlYXRlUmVwb3J0ZXIoXG4gICAgICByZXBvSW5mb18sXG4gICAgICAoKSA9PiBuZXcgU3RhdHNSZXBvcnRlcih0aGlzLnN0YXRzXywgdGhpcy5zZXJ2ZXJfKVxuICAgICk7XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9uc19pbml0XygpO1xuXG4gICAgLy8gVXNlZCBmb3IgLmluZm8uXG4gICAgdGhpcy5pbmZvRGF0YV8gPSBuZXcgU25hcHNob3RIb2xkZXIoKTtcbiAgICB0aGlzLmluZm9TeW5jVHJlZV8gPSBuZXcgU3luY1RyZWUoe1xuICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XG4gICAgICAgIGxldCBpbmZvRXZlbnRzOiBFdmVudFtdID0gW107XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmluZm9EYXRhXy5nZXROb2RlKHF1ZXJ5LnBhdGgpO1xuICAgICAgICAvLyBUaGlzIGlzIHBvc3NpYmx5IGEgaGFjaywgYnV0IHdlIGhhdmUgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgLmluZm8gZW5kcG9pbnRzLiBXZSBkb24ndCByYWlzZSBudWxsIGV2ZW50c1xuICAgICAgICAvLyBvbiBpbml0aWFsIGRhdGEuLi5cbiAgICAgICAgaWYgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgIGluZm9FdmVudHMgPSB0aGlzLmluZm9TeW5jVHJlZV8uYXBwbHlTZXJ2ZXJPdmVyd3JpdGUoXG4gICAgICAgICAgICBxdWVyeS5wYXRoLFxuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCdvaycpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmZvRXZlbnRzO1xuICAgICAgfSxcbiAgICAgIHN0b3BMaXN0ZW5pbmc6ICgpID0+IHt9XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVJbmZvXygnY29ubmVjdGVkJywgZmFsc2UpO1xuXG4gICAgdGhpcy5zZXJ2ZXJTeW5jVHJlZV8gPSBuZXcgU3luY1RyZWUoe1xuICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XG4gICAgICAgIHRoaXMuc2VydmVyXy5saXN0ZW4ocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgKHN0YXR1cywgZGF0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IG9uQ29tcGxldGUoc3RhdHVzLCBkYXRhKTtcbiAgICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocXVlcnkucGF0aCwgZXZlbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vIHN5bmNocm9ub3VzIGV2ZW50cyBmb3IgbmV0d29yay1iYWNrZWQgc3luYyB0cmVlc1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9LFxuICAgICAgc3RvcExpc3RlbmluZzogKHF1ZXJ5LCB0YWcpID0+IHtcbiAgICAgICAgdGhpcy5zZXJ2ZXJfLnVubGlzdGVuKHF1ZXJ5LCB0YWcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gIFRoZSBVUkwgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCBvZiB0aGlzIEZpcmViYXNlLlxuICAgKi9cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHRoaXMucmVwb0luZm9fLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICsgdGhpcy5yZXBvSW5mb18uaG9zdFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IXN0cmluZ30gVGhlIG5hbWVzcGFjZSByZXByZXNlbnRlZCBieSB0aGUgcmVwby5cbiAgICovXG4gIG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yZXBvSW5mb18ubmFtZXNwYWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcywgdGFraW5nIHRoZSBzZXJ2ZXIgb2Zmc2V0IGludG8gYWNjb3VudCBpZiB3ZSBoYXZlIG9uZS5cbiAgICovXG4gIHNlcnZlclRpbWUoKTogbnVtYmVyIHtcbiAgICBjb25zdCBvZmZzZXROb2RlID0gdGhpcy5pbmZvRGF0YV8uZ2V0Tm9kZShcbiAgICAgIG5ldyBQYXRoKCcuaW5mby9zZXJ2ZXJUaW1lT2Zmc2V0JylcbiAgICApO1xuICAgIGNvbnN0IG9mZnNldCA9IChvZmZzZXROb2RlLnZhbCgpIGFzIG51bWJlcikgfHwgMDtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgU2VydmVyVmFsdWVzIHVzaW5nIHNvbWUgdmFyaWFibGVzIGZyb20gdGhlIHJlcG8gb2JqZWN0LlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cbiAgZ2VuZXJhdGVTZXJ2ZXJWYWx1ZXMoKTogT2JqZWN0IHtcbiAgICByZXR1cm4gZ2VuZXJhdGVXaXRoVmFsdWVzKHtcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5zZXJ2ZXJUaW1lKClcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYnkgcmVhbHRpbWUgd2hlbiB3ZSBnZXQgbmV3IG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNZXJnZVxuICAgKiBAcGFyYW0gez9udW1iZXJ9IHRhZ1xuICAgKi9cbiAgcHJpdmF0ZSBvbkRhdGFVcGRhdGVfKFxuICAgIHBhdGhTdHJpbmc6IHN0cmluZyxcbiAgICBkYXRhOiBhbnksXG4gICAgaXNNZXJnZTogYm9vbGVhbixcbiAgICB0YWc6IG51bWJlciB8IG51bGxcbiAgKSB7XG4gICAgLy8gRm9yIHRlc3RpbmcuXG4gICAgdGhpcy5kYXRhVXBkYXRlQ291bnQrKztcbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgocGF0aFN0cmluZyk7XG4gICAgZGF0YSA9IHRoaXMuaW50ZXJjZXB0U2VydmVyRGF0YUNhbGxiYWNrX1xuICAgICAgPyB0aGlzLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18ocGF0aFN0cmluZywgZGF0YSlcbiAgICAgIDogZGF0YTtcbiAgICBsZXQgZXZlbnRzID0gW107XG4gICAgaWYgKHRhZykge1xuICAgICAgaWYgKGlzTWVyZ2UpIHtcbiAgICAgICAgY29uc3QgdGFnZ2VkQ2hpbGRyZW4gPSBtYXAoZGF0YSBhcyB7IFtrOiBzdHJpbmddOiBhbnkgfSwgKHJhdzogYW55KSA9PlxuICAgICAgICAgIG5vZGVGcm9tSlNPTihyYXcpXG4gICAgICAgICk7XG4gICAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5VGFnZ2VkUXVlcnlNZXJnZShcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHRhZ2dlZENoaWxkcmVuLFxuICAgICAgICAgIHRhZ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGFnZ2VkU25hcCA9IG5vZGVGcm9tSlNPTihkYXRhKTtcbiAgICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHRhZ2dlZFNuYXAsXG4gICAgICAgICAgdGFnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc01lcmdlKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkQ2hpbGRyZW4gPSBtYXAoZGF0YSBhcyB7IFtrOiBzdHJpbmddOiBhbnkgfSwgKHJhdzogYW55KSA9PlxuICAgICAgICBub2RlRnJvbUpTT04ocmF3KVxuICAgICAgKTtcbiAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5U2VydmVyTWVyZ2UocGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc25hcCA9IG5vZGVGcm9tSlNPTihkYXRhKTtcbiAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5U2VydmVyT3ZlcndyaXRlKHBhdGgsIHNuYXApO1xuICAgIH1cbiAgICBsZXQgYWZmZWN0ZWRQYXRoID0gcGF0aDtcbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFNpbmNlIHdlIGhhdmUgYSBsaXN0ZW5lciBvdXRzdGFuZGluZyBmb3IgZWFjaCB0cmFuc2FjdGlvbiwgcmVjZWl2aW5nIGFueSBldmVudHNcbiAgICAgIC8vIGlzIGEgcHJveHkgZm9yIHNvbWUgY2hhbmdlIGhhdmluZyBvY2N1cnJlZC5cbiAgICAgIGFmZmVjdGVkUGF0aCA9IHRoaXMucmVydW5UcmFuc2FjdGlvbnNfKHBhdGgpO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoYWZmZWN0ZWRQYXRoLCBldmVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IFRoaXMgc2hvdWxkIGJlIEBwcml2YXRlIGJ1dCBpdCdzIHVzZWQgYnkgdGVzdF9hY2Nlc3MuanMgYW5kIGludGVybmFsLmpzXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9uKCFzdHJpbmcsICopOip9IGNhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbnRlcmNlcHRTZXJ2ZXJEYXRhXyhjYWxsYmFjazogKChhOiBzdHJpbmcsIGI6IGFueSkgPT4gYW55KSB8IG51bGwpIHtcbiAgICB0aGlzLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18gPSBjYWxsYmFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFib29sZWFufSBjb25uZWN0U3RhdHVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIG9uQ29ubmVjdFN0YXR1c18oY29ubmVjdFN0YXR1czogYm9vbGVhbikge1xuICAgIHRoaXMudXBkYXRlSW5mb18oJ2Nvbm5lY3RlZCcsIGNvbm5lY3RTdGF0dXMpO1xuICAgIGlmIChjb25uZWN0U3RhdHVzID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5ydW5PbkRpc2Nvbm5lY3RFdmVudHNfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gdXBkYXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBvblNlcnZlckluZm9VcGRhdGVfKHVwZGF0ZXM6IE9iamVjdCkge1xuICAgIGVhY2godXBkYXRlcywgKHZhbHVlOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUluZm9fKGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aFN0cmluZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUluZm9fKHBhdGhTdHJpbmc6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aCgnLy5pbmZvLycgKyBwYXRoU3RyaW5nKTtcbiAgICBjb25zdCBuZXdOb2RlID0gbm9kZUZyb21KU09OKHZhbHVlKTtcbiAgICB0aGlzLmluZm9EYXRhXy51cGRhdGVTbmFwc2hvdChwYXRoLCBuZXdOb2RlKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmluZm9TeW5jVHJlZV8uYXBwbHlTZXJ2ZXJPdmVyd3JpdGUocGF0aCwgbmV3Tm9kZSk7XG4gICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGV2ZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IW51bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgZ2V0TmV4dFdyaXRlSWRfKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubmV4dFdyaXRlSWRfKys7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0geyp9IG5ld1ZhbFxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8bnVsbH0gbmV3UHJpb3JpdHlcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IG9uQ29tcGxldGVcbiAgICovXG4gIHNldFdpdGhQcmlvcml0eShcbiAgICBwYXRoOiBQYXRoLFxuICAgIG5ld1ZhbDogYW55LFxuICAgIG5ld1ByaW9yaXR5OiBudW1iZXIgfCBzdHJpbmcgfCBudWxsLFxuICAgIG9uQ29tcGxldGU6ICgoc3RhdHVzOiBFcnJvciB8IG51bGwsIGVycm9yUmVhc29uPzogc3RyaW5nKSA9PiB2b2lkKSB8IG51bGxcbiAgKSB7XG4gICAgdGhpcy5sb2dfKCdzZXQnLCB7XG4gICAgICBwYXRoOiBwYXRoLnRvU3RyaW5nKCksXG4gICAgICB2YWx1ZTogbmV3VmFsLFxuICAgICAgcHJpb3JpdHk6IG5ld1ByaW9yaXR5XG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiBPcHRpbWl6ZSB0aGlzIGJlaGF2aW9yIHRvIGVpdGhlciAoYSkgc3RvcmUgZmxhZyB0byBza2lwIHJlc29sdmluZyB3aGVyZSBwb3NzaWJsZSBhbmQgLyBvclxuICAgIC8vIChiKSBzdG9yZSB1bnJlc29sdmVkIHBhdGhzIG9uIEpTT04gcGFyc2VcbiAgICBjb25zdCBzZXJ2ZXJWYWx1ZXMgPSB0aGlzLmdlbmVyYXRlU2VydmVyVmFsdWVzKCk7XG4gICAgY29uc3QgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT04obmV3VmFsLCBuZXdQcmlvcml0eSk7XG4gICAgY29uc3QgbmV3Tm9kZSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QoXG4gICAgICBuZXdOb2RlVW5yZXNvbHZlZCxcbiAgICAgIHNlcnZlclZhbHVlc1xuICAgICk7XG5cbiAgICBjb25zdCB3cml0ZUlkID0gdGhpcy5nZXROZXh0V3JpdGVJZF8oKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJPdmVyd3JpdGUoXG4gICAgICBwYXRoLFxuICAgICAgbmV3Tm9kZSxcbiAgICAgIHdyaXRlSWQsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICB0aGlzLmV2ZW50UXVldWVfLnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gICAgdGhpcy5zZXJ2ZXJfLnB1dChcbiAgICAgIHBhdGgudG9TdHJpbmcoKSxcbiAgICAgIG5ld05vZGVVbnJlc29sdmVkLnZhbCgvKmV4cG9ydD0qLyB0cnVlKSxcbiAgICAgIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XG4gICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgIHdhcm4oJ3NldCBhdCAnICsgcGF0aCArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsZWFyRXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWNrVXNlcldyaXRlKFxuICAgICAgICAgIHdyaXRlSWQsXG4gICAgICAgICAgIXN1Y2Nlc3NcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGNsZWFyRXZlbnRzKTtcbiAgICAgICAgdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gdGhpcy5hYm9ydFRyYW5zYWN0aW9uc18ocGF0aCk7XG4gICAgdGhpcy5yZXJ1blRyYW5zYWN0aW9uc18oYWZmZWN0ZWRQYXRoKTtcbiAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxuICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChhZmZlY3RlZFBhdGgsIFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gY2hpbGRyZW5Ub01lcmdlXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBvbkNvbXBsZXRlXG4gICAqL1xuICB1cGRhdGUoXG4gICAgcGF0aDogUGF0aCxcbiAgICBjaGlsZHJlblRvTWVyZ2U6IHsgW2s6IHN0cmluZ106IGFueSB9LFxuICAgIG9uQ29tcGxldGU6ICgoc3RhdHVzOiBFcnJvciB8IG51bGwsIGVycm9yUmVhc29uPzogc3RyaW5nKSA9PiB2b2lkKSB8IG51bGxcbiAgKSB7XG4gICAgdGhpcy5sb2dfKCd1cGRhdGUnLCB7IHBhdGg6IHBhdGgudG9TdHJpbmcoKSwgdmFsdWU6IGNoaWxkcmVuVG9NZXJnZSB9KTtcblxuICAgIC8vIFN0YXJ0IHdpdGggb3VyIGV4aXN0aW5nIGRhdGEgYW5kIG1lcmdlIGVhY2ggY2hpbGQgaW50byBpdC5cbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVTZXJ2ZXJWYWx1ZXMoKTtcbiAgICBjb25zdCBjaGFuZ2VkQ2hpbGRyZW46IHsgW2s6IHN0cmluZ106IE5vZGUgfSA9IHt9O1xuICAgIGZvckVhY2goY2hpbGRyZW5Ub01lcmdlLCAoY2hhbmdlZEtleTogc3RyaW5nLCBjaGFuZ2VkVmFsdWU6IGFueSkgPT4ge1xuICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG5ld05vZGVVbnJlc29sdmVkID0gbm9kZUZyb21KU09OKGNoYW5nZWRWYWx1ZSk7XG4gICAgICBjaGFuZ2VkQ2hpbGRyZW5bY2hhbmdlZEtleV0gPSByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KFxuICAgICAgICBuZXdOb2RlVW5yZXNvbHZlZCxcbiAgICAgICAgc2VydmVyVmFsdWVzXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaWYgKCFlbXB0eSkge1xuICAgICAgY29uc3Qgd3JpdGVJZCA9IHRoaXMuZ2V0TmV4dFdyaXRlSWRfKCk7XG4gICAgICBjb25zdCBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJNZXJnZShcbiAgICAgICAgcGF0aCxcbiAgICAgICAgY2hhbmdlZENoaWxkcmVuLFxuICAgICAgICB3cml0ZUlkXG4gICAgICApO1xuICAgICAgdGhpcy5ldmVudFF1ZXVlXy5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICAgICAgdGhpcy5zZXJ2ZXJfLm1lcmdlKFxuICAgICAgICBwYXRoLnRvU3RyaW5nKCksXG4gICAgICAgIGNoaWxkcmVuVG9NZXJnZSxcbiAgICAgICAgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcbiAgICAgICAgICBjb25zdCBzdWNjZXNzID0gc3RhdHVzID09PSAnb2snO1xuICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgd2FybigndXBkYXRlIGF0ICcgKyBwYXRoICsgJyBmYWlsZWQ6ICcgKyBzdGF0dXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGNsZWFyRXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWNrVXNlcldyaXRlKFxuICAgICAgICAgICAgd3JpdGVJZCxcbiAgICAgICAgICAgICFzdWNjZXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBhZmZlY3RlZFBhdGggPVxuICAgICAgICAgICAgY2xlYXJFdmVudHMubGVuZ3RoID4gMCA/IHRoaXMucmVydW5UcmFuc2FjdGlvbnNfKHBhdGgpIDogcGF0aDtcbiAgICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoYWZmZWN0ZWRQYXRoLCBjbGVhckV2ZW50cyk7XG4gICAgICAgICAgdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBmb3JFYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoYW5nZWRQYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gdGhpcy5hYm9ydFRyYW5zYWN0aW9uc18ocGF0aC5jaGlsZChjaGFuZ2VkUGF0aCkpO1xuICAgICAgICB0aGlzLnJlcnVuVHJhbnNhY3Rpb25zXyhhZmZlY3RlZFBhdGgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFdlIHF1ZXVlZCB0aGUgZXZlbnRzIGFib3ZlLCBzbyBqdXN0IGZsdXNoIHRoZSBxdWV1ZSBoZXJlXG4gICAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocGF0aCwgW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2coXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpO1xuICAgICAgdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsICdvaycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGFsbCBvZiB0aGUgY2hhbmdlcyBzdG9yZWQgdXAgaW4gdGhlIG9uRGlzY29ubmVjdF8gdHJlZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcnVuT25EaXNjb25uZWN0RXZlbnRzXygpIHtcbiAgICB0aGlzLmxvZ18oJ29uRGlzY29ubmVjdEV2ZW50cycpO1xuXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVNlcnZlclZhbHVlcygpO1xuICAgIGNvbnN0IHJlc29sdmVkT25EaXNjb25uZWN0VHJlZSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZShcbiAgICAgIHRoaXMub25EaXNjb25uZWN0XyxcbiAgICAgIHNlcnZlclZhbHVlc1xuICAgICk7XG4gICAgbGV0IGV2ZW50czogRXZlbnRbXSA9IFtdO1xuXG4gICAgcmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlLmZvckVhY2hUcmVlKFBhdGguRW1wdHksIChwYXRoLCBzbmFwKSA9PiB7XG4gICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KFxuICAgICAgICB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVNlcnZlck92ZXJ3cml0ZShwYXRoLCBzbmFwKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHRoaXMuYWJvcnRUcmFuc2FjdGlvbnNfKHBhdGgpO1xuICAgICAgdGhpcy5yZXJ1blRyYW5zYWN0aW9uc18oYWZmZWN0ZWRQYXRoKTtcbiAgICB9KTtcblxuICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG5ldyBTcGFyc2VTbmFwc2hvdFRyZWUoKTtcbiAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoUGF0aC5FbXB0eSwgZXZlbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBvbkNvbXBsZXRlXG4gICAqL1xuICBvbkRpc2Nvbm5lY3RDYW5jZWwoXG4gICAgcGF0aDogUGF0aCxcbiAgICBvbkNvbXBsZXRlOiAoKHN0YXR1czogRXJyb3IgfCBudWxsLCBlcnJvclJlYXNvbj86IHN0cmluZykgPT4gdm9pZCkgfCBudWxsXG4gICkge1xuICAgIHRoaXMuc2VydmVyXy5vbkRpc2Nvbm5lY3RDYW5jZWwocGF0aC50b1N0cmluZygpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xuICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8uZm9yZ2V0KHBhdGgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsICo9KX0gb25Db21wbGV0ZVxuICAgKi9cbiAgb25EaXNjb25uZWN0U2V0KFxuICAgIHBhdGg6IFBhdGgsXG4gICAgdmFsdWU6IGFueSxcbiAgICBvbkNvbXBsZXRlOiAoKHN0YXR1czogRXJyb3IgfCBudWxsLCBlcnJvclJlYXNvbj86IHN0cmluZykgPT4gdm9pZCkgfCBudWxsXG4gICkge1xuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xuICAgIHRoaXMuc2VydmVyXy5vbkRpc2Nvbm5lY3RQdXQoXG4gICAgICBwYXRoLnRvU3RyaW5nKCksXG4gICAgICBuZXdOb2RlLnZhbCgvKmV4cG9ydD0qLyB0cnVlKSxcbiAgICAgIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8ucmVtZW1iZXIocGF0aCwgbmV3Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gcHJpb3JpdHlcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IG9uQ29tcGxldGVcbiAgICovXG4gIG9uRGlzY29ubmVjdFNldFdpdGhQcmlvcml0eShcbiAgICBwYXRoOiBQYXRoLFxuICAgIHZhbHVlOiBhbnksXG4gICAgcHJpb3JpdHk6IGFueSxcbiAgICBvbkNvbXBsZXRlOiAoKHN0YXR1czogRXJyb3IgfCBudWxsLCBlcnJvclJlYXNvbj86IHN0cmluZykgPT4gdm9pZCkgfCBudWxsXG4gICkge1xuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUsIHByaW9yaXR5KTtcbiAgICB0aGlzLnNlcnZlcl8ub25EaXNjb25uZWN0UHV0KFxuICAgICAgcGF0aC50b1N0cmluZygpLFxuICAgICAgbmV3Tm9kZS52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksXG4gICAgICAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfLnJlbWVtYmVyKHBhdGgsIG5ld05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICogQHBhcmFtIHsqfSBjaGlsZHJlblRvTWVyZ2VcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IG9uQ29tcGxldGVcbiAgICovXG4gIG9uRGlzY29ubmVjdFVwZGF0ZShcbiAgICBwYXRoOiBQYXRoLFxuICAgIGNoaWxkcmVuVG9NZXJnZTogeyBbazogc3RyaW5nXTogYW55IH0sXG4gICAgb25Db21wbGV0ZTogKChzdGF0dXM6IEVycm9yIHwgbnVsbCwgZXJyb3JSZWFzb24/OiBzdHJpbmcpID0+IHZvaWQpIHwgbnVsbFxuICApIHtcbiAgICBpZiAoaXNFbXB0eShjaGlsZHJlblRvTWVyZ2UpKSB7XG4gICAgICBsb2coXG4gICAgICAgIFwib25EaXNjb25uZWN0KCkudXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiXG4gICAgICApO1xuICAgICAgdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsICdvaycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2VydmVyXy5vbkRpc2Nvbm5lY3RNZXJnZShcbiAgICAgIHBhdGgudG9TdHJpbmcoKSxcbiAgICAgIGNoaWxkcmVuVG9NZXJnZSxcbiAgICAgIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICBmb3JFYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoaWxkTmFtZTogc3RyaW5nLCBjaGlsZE5vZGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gbm9kZUZyb21KU09OKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8ucmVtZW1iZXIocGF0aC5jaGlsZChjaGlsZE5hbWUpLCBuZXdDaGlsZE5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgKiBAcGFyYW0geyFFdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICovXG4gIGFkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeShxdWVyeTogUXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uOiBFdmVudFJlZ2lzdHJhdGlvbikge1xuICAgIGxldCBldmVudHM7XG4gICAgaWYgKHF1ZXJ5LnBhdGguZ2V0RnJvbnQoKSA9PT0gJy5pbmZvJykge1xuICAgICAgZXZlbnRzID0gdGhpcy5pbmZvU3luY1RyZWVfLmFkZEV2ZW50UmVnaXN0cmF0aW9uKFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFkZEV2ZW50UmVnaXN0cmF0aW9uKFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNBdFBhdGgocXVlcnkucGF0aCwgZXZlbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICogQHBhcmFtIHs/RXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAqL1xuICByZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkoXG4gICAgcXVlcnk6IFF1ZXJ5LFxuICAgIGV2ZW50UmVnaXN0cmF0aW9uOiBFdmVudFJlZ2lzdHJhdGlvblxuICApIHtcbiAgICAvLyBUaGVzZSBhcmUgZ3VhcmFudGVlZCBub3QgdG8gcmFpc2UgZXZlbnRzLCBzaW5jZSB3ZSdyZSBub3QgcGFzc2luZyBpbiBhIGNhbmNlbEVycm9yLiBIb3dldmVyLCB3ZSBjYW4gZnV0dXJlLXByb29mXG4gICAgLy8gYSBsaXR0bGUgYml0IGJ5IGhhbmRsaW5nIHRoZSByZXR1cm4gdmFsdWVzIGFueXdheXMuXG4gICAgbGV0IGV2ZW50cztcbiAgICBpZiAocXVlcnkucGF0aC5nZXRGcm9udCgpID09PSAnLmluZm8nKSB7XG4gICAgICBldmVudHMgPSB0aGlzLmluZm9TeW5jVHJlZV8ucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBldmVudFJlZ2lzdHJhdGlvblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8ucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBldmVudFJlZ2lzdHJhdGlvblxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0F0UGF0aChxdWVyeS5wYXRoLCBldmVudHMpO1xuICB9XG5cbiAgaW50ZXJydXB0KCkge1xuICAgIGlmICh0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXykge1xuICAgICAgdGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaW50ZXJydXB0KElOVEVSUlVQVF9SRUFTT04pO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcbiAgICAgIHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fLnJlc3VtZShJTlRFUlJVUFRfUkVBU09OKTtcbiAgICB9XG4gIH1cblxuICBzdGF0cyhzaG93RGVsdGE6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgIGxldCBzdGF0czogeyBbazogc3RyaW5nXTogYW55IH07XG4gICAgaWYgKHNob3dEZWx0YSkge1xuICAgICAgaWYgKCF0aGlzLnN0YXRzTGlzdGVuZXJfKVxuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbmV3IFN0YXRzTGlzdGVuZXIodGhpcy5zdGF0c18pO1xuICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzTGlzdGVuZXJfLmdldCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0cyA9IHRoaXMuc3RhdHNfLmdldCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvbmdlc3ROYW1lID0gT2JqZWN0LmtleXMoc3RhdHMpLnJlZHVjZShcbiAgICAgIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+XG4gICAgICAgIE1hdGgubWF4KGN1cnJlbnRWYWx1ZS5sZW5ndGgsIHByZXZpb3VzVmFsdWUpLFxuICAgICAgMFxuICAgICk7XG5cbiAgICBmb3JFYWNoKHN0YXRzLCAoc3RhdDogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgICAvLyBwYWQgc3RhdCBuYW1lcyB0byBiZSB0aGUgc2FtZSBsZW5ndGggKHBsdXMgMiBleHRyYSBzcGFjZXMpLlxuICAgICAgZm9yIChsZXQgaSA9IHN0YXQubGVuZ3RoOyBpIDwgbG9uZ2VzdE5hbWUgKyAyOyBpKyspIHN0YXQgKz0gJyAnO1xuICAgICAgY29uc29sZS5sb2coc3RhdCArIHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRzSW5jcmVtZW50Q291bnRlcihtZXRyaWM6IHN0cmluZykge1xuICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIobWV0cmljKTtcbiAgICB0aGlzLnN0YXRzUmVwb3J0ZXJfLmluY2x1ZGVTdGF0KG1ldHJpYyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJnc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBsb2dfKC4uLnZhcl9hcmdzOiBhbnlbXSkge1xuICAgIGxldCBwcmVmaXggPSAnJztcbiAgICBpZiAodGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcbiAgICAgIHByZWZpeCA9IHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fLmlkICsgJzonO1xuICAgIH1cbiAgICBsb2cocHJlZml4LCAuLi52YXJfYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gc3RhdHVzXG4gICAqIEBwYXJhbSB7P3N0cmluZz19IGVycm9yUmVhc29uXG4gICAqL1xuICBjYWxsT25Db21wbGV0ZUNhbGxiYWNrKFxuICAgIGNhbGxiYWNrOiAoKHN0YXR1czogRXJyb3IgfCBudWxsLCBlcnJvclJlYXNvbj86IHN0cmluZykgPT4gdm9pZCkgfCBudWxsLFxuICAgIHN0YXR1czogc3RyaW5nLFxuICAgIGVycm9yUmVhc29uPzogc3RyaW5nIHwgbnVsbFxuICApIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGV4Y2VwdGlvbkd1YXJkKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc3RhdHVzID09ICdvaycpIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjb2RlID0gKHN0YXR1cyB8fCAnZXJyb3InKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGxldCBtZXNzYWdlID0gY29kZTtcbiAgICAgICAgICBpZiAoZXJyb3JSZWFzb24pIG1lc3NhZ2UgKz0gJzogJyArIGVycm9yUmVhc29uO1xuXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgKGVycm9yIGFzIGFueSkuY29kZSA9IGNvZGU7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgZGF0YWJhc2UoKTogRGF0YWJhc2Uge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YWJhc2UgfHwgKHRoaXMuX19kYXRhYmFzZSA9IG5ldyBEYXRhYmFzZSh0aGlzKSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmRleGVkRmlsdGVyIH0gZnJvbSAnLi9JbmRleGVkRmlsdGVyJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi4vLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuaW1wb3J0IHsgTmFtZWROb2RlLCBOb2RlIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9zbmFwL05vZGUnO1xuaW1wb3J0IHsgQ2hpbGRyZW5Ob2RlIH0gZnJvbSAnLi4vLi4vc25hcC9DaGlsZHJlbk5vZGUnO1xuaW1wb3J0IHsgTm9kZUZpbHRlciB9IGZyb20gJy4vTm9kZUZpbHRlcic7XG5pbXBvcnQgeyBRdWVyeVBhcmFtcyB9IGZyb20gJy4uL1F1ZXJ5UGFyYW1zJztcbmltcG9ydCB7IEluZGV4IH0gZnJvbSAnLi4vLi4vc25hcC9pbmRleGVzL0luZGV4JztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi8uLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgQ29tcGxldGVDaGlsZFNvdXJjZSB9IGZyb20gJy4uL0NvbXBsZXRlQ2hpbGRTb3VyY2UnO1xuaW1wb3J0IHsgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvciB9IGZyb20gJy4uL0NoaWxkQ2hhbmdlQWNjdW11bGF0b3InO1xuXG4vKipcbiAqIEZpbHRlcnMgbm9kZXMgYnkgcmFuZ2UgYW5kIHVzZXMgYW4gSW5kZXhGaWx0ZXIgdG8gdHJhY2sgYW55IGNoYW5nZXMgYWZ0ZXIgZmlsdGVyaW5nIHRoZSBub2RlXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7Tm9kZUZpbHRlcn1cbiAqL1xuZXhwb3J0IGNsYXNzIFJhbmdlZEZpbHRlciBpbXBsZW1lbnRzIE5vZGVGaWx0ZXIge1xuICAvKipcbiAgICogQHR5cGUgeyFJbmRleGVkRmlsdGVyfVxuICAgKiBAY29uc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgaW5kZXhlZEZpbHRlcl86IEluZGV4ZWRGaWx0ZXI7XG5cbiAgLyoqXG4gICAqIEBjb25zdFxuICAgKiBAdHlwZSB7IUluZGV4fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBpbmRleF86IEluZGV4O1xuXG4gIC8qKlxuICAgKiBAY29uc3RcbiAgICogQHR5cGUgeyFOYW1lZE5vZGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXJ0UG9zdF86IE5hbWVkTm9kZTtcblxuICAvKipcbiAgICogQGNvbnN0XG4gICAqIEB0eXBlIHshTmFtZWROb2RlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBlbmRQb3N0XzogTmFtZWROb2RlO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IFF1ZXJ5UGFyYW1zKSB7XG4gICAgdGhpcy5pbmRleGVkRmlsdGVyXyA9IG5ldyBJbmRleGVkRmlsdGVyKHBhcmFtcy5nZXRJbmRleCgpKTtcbiAgICB0aGlzLmluZGV4XyA9IHBhcmFtcy5nZXRJbmRleCgpO1xuICAgIHRoaXMuc3RhcnRQb3N0XyA9IFJhbmdlZEZpbHRlci5nZXRTdGFydFBvc3RfKHBhcmFtcyk7XG4gICAgdGhpcy5lbmRQb3N0XyA9IFJhbmdlZEZpbHRlci5nZXRFbmRQb3N0XyhwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFOYW1lZE5vZGV9XG4gICAqL1xuICBnZXRTdGFydFBvc3QoKTogTmFtZWROb2RlIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFBvc3RfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFOYW1lZE5vZGV9XG4gICAqL1xuICBnZXRFbmRQb3N0KCk6IE5hbWVkTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kUG9zdF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTmFtZWROb2RlfSBub2RlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtYXRjaGVzKG5vZGU6IE5hbWVkTm9kZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmluZGV4Xy5jb21wYXJlKHRoaXMuZ2V0U3RhcnRQb3N0KCksIG5vZGUpIDw9IDAgJiZcbiAgICAgIHRoaXMuaW5kZXhfLmNvbXBhcmUobm9kZSwgdGhpcy5nZXRFbmRQb3N0KCkpIDw9IDBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICB1cGRhdGVDaGlsZChcbiAgICBzbmFwOiBOb2RlLFxuICAgIGtleTogc3RyaW5nLFxuICAgIG5ld0NoaWxkOiBOb2RlLFxuICAgIGFmZmVjdGVkUGF0aDogUGF0aCxcbiAgICBzb3VyY2U6IENvbXBsZXRlQ2hpbGRTb3VyY2UsXG4gICAgb3B0Q2hhbmdlQWNjdW11bGF0b3I6IENoaWxkQ2hhbmdlQWNjdW11bGF0b3IgfCBudWxsXG4gICk6IE5vZGUge1xuICAgIGlmICghdGhpcy5tYXRjaGVzKG5ldyBOYW1lZE5vZGUoa2V5LCBuZXdDaGlsZCkpKSB7XG4gICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVDaGlsZChcbiAgICAgIHNuYXAsXG4gICAgICBrZXksXG4gICAgICBuZXdDaGlsZCxcbiAgICAgIGFmZmVjdGVkUGF0aCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgdXBkYXRlRnVsbE5vZGUoXG4gICAgb2xkU25hcDogTm9kZSxcbiAgICBuZXdTbmFwOiBOb2RlLFxuICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yOiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yIHwgbnVsbFxuICApOiBOb2RlIHtcbiAgICBpZiAobmV3U25hcC5pc0xlYWZOb2RlKCkpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2hpbGRyZW4gbm9kZSB3aXRoIHRoZSBjb3JyZWN0IGluZGV4LCBub3QgYSBsZWFmIG5vZGU7XG4gICAgICBuZXdTbmFwID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgfVxuICAgIGxldCBmaWx0ZXJlZCA9IG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcbiAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xuICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlUHJpb3JpdHkoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbihrZXksIGNoaWxkTm9kZSkge1xuICAgICAgaWYgKCFzZWxmLm1hdGNoZXMobmV3IE5hbWVkTm9kZShrZXksIGNoaWxkTm9kZSkpKSB7XG4gICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhlZEZpbHRlcl8udXBkYXRlRnVsbE5vZGUoXG4gICAgICBvbGRTbmFwLFxuICAgICAgZmlsdGVyZWQsXG4gICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvclxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHVwZGF0ZVByaW9yaXR5KG9sZFNuYXA6IE5vZGUsIG5ld1ByaW9yaXR5OiBOb2RlKTogTm9kZSB7XG4gICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcbiAgICByZXR1cm4gb2xkU25hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZmlsdGVyc05vZGVzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRJbmRleGVkRmlsdGVyKCk6IEluZGV4ZWRGaWx0ZXIge1xuICAgIHJldHVybiB0aGlzLmluZGV4ZWRGaWx0ZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRJbmRleCgpOiBJbmRleCB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldFN0YXJ0UG9zdF8ocGFyYW1zOiBRdWVyeVBhcmFtcyk6IE5hbWVkTm9kZSB7XG4gICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpKSB7XG4gICAgICBjb25zdCBzdGFydE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydE5hbWUoKTtcbiAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5tYWtlUG9zdChwYXJhbXMuZ2V0SW5kZXhTdGFydFZhbHVlKCksIHN0YXJ0TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5taW5Qb3N0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldEVuZFBvc3RfKHBhcmFtczogUXVlcnlQYXJhbXMpOiBOYW1lZE5vZGUge1xuICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcbiAgICAgIGNvbnN0IGVuZE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhFbmROYW1lKCk7XG4gICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWFrZVBvc3QocGFyYW1zLmdldEluZGV4RW5kVmFsdWUoKSwgZW5kTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5tYXhQb3N0KCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUmFuZ2VkRmlsdGVyIH0gZnJvbSAnLi9SYW5nZWRGaWx0ZXInO1xuaW1wb3J0IHsgQ2hpbGRyZW5Ob2RlIH0gZnJvbSAnLi4vLi4vc25hcC9DaGlsZHJlbk5vZGUnO1xuaW1wb3J0IHsgTm9kZSwgTmFtZWROb2RlIH0gZnJvbSAnLi4vLi4vc25hcC9Ob2RlJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENoYW5nZSB9IGZyb20gJy4uL0NoYW5nZSc7XG5pbXBvcnQgeyBOb2RlRmlsdGVyIH0gZnJvbSAnLi9Ob2RlRmlsdGVyJztcbmltcG9ydCB7IEluZGV4IH0gZnJvbSAnLi4vLi4vc25hcC9pbmRleGVzL0luZGV4JztcbmltcG9ydCB7IEluZGV4ZWRGaWx0ZXIgfSBmcm9tICcuL0luZGV4ZWRGaWx0ZXInO1xuaW1wb3J0IHsgUXVlcnlQYXJhbXMgfSBmcm9tICcuLi9RdWVyeVBhcmFtcyc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vLi4vdXRpbC9QYXRoJztcbmltcG9ydCB7IENvbXBsZXRlQ2hpbGRTb3VyY2UgfSBmcm9tICcuLi9Db21wbGV0ZUNoaWxkU291cmNlJztcbmltcG9ydCB7IENoaWxkQ2hhbmdlQWNjdW11bGF0b3IgfSBmcm9tICcuLi9DaGlsZENoYW5nZUFjY3VtdWxhdG9yJztcblxuLyoqXG4gKiBBcHBsaWVzIGEgbGltaXQgYW5kIGEgcmFuZ2UgdG8gYSBub2RlIGFuZCB1c2VzIFJhbmdlZEZpbHRlciB0byBkbyB0aGUgaGVhdnkgbGlmdGluZyB3aGVyZSBwb3NzaWJsZVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge05vZGVGaWx0ZXJ9XG4gKi9cbmV4cG9ydCBjbGFzcyBMaW1pdGVkRmlsdGVyIGltcGxlbWVudHMgTm9kZUZpbHRlciB7XG4gIC8qKlxuICAgKiBAY29uc3RcbiAgICogQHR5cGUge1JhbmdlZEZpbHRlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcmFuZ2VkRmlsdGVyXzogUmFuZ2VkRmlsdGVyO1xuXG4gIC8qKlxuICAgKiBAY29uc3RcbiAgICogQHR5cGUgeyFJbmRleH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgaW5kZXhfOiBJbmRleDtcblxuICAvKipcbiAgICogQGNvbnN0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGxpbWl0XzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBAY29uc3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHJldmVyc2VfOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IFF1ZXJ5UGFyYW1zKSB7XG4gICAgdGhpcy5yYW5nZWRGaWx0ZXJfID0gbmV3IFJhbmdlZEZpbHRlcihwYXJhbXMpO1xuICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XG4gICAgdGhpcy5saW1pdF8gPSBwYXJhbXMuZ2V0TGltaXQoKTtcbiAgICB0aGlzLnJldmVyc2VfID0gIXBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICB1cGRhdGVDaGlsZChcbiAgICBzbmFwOiBOb2RlLFxuICAgIGtleTogc3RyaW5nLFxuICAgIG5ld0NoaWxkOiBOb2RlLFxuICAgIGFmZmVjdGVkUGF0aDogUGF0aCxcbiAgICBzb3VyY2U6IENvbXBsZXRlQ2hpbGRTb3VyY2UsXG4gICAgb3B0Q2hhbmdlQWNjdW11bGF0b3I6IENoaWxkQ2hhbmdlQWNjdW11bGF0b3IgfCBudWxsXG4gICk6IE5vZGUge1xuICAgIGlmICghdGhpcy5yYW5nZWRGaWx0ZXJfLm1hdGNoZXMobmV3IE5hbWVkTm9kZShrZXksIG5ld0NoaWxkKSkpIHtcbiAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgfVxuICAgIGlmIChzbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSkuZXF1YWxzKG5ld0NoaWxkKSkge1xuICAgICAgLy8gTm8gY2hhbmdlXG4gICAgICByZXR1cm4gc25hcDtcbiAgICB9IGVsc2UgaWYgKHNuYXAubnVtQ2hpbGRyZW4oKSA8IHRoaXMubGltaXRfKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXG4gICAgICAgIC5nZXRJbmRleGVkRmlsdGVyKClcbiAgICAgICAgLnVwZGF0ZUNoaWxkKFxuICAgICAgICAgIHNuYXAsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgIGFmZmVjdGVkUGF0aCxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3JcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZnVsbExpbWl0VXBkYXRlQ2hpbGRfKFxuICAgICAgICBzbmFwLFxuICAgICAgICBrZXksXG4gICAgICAgIG5ld0NoaWxkLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgdXBkYXRlRnVsbE5vZGUoXG4gICAgb2xkU25hcDogTm9kZSxcbiAgICBuZXdTbmFwOiBOb2RlLFxuICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yOiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yIHwgbnVsbFxuICApOiBOb2RlIHtcbiAgICBsZXQgZmlsdGVyZWQ7XG4gICAgaWYgKG5ld1NuYXAuaXNMZWFmTm9kZSgpIHx8IG5ld1NuYXAuaXNFbXB0eSgpKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNoaWxkcmVuIG5vZGUgd2l0aCB0aGUgY29ycmVjdCBpbmRleCwgbm90IGEgbGVhZiBub2RlO1xuICAgICAgZmlsdGVyZWQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERS53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubGltaXRfICogMiA8IG5ld1NuYXAubnVtQ2hpbGRyZW4oKSAmJlxuICAgICAgICBuZXdTbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XylcbiAgICAgICkge1xuICAgICAgICAvLyBFYXNpZXIgdG8gYnVpbGQgdXAgYSBzbmFwc2hvdCwgc2luY2Ugd2hhdCB3ZSdyZSBnaXZlbiBoYXMgbW9yZSB0aGFuIHR3aWNlIHRoZSBlbGVtZW50cyB3ZSB3YW50XG4gICAgICAgIGZpbHRlcmVkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcbiAgICAgICAgLy8gYW5jaG9yIHRvIHRoZSBzdGFydFBvc3QsIGVuZFBvc3QsIG9yIGxhc3QgZWxlbWVudCBhcyBhcHByb3ByaWF0ZVxuICAgICAgICBsZXQgaXRlcmF0b3I7XG4gICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XG4gICAgICAgICAgaXRlcmF0b3IgPSAobmV3U25hcCBhcyBDaGlsZHJlbk5vZGUpLmdldFJldmVyc2VJdGVyYXRvckZyb20oXG4gICAgICAgICAgICB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpLFxuICAgICAgICAgICAgdGhpcy5pbmRleF9cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdG9yID0gKG5ld1NuYXAgYXMgQ2hpbGRyZW5Ob2RlKS5nZXRJdGVyYXRvckZyb20oXG4gICAgICAgICAgICB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCksXG4gICAgICAgICAgICB0aGlzLmluZGV4X1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLmhhc05leHQoKSAmJiBjb3VudCA8IHRoaXMubGltaXRfKSB7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcbiAgICAgICAgICBsZXQgaW5SYW5nZTtcbiAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xuICAgICAgICAgICAgaW5SYW5nZSA9XG4gICAgICAgICAgICAgIHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpLCBuZXh0KSA8PSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpblJhbmdlID1cbiAgICAgICAgICAgICAgdGhpcy5pbmRleF8uY29tcGFyZShuZXh0LCB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpKSA8PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5SYW5nZSkge1xuICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Lm5hbWUsIG5leHQubm9kZSk7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBwb3N0LCB3ZSBjYW5ub3Qga2VlcCBhZGRpbmcgZWxlbW1lbnRzXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBzbmFwIGNvbnRhaW5zIGxlc3MgdGhhbiB0d2ljZSB0aGUgbGltaXQuIEZhc3RlciB0byBkZWxldGUgZnJvbSB0aGUgc25hcCB0aGFuIGJ1aWxkIHVwIGEgbmV3IG9uZVxuICAgICAgICBmaWx0ZXJlZCA9IG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcbiAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcbiAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShcbiAgICAgICAgICBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERVxuICAgICAgICApIGFzIENoaWxkcmVuTm9kZTtcbiAgICAgICAgbGV0IHN0YXJ0UG9zdDtcbiAgICAgICAgbGV0IGVuZFBvc3Q7XG4gICAgICAgIGxldCBjbXA7XG4gICAgICAgIGxldCBpdGVyYXRvcjtcbiAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcbiAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldFJldmVyc2VJdGVyYXRvcih0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgc3RhcnRQb3N0ID0gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKTtcbiAgICAgICAgICBlbmRQb3N0ID0gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpO1xuICAgICAgICAgIGNvbnN0IGluZGV4Q29tcGFyZSA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcbiAgICAgICAgICBjbXAgPSAoYTogTmFtZWROb2RlLCBiOiBOYW1lZE5vZGUpID0+IGluZGV4Q29tcGFyZShiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldEl0ZXJhdG9yKHRoaXMuaW5kZXhfKTtcbiAgICAgICAgICBzdGFydFBvc3QgPSB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCk7XG4gICAgICAgICAgZW5kUG9zdCA9IHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCk7XG4gICAgICAgICAgY21wID0gdGhpcy5pbmRleF8uZ2V0Q29tcGFyZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IGZvdW5kU3RhcnRQb3N0ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChpdGVyYXRvci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcbiAgICAgICAgICBpZiAoIWZvdW5kU3RhcnRQb3N0ICYmIGNtcChzdGFydFBvc3QsIG5leHQpIDw9IDApIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGFkZGluZ1xuICAgICAgICAgICAgZm91bmRTdGFydFBvc3QgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaW5SYW5nZSA9XG4gICAgICAgICAgICBmb3VuZFN0YXJ0UG9zdCAmJiBjb3VudCA8IHRoaXMubGltaXRfICYmIGNtcChuZXh0LCBlbmRQb3N0KSA8PSAwO1xuICAgICAgICAgIGlmIChpblJhbmdlKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKFxuICAgICAgICAgICAgICBuZXh0Lm5hbWUsXG4gICAgICAgICAgICAgIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXG4gICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXG4gICAgICAudXBkYXRlRnVsbE5vZGUob2xkU25hcCwgZmlsdGVyZWQsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgdXBkYXRlUHJpb3JpdHkob2xkU25hcDogTm9kZSwgbmV3UHJpb3JpdHk6IE5vZGUpOiBOb2RlIHtcbiAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xuICAgIHJldHVybiBvbGRTbmFwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBmaWx0ZXJzTm9kZXMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEluZGV4ZWRGaWx0ZXIoKTogSW5kZXhlZEZpbHRlciB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRJbmRleGVkRmlsdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEluZGV4KCk6IEluZGV4IHtcbiAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gc25hcFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGRLZXlcbiAgICogQHBhcmFtIHshTm9kZX0gY2hpbGRTbmFwXG4gICAqIEBwYXJhbSB7IUNvbXBsZXRlQ2hpbGRTb3VyY2V9IHNvdXJjZVxuICAgKiBAcGFyYW0gez9DaGlsZENoYW5nZUFjY3VtdWxhdG9yfSBjaGFuZ2VBY2N1bXVsYXRvclxuICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgZnVsbExpbWl0VXBkYXRlQ2hpbGRfKFxuICAgIHNuYXA6IE5vZGUsXG4gICAgY2hpbGRLZXk6IHN0cmluZyxcbiAgICBjaGlsZFNuYXA6IE5vZGUsXG4gICAgc291cmNlOiBDb21wbGV0ZUNoaWxkU291cmNlLFxuICAgIGNoYW5nZUFjY3VtdWxhdG9yOiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yIHwgbnVsbFxuICApOiBOb2RlIHtcbiAgICAvLyBUT0RPOiByZW5hbWUgYWxsIGNhY2hlIHN0dWZmIGV0YyB0byBnZW5lcmFsIHNuYXAgdGVybWlub2xvZ3lcbiAgICBsZXQgY21wO1xuICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XG4gICAgICBjb25zdCBpbmRleENtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcbiAgICAgIGNtcCA9IChhOiBOYW1lZE5vZGUsIGI6IE5hbWVkTm9kZSkgPT4gaW5kZXhDbXAoYiwgYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkRXZlbnRDYWNoZSA9IHNuYXAgYXMgQ2hpbGRyZW5Ob2RlO1xuICAgIGFzc2VydChvbGRFdmVudENhY2hlLm51bUNoaWxkcmVuKCkgPT0gdGhpcy5saW1pdF8sICcnKTtcbiAgICBjb25zdCBuZXdDaGlsZE5hbWVkTm9kZSA9IG5ldyBOYW1lZE5vZGUoY2hpbGRLZXksIGNoaWxkU25hcCk7XG4gICAgY29uc3Qgd2luZG93Qm91bmRhcnkgPSB0aGlzLnJldmVyc2VfXG4gICAgICA/IG9sZEV2ZW50Q2FjaGUuZ2V0Rmlyc3RDaGlsZCh0aGlzLmluZGV4XylcbiAgICAgIDogKG9sZEV2ZW50Q2FjaGUuZ2V0TGFzdENoaWxkKHRoaXMuaW5kZXhfKSBhcyBOYW1lZE5vZGUpO1xuICAgIGNvbnN0IGluUmFuZ2UgPSB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXdDaGlsZE5hbWVkTm9kZSk7XG4gICAgaWYgKG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICBjb25zdCBvbGRDaGlsZFNuYXAgPSBvbGRFdmVudENhY2hlLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgIGxldCBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKFxuICAgICAgICB0aGlzLmluZGV4XyxcbiAgICAgICAgd2luZG93Qm91bmRhcnksXG4gICAgICAgIHRoaXMucmV2ZXJzZV9cbiAgICAgICk7XG4gICAgICB3aGlsZSAoXG4gICAgICAgIG5leHRDaGlsZCAhPSBudWxsICYmXG4gICAgICAgIChuZXh0Q2hpbGQubmFtZSA9PSBjaGlsZEtleSB8fCBvbGRFdmVudENhY2hlLmhhc0NoaWxkKG5leHRDaGlsZC5uYW1lKSlcbiAgICAgICkge1xuICAgICAgICAvLyBUaGVyZSBpcyBhIHdlaXJkIGVkZ2UgY2FzZSB3aGVyZSBhIG5vZGUgaXMgdXBkYXRlZCBhcyBwYXJ0IG9mIGEgbWVyZ2UgaW4gdGhlIHdyaXRlIHRyZWUsIGJ1dCBoYXNuJ3RcbiAgICAgICAgLy8gYmVlbiBhcHBsaWVkIHRvIHRoZSBsaW1pdGVkIGZpbHRlciB5ZXQuIElnbm9yZSB0aGlzIG5leHQgY2hpbGQgd2hpY2ggd2lsbCBiZSB1cGRhdGVkIGxhdGVyIGluXG4gICAgICAgIC8vIHRoZSBsaW1pdGVkIGZpbHRlci4uLlxuICAgICAgICBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKFxuICAgICAgICAgIHRoaXMuaW5kZXhfLFxuICAgICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgICB0aGlzLnJldmVyc2VfXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wYXJlTmV4dCA9XG4gICAgICAgIG5leHRDaGlsZCA9PSBudWxsID8gMSA6IGNtcChuZXh0Q2hpbGQsIG5ld0NoaWxkTmFtZWROb2RlKTtcbiAgICAgIGNvbnN0IHJlbWFpbnNJbldpbmRvdyA9XG4gICAgICAgIGluUmFuZ2UgJiYgIWNoaWxkU25hcC5pc0VtcHR5KCkgJiYgY29tcGFyZU5leHQgPj0gMDtcbiAgICAgIGlmIChyZW1haW5zSW5XaW5kb3cpIHtcbiAgICAgICAgaWYgKGNoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKFxuICAgICAgICAgICAgQ2hhbmdlLmNoaWxkQ2hhbmdlZENoYW5nZShjaGlsZEtleSwgY2hpbGRTbmFwLCBvbGRDaGlsZFNuYXApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgY2hpbGRTbmFwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XG4gICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShcbiAgICAgICAgICAgIENoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2UoY2hpbGRLZXksIG9sZENoaWxkU25hcClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudENhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKFxuICAgICAgICAgIGNoaWxkS2V5LFxuICAgICAgICAgIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZEluUmFuZ2UgPVxuICAgICAgICAgIG5leHRDaGlsZCAhPSBudWxsICYmIHRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5leHRDaGlsZCk7XG4gICAgICAgIGlmIChuZXh0Q2hpbGRJblJhbmdlKSB7XG4gICAgICAgICAgaWYgKGNoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoXG4gICAgICAgICAgICAgIENoYW5nZS5jaGlsZEFkZGVkQ2hhbmdlKG5leHRDaGlsZC5uYW1lLCBuZXh0Q2hpbGQubm9kZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKFxuICAgICAgICAgICAgbmV4dENoaWxkLm5hbWUsXG4gICAgICAgICAgICBuZXh0Q2hpbGQubm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ld0V2ZW50Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoaWxkU25hcC5pc0VtcHR5KCkpIHtcbiAgICAgIC8vIHdlJ3JlIGRlbGV0aW5nIGEgbm9kZSwgYnV0IGl0IHdhcyBub3QgaW4gdGhlIHdpbmRvdywgc28gaWdub3JlIGl0XG4gICAgICByZXR1cm4gc25hcDtcbiAgICB9IGVsc2UgaWYgKGluUmFuZ2UpIHtcbiAgICAgIGlmIChjbXAod2luZG93Qm91bmRhcnksIG5ld0NoaWxkTmFtZWROb2RlKSA+PSAwKSB7XG4gICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XG4gICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShcbiAgICAgICAgICAgIENoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2Uod2luZG93Qm91bmRhcnkubmFtZSwgd2luZG93Qm91bmRhcnkubm9kZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoXG4gICAgICAgICAgICBDaGFuZ2UuY2hpbGRBZGRlZENoYW5nZShjaGlsZEtleSwgY2hpbGRTbmFwKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGVcbiAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIGNoaWxkU25hcClcbiAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQod2luZG93Qm91bmRhcnkubmFtZSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzbmFwO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IE1JTl9OQU1FLCBNQVhfTkFNRSB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBLRVlfSU5ERVggfSBmcm9tICcuLi9zbmFwL2luZGV4ZXMvS2V5SW5kZXgnO1xuaW1wb3J0IHsgUFJJT1JJVFlfSU5ERVggfSBmcm9tICcuLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG5pbXBvcnQgeyBWQUxVRV9JTkRFWCB9IGZyb20gJy4uL3NuYXAvaW5kZXhlcy9WYWx1ZUluZGV4JztcbmltcG9ydCB7IFBhdGhJbmRleCB9IGZyb20gJy4uL3NuYXAvaW5kZXhlcy9QYXRoSW5kZXgnO1xuaW1wb3J0IHsgSW5kZXhlZEZpbHRlciB9IGZyb20gJy4vZmlsdGVyL0luZGV4ZWRGaWx0ZXInO1xuaW1wb3J0IHsgTGltaXRlZEZpbHRlciB9IGZyb20gJy4vZmlsdGVyL0xpbWl0ZWRGaWx0ZXInO1xuaW1wb3J0IHsgUmFuZ2VkRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXIvUmFuZ2VkRmlsdGVyJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IE5vZGVGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlci9Ob2RlRmlsdGVyJztcbmltcG9ydCB7IEluZGV4IH0gZnJvbSAnLi4vc25hcC9pbmRleGVzL0luZGV4JztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIGFuIGltbXV0YWJsZS1mcm9tLXRoZS1wdWJsaWMtYXBpIHN0cnVjdCBjb250YWluaW5nIGEgc2V0IG9mIHF1ZXJ5IHBhcmFtZXRlcnMgZGVmaW5pbmcgYVxuICogcmFuZ2UgdG8gYmUgcmV0dXJuZWQgZm9yIGEgcGFydGljdWxhciBsb2NhdGlvbi4gSXQgaXMgYXNzdW1lZCB0aGF0IHZhbGlkYXRpb24gb2YgcGFyYW1ldGVycyBpcyBkb25lIGF0IHRoZVxuICogdXNlci1mYWNpbmcgQVBJIGxldmVsLCBzbyBpdCBpcyBub3QgZG9uZSBoZXJlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWVyeVBhcmFtcyB7XG4gIHByaXZhdGUgbGltaXRTZXRfID0gZmFsc2U7XG4gIHByaXZhdGUgc3RhcnRTZXRfID0gZmFsc2U7XG4gIHByaXZhdGUgc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xuICBwcml2YXRlIGVuZFNldF8gPSBmYWxzZTtcbiAgcHJpdmF0ZSBlbmROYW1lU2V0XyA9IGZhbHNlO1xuXG4gIHByaXZhdGUgbGltaXRfID0gMDtcbiAgcHJpdmF0ZSB2aWV3RnJvbV8gPSAnJztcbiAgcHJpdmF0ZSBpbmRleFN0YXJ0VmFsdWVfOiBhbnkgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpbmRleFN0YXJ0TmFtZV8gPSAnJztcbiAgcHJpdmF0ZSBpbmRleEVuZFZhbHVlXzogYW55IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaW5kZXhFbmROYW1lXyA9ICcnO1xuXG4gIHByaXZhdGUgaW5kZXhfID0gUFJJT1JJVFlfSU5ERVg7XG5cbiAgLyoqXG4gICAqIFdpcmUgUHJvdG9jb2wgQ29uc3RhbnRzXG4gICAqIEBjb25zdFxuICAgKiBAZW51bSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgV0lSRV9QUk9UT0NPTF9DT05TVEFOVFNfID0ge1xuICAgIElOREVYX1NUQVJUX1ZBTFVFOiAnc3AnLFxuICAgIElOREVYX1NUQVJUX05BTUU6ICdzbicsXG4gICAgSU5ERVhfRU5EX1ZBTFVFOiAnZXAnLFxuICAgIElOREVYX0VORF9OQU1FOiAnZW4nLFxuICAgIExJTUlUOiAnbCcsXG4gICAgVklFV19GUk9NOiAndmYnLFxuICAgIFZJRVdfRlJPTV9MRUZUOiAnbCcsXG4gICAgVklFV19GUk9NX1JJR0hUOiAncicsXG4gICAgSU5ERVg6ICdpJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBSRVNUIFF1ZXJ5IENvbnN0YW50c1xuICAgKiBAY29uc3RcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFJFU1RfUVVFUllfQ09OU1RBTlRTXyA9IHtcbiAgICBPUkRFUl9CWTogJ29yZGVyQnknLFxuICAgIFBSSU9SSVRZX0lOREVYOiAnJHByaW9yaXR5JyxcbiAgICBWQUxVRV9JTkRFWDogJyR2YWx1ZScsXG4gICAgS0VZX0lOREVYOiAnJGtleScsXG4gICAgU1RBUlRfQVQ6ICdzdGFydEF0JyxcbiAgICBFTkRfQVQ6ICdlbmRBdCcsXG4gICAgTElNSVRfVE9fRklSU1Q6ICdsaW1pdFRvRmlyc3QnLFxuICAgIExJTUlUX1RPX0xBU1Q6ICdsaW1pdFRvTGFzdCdcbiAgfTtcblxuICAvKipcbiAgICogRGVmYXVsdCwgZW1wdHkgcXVlcnkgcGFyYW1ldGVyc1xuICAgKiBAdHlwZSB7IVF1ZXJ5UGFyYW1zfVxuICAgKiBAY29uc3RcbiAgICovXG4gIHN0YXRpYyByZWFkb25seSBERUZBVUxUID0gbmV3IFF1ZXJ5UGFyYW1zKCk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTdGFydCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFNldF87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBpdCB3b3VsZCByZXR1cm4gZnJvbSBsZWZ0LlxuICAgKi9cbiAgaXNWaWV3RnJvbUxlZnQoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMudmlld0Zyb21fID09PSAnJykge1xuICAgICAgLy8gbGltaXQoKSwgcmF0aGVyIHRoYW4gbGltaXRUb0ZpcnN0IG9yIGxpbWl0VG9MYXN0IHdhcyBjYWxsZWQuXG4gICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgb25seSBvbmUgb2Ygc3RhcnRTZXRfIGFuZCBlbmRTZXRfIGlzIHRydWUuIFVzZSB0aGVtXG4gICAgICAvLyB0byBjYWxjdWxhdGUgd2hpY2ggc2lkZSBvZiB0aGUgdmlldyB0byBhbmNob3IgdG8uIElmIG5laXRoZXIgaXMgc2V0LFxuICAgICAgLy8gYW5jaG9yIHRvIHRoZSBlbmQuXG4gICAgICByZXR1cm4gdGhpcy5zdGFydFNldF87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudmlld0Zyb21fID09PSBRdWVyeVBhcmFtcy5XSVJFX1BST1RPQ09MX0NPTlNUQU5UU18uVklFV19GUk9NX0xFRlRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0SW5kZXhTdGFydFZhbHVlKCk6IGFueSB7XG4gICAgYXNzZXJ0KHRoaXMuc3RhcnRTZXRfLCAnT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXQnKTtcbiAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0VmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZS5cbiAgICogUmV0dXJucyB0aGUgc3RhcnRpbmcga2V5IG5hbWUgZm9yIHRoZSByYW5nZSBkZWZpbmVkIGJ5IHRoZXNlIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICogQHJldHVybiB7IXN0cmluZ31cbiAgICovXG4gIGdldEluZGV4U3RhcnROYW1lKCk6IHN0cmluZyB7XG4gICAgYXNzZXJ0KHRoaXMuc3RhcnRTZXRfLCAnT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXQnKTtcbiAgICBpZiAodGhpcy5zdGFydE5hbWVTZXRfKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0TmFtZV87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNSU5fTkFNRTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0VuZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5lbmRTZXRfO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXRJbmRleEVuZFZhbHVlKCk6IGFueSB7XG4gICAgYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xuICAgIHJldHVybiB0aGlzLmluZGV4RW5kVmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXG4gICAqIFJldHVybnMgdGhlIGVuZCBrZXkgbmFtZSBmb3IgdGhlIHJhbmdlIGRlZmluZWQgYnkgdGhlc2UgcXVlcnkgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJuIHshc3RyaW5nfVxuICAgKi9cbiAgZ2V0SW5kZXhFbmROYW1lKCk6IHN0cmluZyB7XG4gICAgYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xuICAgIGlmICh0aGlzLmVuZE5hbWVTZXRfKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleEVuZE5hbWVfO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTUFYX05BTUU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNMaW1pdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5saW1pdFNldF87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGxpbWl0IGhhcyBiZWVuIHNldCBhbmQgaXQgaGFzIGJlZW4gZXhwbGljaXRseSBhbmNob3JlZFxuICAgKi9cbiAgaGFzQW5jaG9yZWRMaW1pdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5saW1pdFNldF8gJiYgdGhpcy52aWV3RnJvbV8gIT09ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNMaW1pdCgpIHJldHVybnMgdHJ1ZVxuICAgKiBAcmV0dXJuIHshbnVtYmVyfVxuICAgKi9cbiAgZ2V0TGltaXQoKTogbnVtYmVyIHtcbiAgICBhc3NlcnQodGhpcy5saW1pdFNldF8sICdPbmx5IHZhbGlkIGlmIGxpbWl0IGhhcyBiZWVuIHNldCcpO1xuICAgIHJldHVybiB0aGlzLmxpbWl0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshSW5kZXh9XG4gICAqL1xuICBnZXRJbmRleCgpOiBJbmRleCB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY29weV8oKTogUXVlcnlQYXJhbXMge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgUXVlcnlQYXJhbXMoKTtcbiAgICBjb3B5LmxpbWl0U2V0XyA9IHRoaXMubGltaXRTZXRfO1xuICAgIGNvcHkubGltaXRfID0gdGhpcy5saW1pdF87XG4gICAgY29weS5zdGFydFNldF8gPSB0aGlzLnN0YXJ0U2V0XztcbiAgICBjb3B5LmluZGV4U3RhcnRWYWx1ZV8gPSB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XG4gICAgY29weS5zdGFydE5hbWVTZXRfID0gdGhpcy5zdGFydE5hbWVTZXRfO1xuICAgIGNvcHkuaW5kZXhTdGFydE5hbWVfID0gdGhpcy5pbmRleFN0YXJ0TmFtZV87XG4gICAgY29weS5lbmRTZXRfID0gdGhpcy5lbmRTZXRfO1xuICAgIGNvcHkuaW5kZXhFbmRWYWx1ZV8gPSB0aGlzLmluZGV4RW5kVmFsdWVfO1xuICAgIGNvcHkuZW5kTmFtZVNldF8gPSB0aGlzLmVuZE5hbWVTZXRfO1xuICAgIGNvcHkuaW5kZXhFbmROYW1lXyA9IHRoaXMuaW5kZXhFbmROYW1lXztcbiAgICBjb3B5LmluZGV4XyA9IHRoaXMuaW5kZXhfO1xuICAgIGNvcHkudmlld0Zyb21fID0gdGhpcy52aWV3RnJvbV87XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshbnVtYmVyfSBuZXdMaW1pdFxuICAgKiBAcmV0dXJuIHshUXVlcnlQYXJhbXN9XG4gICAqL1xuICBsaW1pdChuZXdMaW1pdDogbnVtYmVyKTogUXVlcnlQYXJhbXMge1xuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICBuZXdQYXJhbXMubGltaXRTZXRfID0gdHJ1ZTtcbiAgICBuZXdQYXJhbXMubGltaXRfID0gbmV3TGltaXQ7XG4gICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9ICcnO1xuICAgIHJldHVybiBuZXdQYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshbnVtYmVyfSBuZXdMaW1pdFxuICAgKiBAcmV0dXJuIHshUXVlcnlQYXJhbXN9XG4gICAqL1xuICBsaW1pdFRvRmlyc3QobmV3TGltaXQ6IG51bWJlcik6IFF1ZXJ5UGFyYW1zIHtcbiAgICBjb25zdCBuZXdQYXJhbXMgPSB0aGlzLmNvcHlfKCk7XG4gICAgbmV3UGFyYW1zLmxpbWl0U2V0XyA9IHRydWU7XG4gICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xuICAgIG5ld1BhcmFtcy52aWV3RnJvbV8gPSBRdWVyeVBhcmFtcy5XSVJFX1BST1RPQ09MX0NPTlNUQU5UU18uVklFV19GUk9NX0xFRlQ7XG4gICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IG5ld0xpbWl0XG4gICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICovXG4gIGxpbWl0VG9MYXN0KG5ld0xpbWl0OiBudW1iZXIpOiBRdWVyeVBhcmFtcyB7XG4gICAgY29uc3QgbmV3UGFyYW1zID0gdGhpcy5jb3B5XygpO1xuICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xuICAgIG5ld1BhcmFtcy5saW1pdF8gPSBuZXdMaW1pdDtcbiAgICBuZXdQYXJhbXMudmlld0Zyb21fID0gUXVlcnlQYXJhbXMuV0lSRV9QUk9UT0NPTF9DT05TVEFOVFNfLlZJRVdfRlJPTV9SSUdIVDtcbiAgICByZXR1cm4gbmV3UGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgKiBAcGFyYW0gez9zdHJpbmc9fSBrZXlcbiAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgKi9cbiAgc3RhcnRBdChpbmRleFZhbHVlOiBhbnksIGtleT86IHN0cmluZyB8IG51bGwpOiBRdWVyeVBhcmFtcyB7XG4gICAgY29uc3QgbmV3UGFyYW1zID0gdGhpcy5jb3B5XygpO1xuICAgIG5ld1BhcmFtcy5zdGFydFNldF8gPSB0cnVlO1xuICAgIGlmIChpbmRleFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICBuZXdQYXJhbXMuaW5kZXhTdGFydFZhbHVlXyA9IGluZGV4VmFsdWU7XG4gICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IHRydWU7XG4gICAgICBuZXdQYXJhbXMuaW5kZXhTdGFydE5hbWVfID0ga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xuICAgICAgbmV3UGFyYW1zLmluZGV4U3RhcnROYW1lXyA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgKiBAcGFyYW0gez9zdHJpbmc9fSBrZXlcbiAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgKi9cbiAgZW5kQXQoaW5kZXhWYWx1ZTogYW55LCBrZXk/OiBzdHJpbmcgfCBudWxsKTogUXVlcnlQYXJhbXMge1xuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICBuZXdQYXJhbXMuZW5kU2V0XyA9IHRydWU7XG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5kZXhWYWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIG5ld1BhcmFtcy5pbmRleEVuZFZhbHVlXyA9IGluZGV4VmFsdWU7XG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdQYXJhbXMuZW5kTmFtZVNldF8gPSB0cnVlO1xuICAgICAgbmV3UGFyYW1zLmluZGV4RW5kTmFtZV8gPSBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IGZhbHNlO1xuICAgICAgbmV3UGFyYW1zLmluZGV4RW5kTmFtZV8gPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhcbiAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgKi9cbiAgb3JkZXJCeShpbmRleDogSW5kZXgpOiBRdWVyeVBhcmFtcyB7XG4gICAgY29uc3QgbmV3UGFyYW1zID0gdGhpcy5jb3B5XygpO1xuICAgIG5ld1BhcmFtcy5pbmRleF8gPSBpbmRleDtcbiAgICByZXR1cm4gbmV3UGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqL1xuICBnZXRRdWVyeU9iamVjdCgpOiBPYmplY3Qge1xuICAgIGNvbnN0IFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTID0gUXVlcnlQYXJhbXMuV0lSRV9QUk9UT0NPTF9DT05TVEFOVFNfO1xuICAgIGNvbnN0IG9iajogeyBbazogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgICBpZiAodGhpcy5zdGFydFNldF8pIHtcbiAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9TVEFSVF9WQUxVRV0gPSB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XG4gICAgICBpZiAodGhpcy5zdGFydE5hbWVTZXRfKSB7XG4gICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9TVEFSVF9OQU1FXSA9IHRoaXMuaW5kZXhTdGFydE5hbWVfO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5lbmRTZXRfKSB7XG4gICAgICBvYmpbV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX1ZBTFVFXSA9IHRoaXMuaW5kZXhFbmRWYWx1ZV87XG4gICAgICBpZiAodGhpcy5lbmROYW1lU2V0Xykge1xuICAgICAgICBvYmpbV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX05BTUVdID0gdGhpcy5pbmRleEVuZE5hbWVfO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5saW1pdFNldF8pIHtcbiAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5MSU1JVF0gPSB0aGlzLmxpbWl0XztcbiAgICAgIGxldCB2aWV3RnJvbSA9IHRoaXMudmlld0Zyb21fO1xuICAgICAgaWYgKHZpZXdGcm9tID09PSAnJykge1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdGcm9tTGVmdCgpKSB7XG4gICAgICAgICAgdmlld0Zyb20gPSBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWV3RnJvbSA9IFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9SSUdIVDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqW1dJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV0gPSB2aWV3RnJvbTtcbiAgICB9XG4gICAgLy8gRm9yIG5vdywgcHJpb3JpdHkgaW5kZXggaXMgdGhlIGRlZmF1bHQsIHNvIHdlIG9ubHkgc3BlY2lmeSBpZiBpdCdzIHNvbWUgb3RoZXIgaW5kZXhcbiAgICBpZiAodGhpcy5pbmRleF8gIT09IFBSSU9SSVRZX0lOREVYKSB7XG4gICAgICBvYmpbV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhdID0gdGhpcy5pbmRleF8udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbG9hZHNBbGxEYXRhKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhKHRoaXMuc3RhcnRTZXRfIHx8IHRoaXMuZW5kU2V0XyB8fCB0aGlzLmxpbWl0U2V0Xyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRGVmYXVsdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sb2Fkc0FsbERhdGEoKSAmJiB0aGlzLmluZGV4XyA9PSBQUklPUklUWV9JTkRFWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTm9kZUZpbHRlcn1cbiAgICovXG4gIGdldE5vZGVGaWx0ZXIoKTogTm9kZUZpbHRlciB7XG4gICAgaWYgKHRoaXMubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgIHJldHVybiBuZXcgSW5kZXhlZEZpbHRlcih0aGlzLmdldEluZGV4KCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNMaW1pdCgpKSB7XG4gICAgICByZXR1cm4gbmV3IExpbWl0ZWRGaWx0ZXIodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2VkRmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIFJFU1QgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMgcmVwcmVzZW50aW5nIHRoaXMgcXVlcnkuXG4gICAqXG4gICAqIEByZXR1cm4geyFPYmplY3QuPHN0cmluZywqPn0gcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAgICovXG4gIHRvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycygpOiB7IFtrOiBzdHJpbmddOiBhbnkgfSB7XG4gICAgY29uc3QgUkVTVF9DT05TVEFOVFMgPSBRdWVyeVBhcmFtcy5SRVNUX1FVRVJZX0NPTlNUQU5UU187XG4gICAgY29uc3QgcXM6IHsgW2s6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB9ID0ge307XG5cbiAgICBpZiAodGhpcy5pc0RlZmF1bHQoKSkge1xuICAgICAgcmV0dXJuIHFzO1xuICAgIH1cblxuICAgIGxldCBvcmRlckJ5O1xuICAgIGlmICh0aGlzLmluZGV4XyA9PT0gUFJJT1JJVFlfSU5ERVgpIHtcbiAgICAgIG9yZGVyQnkgPSBSRVNUX0NPTlNUQU5UUy5QUklPUklUWV9JTkRFWDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5kZXhfID09PSBWQUxVRV9JTkRFWCkge1xuICAgICAgb3JkZXJCeSA9IFJFU1RfQ09OU1RBTlRTLlZBTFVFX0lOREVYO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbmRleF8gPT09IEtFWV9JTkRFWCkge1xuICAgICAgb3JkZXJCeSA9IFJFU1RfQ09OU1RBTlRTLktFWV9JTkRFWDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHRoaXMuaW5kZXhfIGluc3RhbmNlb2YgUGF0aEluZGV4LCAnVW5yZWNvZ25pemVkIGluZGV4IHR5cGUhJyk7XG4gICAgICBvcmRlckJ5ID0gdGhpcy5pbmRleF8udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcXNbUkVTVF9DT05TVEFOVFMuT1JERVJfQlldID0gc3RyaW5naWZ5KG9yZGVyQnkpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnRTZXRfKSB7XG4gICAgICBxc1tSRVNUX0NPTlNUQU5UUy5TVEFSVF9BVF0gPSBzdHJpbmdpZnkodGhpcy5pbmRleFN0YXJ0VmFsdWVfKTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0TmFtZVNldF8pIHtcbiAgICAgICAgcXNbUkVTVF9DT05TVEFOVFMuU1RBUlRfQVRdICs9ICcsJyArIHN0cmluZ2lmeSh0aGlzLmluZGV4U3RhcnROYW1lXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kU2V0Xykge1xuICAgICAgcXNbUkVTVF9DT05TVEFOVFMuRU5EX0FUXSA9IHN0cmluZ2lmeSh0aGlzLmluZGV4RW5kVmFsdWVfKTtcbiAgICAgIGlmICh0aGlzLmVuZE5hbWVTZXRfKSB7XG4gICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLkVORF9BVF0gKz0gJywnICsgc3RyaW5naWZ5KHRoaXMuaW5kZXhFbmROYW1lXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGltaXRTZXRfKSB7XG4gICAgICBpZiAodGhpcy5pc1ZpZXdGcm9tTGVmdCgpKSB7XG4gICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLkxJTUlUX1RPX0ZJUlNUXSA9IHRoaXMubGltaXRfO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXNbUkVTVF9DT05TVEFOVFMuTElNSVRfVE9fTEFTVF0gPSB0aGlzLmxpbWl0XztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXM7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBPbkRpc2Nvbm5lY3QgfSBmcm9tICcuL29uRGlzY29ubmVjdCc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblJlc3VsdCB9IGZyb20gJy4vVHJhbnNhY3Rpb25SZXN1bHQnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL2NvcmUvdXRpbC91dGlsJztcbmltcG9ydCB7IG5leHRQdXNoSWQgfSBmcm9tICcuLi9jb3JlL3V0aWwvTmV4dFB1c2hJZCc7XG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gJy4vUXVlcnknO1xuaW1wb3J0IHsgUmVwbyB9IGZyb20gJy4uL2NvcmUvUmVwbyc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vY29yZS91dGlsL1BhdGgnO1xuaW1wb3J0IHsgUXVlcnlQYXJhbXMgfSBmcm9tICcuLi9jb3JlL3ZpZXcvUXVlcnlQYXJhbXMnO1xuaW1wb3J0IHtcbiAgdmFsaWRhdGVSb290UGF0aFN0cmluZyxcbiAgdmFsaWRhdGVQYXRoU3RyaW5nLFxuICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnLFxuICB2YWxpZGF0ZUJvb2xlYW4sXG4gIHZhbGlkYXRlUHJpb3JpdHksXG4gIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnLFxuICB2YWxpZGF0ZVdyaXRhYmxlUGF0aFxufSBmcm9tICcuLi9jb3JlL3V0aWwvdmFsaWRhdGlvbic7XG5pbXBvcnQgeyB2YWxpZGF0ZUFyZ0NvdW50LCB2YWxpZGF0ZUNhbGxiYWNrIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBTeW5jUG9pbnQgfSBmcm9tICcuLi9jb3JlL1N5bmNQb2ludCc7XG5pbXBvcnQgeyBEYXRhYmFzZSB9IGZyb20gJy4vRGF0YWJhc2UnO1xuaW1wb3J0IHsgRGF0YVNuYXBzaG90IH0gZnJvbSAnLi9EYXRhU25hcHNob3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlZmVyZW5jZUNvbnN0cnVjdG9yIHtcbiAgbmV3IChyZXBvOiBSZXBvLCBwYXRoOiBQYXRoKTogUmVmZXJlbmNlO1xufVxuXG5leHBvcnQgY2xhc3MgUmVmZXJlbmNlIGV4dGVuZHMgUXVlcnkge1xuICBwdWJsaWMgdGhlbjogKGE/OiBhbnkpID0+IFByb21pc2U8YW55PjtcbiAgcHVibGljIGNhdGNoOiAoYT86IEVycm9yKSA9PiBQcm9taXNlPGFueT47XG5cbiAgLyoqXG4gICAqIENhbGwgb3B0aW9uczpcbiAgICogICBuZXcgUmVmZXJlbmNlKFJlcG8sIFBhdGgpIG9yXG4gICAqICAgbmV3IFJlZmVyZW5jZSh1cmw6IHN0cmluZywgc3RyaW5nfFJlcG9NYW5hZ2VyKVxuICAgKlxuICAgKiBFeHRlcm5hbGx5IC0gdGhpcyBpcyB0aGUgZmlyZWJhc2UuZGF0YWJhc2UuUmVmZXJlbmNlIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IVJlcG99IHJlcG9cbiAgICogQHBhcmFtIHsoIVBhdGgpfSBwYXRoXG4gICAqIEBleHRlbmRzIHtRdWVyeX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlcG86IFJlcG8sIHBhdGg6IFBhdGgpIHtcbiAgICBpZiAoIShyZXBvIGluc3RhbmNlb2YgUmVwbykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ25ldyBSZWZlcmVuY2UoKSBubyBsb25nZXIgc3VwcG9ydGVkIC0gdXNlIGFwcC5kYXRhYmFzZSgpLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY2FsbCBRdWVyeSdzIGNvbnN0cnVjdG9yLCBwYXNzaW5nIGluIHRoZSByZXBvIGFuZCBwYXRoLlxuICAgIHN1cGVyKHJlcG8sIHBhdGgsIFF1ZXJ5UGFyYW1zLkRFRkFVTFQsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICBnZXRLZXkoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLmtleScsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXG4gICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpIHJldHVybiBudWxsO1xuICAgIGVsc2UgcmV0dXJuIHRoaXMucGF0aC5nZXRCYWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshKHN0cmluZ3xQYXRoKX0gcGF0aFN0cmluZ1xuICAgKiBAcmV0dXJuIHshUmVmZXJlbmNlfVxuICAgKi9cbiAgY2hpbGQocGF0aFN0cmluZzogc3RyaW5nIHwgUGF0aCk6IFJlZmVyZW5jZSB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLmNoaWxkJywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgaWYgKHR5cGVvZiBwYXRoU3RyaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgcGF0aFN0cmluZyA9IFN0cmluZyhwYXRoU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKCEocGF0aFN0cmluZyBpbnN0YW5jZW9mIFBhdGgpKSB7XG4gICAgICBpZiAodGhpcy5wYXRoLmdldEZyb250KCkgPT09IG51bGwpXG4gICAgICAgIHZhbGlkYXRlUm9vdFBhdGhTdHJpbmcoJ1JlZmVyZW5jZS5jaGlsZCcsIDEsIHBhdGhTdHJpbmcsIGZhbHNlKTtcbiAgICAgIGVsc2UgdmFsaWRhdGVQYXRoU3RyaW5nKCdSZWZlcmVuY2UuY2hpbGQnLCAxLCBwYXRoU3RyaW5nLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UodGhpcy5yZXBvLCB0aGlzLnBhdGguY2hpbGQocGF0aFN0cmluZykpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gez9SZWZlcmVuY2V9ICovXG4gIGdldFBhcmVudCgpOiBSZWZlcmVuY2UgfCBudWxsIHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2UucGFyZW50JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG5cbiAgICBjb25zdCBwYXJlbnRQYXRoID0gdGhpcy5wYXRoLnBhcmVudCgpO1xuICAgIHJldHVybiBwYXJlbnRQYXRoID09PSBudWxsID8gbnVsbCA6IG5ldyBSZWZlcmVuY2UodGhpcy5yZXBvLCBwYXJlbnRQYXRoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshUmVmZXJlbmNlfSAqL1xuICBnZXRSb290KCk6IFJlZmVyZW5jZSB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnJvb3QnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgIGxldCByZWYgPSB0aGlzIGFzIGFueTtcbiAgICB3aGlsZSAocmVmLmdldFBhcmVudCgpICE9PSBudWxsKSB7XG4gICAgICByZWYgPSByZWYuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG4gIH1cblxuICAvKiogQHJldHVybiB7IURhdGFiYXNlfSAqL1xuICBkYXRhYmFzZVByb3AoKTogRGF0YWJhc2Uge1xuICAgIHJldHVybiB0aGlzLnJlcG8uZGF0YWJhc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBuZXdWYWxcbiAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICovXG4gIHNldChuZXdWYWw6IGFueSwgb25Db21wbGV0ZT86IChhOiBFcnJvciB8IG51bGwpID0+IHZvaWQpOiBQcm9taXNlPGFueT4ge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5zZXQnLCAxLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnNldCcsIHRoaXMucGF0aCk7XG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ1JlZmVyZW5jZS5zZXQnLCAxLCBuZXdWYWwsIHRoaXMucGF0aCwgZmFsc2UpO1xuICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS5zZXQnLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcblxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgdGhpcy5yZXBvLnNldFdpdGhQcmlvcml0eShcbiAgICAgIHRoaXMucGF0aCxcbiAgICAgIG5ld1ZhbCxcbiAgICAgIC8qcHJpb3JpdHk9Ki8gbnVsbCxcbiAgICAgIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKVxuICAgICk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RUb01lcmdlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAqL1xuICB1cGRhdGUoXG4gICAgb2JqZWN0VG9NZXJnZTogT2JqZWN0LFxuICAgIG9uQ29tcGxldGU/OiAoYTogRXJyb3IgfCBudWxsKSA9PiB2b2lkXG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnVwZGF0ZScsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2UudXBkYXRlJywgdGhpcy5wYXRoKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdFRvTWVyZ2UpKSB7XG4gICAgICBjb25zdCBuZXdPYmplY3RUb01lcmdlOiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RUb01lcmdlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5ld09iamVjdFRvTWVyZ2VbJycgKyBpXSA9IG9iamVjdFRvTWVyZ2VbaV07XG4gICAgICB9XG4gICAgICBvYmplY3RUb01lcmdlID0gbmV3T2JqZWN0VG9NZXJnZTtcbiAgICAgIHdhcm4oXG4gICAgICAgICdQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuICcgK1xuICAgICAgICAgICdVc2Ugc2V0KCkgaWYgeW91IHdhbnQgdG8gb3ZlcndyaXRlIHRoZSBleGlzdGluZyBkYXRhLCBvciAnICtcbiAgICAgICAgICAnYW4gT2JqZWN0IHdpdGggaW50ZWdlciBrZXlzIGlmIHlvdSByZWFsbHkgZG8gd2FudCB0byAnICtcbiAgICAgICAgICAnb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uJ1xuICAgICAgKTtcbiAgICB9XG4gICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZyhcbiAgICAgICdSZWZlcmVuY2UudXBkYXRlJyxcbiAgICAgIDEsXG4gICAgICBvYmplY3RUb01lcmdlLFxuICAgICAgdGhpcy5wYXRoLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS51cGRhdGUnLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHRoaXMucmVwby51cGRhdGUoXG4gICAgICB0aGlzLnBhdGgsXG4gICAgICBvYmplY3RUb01lcmdlLFxuICAgICAgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpXG4gICAgKTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IG5ld1ZhbFxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8bnVsbH0gbmV3UHJpb3JpdHlcbiAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICovXG4gIHNldFdpdGhQcmlvcml0eShcbiAgICBuZXdWYWw6IGFueSxcbiAgICBuZXdQcmlvcml0eTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCxcbiAgICBvbkNvbXBsZXRlPzogKGE6IEVycm9yIHwgbnVsbCkgPT4gdm9pZFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCAyLCAzLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnNldFdpdGhQcmlvcml0eScsIHRoaXMucGF0aCk7XG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoXG4gICAgICAnUmVmZXJlbmNlLnNldFdpdGhQcmlvcml0eScsXG4gICAgICAxLFxuICAgICAgbmV3VmFsLFxuICAgICAgdGhpcy5wYXRoLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHZhbGlkYXRlUHJpb3JpdHkoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCAyLCBuZXdQcmlvcml0eSwgZmFsc2UpO1xuICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCAzLCBvbkNvbXBsZXRlLCB0cnVlKTtcblxuICAgIGlmICh0aGlzLmdldEtleSgpID09PSAnLmxlbmd0aCcgfHwgdGhpcy5nZXRLZXkoKSA9PT0gJy5rZXlzJylcbiAgICAgIHRocm93ICdSZWZlcmVuY2Uuc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogJyArXG4gICAgICAgIHRoaXMuZ2V0S2V5KCkgK1xuICAgICAgICAnIGlzIGEgcmVhZC1vbmx5IG9iamVjdC4nO1xuXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICB0aGlzLnJlcG8uc2V0V2l0aFByaW9yaXR5KFxuICAgICAgdGhpcy5wYXRoLFxuICAgICAgbmV3VmFsLFxuICAgICAgbmV3UHJpb3JpdHksXG4gICAgICBkZWZlcnJlZC53cmFwQ2FsbGJhY2sob25Db21wbGV0ZSlcbiAgICApO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAqL1xuICByZW1vdmUob25Db21wbGV0ZT86IChhOiBFcnJvciB8IG51bGwpID0+IHZvaWQpOiBQcm9taXNlPGFueT4ge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5yZW1vdmUnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnJlbW92ZScsIHRoaXMucGF0aCk7XG4gICAgdmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnJlbW92ZScsIDEsIG9uQ29tcGxldGUsIHRydWUpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0KG51bGwsIG9uQ29tcGxldGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6Kn0gdHJhbnNhY3Rpb25VcGRhdGVcbiAgICogQHBhcmFtIHsoZnVuY3Rpb24oP0Vycm9yLCBib29sZWFuLCA/RGF0YVNuYXBzaG90KSk9fSBvbkNvbXBsZXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGFwcGx5TG9jYWxseVxuICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICovXG4gIHRyYW5zYWN0aW9uKFxuICAgIHRyYW5zYWN0aW9uVXBkYXRlOiAoYTogYW55KSA9PiBhbnksXG4gICAgb25Db21wbGV0ZT86IChhOiBFcnJvciB8IG51bGwsIGI6IGJvb2xlYW4sIGM6IERhdGFTbmFwc2hvdCB8IG51bGwpID0+IHZvaWQsXG4gICAgYXBwbHlMb2NhbGx5PzogYm9vbGVhblxuICApOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzdWx0PiB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgMSwgMywgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS50cmFuc2FjdGlvbicsIHRoaXMucGF0aCk7XG4gICAgdmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgMSwgdHJhbnNhY3Rpb25VcGRhdGUsIGZhbHNlKTtcbiAgICB2YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2UudHJhbnNhY3Rpb24nLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAvLyBOT1RFOiBhcHBseUxvY2FsbHkgaXMgYW4gaW50ZXJuYWwtb25seSBvcHRpb24gZm9yIG5vdy4gIFdlIG5lZWQgdG8gZGVjaWRlIGlmIHdlIHdhbnQgdG8ga2VlcCBpdCBhbmQgaG93XG4gICAgLy8gdG8gZXhwb3NlIGl0LlxuICAgIHZhbGlkYXRlQm9vbGVhbignUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgMywgYXBwbHlMb2NhbGx5LCB0cnVlKTtcblxuICAgIGlmICh0aGlzLmdldEtleSgpID09PSAnLmxlbmd0aCcgfHwgdGhpcy5nZXRLZXkoKSA9PT0gJy5rZXlzJylcbiAgICAgIHRocm93ICdSZWZlcmVuY2UudHJhbnNhY3Rpb24gZmFpbGVkOiAnICtcbiAgICAgICAgdGhpcy5nZXRLZXkoKSArXG4gICAgICAgICcgaXMgYSByZWFkLW9ubHkgb2JqZWN0Lic7XG5cbiAgICBpZiAoYXBwbHlMb2NhbGx5ID09PSB1bmRlZmluZWQpIGFwcGx5TG9jYWxseSA9IHRydWU7XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZDxUcmFuc2FjdGlvblJlc3VsdD4oKTtcbiAgICBpZiAodHlwZW9mIG9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRlZmVycmVkLnByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2VDb21wbGV0ZSA9IGZ1bmN0aW9uKFxuICAgICAgZXJyb3I6IEVycm9yLFxuICAgICAgY29tbWl0dGVkOiBib29sZWFuLFxuICAgICAgc25hcHNob3Q6IERhdGFTbmFwc2hvdFxuICAgICkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG5ldyBUcmFuc2FjdGlvblJlc3VsdChjb21taXR0ZWQsIHNuYXBzaG90KSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25Db21wbGV0ZShlcnJvciwgY29tbWl0dGVkLCBzbmFwc2hvdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlcG8uc3RhcnRUcmFuc2FjdGlvbihcbiAgICAgIHRoaXMucGF0aCxcbiAgICAgIHRyYW5zYWN0aW9uVXBkYXRlLFxuICAgICAgcHJvbWlzZUNvbXBsZXRlLFxuICAgICAgYXBwbHlMb2NhbGx5XG4gICAgKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxudWxsfSBwcmlvcml0eVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAqIEByZXR1cm4geyFQcm9taXNlfVxuICAgKi9cbiAgc2V0UHJpb3JpdHkoXG4gICAgcHJpb3JpdHk6IHN0cmluZyB8IG51bWJlciB8IG51bGwsXG4gICAgb25Db21wbGV0ZT86IChhOiBFcnJvciB8IG51bGwpID0+IHZvaWRcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2Uuc2V0UHJpb3JpdHknLCAxLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnNldFByaW9yaXR5JywgdGhpcy5wYXRoKTtcbiAgICB2YWxpZGF0ZVByaW9yaXR5KCdSZWZlcmVuY2Uuc2V0UHJpb3JpdHknLCAxLCBwcmlvcml0eSwgZmFsc2UpO1xuICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS5zZXRQcmlvcml0eScsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICB0aGlzLnJlcG8uc2V0V2l0aFByaW9yaXR5KFxuICAgICAgdGhpcy5wYXRoLmNoaWxkKCcucHJpb3JpdHknKSxcbiAgICAgIHByaW9yaXR5LFxuICAgICAgbnVsbCxcbiAgICAgIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKVxuICAgICk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqPX0gdmFsdWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgKiBAcmV0dXJuIHshUmVmZXJlbmNlfVxuICAgKi9cbiAgcHVzaCh2YWx1ZT86IGFueSwgb25Db21wbGV0ZT86IChhOiBFcnJvciB8IG51bGwpID0+IHZvaWQpOiBSZWZlcmVuY2Uge1xuICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5wdXNoJywgMCwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5wdXNoJywgdGhpcy5wYXRoKTtcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnUmVmZXJlbmNlLnB1c2gnLCAxLCB2YWx1ZSwgdGhpcy5wYXRoLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2UucHVzaCcsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuXG4gICAgY29uc3Qgbm93ID0gdGhpcy5yZXBvLnNlcnZlclRpbWUoKTtcbiAgICBjb25zdCBuYW1lID0gbmV4dFB1c2hJZChub3cpO1xuXG4gICAgLy8gcHVzaCgpIHJldHVybnMgYSBUaGVubmFibGVSZWZlcmVuY2Ugd2hvc2UgcHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhIHJlZ3VsYXIgUmVmZXJlbmNlLlxuICAgIC8vIFdlIHVzZSBjaGlsZCgpIHRvIGNyZWF0ZSBoYW5kbGVzIHRvIHR3byBkaWZmZXJlbnQgcmVmZXJlbmNlcy4gVGhlIGZpcnN0IGlzIHR1cm5lZCBpbnRvIGFcbiAgICAvLyBUaGVubmFibGVSZWZlcmVuY2UgYmVsb3cgYnkgYWRkaW5nIHRoZW4oKSBhbmQgY2F0Y2goKSBtZXRob2RzIGFuZCBpcyB1c2VkIGFzIHRoZVxuICAgIC8vIHJldHVybiB2YWx1ZSBvZiBwdXNoKCkuIFRoZSBzZWNvbmQgcmVtYWlucyBhIHJlZ3VsYXIgUmVmZXJlbmNlIGFuZCBpcyB1c2VkIGFzIHRoZSBmdWxmaWxsZWRcbiAgICAvLyB2YWx1ZSBvZiB0aGUgZmlyc3QgVGhlbm5hYmxlUmVmZXJlbmNlLlxuICAgIGNvbnN0IHRoZW5uYWJsZVB1c2hSZWYgPSB0aGlzLmNoaWxkKG5hbWUpO1xuICAgIGNvbnN0IHB1c2hSZWYgPSB0aGlzLmNoaWxkKG5hbWUpO1xuXG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHByb21pc2UgPSB0aGVubmFibGVQdXNoUmVmLnNldCh2YWx1ZSwgb25Db21wbGV0ZSkudGhlbigoKSA9PiBwdXNoUmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwdXNoUmVmKTtcbiAgICB9XG5cbiAgICB0aGVubmFibGVQdXNoUmVmLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcbiAgICB0aGVubmFibGVQdXNoUmVmLmNhdGNoID0gcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSwgdW5kZWZpbmVkKTtcblxuICAgIGlmICh0eXBlb2Ygb25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoZW5uYWJsZVB1c2hSZWY7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU9uRGlzY29ubmVjdH1cbiAgICovXG4gIG9uRGlzY29ubmVjdCgpOiBPbkRpc2Nvbm5lY3Qge1xuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2Uub25EaXNjb25uZWN0JywgdGhpcy5wYXRoKTtcbiAgICByZXR1cm4gbmV3IE9uRGlzY29ubmVjdCh0aGlzLnJlcG8sIHRoaXMucGF0aCk7XG4gIH1cblxuICBnZXQgZGF0YWJhc2UoKTogRGF0YWJhc2Uge1xuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlUHJvcCgpO1xuICB9XG5cbiAgZ2V0IGtleSgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRLZXkoKTtcbiAgfVxuXG4gIGdldCBwYXJlbnQoKTogUmVmZXJlbmNlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50KCk7XG4gIH1cblxuICBnZXQgcm9vdCgpOiBSZWZlcmVuY2Uge1xuICAgIHJldHVybiB0aGlzLmdldFJvb3QoKTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmluZSByZWZlcmVuY2UgY29uc3RydWN0b3IgaW4gdmFyaW91cyBtb2R1bGVzXG4gKlxuICogV2UgYXJlIGRvaW5nIHRoaXMgaGVyZSB0byBhdm9pZCBzZXZlcmFsIGNpcmN1bGFyXG4gKiBkZXBlbmRlbmN5IGlzc3Vlc1xuICovXG5RdWVyeS5fX3JlZmVyZW5jZUNvbnN0cnVjdG9yID0gUmVmZXJlbmNlO1xuU3luY1BvaW50Ll9fcmVmZXJlbmNlQ29uc3RydWN0b3IgPSBSZWZlcmVuY2U7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgeyBmb3JFYWNoLCBjb250YWlucywgc2FmZUdldCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXG4gKiBOb2RlIGluIGEgVHJlZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyZWVOb2RlPFQ+IHtcbiAgLy8gVE9ETzogQ29uc2lkZXIgbWFraW5nIGFjY2Vzc29ycyB0aGF0IGNyZWF0ZSBjaGlsZHJlbiBhbmQgdmFsdWUgbGF6aWx5IG9yXG4gIC8vIHNlcGFyYXRlIEludGVybmFsIC8gTGVhZiAndHlwZXMnLlxuICBjaGlsZHJlbjogeyBbbmFtZTogc3RyaW5nXTogVHJlZU5vZGU8VD4gfSA9IHt9O1xuICBjaGlsZENvdW50ID0gMDtcbiAgdmFsdWU6IFQgfCBudWxsID0gbnVsbDtcbn1cblxuLyoqXG4gKiBBIGxpZ2h0LXdlaWdodCB0cmVlLCB0cmF2ZXJzYWJsZSBieSBwYXRoLiAgTm9kZXMgY2FuIGhhdmUgYm90aCB2YWx1ZXMgYW5kIGNoaWxkcmVuLlxuICogTm9kZXMgYXJlIG5vdCBlbnVtZXJhdGVkIChieSBmb3JFYWNoQ2hpbGQpIHVubGVzcyB0aGV5IGhhdmUgYSB2YWx1ZSBvciBub24tZW1wdHlcbiAqIGNoaWxkcmVuLlxuICovXG5leHBvcnQgY2xhc3MgVHJlZTxUPiB7XG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWVfIE9wdGlvbmFsIG5hbWUgb2YgdGhlIG5vZGUuXG4gICAqIEBwYXJhbSB7VHJlZT19IHBhcmVudF8gT3B0aW9uYWwgcGFyZW50IG5vZGUuXG4gICAqIEBwYXJhbSB7VHJlZU5vZGU9fSBub2RlXyBPcHRpb25hbCBub2RlIHRvIHdyYXAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG5hbWVfOiBzdHJpbmcgPSAnJyxcbiAgICBwcml2YXRlIHBhcmVudF86IFRyZWU8VD4gfCBudWxsID0gbnVsbCxcbiAgICBwcml2YXRlIG5vZGVfOiBUcmVlTm9kZTxUPiA9IG5ldyBUcmVlTm9kZTxUPigpXG4gICkge31cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN1Yi1UcmVlIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHshKHN0cmluZ3xQYXRoKX0gcGF0aE9iaiBQYXRoIHRvIGxvb2sgdXAuXG4gICAqIEByZXR1cm4geyFUcmVlLjxUPn0gVHJlZSBmb3IgcGF0aC5cbiAgICovXG4gIHN1YlRyZWUocGF0aE9iajogc3RyaW5nIHwgUGF0aCk6IFRyZWU8VD4ge1xuICAgIC8vIFRPRE86IFJlcXVpcmUgcGF0aE9iaiB0byBiZSBQYXRoP1xuICAgIGxldCBwYXRoID0gcGF0aE9iaiBpbnN0YW5jZW9mIFBhdGggPyBwYXRoT2JqIDogbmV3IFBhdGgocGF0aE9iaik7XG4gICAgbGV0IGNoaWxkID0gdGhpcyBhcyBUcmVlPFQ+LFxuICAgICAgbmV4dDtcbiAgICB3aGlsZSAoKG5leHQgPSBwYXRoLmdldEZyb250KCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjaGlsZE5vZGUgPSBzYWZlR2V0KGNoaWxkLm5vZGVfLmNoaWxkcmVuLCBuZXh0KSB8fCBuZXcgVHJlZU5vZGUoKTtcbiAgICAgIGNoaWxkID0gbmV3IFRyZWUobmV4dCwgY2hpbGQsIGNoaWxkTm9kZSk7XG4gICAgICBwYXRoID0gcGF0aC5wb3BGcm9udCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRyZWUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7P1R9IFRoZSBkYXRhIG9yIG51bGwgaWYgbm8gZGF0YSBleGlzdHMuXG4gICAqL1xuICBnZXRWYWx1ZSgpOiBUIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMubm9kZV8udmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBkYXRhIHRvIHRoaXMgdHJlZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0geyFUfSB2YWx1ZSBWYWx1ZSB0byBzZXQuXG4gICAqL1xuICBzZXRWYWx1ZSh2YWx1ZTogVCkge1xuICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnLCAnQ2Fubm90IHNldCB2YWx1ZSB0byB1bmRlZmluZWQnKTtcbiAgICB0aGlzLm5vZGVfLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJlbnRzXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgY29udGVudHMgb2YgdGhlIHRyZWUgbm9kZSAoaXRzIHZhbHVlIGFuZCBhbGwgY2hpbGRyZW4pLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5ub2RlXy52YWx1ZSA9IG51bGw7XG4gICAgdGhpcy5ub2RlXy5jaGlsZHJlbiA9IHt9O1xuICAgIHRoaXMubm9kZV8uY2hpbGRDb3VudCA9IDA7XG4gICAgdGhpcy51cGRhdGVQYXJlbnRzXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRyZWUgaGFzIGFueSBjaGlsZHJlbi5cbiAgICovXG4gIGhhc0NoaWxkcmVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm5vZGVfLmNoaWxkQ291bnQgPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRyZWUgaXMgZW1wdHkgKG5vIHZhbHVlIG9yIGNoaWxkcmVuKS5cbiAgICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKSA9PT0gbnVsbCAmJiAhdGhpcy5oYXNDaGlsZHJlbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGFjdGlvbiBmb3IgZWFjaCBjaGlsZCBvZiB0aGlzIHRyZWUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbighVHJlZS48VD4pfSBhY3Rpb24gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cbiAgICovXG4gIGZvckVhY2hDaGlsZChhY3Rpb246ICh0cmVlOiBUcmVlPFQ+KSA9PiB2b2lkKSB7XG4gICAgZm9yRWFjaCh0aGlzLm5vZGVfLmNoaWxkcmVuLCAoY2hpbGQ6IHN0cmluZywgY2hpbGRUcmVlOiBUcmVlTm9kZTxUPikgPT4ge1xuICAgICAgYWN0aW9uKG5ldyBUcmVlPFQ+KGNoaWxkLCB0aGlzLCBjaGlsZFRyZWUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEb2VzIGEgZGVwdGgtZmlyc3QgdHJhdmVyc2FsIG9mIHRoaXMgbm9kZSdzIGRlc2NlbmRhbnRzLCBjYWxsaW5nIGFjdGlvbiBmb3IgZWFjaCBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIVRyZWUuPFQ+KX0gYWN0aW9uIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVTZWxmIFdoZXRoZXIgdG8gY2FsbCBhY3Rpb24gb24gdGhpcyBub2RlIGFzIHdlbGwuIERlZmF1bHRzIHRvXG4gICAqICAgZmFsc2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGNoaWxkcmVuRmlyc3QgV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiBjaGlsZHJlbiBiZWZvcmUgY2FsbGluZyBpdCBvblxuICAgKiAgIHBhcmVudC5cbiAgICovXG4gIGZvckVhY2hEZXNjZW5kYW50KFxuICAgIGFjdGlvbjogKHRyZWU6IFRyZWU8VD4pID0+IHZvaWQsXG4gICAgaW5jbHVkZVNlbGY/OiBib29sZWFuLFxuICAgIGNoaWxkcmVuRmlyc3Q/OiBib29sZWFuXG4gICkge1xuICAgIGlmIChpbmNsdWRlU2VsZiAmJiAhY2hpbGRyZW5GaXJzdCkgYWN0aW9uKHRoaXMpO1xuXG4gICAgdGhpcy5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGNoaWxkLmZvckVhY2hEZXNjZW5kYW50KGFjdGlvbiwgLyppbmNsdWRlU2VsZj0qLyB0cnVlLCBjaGlsZHJlbkZpcnN0KTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlU2VsZiAmJiBjaGlsZHJlbkZpcnN0KSBhY3Rpb24odGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgYWN0aW9uIG9uIGVhY2ggYW5jZXN0b3Igbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbighVHJlZS48VD4pfSBhY3Rpb24gQWN0aW9uIHRvIGJlIGNhbGxlZCBvbiBlYWNoIHBhcmVudDsgcmV0dXJuXG4gICAqICAgdHJ1ZSB0byBhYm9ydC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZVNlbGYgV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYWN0aW9uIGNhbGxiYWNrIHJldHVybmVkIHRydWUuXG4gICAqL1xuICBmb3JFYWNoQW5jZXN0b3IoXG4gICAgYWN0aW9uOiAodHJlZTogVHJlZTxUPikgPT4gdW5rbm93bixcbiAgICBpbmNsdWRlU2VsZj86IGJvb2xlYW5cbiAgKTogYm9vbGVhbiB7XG4gICAgbGV0IG5vZGUgPSBpbmNsdWRlU2VsZiA/IHRoaXMgOiB0aGlzLnBhcmVudCgpO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0aW9uKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEb2VzIGEgZGVwdGgtZmlyc3QgdHJhdmVyc2FsIG9mIHRoaXMgbm9kZSdzIGRlc2NlbmRhbnRzLiAgV2hlbiBhIGRlc2NlbmRhbnQgd2l0aCBhIHZhbHVlXG4gICAqIGlzIGZvdW5kLCBhY3Rpb24gaXMgY2FsbGVkIG9uIGl0IGFuZCB0cmF2ZXJzYWwgZG9lcyBub3QgY29udGludWUgaW5zaWRlIHRoZSBub2RlLlxuICAgKiBBY3Rpb24gaXMgKm5vdCogY2FsbGVkIG9uIHRoaXMgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbighVHJlZS48VD4pfSBhY3Rpb24gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cbiAgICovXG4gIGZvckVhY2hJbW1lZGlhdGVEZXNjZW5kYW50V2l0aFZhbHVlKGFjdGlvbjogKHRyZWU6IFRyZWU8VD4pID0+IHZvaWQpIHtcbiAgICB0aGlzLmZvckVhY2hDaGlsZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLmdldFZhbHVlKCkgIT09IG51bGwpIGFjdGlvbihjaGlsZCk7XG4gICAgICBlbHNlIGNoaWxkLmZvckVhY2hJbW1lZGlhdGVEZXNjZW5kYW50V2l0aFZhbHVlKGFjdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IVBhdGh9IFRoZSBwYXRoIG9mIHRoaXMgdHJlZSBub2RlLCBhcyBhIFBhdGguXG4gICAqL1xuICBwYXRoKCk6IFBhdGgge1xuICAgIHJldHVybiBuZXcgUGF0aChcbiAgICAgIHRoaXMucGFyZW50XyA9PT0gbnVsbFxuICAgICAgICA/IHRoaXMubmFtZV9cbiAgICAgICAgOiB0aGlzLnBhcmVudF8ucGF0aCgpICsgJy8nICsgdGhpcy5uYW1lX1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdHJlZSBub2RlLlxuICAgKi9cbiAgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gez9UcmVlfSBUaGUgcGFyZW50IHRyZWUgbm9kZSwgb3IgbnVsbCBpZiB0aGlzIGlzIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgKi9cbiAgcGFyZW50KCk6IFRyZWU8VD4gfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb3IgcmVtb3ZlcyB0aGlzIGNoaWxkIGZyb20gaXRzIHBhcmVudCBiYXNlZCBvbiB3aGV0aGVyIGl0J3MgZW1wdHkgb3Igbm90LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVQYXJlbnRzXygpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRfICE9PSBudWxsKSB0aGlzLnBhcmVudF8udXBkYXRlQ2hpbGRfKHRoaXMubmFtZV8sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb3IgcmVtb3ZlcyB0aGUgcGFzc2VkIGNoaWxkIHRvIHRoaXMgdHJlZSBub2RlLCBkZXBlbmRpbmcgb24gd2hldGhlciBpdCdzIGVtcHR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGROYW1lIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7IVRyZWUuPFQ+fSBjaGlsZCBUaGUgY2hpbGQgdG8gdXBkYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVDaGlsZF8oY2hpbGROYW1lOiBzdHJpbmcsIGNoaWxkOiBUcmVlPFQ+KSB7XG4gICAgY29uc3QgY2hpbGRFbXB0eSA9IGNoaWxkLmlzRW1wdHkoKTtcbiAgICBjb25zdCBjaGlsZEV4aXN0cyA9IGNvbnRhaW5zKHRoaXMubm9kZV8uY2hpbGRyZW4sIGNoaWxkTmFtZSk7XG4gICAgaWYgKGNoaWxkRW1wdHkgJiYgY2hpbGRFeGlzdHMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm5vZGVfLmNoaWxkcmVuW2NoaWxkTmFtZV07XG4gICAgICB0aGlzLm5vZGVfLmNoaWxkQ291bnQtLTtcbiAgICAgIHRoaXMudXBkYXRlUGFyZW50c18oKTtcbiAgICB9IGVsc2UgaWYgKCFjaGlsZEVtcHR5ICYmICFjaGlsZEV4aXN0cykge1xuICAgICAgdGhpcy5ub2RlXy5jaGlsZHJlbltjaGlsZE5hbWVdID0gY2hpbGQubm9kZV87XG4gICAgICB0aGlzLm5vZGVfLmNoaWxkQ291bnQrKztcbiAgICAgIHRoaXMudXBkYXRlUGFyZW50c18oKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tICcuLi9hcGkvUmVmZXJlbmNlJztcbmltcG9ydCB7IERhdGFTbmFwc2hvdCB9IGZyb20gJy4uL2FwaS9EYXRhU25hcHNob3QnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vdXRpbC9QYXRoJztcbmltcG9ydCB7IFRyZWUgfSBmcm9tICcuL3V0aWwvVHJlZSc7XG5pbXBvcnQgeyBQUklPUklUWV9JTkRFWCB9IGZyb20gJy4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vc25hcC9Ob2RlJztcbmltcG9ydCB7IExVSURHZW5lcmF0b3IsIHdhcm4sIGV4Y2VwdGlvbkd1YXJkIH0gZnJvbSAnLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdCB9IGZyb20gJy4vdXRpbC9TZXJ2ZXJWYWx1ZXMnO1xuaW1wb3J0IHsgaXNWYWxpZFByaW9yaXR5LCB2YWxpZGF0ZUZpcmViYXNlRGF0YSB9IGZyb20gJy4vdXRpbC92YWxpZGF0aW9uJztcbmltcG9ydCB7IGNvbnRhaW5zLCBzYWZlR2V0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgbm9kZUZyb21KU09OIH0gZnJvbSAnLi9zbmFwL25vZGVGcm9tSlNPTic7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuL3NuYXAvQ2hpbGRyZW5Ob2RlJztcbmltcG9ydCB7IFJlcG8gfSBmcm9tICcuL1JlcG8nO1xuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL3ZpZXcvRXZlbnQnO1xuXG4vLyBUT0RPOiBUaGlzIGlzIHByZXR0eSBtZXNzeS4gIElkZWFsbHksIGEgbG90IG9mIHRoaXMgd291bGQgbW92ZSBpbnRvIEZpcmViYXNlRGF0YSwgb3IgYSB0cmFuc2FjdGlvbi1zcGVjaWZpY1xuLy8gY29tcG9uZW50IHVzZWQgYnkgRmlyZWJhc2VEYXRhLCBidXQgaXQgaGFzIHRpZXMgdG8gdXNlciBjYWxsYmFja3MgKHRyYW5zYWN0aW9uIHVwZGF0ZSBhbmQgb25Db21wbGV0ZSkgYXMgd2VsbFxuLy8gYXMgdGhlIHJlYWx0aW1lIGNvbm5lY3Rpb24gKHRvIHNlbmQgdHJhbnNhY3Rpb25zIHRvIHRoZSBzZXJ2ZXIpLiAgU28gdGhhdCBhbGwgbmVlZHMgdG8gYmUgZGVjb3VwbGVkIGZpcnN0LlxuLy8gRm9yIG5vdyBpdCdzIHBhcnQgb2YgUmVwbywgYnV0IGluIGl0cyBvd24gZmlsZS5cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZW51bSBUcmFuc2FjdGlvblN0YXR1cyB7XG4gIC8vIFdlJ3ZlIHJ1biB0aGUgdHJhbnNhY3Rpb24gYW5kIHVwZGF0ZWQgdHJhbnNhY3Rpb25SZXN1bHREYXRhXyB3aXRoIHRoZSByZXN1bHQsIGJ1dCBpdCBpc24ndCBjdXJyZW50bHkgc2VudCB0byB0aGVcbiAgLy8gc2VydmVyLiBBIHRyYW5zYWN0aW9uIHdpbGwgZ28gZnJvbSBSVU4gLT4gU0VOVCAtPiBSVU4gaWYgaXQgY29tZXMgYmFjayBmcm9tIHRoZSBzZXJ2ZXIgYXMgcmVqZWN0ZWQgZHVlIHRvXG4gIC8vIG1pc21hdGNoZWQgaGFzaC5cbiAgUlVOLFxuXG4gIC8vIFdlJ3ZlIHJ1biB0aGUgdHJhbnNhY3Rpb24gYW5kIHNlbnQgaXQgdG8gdGhlIHNlcnZlciBhbmQgaXQncyBjdXJyZW50bHkgb3V0c3RhbmRpbmcgKGhhc24ndCBjb21lIGJhY2sgYXMgYWNjZXB0ZWRcbiAgLy8gb3IgcmVqZWN0ZWQgeWV0KS5cbiAgU0VOVCxcblxuICAvLyBUZW1wb3Jhcnkgc3RhdGUgdXNlZCB0byBtYXJrIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgKHdoZXRoZXIgc3VjY2Vzc2Z1bCBvciBhYm9ydGVkKS4gIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlXG4gIC8vIHJlbW92ZWQgd2hlbiB3ZSBnZXQgYSBjaGFuY2UgdG8gcHJ1bmUgY29tcGxldGVkIG9uZXMuXG4gIENPTVBMRVRFRCxcblxuICAvLyBVc2VkIHdoZW4gYW4gYWxyZWFkeS1zZW50IHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGFib3J0ZWQgKGUuZy4gZHVlIHRvIGEgY29uZmxpY3Rpbmcgc2V0KCkgY2FsbCB0aGF0IHdhcyBtYWRlKS5cbiAgLy8gSWYgaXQgY29tZXMgYmFjayBhcyB1bnN1Y2Nlc3NmdWwsIHdlJ2xsIGFib3J0IGl0LlxuICBTRU5UX05FRURTX0FCT1JULFxuXG4gIC8vIFRlbXBvcmFyeSBzdGF0ZSB1c2VkIHRvIG1hcmsgdHJhbnNhY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBhYm9ydGVkLlxuICBORUVEU19BQk9SVFxufVxuXG4vKipcbiAqIElmIGEgdHJhbnNhY3Rpb24gZG9lcyBub3Qgc3VjY2VlZCBhZnRlciAyNSByZXRyaWVzLCB3ZSBhYm9ydCBpdC4gIEFtb25nIG90aGVyIHRoaW5ncyB0aGlzIGVuc3VyZSB0aGF0IGlmIHRoZXJlJ3NcbiAqIGV2ZXIgYSBidWcgY2F1c2luZyBhIG1pc21hdGNoIGJldHdlZW4gY2xpZW50IC8gc2VydmVyIGhhc2hlcyBmb3Igc29tZSBkYXRhLCB3ZSB3b24ndCByZXRyeSBpbmRlZmluaXRlbHkuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAcHJpdmF0ZVxuICovXG4oUmVwbyBhcyBhbnkpLk1BWF9UUkFOU0FDVElPTl9SRVRSSUVTXyA9IDI1O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHBhdGg6ICFQYXRoLFxuICogICB1cGRhdGU6IGZ1bmN0aW9uKCopOiosXG4gKiAgIG9uQ29tcGxldGU6ID9mdW5jdGlvbig/RXJyb3IsIGJvb2xlYW4sID9EYXRhU25hcHNob3QpLFxuICogICBzdGF0dXM6ID9UcmFuc2FjdGlvblN0YXR1cyxcbiAqICAgb3JkZXI6ICFudW1iZXIsXG4gKiAgIGFwcGx5TG9jYWxseTogYm9vbGVhbixcbiAqICAgcmV0cnlDb3VudDogIW51bWJlcixcbiAqICAgdW53YXRjaGVyOiBmdW5jdGlvbigpLFxuICogICBhYm9ydFJlYXNvbjogP3N0cmluZyxcbiAqICAgY3VycmVudFdyaXRlSWQ6ICFudW1iZXIsXG4gKiAgIGN1cnJlbnRJbnB1dFNuYXBzaG90OiA/Tm9kZSxcbiAqICAgY3VycmVudE91dHB1dFNuYXBzaG90UmF3OiA/Tm9kZSxcbiAqICAgY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQ6ID9Ob2RlXG4gKiB9fVxuICovXG50eXBlIFRyYW5zYWN0aW9uID0ge1xuICBwYXRoOiBQYXRoO1xuICB1cGRhdGU6IChhOiBhbnkpID0+IGFueTtcbiAgb25Db21wbGV0ZTogKGE6IEVycm9yIHwgbnVsbCwgYjogYm9vbGVhbiwgYzogRGF0YVNuYXBzaG90IHwgbnVsbCkgPT4gdm9pZDtcbiAgc3RhdHVzOiBUcmFuc2FjdGlvblN0YXR1cztcbiAgb3JkZXI6IG51bWJlcjtcbiAgYXBwbHlMb2NhbGx5OiBib29sZWFuO1xuICByZXRyeUNvdW50OiBudW1iZXI7XG4gIHVud2F0Y2hlcjogKCkgPT4gdm9pZDtcbiAgYWJvcnRSZWFzb246IHN0cmluZyB8IG51bGw7XG4gIGN1cnJlbnRXcml0ZUlkOiBudW1iZXI7XG4gIGN1cnJlbnRJbnB1dFNuYXBzaG90OiBOb2RlIHwgbnVsbDtcbiAgY3VycmVudE91dHB1dFNuYXBzaG90UmF3OiBOb2RlIHwgbnVsbDtcbiAgY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQ6IE5vZGUgfCBudWxsO1xufTtcblxuLyoqXG4gKiBTZXR1cCB0aGUgdHJhbnNhY3Rpb24gZGF0YSBzdHJ1Y3R1cmVzXG4gKiBAcHJpdmF0ZVxuICovXG4oUmVwby5wcm90b3R5cGUgYXMgYW55KS50cmFuc2FjdGlvbnNfaW5pdF8gPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIFN0b3JlcyBxdWV1ZXMgb2Ygb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb25zIGZvciBGaXJlYmFzZSBsb2NhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHshVHJlZS48QXJyYXkuPCFUcmFuc2FjdGlvbj4+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV8gPSBuZXcgVHJlZTxUcmFuc2FjdGlvbltdPigpO1xufTtcblxuZGVjbGFyZSBtb2R1bGUgJy4vUmVwbycge1xuICBpbnRlcmZhY2UgUmVwbyB7XG4gICAgc3RhcnRUcmFuc2FjdGlvbihcbiAgICAgIHBhdGg6IFBhdGgsXG4gICAgICB0cmFuc2FjdGlvblVwZGF0ZTogKGE6IGFueSkgPT4gdm9pZCxcbiAgICAgIG9uQ29tcGxldGU6ICgoYTogRXJyb3IsIGI6IGJvb2xlYW4sIGM6IERhdGFTbmFwc2hvdCkgPT4gdm9pZCkgfCBudWxsLFxuICAgICAgYXBwbHlMb2NhbGx5OiBib29sZWFuXG4gICAgKTogdm9pZDtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24sIGFkZHMgaXQgdG8gdGhlIHRyYW5zYWN0aW9ucyB3ZSdyZSB0cmFja2luZywgYW5kIHNlbmRzIGl0IHRvIHRoZSBzZXJ2ZXIgaWYgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIHshUGF0aH0gcGF0aCBQYXRoIGF0IHdoaWNoIHRvIGRvIHRyYW5zYWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbigqKToqfSB0cmFuc2FjdGlvblVwZGF0ZSBVcGRhdGUgY2FsbGJhY2suXG4gKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsIGJvb2xlYW4sID9EYXRhU25hcHNob3QpfSBvbkNvbXBsZXRlIENvbXBsZXRpb24gY2FsbGJhY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFwcGx5TG9jYWxseSBXaGV0aGVyIG9yIG5vdCB0byBtYWtlIGludGVybWVkaWF0ZSByZXN1bHRzIHZpc2libGVcbiAqL1xuUmVwby5wcm90b3R5cGUuc3RhcnRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKFxuICBwYXRoOiBQYXRoLFxuICB0cmFuc2FjdGlvblVwZGF0ZTogKGE6IGFueSkgPT4gYW55LFxuICBvbkNvbXBsZXRlOiAoKGE6IEVycm9yLCBiOiBib29sZWFuLCBjOiBEYXRhU25hcHNob3QpID0+IHZvaWQpIHwgbnVsbCxcbiAgYXBwbHlMb2NhbGx5OiBib29sZWFuXG4pIHtcbiAgdGhpcy5sb2dfKCd0cmFuc2FjdGlvbiBvbiAnICsgcGF0aCk7XG5cbiAgLy8gQWRkIGEgd2F0Y2ggdG8gbWFrZSBzdXJlIHdlIGdldCBzZXJ2ZXIgdXBkYXRlcy5cbiAgY29uc3QgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uKCkge307XG4gIGNvbnN0IHdhdGNoUmVmID0gbmV3IFJlZmVyZW5jZSh0aGlzLCBwYXRoKTtcbiAgd2F0Y2hSZWYub24oJ3ZhbHVlJywgdmFsdWVDYWxsYmFjayk7XG4gIGNvbnN0IHVud2F0Y2hlciA9IGZ1bmN0aW9uKCkge1xuICAgIHdhdGNoUmVmLm9mZigndmFsdWUnLCB2YWx1ZUNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIHRyYW5zYWN0aW9uLlxuICBjb25zdCB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24gPSB7XG4gICAgcGF0aCxcbiAgICB1cGRhdGU6IHRyYW5zYWN0aW9uVXBkYXRlLFxuICAgIG9uQ29tcGxldGUsXG5cbiAgICAvLyBPbmUgb2YgVHJhbnNhY3Rpb25TdGF0dXMgZW51bXMuXG4gICAgc3RhdHVzOiBudWxsLFxuXG4gICAgLy8gVXNlZCB3aGVuIGNvbWJpbmluZyB0cmFuc2FjdGlvbnMgYXQgZGlmZmVyZW50IGxvY2F0aW9ucyB0byBmaWd1cmUgb3V0IHdoaWNoIG9uZSBnb2VzIGZpcnN0LlxuICAgIG9yZGVyOiBMVUlER2VuZXJhdG9yKCksXG5cbiAgICAvLyBXaGV0aGVyIHRvIHJhaXNlIGxvY2FsIGV2ZW50cyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICBhcHBseUxvY2FsbHk6IGFwcGx5TG9jYWxseSxcblxuICAgIC8vIENvdW50IG9mIGhvdyBtYW55IHRpbWVzIHdlJ3ZlIHJldHJpZWQgdGhlIHRyYW5zYWN0aW9uLlxuICAgIHJldHJ5Q291bnQ6IDAsXG5cbiAgICAvLyBGdW5jdGlvbiB0byBjYWxsIHRvIGNsZWFuIHVwIG91ciAub24oKSBsaXN0ZW5lci5cbiAgICB1bndhdGNoZXIsXG5cbiAgICAvLyBTdG9yZXMgd2h5IGEgdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQuXG4gICAgYWJvcnRSZWFzb246IG51bGwsXG5cbiAgICBjdXJyZW50V3JpdGVJZDogbnVsbCxcblxuICAgIGN1cnJlbnRJbnB1dFNuYXBzaG90OiBudWxsLFxuXG4gICAgY3VycmVudE91dHB1dFNuYXBzaG90UmF3OiBudWxsLFxuXG4gICAgY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQ6IG51bGxcbiAgfTtcblxuICAvLyBSdW4gdHJhbnNhY3Rpb24gaW5pdGlhbGx5LlxuICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmdldExhdGVzdFN0YXRlXyhwYXRoKTtcbiAgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QgPSBjdXJyZW50U3RhdGU7XG4gIGNvbnN0IG5ld1ZhbCA9IHRyYW5zYWN0aW9uLnVwZGF0ZShjdXJyZW50U3RhdGUudmFsKCkpO1xuICBpZiAobmV3VmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBBYm9ydCB0cmFuc2FjdGlvbi5cbiAgICB0cmFuc2FjdGlvbi51bndhdGNoZXIoKTtcbiAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBudWxsO1xuICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbnVsbDtcbiAgICBpZiAodHJhbnNhY3Rpb24ub25Db21wbGV0ZSkge1xuICAgICAgLy8gV2UganVzdCBzZXQgdGhlIGlucHV0IHNuYXBzaG90LCBzbyB0aGlzIGNhc3Qgc2hvdWxkIGJlIHNhZmVcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gbmV3IERhdGFTbmFwc2hvdChcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QsXG4gICAgICAgIG5ldyBSZWZlcmVuY2UodGhpcywgdHJhbnNhY3Rpb24ucGF0aCksXG4gICAgICAgIFBSSU9SSVRZX0lOREVYXG4gICAgICApO1xuICAgICAgdHJhbnNhY3Rpb24ub25Db21wbGV0ZShudWxsLCBmYWxzZSwgc25hcHNob3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YShcbiAgICAgICd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJyxcbiAgICAgIG5ld1ZhbCxcbiAgICAgIHRyYW5zYWN0aW9uLnBhdGhcbiAgICApO1xuXG4gICAgLy8gTWFyayBhcyBydW4gYW5kIGFkZCB0byBvdXIgcXVldWUuXG4gICAgdHJhbnNhY3Rpb24uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuUlVOO1xuICAgIGNvbnN0IHF1ZXVlTm9kZSA9IHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfLnN1YlRyZWUocGF0aCk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlID0gcXVldWVOb2RlLmdldFZhbHVlKCkgfHwgW107XG4gICAgbm9kZVF1ZXVlLnB1c2godHJhbnNhY3Rpb24pO1xuXG4gICAgcXVldWVOb2RlLnNldFZhbHVlKG5vZGVRdWV1ZSk7XG5cbiAgICAvLyBVcGRhdGUgdmlzaWJsZURhdGEgYW5kIHJhaXNlIGV2ZW50c1xuICAgIC8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgcmFpc2UgZXZlbnRzIGFmdGVyIHVwZGF0aW5nIGFsbCBvZiBvdXIgdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSB1c2VyIGNvdWxkXG4gICAgLy8gc3RhcnQgbmV3IHRyYW5zYWN0aW9ucyBmcm9tIHRoZSBldmVudCBjYWxsYmFja3MuXG4gICAgbGV0IHByaW9yaXR5Rm9yTm9kZTtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbmV3VmFsID09PSAnb2JqZWN0JyAmJlxuICAgICAgbmV3VmFsICE9PSBudWxsICYmXG4gICAgICBjb250YWlucyhuZXdWYWwsICcucHJpb3JpdHknKVxuICAgICkge1xuICAgICAgcHJpb3JpdHlGb3JOb2RlID0gc2FmZUdldChuZXdWYWwsICcucHJpb3JpdHknKTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgaXNWYWxpZFByaW9yaXR5KHByaW9yaXR5Rm9yTm9kZSksXG4gICAgICAgICdJbnZhbGlkIHByaW9yaXR5IHJldHVybmVkIGJ5IHRyYW5zYWN0aW9uLiAnICtcbiAgICAgICAgICAnUHJpb3JpdHkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGN1cnJlbnROb2RlID1cbiAgICAgICAgdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uY2FsY0NvbXBsZXRlRXZlbnRDYWNoZShwYXRoKSB8fFxuICAgICAgICBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkudmFsKCk7XG4gICAgfVxuICAgIHByaW9yaXR5Rm9yTm9kZSAvKiogQHR5cGUge251bGx8bnVtYmVyfHN0cmluZ30gKi8gPSBwcmlvcml0eUZvck5vZGU7XG5cbiAgICBjb25zdCBzZXJ2ZXJWYWx1ZXMgPSB0aGlzLmdlbmVyYXRlU2VydmVyVmFsdWVzKCk7XG4gICAgY29uc3QgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT04obmV3VmFsLCBwcmlvcml0eUZvck5vZGUpO1xuICAgIGNvbnN0IG5ld05vZGUgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KFxuICAgICAgbmV3Tm9kZVVucmVzb2x2ZWQsXG4gICAgICBzZXJ2ZXJWYWx1ZXNcbiAgICApO1xuICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld05vZGVVbnJlc29sdmVkO1xuICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZTtcbiAgICB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCA9IHRoaXMuZ2V0TmV4dFdyaXRlSWRfKCk7XG5cbiAgICBjb25zdCBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJPdmVyd3JpdGUoXG4gICAgICBwYXRoLFxuICAgICAgbmV3Tm9kZSxcbiAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLFxuICAgICAgdHJhbnNhY3Rpb24uYXBwbHlMb2NhbGx5XG4gICAgKTtcbiAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocGF0aCwgZXZlbnRzKTtcblxuICAgIHRoaXMuc2VuZFJlYWR5VHJhbnNhY3Rpb25zXygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBleGNsdWRlU2V0cyBBIHNwZWNpZmljIHNldCB0byBleGNsdWRlXG4gKiBAcmV0dXJuIHtOb2RlfVxuICogQHByaXZhdGVcbiAqL1xuKFJlcG8ucHJvdG90eXBlIGFzIGFueSkuZ2V0TGF0ZXN0U3RhdGVfID0gZnVuY3Rpb24oXG4gIHBhdGg6IFBhdGgsXG4gIGV4Y2x1ZGVTZXRzPzogbnVtYmVyW11cbik6IE5vZGUge1xuICByZXR1cm4gKFxuICAgIHRoaXMuc2VydmVyU3luY1RyZWVfLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocGF0aCwgZXhjbHVkZVNldHMpIHx8XG4gICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREVcbiAgKTtcbn07XG5cbi8qKlxuICogU2VuZHMgYW55IGFscmVhZHktcnVuIHRyYW5zYWN0aW9ucyB0aGF0IGFyZW4ndCB3YWl0aW5nIGZvciBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbnMgdG9cbiAqIGNvbXBsZXRlLlxuICpcbiAqIEV4dGVybmFsbHkgaXQncyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIGJ1dCBpdCBjYWxscyBpdHNlbGYgcmVjdXJzaXZlbHkgd2l0aCBhIHBhcnRpY3VsYXJcbiAqIHRyYW5zYWN0aW9uUXVldWVUcmVlIG5vZGUgdG8gcmVjdXJzZSB0aHJvdWdoIHRoZSB0cmVlLlxuICpcbiAqIEBwYXJhbSB7VHJlZS48QXJyYXkuPFRyYW5zYWN0aW9uPj49fSBub2RlICB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHN0YXJ0IGF0LlxuICogQHByaXZhdGVcbiAqL1xuKFJlcG8ucHJvdG90eXBlIGFzIGFueSkuc2VuZFJlYWR5VHJhbnNhY3Rpb25zXyA9IGZ1bmN0aW9uKFxuICBub2RlOiBUcmVlPFRyYW5zYWN0aW9uW10+ID0gdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV9cbikge1xuICAvLyBCZWZvcmUgcmVjdXJzaW5nLCBtYWtlIHN1cmUgYW55IGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgYXJlIHJlbW92ZWQuXG4gIGlmICghbm9kZSkge1xuICAgIHRoaXMucHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGVfKG5vZGUpO1xuICB9XG5cbiAgaWYgKG5vZGUuZ2V0VmFsdWUoKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uUXVldWVfKG5vZGUpO1xuICAgIGFzc2VydChxdWV1ZS5sZW5ndGggPiAwLCAnU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZScpO1xuXG4gICAgY29uc3QgYWxsUnVuID0gcXVldWUuZXZlcnkoXG4gICAgICAodHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlJVTlxuICAgICk7XG5cbiAgICAvLyBJZiB0aGV5J3JlIGFsbCBydW4gKGFuZCBub3Qgc2VudCksIHdlIGNhbiBzZW5kIHRoZW0uICBFbHNlLCB3ZSBtdXN0IHdhaXQuXG4gICAgaWYgKGFsbFJ1bikge1xuICAgICAgdGhpcy5zZW5kVHJhbnNhY3Rpb25RdWV1ZV8obm9kZS5wYXRoKCksIHF1ZXVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgbm9kZS5mb3JFYWNoQ2hpbGQoY2hpbGROb2RlID0+IHtcbiAgICAgIHRoaXMuc2VuZFJlYWR5VHJhbnNhY3Rpb25zXyhjaGlsZE5vZGUpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiBydW4gdHJhbnNhY3Rpb25zLCBzZW5kIHRoZW0gdG8gdGhlIHNlcnZlciBhbmQgdGhlbiBoYW5kbGUgdGhlIHJlc3VsdCAoc3VjY2VzcyBvciBmYWlsdXJlKS5cbiAqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBsb2NhdGlvbiBvZiB0aGUgcXVldWUuXG4gKiBAcGFyYW0geyFBcnJheS48VHJhbnNhY3Rpb24+fSBxdWV1ZSBRdWV1ZSBvZiB0cmFuc2FjdGlvbnMgdW5kZXIgdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbihSZXBvLnByb3RvdHlwZSBhcyBhbnkpLnNlbmRUcmFuc2FjdGlvblF1ZXVlXyA9IGZ1bmN0aW9uKFxuICBwYXRoOiBQYXRoLFxuICBxdWV1ZTogQXJyYXk8VHJhbnNhY3Rpb24+XG4pIHtcbiAgLy8gTWFyayB0cmFuc2FjdGlvbnMgYXMgc2VudCBhbmQgaW5jcmVtZW50IHJldHJ5IGNvdW50IVxuICBjb25zdCBzZXRzVG9JZ25vcmUgPSBxdWV1ZS5tYXAoZnVuY3Rpb24odHhuKSB7XG4gICAgcmV0dXJuIHR4bi5jdXJyZW50V3JpdGVJZDtcbiAgfSk7XG4gIGNvbnN0IGxhdGVzdFN0YXRlID0gdGhpcy5nZXRMYXRlc3RTdGF0ZV8ocGF0aCwgc2V0c1RvSWdub3JlKTtcbiAgbGV0IHNuYXBUb1NlbmQgPSBsYXRlc3RTdGF0ZTtcbiAgY29uc3QgbGF0ZXN0SGFzaCA9IGxhdGVzdFN0YXRlLmhhc2goKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHR4biA9IHF1ZXVlW2ldO1xuICAgIGFzc2VydChcbiAgICAgIHR4bi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlJVTixcbiAgICAgICd0cnlUb1NlbmRUcmFuc2FjdGlvblF1ZXVlXzogaXRlbXMgaW4gcXVldWUgc2hvdWxkIGFsbCBiZSBydW4uJ1xuICAgICk7XG4gICAgdHhuLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLlNFTlQ7XG4gICAgdHhuLnJldHJ5Q291bnQrKztcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBQYXRoLnJlbGF0aXZlUGF0aChwYXRoLCB0eG4ucGF0aCk7XG4gICAgLy8gSWYgd2UndmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIHRoZSBvdXRwdXQgc25hcHNob3QgbXVzdCBiZSBkZWZpbmVkLlxuICAgIHNuYXBUb1NlbmQgPSBzbmFwVG9TZW5kLnVwZGF0ZUNoaWxkKFxuICAgICAgcmVsYXRpdmVQYXRoIC8qKkB0eXBlIHshTm9kZX0gKi8sXG4gICAgICB0eG4uY3VycmVudE91dHB1dFNuYXBzaG90UmF3XG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGFUb1NlbmQgPSBzbmFwVG9TZW5kLnZhbCh0cnVlKTtcbiAgY29uc3QgcGF0aFRvU2VuZCA9IHBhdGg7XG5cbiAgLy8gU2VuZCB0aGUgcHV0LlxuICB0aGlzLnNlcnZlcl8ucHV0KFxuICAgIHBhdGhUb1NlbmQudG9TdHJpbmcoKSxcbiAgICBkYXRhVG9TZW5kLFxuICAgIChzdGF0dXM6IHN0cmluZykgPT4ge1xuICAgICAgdGhpcy5sb2dfKCd0cmFuc2FjdGlvbiBwdXQgcmVzcG9uc2UnLCB7XG4gICAgICAgIHBhdGg6IHBhdGhUb1NlbmQudG9TdHJpbmcoKSxcbiAgICAgICAgc3RhdHVzXG4gICAgICB9KTtcblxuICAgICAgbGV0IGV2ZW50czogRXZlbnRbXSA9IFtdO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91ciB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2VcbiAgICAgICAgLy8gdGhlIGNhbGxiYWNrIGNvdWxkIHRyaWdnZXIgbW9yZSB0cmFuc2FjdGlvbnMgb3Igc2V0cy5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURUQ7XG4gICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChcbiAgICAgICAgICAgIHRoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZShxdWV1ZVtpXS5jdXJyZW50V3JpdGVJZClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAvLyBXZSBuZXZlciB1bnNldCB0aGUgb3V0cHV0IHNuYXBzaG90LCBhbmQgZ2l2ZW4gdGhhdCB0aGlzIHRyYW5zYWN0aW9uIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgYmUgc2V0XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcXVldWVbaV0uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgYXMgTm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IG5ldyBSZWZlcmVuY2UodGhpcywgcXVldWVbaV0ucGF0aCk7XG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IG5ldyBEYXRhU25hcHNob3Qobm9kZSwgcmVmLCBQUklPUklUWV9JTkRFWCk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChcbiAgICAgICAgICAgICAgcXVldWVbaV0ub25Db21wbGV0ZS5iaW5kKG51bGwsIG51bGwsIHRydWUsIHNuYXBzaG90KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVldWVbaV0udW53YXRjaGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgcmVtb3ZlIHRoZSBjb21wbGV0ZWQgdHJhbnNhY3Rpb25zLlxuICAgICAgICB0aGlzLnBydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlXyhcbiAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXy5zdWJUcmVlKHBhdGgpXG4gICAgICAgICk7XG4gICAgICAgIC8vIFRoZXJlIG1heSBiZSBwZW5kaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHdlIGNhbiBub3cgc2VuZC5cbiAgICAgICAgdGhpcy5zZW5kUmVhZHlUcmFuc2FjdGlvbnNfKCk7XG5cbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGV2ZW50cyk7XG5cbiAgICAgICAgLy8gRmluYWxseSwgdHJpZ2dlciBvbkNvbXBsZXRlIGNhbGxiYWNrcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBleGNlcHRpb25HdWFyZChjYWxsYmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0cmFuc2FjdGlvbnMgYXJlIG5vIGxvbmdlciBzZW50LiAgVXBkYXRlIHRoZWlyIHN0YXR1cyBhcHByb3ByaWF0ZWx5LlxuICAgICAgICBpZiAoc3RhdHVzID09PSAnZGF0YXN0YWxlJykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQpXG4gICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLk5FRURTX0FCT1JUO1xuICAgICAgICAgICAgZWxzZSBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5SVU47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAndHJhbnNhY3Rpb24gYXQgJyArIHBhdGhUb1NlbmQudG9TdHJpbmcoKSArICcgZmFpbGVkOiAnICsgc3RhdHVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVDtcbiAgICAgICAgICAgIHF1ZXVlW2ldLmFib3J0UmVhc29uID0gc3RhdHVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVydW5UcmFuc2FjdGlvbnNfKHBhdGgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGF0ZXN0SGFzaFxuICApO1xufTtcblxuLyoqXG4gKiBGaW5kcyBhbGwgdHJhbnNhY3Rpb25zIGRlcGVuZGVudCBvbiB0aGUgZGF0YSBhdCBjaGFuZ2VkUGF0aCBhbmQgcmVydW5zIHRoZW0uXG4gKlxuICogU2hvdWxkIGJlIGNhbGxlZCBhbnkgdGltZSBjYWNoZWQgZGF0YSBjaGFuZ2VzLlxuICpcbiAqIFJldHVybiB0aGUgaGlnaGVzdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuICBUaGlzIGlzIHRoZSBwYXRoIGF0IHdoaWNoIGV2ZW50cyBuZWVkIHRvXG4gKiBiZSByYWlzZWQgZm9yLlxuICpcbiAqIEBwYXJhbSB7IVBhdGh9IGNoYW5nZWRQYXRoIFRoZSBwYXRoIGluIG1lcmdlZERhdGEgdGhhdCBjaGFuZ2VkLlxuICogQHJldHVybiB7IVBhdGh9IFRoZSByb290bW9zdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG4oUmVwby5wcm90b3R5cGUgYXMgYW55KS5yZXJ1blRyYW5zYWN0aW9uc18gPSBmdW5jdGlvbihjaGFuZ2VkUGF0aDogUGF0aCk6IFBhdGgge1xuICBjb25zdCByb290TW9zdFRyYW5zYWN0aW9uTm9kZSA9IHRoaXMuZ2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGVfKGNoYW5nZWRQYXRoKTtcbiAgY29uc3QgcGF0aCA9IHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlLnBhdGgoKTtcblxuICBjb25zdCBxdWV1ZSA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvblF1ZXVlXyhyb290TW9zdFRyYW5zYWN0aW9uTm9kZSk7XG4gIHRoaXMucmVydW5UcmFuc2FjdGlvblF1ZXVlXyhxdWV1ZSwgcGF0aCk7XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIERvZXMgYWxsIHRoZSB3b3JrIG9mIHJlcnVubmluZyB0cmFuc2FjdGlvbnMgKGFzIHdlbGwgYXMgY2xlYW5zIHVwIGFib3J0ZWQgdHJhbnNhY3Rpb25zIGFuZCB3aGF0bm90KS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxUcmFuc2FjdGlvbj59IHF1ZXVlIFRoZSBxdWV1ZSBvZiB0cmFuc2FjdGlvbnMgdG8gcnVuLlxuICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0aGUgcXVldWUgaXMgZm9yLlxuICogQHByaXZhdGVcbiAqL1xuKFJlcG8ucHJvdG90eXBlIGFzIGFueSkucmVydW5UcmFuc2FjdGlvblF1ZXVlXyA9IGZ1bmN0aW9uKFxuICBxdWV1ZTogQXJyYXk8VHJhbnNhY3Rpb24+LFxuICBwYXRoOiBQYXRoXG4pIHtcbiAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkbyFcbiAgfVxuXG4gIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZVxuICAvLyB0aGUgY2FsbGJhY2sgY291bGQgdHJpZ2dlciBtb3JlIHRyYW5zYWN0aW9ucyBvciBzZXRzLlxuICBjb25zdCBjYWxsYmFja3MgPSBbXTtcbiAgbGV0IGV2ZW50czogRXZlbnRbXSA9IFtdO1xuICAvLyBJZ25vcmUgYWxsIG9mIHRoZSBzZXRzIHdlJ3JlIGdvaW5nIHRvIHJlLXJ1bi5cbiAgY29uc3QgdHhuc1RvUmVydW4gPSBxdWV1ZS5maWx0ZXIoZnVuY3Rpb24ocSkge1xuICAgIHJldHVybiBxLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUlVOO1xuICB9KTtcbiAgY29uc3Qgc2V0c1RvSWdub3JlID0gdHhuc1RvUmVydW4ubWFwKGZ1bmN0aW9uKHEpIHtcbiAgICByZXR1cm4gcS5jdXJyZW50V3JpdGVJZDtcbiAgfSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHF1ZXVlW2ldO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IFBhdGgucmVsYXRpdmVQYXRoKHBhdGgsIHRyYW5zYWN0aW9uLnBhdGgpO1xuICAgIGxldCBhYm9ydFRyYW5zYWN0aW9uID0gZmFsc2UsXG4gICAgICBhYm9ydFJlYXNvbjtcbiAgICBhc3NlcnQoXG4gICAgICByZWxhdGl2ZVBhdGggIT09IG51bGwsXG4gICAgICAncmVydW5UcmFuc2FjdGlvbnNVbmRlck5vZGVfOiByZWxhdGl2ZVBhdGggc2hvdWxkIG5vdCBiZSBudWxsLidcbiAgICApO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuTkVFRFNfQUJPUlQpIHtcbiAgICAgIGFib3J0VHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgYWJvcnRSZWFzb24gPSB0cmFuc2FjdGlvbi5hYm9ydFJlYXNvbjtcbiAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoXG4gICAgICAgIHRoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZSh0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlJVTikge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJldHJ5Q291bnQgPj0gKFJlcG8gYXMgYW55KS5NQVhfVFJBTlNBQ1RJT05fUkVUUklFU18pIHtcbiAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgIGFib3J0UmVhc29uID0gJ21heHJldHJ5JztcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChcbiAgICAgICAgICB0aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUodHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGNvZGUgcmVydW5zIGEgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSB0aGlzLmdldExhdGVzdFN0YXRlXyhcbiAgICAgICAgICB0cmFuc2FjdGlvbi5wYXRoLFxuICAgICAgICAgIHNldHNUb0lnbm9yZVxuICAgICAgICApO1xuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnROb2RlO1xuICAgICAgICBjb25zdCBuZXdEYXRhID0gcXVldWVbaV0udXBkYXRlKGN1cnJlbnROb2RlLnZhbCgpKTtcbiAgICAgICAgaWYgKG5ld0RhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKFxuICAgICAgICAgICAgJ3RyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCAnLFxuICAgICAgICAgICAgbmV3RGF0YSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnBhdGhcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBuZXdEYXRhTm9kZSA9IG5vZGVGcm9tSlNPTihuZXdEYXRhKTtcbiAgICAgICAgICBjb25zdCBoYXNFeHBsaWNpdFByaW9yaXR5ID1cbiAgICAgICAgICAgIHR5cGVvZiBuZXdEYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgbmV3RGF0YSAhPSBudWxsICYmXG4gICAgICAgICAgICBjb250YWlucyhuZXdEYXRhLCAnLnByaW9yaXR5Jyk7XG4gICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdFByaW9yaXR5KSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRoZSBvbGQgcHJpb3JpdHkgaWYgdGhlcmUgd2Fzbid0IGEgcHJpb3JpdHkgZXhwbGljaXRseSBzcGVjaWZpZWQuXG4gICAgICAgICAgICBuZXdEYXRhTm9kZSA9IG5ld0RhdGFOb2RlLnVwZGF0ZVByaW9yaXR5KGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG9sZFdyaXRlSWQgPSB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZDtcbiAgICAgICAgICBjb25zdCBzZXJ2ZXJWYWx1ZXMgPSB0aGlzLmdlbmVyYXRlU2VydmVyVmFsdWVzKCk7XG4gICAgICAgICAgY29uc3QgbmV3Tm9kZVJlc29sdmVkID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChcbiAgICAgICAgICAgIG5ld0RhdGFOb2RlLFxuICAgICAgICAgICAgc2VydmVyVmFsdWVzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld0RhdGFOb2RlO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZVJlc29sdmVkO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkID0gdGhpcy5nZXROZXh0V3JpdGVJZF8oKTtcbiAgICAgICAgICAvLyBNdXRhdGVzIHNldHNUb0lnbm9yZSBpbiBwbGFjZVxuICAgICAgICAgIHNldHNUb0lnbm9yZS5zcGxpY2Uoc2V0c1RvSWdub3JlLmluZGV4T2Yob2xkV3JpdGVJZCksIDEpO1xuICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoXG4gICAgICAgICAgICB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJPdmVyd3JpdGUoXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnBhdGgsXG4gICAgICAgICAgICAgIG5ld05vZGVSZXNvbHZlZCxcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFwcGx5TG9jYWxseVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChcbiAgICAgICAgICAgIHRoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZShvbGRXcml0ZUlkLCB0cnVlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgYWJvcnRSZWFzb24gPSAnbm9kYXRhJztcbiAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KFxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWNrVXNlcldyaXRlKHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGV2ZW50cyk7XG4gICAgZXZlbnRzID0gW107XG4gICAgaWYgKGFib3J0VHJhbnNhY3Rpb24pIHtcbiAgICAgIC8vIEFib3J0LlxuICAgICAgcXVldWVbaV0uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEO1xuXG4gICAgICAvLyBSZW1vdmluZyBhIGxpc3RlbmVyIGNhbiB0cmlnZ2VyIHBydW5pbmcgd2hpY2ggY2FuIG11Y2sgd2l0aCBtZXJnZWREYXRhL3Zpc2libGVEYXRhIChhcyBpdCBwcnVuZXMgZGF0YSkuXG4gICAgICAvLyBTbyBkZWZlciB0aGUgdW53YXRjaGVyIHVudGlsIHdlJ3JlIGRvbmUuXG4gICAgICAoZnVuY3Rpb24odW53YXRjaGVyKSB7XG4gICAgICAgIHNldFRpbWVvdXQodW53YXRjaGVyLCBNYXRoLmZsb29yKDApKTtcbiAgICAgIH0pKHF1ZXVlW2ldLnVud2F0Y2hlcik7XG5cbiAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XG4gICAgICAgIGlmIChhYm9ydFJlYXNvbiA9PT0gJ25vZGF0YScpIHtcbiAgICAgICAgICBjb25zdCByZWYgPSBuZXcgUmVmZXJlbmNlKHRoaXMsIHF1ZXVlW2ldLnBhdGgpO1xuICAgICAgICAgIC8vIFdlIHNldCB0aGlzIGZpZWxkIGltbWVkaWF0ZWx5LCBzbyBpdCdzIHNhZmUgdG8gY2FzdCB0byBhbiBhY3R1YWwgc25hcHNob3RcbiAgICAgICAgICBjb25zdCBsYXN0SW5wdXQgLyoqIEB0eXBlIHshTm9kZX0gKi8gPSBxdWV1ZVtpXS5jdXJyZW50SW5wdXRTbmFwc2hvdDtcbiAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IG5ldyBEYXRhU25hcHNob3QobGFzdElucHV0LCByZWYsIFBSSU9SSVRZX0lOREVYKTtcbiAgICAgICAgICBjYWxsYmFja3MucHVzaChxdWV1ZVtpXS5vbkNvbXBsZXRlLmJpbmQobnVsbCwgbnVsbCwgZmFsc2UsIHNuYXBzaG90KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2tzLnB1c2goXG4gICAgICAgICAgICBxdWV1ZVtpXS5vbkNvbXBsZXRlLmJpbmQobnVsbCwgbmV3IEVycm9yKGFib3J0UmVhc29uKSwgZmFsc2UsIG51bGwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMuXG4gIHRoaXMucHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGVfKHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcblxuICAvLyBOb3cgZmlyZSBjYWxsYmFja3MsIG5vdyB0aGF0IHdlJ3JlIGluIGEgZ29vZCwga25vd24gc3RhdGUuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcbiAgfVxuXG4gIC8vIFRyeSB0byBzZW5kIHRoZSB0cmFuc2FjdGlvbiByZXN1bHQgdG8gdGhlIHNlcnZlci5cbiAgdGhpcy5zZW5kUmVhZHlUcmFuc2FjdGlvbnNfKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJvb3Rtb3N0IGFuY2VzdG9yIG5vZGUgb2YgdGhlIHNwZWNpZmllZCBwYXRoIHRoYXQgaGFzIGEgcGVuZGluZyB0cmFuc2FjdGlvbiBvbiBpdCwgb3IganVzdCByZXR1cm5zXG4gKiB0aGUgbm9kZSBmb3IgdGhlIGdpdmVuIHBhdGggaWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9uIGFueSBhbmNlc3Rvci5cbiAqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBsb2NhdGlvbiB0byBzdGFydCBhdC5cbiAqIEByZXR1cm4geyFUcmVlLjxBcnJheS48IVRyYW5zYWN0aW9uPj59IFRoZSByb290bW9zdCBub2RlIHdpdGggYSB0cmFuc2FjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbihSZXBvLnByb3RvdHlwZSBhcyBhbnkpLmdldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlXyA9IGZ1bmN0aW9uKFxuICBwYXRoOiBQYXRoXG4pOiBUcmVlPFRyYW5zYWN0aW9uW10+IHtcbiAgbGV0IGZyb250O1xuXG4gIC8vIFN0YXJ0IGF0IHRoZSByb290IGFuZCB3YWxrIGRlZXBlciBpbnRvIHRoZSB0cmVlIHRvd2FyZHMgcGF0aCB1bnRpbCB3ZSBmaW5kIGEgbm9kZSB3aXRoIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICBsZXQgdHJhbnNhY3Rpb25Ob2RlID0gdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV87XG4gIHdoaWxlIChcbiAgICAoZnJvbnQgPSBwYXRoLmdldEZyb250KCkpICE9PSBudWxsICYmXG4gICAgdHJhbnNhY3Rpb25Ob2RlLmdldFZhbHVlKCkgPT09IG51bGxcbiAgKSB7XG4gICAgdHJhbnNhY3Rpb25Ob2RlID0gdHJhbnNhY3Rpb25Ob2RlLnN1YlRyZWUoZnJvbnQpO1xuICAgIHBhdGggPSBwYXRoLnBvcEZyb250KCk7XG4gIH1cblxuICByZXR1cm4gdHJhbnNhY3Rpb25Ob2RlO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgdGhlIHF1ZXVlIG9mIGFsbCB0cmFuc2FjdGlvbnMgYXQgb3IgYmVsb3cgdGhlIHNwZWNpZmllZCB0cmFuc2FjdGlvbk5vZGUuXG4gKlxuICogQHBhcmFtIHshVHJlZS48QXJyYXkuPFRyYW5zYWN0aW9uPj59IHRyYW5zYWN0aW9uTm9kZVxuICogQHJldHVybiB7QXJyYXkuPFRyYW5zYWN0aW9uPn0gVGhlIGdlbmVyYXRlZCBxdWV1ZS5cbiAqIEBwcml2YXRlXG4gKi9cbihSZXBvLnByb3RvdHlwZSBhcyBhbnkpLmJ1aWxkVHJhbnNhY3Rpb25RdWV1ZV8gPSBmdW5jdGlvbihcbiAgdHJhbnNhY3Rpb25Ob2RlOiBUcmVlPFRyYW5zYWN0aW9uW10+XG4pOiBBcnJheTxUcmFuc2FjdGlvbj4ge1xuICAvLyBXYWxrIGFueSBjaGlsZCB0cmFuc2FjdGlvbiBxdWV1ZXMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYSBzaW5nbGUgcXVldWUuXG4gIGNvbnN0IHRyYW5zYWN0aW9uUXVldWU6IFRyYW5zYWN0aW9uW10gPSBbXTtcbiAgdGhpcy5hZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGVfKHRyYW5zYWN0aW9uTm9kZSwgdHJhbnNhY3Rpb25RdWV1ZSk7XG5cbiAgLy8gU29ydCB0aGVtIGJ5IHRoZSBvcmRlciB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgY3JlYXRlZC5cbiAgdHJhbnNhY3Rpb25RdWV1ZS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc2FjdGlvblF1ZXVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFUcmVlLjxBcnJheS48VHJhbnNhY3Rpb24+Pn0gbm9kZVxuICogQHBhcmFtIHtBcnJheS48VHJhbnNhY3Rpb24+fSBxdWV1ZVxuICogQHByaXZhdGVcbiAqL1xuKFJlcG8ucHJvdG90eXBlIGFzIGFueSkuYWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlXyA9IGZ1bmN0aW9uKFxuICBub2RlOiBUcmVlPFRyYW5zYWN0aW9uW10+LFxuICBxdWV1ZTogQXJyYXk8VHJhbnNhY3Rpb24+XG4pIHtcbiAgY29uc3Qgbm9kZVF1ZXVlID0gbm9kZS5nZXRWYWx1ZSgpO1xuICBpZiAobm9kZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHF1ZXVlLnB1c2gobm9kZVF1ZXVlW2ldKTtcbiAgICB9XG4gIH1cblxuICBub2RlLmZvckVhY2hDaGlsZChjaGlsZCA9PiB7XG4gICAgdGhpcy5hZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGVfKGNoaWxkLCBxdWV1ZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgQ09NUExFVEVEIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGlzIG5vZGUgaW4gdGhlIHRyYW5zYWN0aW9uUXVldWVUcmVlXy5cbiAqXG4gKiBAcGFyYW0geyFUcmVlLjxBcnJheS48IVRyYW5zYWN0aW9uPj59IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbihSZXBvLnByb3RvdHlwZSBhcyBhbnkpLnBydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlXyA9IGZ1bmN0aW9uKFxuICBub2RlOiBUcmVlPFRyYW5zYWN0aW9uW10+XG4pIHtcbiAgY29uc3QgcXVldWUgPSBub2RlLmdldFZhbHVlKCk7XG4gIGlmIChxdWV1ZSkge1xuICAgIGxldCB0byA9IDA7XG4gICAgZm9yIChsZXQgZnJvbSA9IDA7IGZyb20gPCBxdWV1ZS5sZW5ndGg7IGZyb20rKykge1xuICAgICAgaWYgKHF1ZXVlW2Zyb21dLnN0YXR1cyAhPT0gVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEKSB7XG4gICAgICAgIHF1ZXVlW3RvXSA9IHF1ZXVlW2Zyb21dO1xuICAgICAgICB0bysrO1xuICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSB0bztcbiAgICBub2RlLnNldFZhbHVlKHF1ZXVlLmxlbmd0aCA+IDAgPyBxdWV1ZSA6IG51bGwpO1xuICB9XG5cbiAgbm9kZS5mb3JFYWNoQ2hpbGQoY2hpbGROb2RlID0+IHtcbiAgICB0aGlzLnBydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlXyhjaGlsZE5vZGUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQWJvcnRzIGFsbCB0cmFuc2FjdGlvbnMgb24gYW5jZXN0b3JzIG9yIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWQgcGF0aC4gIENhbGxlZCB3aGVuIGRvaW5nIGEgc2V0KCkgb3IgdXBkYXRlKClcbiAqIHNpbmNlIHdlIGNvbnNpZGVyIHRoZW0gaW5jb21wYXRpYmxlIHdpdGggdHJhbnNhY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGggUGF0aCBmb3Igd2hpY2ggd2Ugd2FudCB0byBhYm9ydCByZWxhdGVkIHRyYW5zYWN0aW9ucy5cbiAqIEByZXR1cm4geyFQYXRofVxuICogQHByaXZhdGVcbiAqL1xuKFJlcG8ucHJvdG90eXBlIGFzIGFueSkuYWJvcnRUcmFuc2FjdGlvbnNfID0gZnVuY3Rpb24ocGF0aDogUGF0aCk6IFBhdGgge1xuICBjb25zdCBhZmZlY3RlZFBhdGggPSB0aGlzLmdldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlXyhwYXRoKS5wYXRoKCk7XG5cbiAgY29uc3QgdHJhbnNhY3Rpb25Ob2RlID0gdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV8uc3ViVHJlZShwYXRoKTtcblxuICB0cmFuc2FjdGlvbk5vZGUuZm9yRWFjaEFuY2VzdG9yKChub2RlOiBUcmVlPFRyYW5zYWN0aW9uW10+KSA9PiB7XG4gICAgdGhpcy5hYm9ydFRyYW5zYWN0aW9uc09uTm9kZV8obm9kZSk7XG4gIH0pO1xuXG4gIHRoaXMuYWJvcnRUcmFuc2FjdGlvbnNPbk5vZGVfKHRyYW5zYWN0aW9uTm9kZSk7XG5cbiAgdHJhbnNhY3Rpb25Ob2RlLmZvckVhY2hEZXNjZW5kYW50KChub2RlOiBUcmVlPFRyYW5zYWN0aW9uW10+KSA9PiB7XG4gICAgdGhpcy5hYm9ydFRyYW5zYWN0aW9uc09uTm9kZV8obm9kZSk7XG4gIH0pO1xuXG4gIHJldHVybiBhZmZlY3RlZFBhdGg7XG59O1xuXG4vKipcbiAqIEFib3J0IHRyYW5zYWN0aW9ucyBzdG9yZWQgaW4gdGhpcyB0cmFuc2FjdGlvbiBxdWV1ZSBub2RlLlxuICpcbiAqIEBwYXJhbSB7IVRyZWUuPEFycmF5LjxUcmFuc2FjdGlvbj4+fSBub2RlIE5vZGUgdG8gYWJvcnQgdHJhbnNhY3Rpb25zIGZvci5cbiAqIEBwcml2YXRlXG4gKi9cbihSZXBvLnByb3RvdHlwZSBhcyBhbnkpLmFib3J0VHJhbnNhY3Rpb25zT25Ob2RlXyA9IGZ1bmN0aW9uKFxuICBub2RlOiBUcmVlPFRyYW5zYWN0aW9uW10+XG4pIHtcbiAgY29uc3QgcXVldWUgPSBub2RlLmdldFZhbHVlKCk7XG4gIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZVxuICAgIC8vIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zIG9yIHNldHMuXG4gICAgY29uc3QgY2FsbGJhY2tzID0gW107XG5cbiAgICAvLyBHbyB0aHJvdWdoIHF1ZXVlLiAgQW55IGFscmVhZHktc2VudCB0cmFuc2FjdGlvbnMgbXVzdCBiZSBtYXJrZWQgZm9yIGFib3J0LCB3aGlsZSB0aGUgdW5zZW50IG9uZXNcbiAgICAvLyBjYW4gYmUgaW1tZWRpYXRlbHkgYWJvcnRlZCBhbmQgcmVtb3ZlZC5cbiAgICBsZXQgZXZlbnRzOiBFdmVudFtdID0gW107XG4gICAgbGV0IGxhc3RTZW50ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVCkge1xuICAgICAgICAvLyBBbHJlYWR5IG1hcmtlZC4gIE5vIGFjdGlvbiBuZWVkZWQuXG4gICAgICB9IGVsc2UgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVCkge1xuICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgbGFzdFNlbnQgPT09IGkgLSAxLFxuICAgICAgICAgICdBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLidcbiAgICAgICAgKTtcbiAgICAgICAgbGFzdFNlbnQgPSBpO1xuICAgICAgICAvLyBNYXJrIHRyYW5zYWN0aW9uIGZvciBhYm9ydCB3aGVuIGl0IGNvbWVzIGJhY2suXG4gICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQ7XG4gICAgICAgIHF1ZXVlW2ldLmFib3J0UmVhc29uID0gJ3NldCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgcXVldWVbaV0uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5SVU4sXG4gICAgICAgICAgJ1VuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0J1xuICAgICAgICApO1xuICAgICAgICAvLyBXZSBjYW4gYWJvcnQgaXQgaW1tZWRpYXRlbHkuXG4gICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KFxuICAgICAgICAgIHRoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZShxdWV1ZVtpXS5jdXJyZW50V3JpdGVJZCwgdHJ1ZSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHF1ZXVlW2ldLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICBjb25zdCBzbmFwc2hvdDogRGF0YVNuYXBzaG90IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgY2FsbGJhY2tzLnB1c2goXG4gICAgICAgICAgICBxdWV1ZVtpXS5vbkNvbXBsZXRlLmJpbmQobnVsbCwgbmV3IEVycm9yKCdzZXQnKSwgZmFsc2UsIHNuYXBzaG90KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RTZW50ID09PSAtMSkge1xuICAgICAgLy8gV2UncmUgbm90IHdhaXRpbmcgZm9yIGFueSBzZW50IHRyYW5zYWN0aW9ucy4gIFdlIGNhbiBjbGVhciB0aGUgcXVldWUuXG4gICAgICBub2RlLnNldFZhbHVlKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHRyYW5zYWN0aW9ucyB3ZSBhYm9ydGVkLlxuICAgICAgcXVldWUubGVuZ3RoID0gbGFzdFNlbnQgKyAxO1xuICAgIH1cblxuICAgIC8vIE5vdyBmaXJlIHRoZSBjYWxsYmFja3MuXG4gICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKG5vZGUucGF0aCgpLCBldmVudHMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleGNlcHRpb25HdWFyZChjYWxsYmFja3NbaV0pO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaXJlYmFzZUFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAtdHlwZXMnO1xuaW1wb3J0IHsgc2FmZUdldCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFJlcG8gfSBmcm9tICcuL1JlcG8nO1xuaW1wb3J0IHsgZmF0YWwgfSBmcm9tICcuL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBwYXJzZVJlcG9JbmZvIH0gZnJvbSAnLi91dGlsL2xpYnMvcGFyc2VyJztcbmltcG9ydCB7IHZhbGlkYXRlVXJsIH0gZnJvbSAnLi91dGlsL3ZhbGlkYXRpb24nO1xuaW1wb3J0ICcuL1JlcG9fdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tICcuLi9hcGkvRGF0YWJhc2UnO1xuaW1wb3J0IHsgUmVwb0luZm8gfSBmcm9tICcuL1JlcG9JbmZvJztcblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgREFUQUJBU0VfVVJMX09QVElPTiA9ICdkYXRhYmFzZVVSTCc7XG5cbmxldCBfc3RhdGljSW5zdGFuY2U6IFJlcG9NYW5hZ2VyO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGNhY2hlcyBSZXBvIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlcG9NYW5hZ2VyIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlIHshT2JqZWN0LjxzdHJpbmcsIE9iamVjdDxzdHJpbmcsICFmYi5jb3JlLlJlcG8+Pn1cbiAgICovXG4gIHByaXZhdGUgcmVwb3NfOiB7XG4gICAgW2FwcE5hbWU6IHN0cmluZ106IHtcbiAgICAgIFtkYlVybDogc3RyaW5nXTogUmVwbztcbiAgICB9O1xuICB9ID0ge307XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIG5ldyBSZXBvcyB3aWxsIGJlIGNyZWF0ZWQgdG8gdXNlIFJlYWRvbmx5UmVzdENsaWVudCAoZm9yIHRlc3RpbmcgcHVycG9zZXMpLlxuICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICovXG4gIHByaXZhdGUgdXNlUmVzdENsaWVudF86IGJvb2xlYW4gPSBmYWxzZTtcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogUmVwb01hbmFnZXIge1xuICAgIGlmICghX3N0YXRpY0luc3RhbmNlKSB7XG4gICAgICBfc3RhdGljSW5zdGFuY2UgPSBuZXcgUmVwb01hbmFnZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9zdGF0aWNJbnN0YW5jZTtcbiAgfVxuXG4gIC8vIFRPRE8oa29zcyk6IFJlbW92ZSB0aGVzZSBmdW5jdGlvbnMgdW5sZXNzIHVzZWQgaW4gdGVzdHM/XG4gIGludGVycnVwdCgpIHtcbiAgICBmb3IgKGNvbnN0IGFwcE5hbWUgaW4gdGhpcy5yZXBvc18pIHtcbiAgICAgIGZvciAoY29uc3QgZGJVcmwgaW4gdGhpcy5yZXBvc19bYXBwTmFtZV0pIHtcbiAgICAgICAgdGhpcy5yZXBvc19bYXBwTmFtZV1bZGJVcmxdLmludGVycnVwdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlc3VtZSgpIHtcbiAgICBmb3IgKGNvbnN0IGFwcE5hbWUgaW4gdGhpcy5yZXBvc18pIHtcbiAgICAgIGZvciAoY29uc3QgZGJVcmwgaW4gdGhpcy5yZXBvc19bYXBwTmFtZV0pIHtcbiAgICAgICAgdGhpcy5yZXBvc19bYXBwTmFtZV1bZGJVcmxdLnJlc3VtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGV2ZXIgYmUgY2FsbGVkIHRvIENSRUFURSBhIG5ldyBkYXRhYmFzZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHshRmlyZWJhc2VBcHB9IGFwcFxuICAgKiBAcmV0dXJuIHshRGF0YWJhc2V9XG4gICAqL1xuICBkYXRhYmFzZUZyb21BcHAoYXBwOiBGaXJlYmFzZUFwcCwgdXJsPzogc3RyaW5nKTogRGF0YWJhc2Uge1xuICAgIGNvbnN0IGRiVXJsOiBzdHJpbmcgPSB1cmwgfHwgYXBwLm9wdGlvbnNbREFUQUJBU0VfVVJMX09QVElPTl07XG4gICAgaWYgKGRiVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZhdGFsKFxuICAgICAgICBcIkNhbid0IGRldGVybWluZSBGaXJlYmFzZSBEYXRhYmFzZSBVUkwuICBCZSBzdXJlIHRvIGluY2x1ZGUgXCIgK1xuICAgICAgICAgIERBVEFCQVNFX1VSTF9PUFRJT04gK1xuICAgICAgICAgICcgb3B0aW9uIHdoZW4gY2FsbGluZyBmaXJlYmFzZS5pbml0aWFsaXplQXBwKCkuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRVcmwgPSBwYXJzZVJlcG9JbmZvKGRiVXJsKTtcbiAgICBjb25zdCByZXBvSW5mbyA9IHBhcnNlZFVybC5yZXBvSW5mbztcblxuICAgIHZhbGlkYXRlVXJsKCdJbnZhbGlkIEZpcmViYXNlIERhdGFiYXNlIFVSTCcsIDEsIHBhcnNlZFVybCk7XG4gICAgaWYgKCFwYXJzZWRVcmwucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIGZhdGFsKFxuICAgICAgICAnRGF0YWJhc2UgVVJMIG11c3QgcG9pbnQgdG8gdGhlIHJvb3Qgb2YgYSBGaXJlYmFzZSBEYXRhYmFzZSAnICtcbiAgICAgICAgICAnKG5vdCBpbmNsdWRpbmcgYSBjaGlsZCBwYXRoKS4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcG8gPSB0aGlzLmNyZWF0ZVJlcG8ocmVwb0luZm8sIGFwcCk7XG5cbiAgICByZXR1cm4gcmVwby5kYXRhYmFzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHJlcG8gYW5kIG1ha2Ugc3VyZSBpdCBpcyBkaXNjb25uZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IVJlcG99IHJlcG9cbiAgICovXG4gIGRlbGV0ZVJlcG8ocmVwbzogUmVwbykge1xuICAgIGNvbnN0IGFwcFJlcG9zID0gc2FmZUdldCh0aGlzLnJlcG9zXywgcmVwby5hcHAubmFtZSk7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLi4uXG4gICAgaWYgKCFhcHBSZXBvcyB8fCBzYWZlR2V0KGFwcFJlcG9zLCByZXBvLnJlcG9JbmZvXy50b1VSTFN0cmluZygpKSAhPT0gcmVwbykge1xuICAgICAgZmF0YWwoXG4gICAgICAgIGBEYXRhYmFzZSAke3JlcG8uYXBwLm5hbWV9KCR7cmVwby5yZXBvSW5mb199KSBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmVwby5pbnRlcnJ1cHQoKTtcbiAgICBkZWxldGUgYXBwUmVwb3NbcmVwby5yZXBvSW5mb18udG9VUkxTdHJpbmcoKV07XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyBhIHJlcG8gZG9lc24ndCBhbHJlYWR5IGV4aXN0IGFuZCB0aGVuIGNyZWF0ZXMgb25lIHVzaW5nIHRoZVxuICAgKiBwcm92aWRlZCBhcHAuXG4gICAqXG4gICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mbyBUaGUgbWV0YWRhdGEgYWJvdXQgdGhlIFJlcG9cbiAgICogQHBhcmFtIHshRmlyZWJhc2VBcHB9IGFwcFxuICAgKiBAcmV0dXJuIHshUmVwb30gVGhlIFJlcG8gb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHNlcnZlciAvIHJlcG9OYW1lLlxuICAgKi9cbiAgY3JlYXRlUmVwbyhyZXBvSW5mbzogUmVwb0luZm8sIGFwcDogRmlyZWJhc2VBcHApOiBSZXBvIHtcbiAgICBsZXQgYXBwUmVwb3MgPSBzYWZlR2V0KHRoaXMucmVwb3NfLCBhcHAubmFtZSk7XG5cbiAgICBpZiAoIWFwcFJlcG9zKSB7XG4gICAgICBhcHBSZXBvcyA9IHt9O1xuICAgICAgdGhpcy5yZXBvc19bYXBwLm5hbWVdID0gYXBwUmVwb3M7XG4gICAgfVxuXG4gICAgbGV0IHJlcG8gPSBzYWZlR2V0KGFwcFJlcG9zLCByZXBvSW5mby50b1VSTFN0cmluZygpKTtcbiAgICBpZiAocmVwbykge1xuICAgICAgZmF0YWwoXG4gICAgICAgICdEYXRhYmFzZSBpbml0aWFsaXplZCBtdWx0aXBsZSB0aW1lcy4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhYmFzZSBVUkwgbWF0Y2hlcyB3aXRoIGVhY2ggZGF0YWJhc2UoKSBjYWxsLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJlcG8gPSBuZXcgUmVwbyhyZXBvSW5mbywgdGhpcy51c2VSZXN0Q2xpZW50XywgYXBwKTtcbiAgICBhcHBSZXBvc1tyZXBvSW5mby50b1VSTFN0cmluZygpXSA9IHJlcG87XG5cbiAgICByZXR1cm4gcmVwbztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgdXMgdG8gdXNlIFJlYWRvbmx5UmVzdENsaWVudCBpbnN0ZWFkIG9mIFBlcnNpc3RlbnRDb25uZWN0aW9uIGZvciBuZXcgUmVwb3MuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZXN0Q2xpZW50XG4gICAqL1xuICBmb3JjZVJlc3RDbGllbnQoZm9yY2VSZXN0Q2xpZW50OiBib29sZWFuKSB7XG4gICAgdGhpcy51c2VSZXN0Q2xpZW50XyA9IGZvcmNlUmVzdENsaWVudDtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGZhdGFsIH0gZnJvbSAnLi4vY29yZS91dGlsL3V0aWwnO1xuaW1wb3J0IHsgcGFyc2VSZXBvSW5mbyB9IGZyb20gJy4uL2NvcmUvdXRpbC9saWJzL3BhcnNlcic7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vY29yZS91dGlsL1BhdGgnO1xuaW1wb3J0IHsgUmVmZXJlbmNlIH0gZnJvbSAnLi9SZWZlcmVuY2UnO1xuaW1wb3J0IHsgUmVwbyB9IGZyb20gJy4uL2NvcmUvUmVwbyc7XG5pbXBvcnQgeyBSZXBvTWFuYWdlciB9IGZyb20gJy4uL2NvcmUvUmVwb01hbmFnZXInO1xuaW1wb3J0IHsgdmFsaWRhdGVBcmdDb3VudCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHZhbGlkYXRlVXJsIH0gZnJvbSAnLi4vY29yZS91dGlsL3ZhbGlkYXRpb24nO1xuaW1wb3J0IHsgRmlyZWJhc2VBcHAgfSBmcm9tICdAZmlyZWJhc2UvYXBwLXR5cGVzJztcbmltcG9ydCB7IEZpcmViYXNlU2VydmljZSB9IGZyb20gJ0BmaXJlYmFzZS9hcHAtdHlwZXMvcHJpdmF0ZSc7XG5pbXBvcnQgeyBSZXBvSW5mbyB9IGZyb20gJy4uL2NvcmUvUmVwb0luZm8nO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGZpcmViYXNlIGRhdGFiYXNlLlxuICogQGltcGxlbWVudHMge0ZpcmViYXNlU2VydmljZX1cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFiYXNlIGltcGxlbWVudHMgRmlyZWJhc2VTZXJ2aWNlIHtcbiAgSU5URVJOQUw6IERhdGFiYXNlSW50ZXJuYWxzO1xuICBwcml2YXRlIHJvb3RfOiBSZWZlcmVuY2U7XG5cbiAgc3RhdGljIHJlYWRvbmx5IFNlcnZlclZhbHVlID0ge1xuICAgIFRJTUVTVEFNUDoge1xuICAgICAgJy5zdic6ICd0aW1lc3RhbXAnXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgY29uc3RydWN0b3Igc2hvdWxkIG5vdCBiZSBjYWxsZWQgYnkgdXNlcnMgb2Ygb3VyIHB1YmxpYyBBUEkuXG4gICAqIEBwYXJhbSB7IVJlcG99IHJlcG9fXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlcG9fOiBSZXBvKSB7XG4gICAgaWYgKCEocmVwb18gaW5zdGFuY2VvZiBSZXBvKSkge1xuICAgICAgZmF0YWwoXG4gICAgICAgIFwiRG9uJ3QgY2FsbCBuZXcgRGF0YWJhc2UoKSBkaXJlY3RseSAtIHBsZWFzZSB1c2UgZmlyZWJhc2UuZGF0YWJhc2UoKS5cIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1JlZmVyZW5jZX0gKi9cbiAgICB0aGlzLnJvb3RfID0gbmV3IFJlZmVyZW5jZShyZXBvXywgUGF0aC5FbXB0eSk7XG5cbiAgICB0aGlzLklOVEVSTkFMID0gbmV3IERhdGFiYXNlSW50ZXJuYWxzKHRoaXMpO1xuICB9XG5cbiAgZ2V0IGFwcCgpOiBGaXJlYmFzZUFwcCB7XG4gICAgcmV0dXJuIHRoaXMucmVwb18uYXBwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgb3IgdG8gdGhlIHBhdGggc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZFxuICAgKiBhcmd1bWVudC5cblxuICAgKiBAcGFyYW0ge3N0cmluZ3xSZWZlcmVuY2U9fSBwYXRoIFRoZSByZWxhdGl2ZSBzdHJpbmcgcGF0aCBvciBhbiBleGlzdGluZ1xuICAgKiBSZWZlcmVuY2UgdG8gYSBkYXRhYmFzZSBsb2NhdGlvbi5cbiAgICogQHRocm93cyBJZiBhIFJlZmVyZW5jZSBpcyBwcm92aWRlZCwgdGhyb3dzIGlmIGl0IGRvZXMgbm90IGJlbG9uZyB0byB0aGVcbiAgICogc2FtZSBwcm9qZWN0LlxuICAgKiBAcmV0dXJuIHshUmVmZXJlbmNlfSBGaXJlYmFzZSByZWZlcmVuY2UuXG4gICAqKi9cbiAgcmVmKHBhdGg/OiBzdHJpbmcpOiBSZWZlcmVuY2U7XG4gIHJlZihwYXRoPzogUmVmZXJlbmNlKTogUmVmZXJlbmNlO1xuICByZWYocGF0aD86IHN0cmluZyB8IFJlZmVyZW5jZSk6IFJlZmVyZW5jZSB7XG4gICAgdGhpcy5jaGVja0RlbGV0ZWRfKCdyZWYnKTtcbiAgICB2YWxpZGF0ZUFyZ0NvdW50KCdkYXRhYmFzZS5yZWYnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVmZXJlbmNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZGcm9tVVJMKHBhdGgudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGggIT09IHVuZGVmaW5lZCA/IHRoaXMucm9vdF8uY2hpbGQocGF0aCkgOiB0aGlzLnJvb3RfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgb3IgdGhlIHBhdGggc3BlY2lmaWVkIGluIHVybC5cbiAgICogV2UgdGhyb3cgYSBleGNlcHRpb24gaWYgdGhlIHVybCBpcyBub3QgaW4gdGhlIHNhbWUgZG9tYWluIGFzIHRoZVxuICAgKiBjdXJyZW50IHJlcG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHJldHVybiB7IVJlZmVyZW5jZX0gRmlyZWJhc2UgcmVmZXJlbmNlLlxuICAgKi9cbiAgcmVmRnJvbVVSTCh1cmw6IHN0cmluZyk6IFJlZmVyZW5jZSB7XG4gICAgLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuICAgIGNvbnN0IGFwaU5hbWUgPSAnZGF0YWJhc2UucmVmRnJvbVVSTCc7XG4gICAgdGhpcy5jaGVja0RlbGV0ZWRfKGFwaU5hbWUpO1xuICAgIHZhbGlkYXRlQXJnQ291bnQoYXBpTmFtZSwgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgY29uc3QgcGFyc2VkVVJMID0gcGFyc2VSZXBvSW5mbyh1cmwpO1xuICAgIHZhbGlkYXRlVXJsKGFwaU5hbWUsIDEsIHBhcnNlZFVSTCk7XG5cbiAgICBjb25zdCByZXBvSW5mbyA9IHBhcnNlZFVSTC5yZXBvSW5mbztcbiAgICBpZiAocmVwb0luZm8uaG9zdCAhPT0gKCh0aGlzLnJlcG9fIGFzIGFueSkucmVwb0luZm9fIGFzIFJlcG9JbmZvKS5ob3N0KSB7XG4gICAgICBmYXRhbChcbiAgICAgICAgYXBpTmFtZSArXG4gICAgICAgICAgJzogSG9zdCBuYW1lIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IGRhdGFiYXNlOiAnICtcbiAgICAgICAgICAnKGZvdW5kICcgK1xuICAgICAgICAgIHJlcG9JbmZvLmhvc3QgK1xuICAgICAgICAgICcgYnV0IGV4cGVjdGVkICcgK1xuICAgICAgICAgICgodGhpcy5yZXBvXyBhcyBhbnkpLnJlcG9JbmZvXyBhcyBSZXBvSW5mbykuaG9zdCArXG4gICAgICAgICAgJyknXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlZihwYXJzZWRVUkwucGF0aC50b1N0cmluZygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpTmFtZVxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja0RlbGV0ZWRfKGFwaU5hbWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLnJlcG9fID09PSBudWxsKSB7XG4gICAgICBmYXRhbCgnQ2Fubm90IGNhbGwgJyArIGFwaU5hbWUgKyAnIG9uIGEgZGVsZXRlZCBkYXRhYmFzZS4nKTtcbiAgICB9XG4gIH1cblxuICAvLyBNYWtlIGluZGl2aWR1YWwgcmVwbyBnbyBvZmZsaW5lLlxuICBnb09mZmxpbmUoKSB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnZGF0YWJhc2UuZ29PZmZsaW5lJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdGhpcy5jaGVja0RlbGV0ZWRfKCdnb09mZmxpbmUnKTtcbiAgICB0aGlzLnJlcG9fLmludGVycnVwdCgpO1xuICB9XG5cbiAgZ29PbmxpbmUoKSB7XG4gICAgdmFsaWRhdGVBcmdDb3VudCgnZGF0YWJhc2UuZ29PbmxpbmUnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB0aGlzLmNoZWNrRGVsZXRlZF8oJ2dvT25saW5lJyk7XG4gICAgdGhpcy5yZXBvXy5yZXN1bWUoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGF0YWJhc2VJbnRlcm5hbHMge1xuICAvKiogQHBhcmFtIHshRGF0YWJhc2V9IGRhdGFiYXNlICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRhYmFzZTogRGF0YWJhc2UpIHt9XG5cbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59ICovXG4gIGFzeW5jIGRlbGV0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAodGhpcy5kYXRhYmFzZSBhcyBhbnkpLmNoZWNrRGVsZXRlZF8oJ2RlbGV0ZScpO1xuICAgIFJlcG9NYW5hZ2VyLmdldEluc3RhbmNlKCkuZGVsZXRlUmVwbygodGhpcy5kYXRhYmFzZSBhcyBhbnkpLnJlcG9fIGFzIFJlcG8pO1xuXG4gICAgKHRoaXMuZGF0YWJhc2UgYXMgYW55KS5yZXBvXyA9IG51bGw7XG4gICAgKHRoaXMuZGF0YWJhc2UgYXMgYW55KS5yb290XyA9IG51bGw7XG4gICAgdGhpcy5kYXRhYmFzZS5JTlRFUk5BTCA9IG51bGw7XG4gICAgdGhpcy5kYXRhYmFzZSA9IG51bGw7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBXZWJTb2NrZXRDb25uZWN0aW9uIH0gZnJvbSAnLi4vcmVhbHRpbWUvV2ViU29ja2V0Q29ubmVjdGlvbic7XG5pbXBvcnQgeyBCcm93c2VyUG9sbENvbm5lY3Rpb24gfSBmcm9tICcuLi9yZWFsdGltZS9Ccm93c2VyUG9sbENvbm5lY3Rpb24nO1xuaW1wb3J0IHsgUmVmZXJlbmNlIH0gZnJvbSAnLi9SZWZlcmVuY2UnO1xuXG4vKipcbiAqIElOVEVSTkFMIG1ldGhvZHMgZm9yIGludGVybmFsLXVzZSBvbmx5ICh0ZXN0cywgZXRjLikuXG4gKlxuICogQ3VzdG9tZXJzIHNob3VsZG4ndCB1c2UgdGhlc2Ugb3IgZWxzZSBzaG91bGQgYmUgYXdhcmUgdGhhdCB0aGV5IGNvdWxkIGJyZWFrIGF0IGFueSB0aW1lLlxuICpcbiAqIEBjb25zdFxuICovXG5cbmV4cG9ydCBjb25zdCBmb3JjZUxvbmdQb2xsaW5nID0gZnVuY3Rpb24oKSB7XG4gIFdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdygpO1xuICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvdygpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZvcmNlV2ViU29ja2V0cyA9IGZ1bmN0aW9uKCkge1xuICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdygpO1xufTtcblxuLyogVXNlZCBieSBBcHAgTWFuYWdlciAqL1xuZXhwb3J0IGNvbnN0IGlzV2ViU29ja2V0c0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gV2ViU29ja2V0Q29ubmVjdGlvblsnaXNBdmFpbGFibGUnXSgpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNldFNlY3VyaXR5RGVidWdDYWxsYmFjayA9IGZ1bmN0aW9uKFxuICByZWY6IFJlZmVyZW5jZSxcbiAgY2FsbGJhY2s6IChhOiBPYmplY3QpID0+IHZvaWRcbikge1xuICAocmVmLnJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fIGFzIGFueSkuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXyA9IGNhbGxiYWNrO1xufTtcblxuZXhwb3J0IGNvbnN0IHN0YXRzID0gZnVuY3Rpb24ocmVmOiBSZWZlcmVuY2UsIHNob3dEZWx0YT86IGJvb2xlYW4pIHtcbiAgcmVmLnJlcG8uc3RhdHMoc2hvd0RlbHRhKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdGF0c0luY3JlbWVudENvdW50ZXIgPSBmdW5jdGlvbihyZWY6IFJlZmVyZW5jZSwgbWV0cmljOiBzdHJpbmcpIHtcbiAgcmVmLnJlcG8uc3RhdHNJbmNyZW1lbnRDb3VudGVyKG1ldHJpYyk7XG59O1xuXG5leHBvcnQgY29uc3QgZGF0YVVwZGF0ZUNvdW50ID0gZnVuY3Rpb24ocmVmOiBSZWZlcmVuY2UpOiBudW1iZXIge1xuICByZXR1cm4gcmVmLnJlcG8uZGF0YVVwZGF0ZUNvdW50O1xufTtcblxuZXhwb3J0IGNvbnN0IGludGVyY2VwdFNlcnZlckRhdGEgPSBmdW5jdGlvbihcbiAgcmVmOiBSZWZlcmVuY2UsXG4gIGNhbGxiYWNrOiAoKGE6IHN0cmluZywgYjogYW55KSA9PiB2b2lkKSB8IG51bGxcbikge1xuICByZXR1cm4gcmVmLnJlcG8uaW50ZXJjZXB0U2VydmVyRGF0YV8oY2FsbGJhY2spO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBSZXBvSW5mbyB9IGZyb20gJy4uL2NvcmUvUmVwb0luZm8nO1xuaW1wb3J0IHsgUGVyc2lzdGVudENvbm5lY3Rpb24gfSBmcm9tICcuLi9jb3JlL1BlcnNpc3RlbnRDb25uZWN0aW9uJztcbmltcG9ydCB7IFJlcG9NYW5hZ2VyIH0gZnJvbSAnLi4vY29yZS9SZXBvTWFuYWdlcic7XG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnLi4vcmVhbHRpbWUvQ29ubmVjdGlvbic7XG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gJy4vUXVlcnknO1xuXG5leHBvcnQgY29uc3QgRGF0YUNvbm5lY3Rpb24gPSBQZXJzaXN0ZW50Q29ubmVjdGlvbjtcblxuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IG9uQ29tcGxldGVcbiAqL1xuKFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZSBhcyBhbnkpLnNpbXBsZUxpc3RlbiA9IGZ1bmN0aW9uKFxuICBwYXRoU3RyaW5nOiBzdHJpbmcsXG4gIG9uQ29tcGxldGU6IChhOiBhbnkpID0+IHZvaWRcbikge1xuICB0aGlzLnNlbmRSZXF1ZXN0KCdxJywgeyBwOiBwYXRoU3RyaW5nIH0sIG9uQ29tcGxldGUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IG9uRWNob1xuICovXG4oUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlIGFzIGFueSkuZWNobyA9IGZ1bmN0aW9uKFxuICBkYXRhOiBhbnksXG4gIG9uRWNobzogKGE6IGFueSkgPT4gdm9pZFxuKSB7XG4gIHRoaXMuc2VuZFJlcXVlc3QoJ2VjaG8nLCB7IGQ6IGRhdGEgfSwgb25FY2hvKTtcbn07XG5cbi8vIFJlYWxUaW1lQ29ubmVjdGlvbiBwcm9wZXJ0aWVzIHRoYXQgd2UgdXNlIGluIHRlc3RzLlxuZXhwb3J0IGNvbnN0IFJlYWxUaW1lQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOiBzdHJpbmd9IG5ld0hhc2hcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydCBjb25zdCBoaWphY2tIYXNoID0gZnVuY3Rpb24obmV3SGFzaDogKCkgPT4gc3RyaW5nKSB7XG4gIGNvbnN0IG9sZFB1dCA9IFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQ7XG4gIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbihcbiAgICBwYXRoU3RyaW5nLFxuICAgIGRhdGEsXG4gICAgb3B0X29uQ29tcGxldGUsXG4gICAgb3B0X2hhc2hcbiAgKSB7XG4gICAgaWYgKG9wdF9oYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdF9oYXNoID0gbmV3SGFzaCgpO1xuICAgIH1cbiAgICBvbGRQdXQuY2FsbCh0aGlzLCBwYXRoU3RyaW5nLCBkYXRhLCBvcHRfb25Db21wbGV0ZSwgb3B0X2hhc2gpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dCA9IG9sZFB1dDtcbiAgfTtcbn07XG5cbi8qKlxuICogQHR5cGUge2Z1bmN0aW9uKG5ldzpSZXBvSW5mbywgIXN0cmluZywgYm9vbGVhbiwgIXN0cmluZywgYm9vbGVhbik6IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25UYXJnZXQgPSBSZXBvSW5mbztcblxuLyoqXG4gKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAqIEByZXR1cm4geyFzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBxdWVyeUlkZW50aWZpZXIgPSBmdW5jdGlvbihxdWVyeTogUXVlcnkpIHtcbiAgcmV0dXJuIHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFRdWVyeX0gZmlyZWJhc2VSZWZcbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0ZW5zID0gZnVuY3Rpb24oZmlyZWJhc2VSZWY6IFF1ZXJ5KSB7XG4gIHJldHVybiAoZmlyZWJhc2VSZWYucmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8gYXMgYW55KS5saXN0ZW5zXztcbn07XG5cbi8qKlxuICogRm9yY2VzIHRoZSBSZXBvTWFuYWdlciB0byBjcmVhdGUgUmVwb3MgdGhhdCB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZVJlc3RDbGllbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcmNlUmVzdENsaWVudCA9IGZ1bmN0aW9uKGZvcmNlUmVzdENsaWVudDogYm9vbGVhbikge1xuICBSZXBvTWFuYWdlci5nZXRJbnN0YW5jZSgpLmZvcmNlUmVzdENsaWVudChmb3JjZVJlc3RDbGllbnQpO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBhbGwgb2YgdGhlIExvZ2dlciBpbnN0YW5jZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGluc3RhbmNlczogTG9nZ2VyW10gPSBbXTtcblxuLyoqXG4gKiBUaGUgSlMgU0RLIHN1cHBvcnRzIDUgbG9nIGxldmVscyBhbmQgYWxzbyBhbGxvd3MgYSB1c2VyIHRoZSBhYmlsaXR5IHRvXG4gKiBzaWxlbmNlIHRoZSBsb2dzIGFsdG9nZXRoZXIuXG4gKlxuICogVGhlIG9yZGVyIGlzIGEgZm9sbG93czpcbiAqIERFQlVHIDwgVkVSQk9TRSA8IElORk8gPCBXQVJOIDwgRVJST1JcbiAqXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBjYXB0dXJlZCAoaS5lLiBpZlxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBJTkZPYCwgZXJyb3JzIHdpbGwgc3RpbGwgYmUgbG9nZ2VkLCBidXQgYERFQlVHYCBhbmRcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxuICovXG5leHBvcnQgZW51bSBMb2dMZXZlbCB7XG4gIERFQlVHLFxuICBWRVJCT1NFLFxuICBJTkZPLFxuICBXQVJOLFxuICBFUlJPUixcbiAgU0lMRU5UXG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbG9nIGxldmVsXG4gKi9cbmNvbnN0IGRlZmF1bHRMb2dMZXZlbDogTG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xuXG4vKipcbiAqIFdlIGFsbG93IHVzZXJzIHRoZSBhYmlsaXR5IHRvIHBhc3MgdGhlaXIgb3duIGxvZyBoYW5kbGVyLiBXZSB3aWxsIHBhc3MgdGhlXG4gKiB0eXBlIG9mIGxvZywgdGhlIGN1cnJlbnQgbG9nIGxldmVsLCBhbmQgYW55IG90aGVyIGFyZ3VtZW50cyBwYXNzZWQgKGkuZS4gdGhlXG4gKiBtZXNzYWdlcyB0aGF0IHRoZSB1c2VyIHdhbnRzIHRvIGxvZykgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgTG9nSGFuZGxlciA9IChcbiAgbG9nZ2VySW5zdGFuY2U6IExvZ2dlcixcbiAgbG9nVHlwZTogTG9nTGV2ZWwsXG4gIC4uLmFyZ3M6IHVua25vd25bXVxuKSA9PiB2b2lkO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvZyBoYW5kbGVyIHdpbGwgZm9yd2FyZCBERUJVRywgVkVSQk9TRSwgSU5GTywgV0FSTiwgYW5kIEVSUk9SXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxuICogaXMgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGxvZyBsZXZlbClcbiAqL1xuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXI6IExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpOiB2b2lkID0+IHtcbiAgaWYgKGxvZ1R5cGUgPCBpbnN0YW5jZS5sb2dMZXZlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIHN3aXRjaCAobG9nVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgZGlzcGxheWVkIGluIHRoZSBkZXZlbG9wZXIgY29uc29sZSAoaW5cbiAgICAgKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcbiAgICAgKiAoaS5lLiBvbmNlIGZvciBmaXJlYmFzZSwgYW5kIG9uY2UgaW4gdGhlIGNvbnNvbGUpLCB3ZSBhcmUgc2VuZGluZyBgREVCVUdgXG4gICAgICogbG9ncyB0byB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjYXNlIExvZ0xldmVsLkRFQlVHOlxuICAgICAgY29uc29sZS5sb2coYFske25vd31dICAke2luc3RhbmNlLm5hbWV9OmAsIC4uLmFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMb2dMZXZlbC5WRVJCT1NFOlxuICAgICAgY29uc29sZS5sb2coYFske25vd31dICAke2luc3RhbmNlLm5hbWV9OmAsIC4uLmFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMb2dMZXZlbC5JTkZPOlxuICAgICAgY29uc29sZS5pbmZvKGBbJHtub3d9XSAgJHtpbnN0YW5jZS5uYW1lfTpgLCAuLi5hcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTG9nTGV2ZWwuV0FSTjpcbiAgICAgIGNvbnNvbGUud2FybihgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExvZ0xldmVsLkVSUk9SOlxuICAgICAgY29uc29sZS5lcnJvcihgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIGxvZyBhIG1lc3NhZ2Ugd2l0aCBhbiBpbnZhbGlkIGxvZ1R5cGUgKHZhbHVlOiAke2xvZ1R5cGV9KWBcbiAgICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuICAvKipcbiAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXG4gICAqIEZpcmViYXNlJ3MgbG9nZ2luZyBzY2hlbWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lOiBzdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDYXB0dXJlIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBsYXRlciB1c2VcbiAgICAgKi9cbiAgICBpbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbG9nIGxldmVsIG9mIHRoZSBnaXZlbiBMb2dnZXIgaW5zdGFuY2UuXG4gICAqL1xuICBwcml2YXRlIF9sb2dMZXZlbCA9IGRlZmF1bHRMb2dMZXZlbDtcbiAgZ2V0IGxvZ0xldmVsKCk6IExvZ0xldmVsIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gIH1cbiAgc2V0IGxvZ0xldmVsKHZhbDogTG9nTGV2ZWwpIHtcbiAgICBpZiAoISh2YWwgaW4gTG9nTGV2ZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHZhbHVlIGFzc2lnbmVkIHRvIGBsb2dMZXZlbGAnKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nTGV2ZWwgPSB2YWw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxvZyBoYW5kbGVyIGZvciB0aGUgTG9nZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgcHJpdmF0ZSBfbG9nSGFuZGxlcjogTG9nSGFuZGxlciA9IGRlZmF1bHRMb2dIYW5kbGVyO1xuICBnZXQgbG9nSGFuZGxlcigpOiBMb2dIYW5kbGVyIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nSGFuZGxlcjtcbiAgfVxuICBzZXQgbG9nSGFuZGxlcih2YWw6IExvZ0hhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgYXNzaWduZWQgdG8gYGxvZ0hhbmRsZXJgIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9sb2dIYW5kbGVyID0gdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGFsbCBiYXNlZCBvbiB0aGUgYGNvbnNvbGVgIGludGVyZmFjZVxuICAgKi9cblxuICBkZWJ1ZyguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcbiAgfVxuICBsb2coLi4uYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcbiAgfVxuICBpbmZvKC4uLmFyZ3M6IHVua25vd25bXSk6IHZvaWQge1xuICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XG4gIH1cbiAgd2FybiguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xuICB9XG4gIGVycm9yKC4uLmFyZ3M6IHVua25vd25bXSk6IHZvaWQge1xuICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuRVJST1IsIC4uLmFyZ3MpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XG4gKi9cbmV4cG9ydCBjb25zdCBhc3NlcnQgPSBmdW5jdGlvbihhc3NlcnRpb246IHVua25vd24sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IGFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gRXJyb3Igb2JqZWN0IHN1aXRhYmxlIGZvciB0aHJvd2luZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24obWVzc2FnZTogc3RyaW5nKTogRXJyb3Ige1xuICByZXR1cm4gbmV3IEVycm9yKFxuICAgICdGaXJlYmFzZSBEYXRhYmFzZSAoJyArXG4gICAgICBDT05TVEFOVFMuU0RLX1ZFUlNJT04gK1xuICAgICAgJykgSU5URVJOQUwgQVNTRVJUIEZBSUxFRDogJyArXG4gICAgICBtZXNzYWdlXG4gICk7XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24oc3RyOiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXG4gIGNvbnN0IG91dDogbnVtYmVyW10gPSBbXTtcbiAgbGV0IHAgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgIG91dFtwKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiZcbiAgICAgIGkgKyAxIDwgc3RyLmxlbmd0aCAmJlxuICAgICAgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMFxuICAgICkge1xuICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNmZik7XG4gICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXG4gKi9cbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24oYnl0ZXM6IG51bWJlcltdKTogc3RyaW5nIHtcbiAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcbiAgY29uc3Qgb3V0OiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgcG9zID0gMCxcbiAgICBjID0gMDtcbiAgd2hpbGUgKHBvcyA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGMxID0gYnl0ZXNbcG9zKytdO1xuICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxKTtcbiAgICB9IGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XG4gICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcbiAgICB9IGVsc2UgaWYgKGMxID4gMjM5ICYmIGMxIDwgMzY1KSB7XG4gICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XG4gICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIGNvbnN0IGM0ID0gYnl0ZXNbcG9zKytdO1xuICAgICAgY29uc3QgdSA9XG4gICAgICAgICgoKGMxICYgNykgPDwgMTgpIHwgKChjMiAmIDYzKSA8PCAxMikgfCAoKGMzICYgNjMpIDw8IDYpIHwgKGM0ICYgNjMpKSAtXG4gICAgICAgIDB4MTAwMDA7XG4gICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcbiAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XG4gICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0LmpvaW4oJycpO1xufTtcblxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcbmV4cG9ydCBjb25zdCBiYXNlNjQgPSB7XG4gIC8qKlxuICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBieXRlVG9DaGFyTWFwXzogbnVsbCxcblxuICAvKipcbiAgICogTWFwcyBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hhclRvQnl0ZU1hcF86IG51bGwsXG5cbiAgLyoqXG4gICAqIE1hcHMgYnl0ZXMgdG8gd2Vic2FmZSBjaGFyYWN0ZXJzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYnl0ZVRvQ2hhck1hcFdlYlNhZmVfOiBudWxsLFxuXG4gIC8qKlxuICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcblxuICAvKipcbiAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQsIHNoYXJlZCBiZXR3ZWVuXG4gICAqIEVOQ09ERURfVkFMUyBhbmQgRU5DT0RFRF9WQUxTX1dFQlNBRkVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIEVOQ09ERURfVkFMU19CQVNFOlxuICAgICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxuXG4gIC8qKlxuICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldC4gVmFsdWUgNjQgKD0pIGlzIHNwZWNpYWw7IGl0IG1lYW5zIFwibm90aGluZy5cIlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IEVOQ09ERURfVkFMUygpIHtcbiAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPdXIgd2Vic2FmZSBhbHBoYWJldC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcbiAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICctXy4nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyB0aGUgYXRvYiBhbmQgYnRvYSBmdW5jdGlvbnMuIFRoaXMgZXh0ZW5zaW9uXG4gICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcbiAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XG4gICAqIGJ1dCBzdGlsbCBhbGxvd2luZyB0aGUgc3RhbmRhcmQgcGVyLWJyb3dzZXIgY29tcGlsYXRpb25zLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIEhBU19OQVRJVkVfU1VQUE9SVDogdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicsXG5cbiAgLyoqXG4gICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dCBBbiBhcnJheSBvZiBieXRlcyAobnVtYmVycyB3aXRoXG4gICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxuICAgKiBAcGFyYW0gd2ViU2FmZSBCb29sZWFuIGluZGljYXRpbmcgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAqL1xuICBlbmNvZGVCeXRlQXJyYXkoaW5wdXQ6IG51bWJlcltdIHwgVWludDhBcnJheSwgd2ViU2FmZT86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRfKCk7XG5cbiAgICBjb25zdCBieXRlVG9DaGFyTWFwOiBudW1iZXJbXSA9IHdlYlNhZmVcbiAgICAgID8gdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9cbiAgICAgIDogdGhpcy5ieXRlVG9DaGFyTWFwXztcblxuICAgIGNvbnN0IG91dHB1dDogbnVtYmVyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGNvbnN0IGJ5dGUxID0gaW5wdXRbaV07XG4gICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpICsgMSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gaW5wdXRbaSArIDFdIDogMDtcbiAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgKyAyIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBpbnB1dFtpICsgMl0gOiAwO1xuXG4gICAgICBjb25zdCBvdXRCeXRlMSA9IGJ5dGUxID4+IDI7XG4gICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTEgJiAweDAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcbiAgICAgIGxldCBvdXRCeXRlMyA9ICgoYnl0ZTIgJiAweDBmKSA8PCAyKSB8IChieXRlMyA+PiA2KTtcbiAgICAgIGxldCBvdXRCeXRlNCA9IGJ5dGUzICYgMHgzZjtcblxuICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcbiAgICAgICAgb3V0Qnl0ZTQgPSA2NDtcblxuICAgICAgICBpZiAoIWhhdmVCeXRlMikge1xuICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3V0cHV0LnB1c2goXG4gICAgICAgIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLFxuICAgICAgICBieXRlVG9DaGFyTWFwW291dEJ5dGUyXSxcbiAgICAgICAgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlM10sXG4gICAgICAgIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2U2NC1lbmNvZGUgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dCBBIHN0cmluZyB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB3ZWJTYWZlIElmIHRydWUsIHdlIHNob3VsZCB1c2UgdGhlXG4gICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICAgKi9cbiAgZW5jb2RlU3RyaW5nKGlucHV0OiBzdHJpbmcsIHdlYlNhZmU/OiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcbiAgICAgIHJldHVybiBidG9hKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5KGlucHV0KSwgd2ViU2FmZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dCB0byBkZWNvZGUuXG4gICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXG4gICAqL1xuICBkZWNvZGVTdHJpbmcoaW5wdXQ6IHN0cmluZywgd2ViU2FmZTogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcbiAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXG4gICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XG4gICAgICByZXR1cm4gYXRvYihpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAqXG4gICAqIEluIGJhc2UtNjQgZGVjb2RpbmcsIGdyb3VwcyBvZiBmb3VyIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCBpbnRvIHRocmVlXG4gICAqIGJ5dGVzLiAgSWYgdGhlIGVuY29kZXIgZGlkIG5vdCBhcHBseSBwYWRkaW5nLCB0aGUgaW5wdXQgbGVuZ3RoIG1heSBub3RcbiAgICogYmUgYSBtdWx0aXBsZSBvZiA0LlxuICAgKlxuICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGdyb3VwIHdpbGwgaGF2ZSBmZXdlciB0aGFuIDQgY2hhcmFjdGVycywgYW5kXG4gICAqIHBhZGRpbmcgd2lsbCBiZSBpbmZlcnJlZC4gIElmIHRoZSBncm91cCBoYXMgb25lIG9yIHR3byBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzXG4gICAqIHRvIG9uZSBieXRlLiAgSWYgdGhlIGdyb3VwIGhhcyB0aHJlZSBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzIHRvIHR3byBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IElucHV0IHRvIGRlY29kZS5cbiAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZSB3ZWItc2FmZSBhbHBoYWJldC5cbiAgICogQHJldHVybiBieXRlcyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXG4gICAqL1xuICBkZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dDogc3RyaW5nLCB3ZWJTYWZlOiBib29sZWFuKTogbnVtYmVyW10ge1xuICAgIHRoaXMuaW5pdF8oKTtcblxuICAgIGNvbnN0IGNoYXJUb0J5dGVNYXAgPSB3ZWJTYWZlXG4gICAgICA/IHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfXG4gICAgICA6IHRoaXMuY2hhclRvQnl0ZU1hcF87XG5cbiAgICBjb25zdCBvdXRwdXQ6IG51bWJlcltdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBieXRlMSA9IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkrKyldO1xuXG4gICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiAwO1xuICAgICAgKytpO1xuXG4gICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcbiAgICAgICsraTtcblxuICAgICAgY29uc3QgaGF2ZUJ5dGU0ID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGJ5dGU0ID0gaGF2ZUJ5dGU0ID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XG4gICAgICArK2k7XG5cbiAgICAgIGlmIChieXRlMSA9PSBudWxsIHx8IGJ5dGUyID09IG51bGwgfHwgYnl0ZTMgPT0gbnVsbCB8fCBieXRlNCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xuXG4gICAgICBpZiAoYnl0ZTMgIT09IDY0KSB7XG4gICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xuICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMik7XG5cbiAgICAgICAgaWYgKGJ5dGU0ICE9PSA2NCkge1xuICAgICAgICAgIGNvbnN0IG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XG4gICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6eSBzdGF0aWMgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uIENhbGxlZCBiZWZvcmVcbiAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0XygpIHtcbiAgICBpZiAoIXRoaXMuYnl0ZVRvQ2hhck1hcF8pIHtcbiAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF8gPSB7fTtcbiAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF8gPSB7fTtcbiAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfID0ge307XG4gICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlXyA9IHt9O1xuXG4gICAgICAvLyBXZSB3YW50IHF1aWNrIG1hcHBpbmdzIGJhY2sgYW5kIGZvcnRoLCBzbyB3ZSBwcmVjb21wdXRlIHR3byBtYXBzLlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpO1xuICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcbiAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV0gPSB0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKTtcbiAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV1dID0gaTtcblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcgd2hlbiBkZWNvZGluZyBhbmQgY29ycmVjdGx5IGRlY29kZSBib3RoIGVuY29kaW5ncy5cbiAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNjRFbmNvZGUgPSBmdW5jdGlvbihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5KHN0cik7XG4gIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xuICpcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHN0ciBUbyBiZSBkZWNvZGVkXG4gKiBAcmV0dXJuIERlY29kZWQgcmVzdWx0LCBpZiBwb3NzaWJsZVxuICovXG5leHBvcnQgY29uc3QgYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24oc3RyOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcignYmFzZTY0RGVjb2RlIGZhaWxlZDogJywgZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5PFQ+KHZhbHVlOiBUKTogVCB7XG4gIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpIGFzIFQ7XG59XG5cbi8qKlxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxuICogb2YgT2JqZWN0cyBhbmQgQXJyYXlzKS4gIFNjYWxhciB2YWx1ZXMgaW4gdGhlIHRhcmdldCBhcmUgb3Zlci13cml0dGVuLlxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxuICogKGFuZCByZXR1cm5lZCkuXG4gKlxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBFeHRlbmQodGFyZ2V0OiB1bmtub3duLCBzb3VyY2U6IHVua25vd24pOiB1bmtub3duIHtcbiAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBzd2l0Y2ggKHNvdXJjZS5jb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgRGF0ZTpcbiAgICAgIC8vIFRyZWF0IERhdGVzIGxpa2Ugc2NhbGFyczsgaWYgdGhlIHRhcmdldCBkYXRlIG9iamVjdCBoYWQgYW55IGNoaWxkXG4gICAgICAvLyBwcm9wZXJ0aWVzIC0gdGhleSB3aWxsIGJlIGxvc3QhXG4gICAgICBjb25zdCBkYXRlVmFsdWUgPSBzb3VyY2UgYXMgRGF0ZTtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcblxuICAgIGNhc2UgT2JqZWN0OlxuICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhcmdldCA9IHt9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFycmF5OlxuICAgICAgLy8gQWx3YXlzIGNvcHkgdGhlIGFycmF5IHNvdXJjZSBhbmQgb3ZlcndyaXRlIHRoZSB0YXJnZXQuXG4gICAgICB0YXJnZXQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIE5vdCBhIHBsYWluIE9iamVjdCAtIHRyZWF0IGl0IGFzIGEgc2NhbGFyLlxuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICh0YXJnZXQgYXMgeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0pW3Byb3BdID0gZGVlcEV4dGVuZChcbiAgICAgICh0YXJnZXQgYXMgeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0pW3Byb3BdLFxuICAgICAgKHNvdXJjZSBhcyB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfSlbcHJvcF1cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQ8Uj4ge1xuICBwcm9taXNlOiBQcm9taXNlPFI+O1xuICByZWplY3Q6ICh2YWx1ZT86IHVua25vd24pID0+IHZvaWQ7XG4gIHJlc29sdmU6ICh2YWx1ZT86IHVua25vd24pID0+IHZvaWQ7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdXIgQVBJIGludGVybmFscyBhcmUgbm90IHByb21pc2VpZmllZCBhbmQgY2Fubm90IGJlY2F1c2Ugb3VyIGNhbGxiYWNrIEFQSXMgaGF2ZSBzdWJ0bGUgZXhwZWN0YXRpb25zIGFyb3VuZFxuICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xuICAgKiBhbmQgcmV0dXJucyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgd2hpY2ggd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgRGVmZXJyZWQncyBwcm9taXNlLlxuICAgKi9cbiAgd3JhcENhbGxiYWNrKFxuICAgIGNhbGxiYWNrPzogKGVycm9yPzogdW5rbm93biwgdmFsdWU/OiB1bmtub3duKSA9PiB2b2lkXG4gICk6IChlcnJvcjogdW5rbm93biwgdmFsdWU/OiB1bmtub3duKSA9PiB2b2lkIHtcbiAgICByZXR1cm4gKGVycm9yLCB2YWx1ZT8pID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBBdHRhY2hpbmcgbm9vcCBoYW5kbGVyIGp1c3QgaW4gY2FzZSBkZXZlbG9wZXIgd2Fzbid0IGV4cGVjdGluZ1xuICAgICAgICAvLyBwcm9taXNlc1xuICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuXG4gICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xuICAgICAgICAvLyBhc3NlcnQgdGhhdCB0aGUgcGFyYW1ldGVyIGxlbmd0aCBpcyAxXG4gICAgICAgIGlmIChjYWxsYmFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogUmV0dXJucyBuYXZpZ2F0b3IudXNlckFnZW50IHN0cmluZyBvciAnJyBpZiBpdCdzIG5vdCBkZWZpbmVkLlxuICogQHJldHVybiB1c2VyIGFnZW50IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VUEoKTogc3RyaW5nIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvclsndXNlckFnZW50J10gPT09ICdzdHJpbmcnXG4gICkge1xuICAgIHJldHVybiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vKipcbiAqIERldGVjdCBDb3Jkb3ZhIC8gUGhvbmVHYXAgLyBJb25pYyBmcmFtZXdvcmtzIG9uIGEgbW9iaWxlIGRldmljZS5cbiAqXG4gKiBEZWxpYmVyYXRlbHkgZG9lcyBub3QgcmVseSBvbiBjaGVja2luZyBgZmlsZTovL2AgVVJMcyAoYXMgdGhpcyBmYWlscyBQaG9uZUdhcFxuICogaW4gdGhlIFJpcHBsZSBlbXVsYXRvcikgbm9yIENvcmRvdmEgYG9uRGV2aWNlUmVhZHlgLCB3aGljaCB3b3VsZCBub3JtYWxseVxuICogd2FpdCBmb3IgYSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlQ29yZG92YSgpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC8vIEB0cy1pZ25vcmUgU2V0dGluZyB1cCBhbiBicm9hZGx5IGFwcGxpY2FibGUgaW5kZXggc2lnbmF0dXJlIGZvciBXaW5kb3dcbiAgICAvLyBqdXN0IHRvIGRlYWwgd2l0aCB0aGlzIGNhc2Ugd291bGQgcHJvYmFibHkgYmUgYSBiYWQgaWRlYS5cbiAgICAhISh3aW5kb3dbJ2NvcmRvdmEnXSB8fCB3aW5kb3dbJ3Bob25lZ2FwJ10gfHwgd2luZG93WydQaG9uZUdhcCddKSAmJlxuICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGdldFVBKCkpXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZWN0IE5vZGUuanMuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQuXG4gKi9cbi8vIE5vZGUgZGV0ZWN0aW9uIGxvZ2ljIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9pbGlha2FuL2RldGVjdC1ub2RlL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZSgpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVjdCBCcm93c2VyIEVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXIoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmO1xufVxuXG4vKipcbiAqIERldGVjdCBSZWFjdCBOYXRpdmUuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3JbJ3Byb2R1Y3QnXSA9PT0gJ1JlYWN0TmF0aXZlJ1xuICApO1xufVxuXG4vKipcbiAqIERldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IFNESyBidWlsZCBpcyB0aGUgTm9kZSB2ZXJzaW9uLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHRoZSBOb2RlIFNESyBidWlsZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVNkaygpOiBib29sZWFuIHtcbiAgcmV0dXJuIENPTlNUQU5UUy5OT0RFX0NMSUVOVCA9PT0gdHJ1ZSB8fCBDT05TVEFOVFMuTk9ERV9BRE1JTiA9PT0gdHJ1ZTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbkV2YWwoc3RyOiBzdHJpbmcpOiB1bmtub3duIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YXNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkoZGF0YTogdW5rbm93bik6IHN0cmluZyB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBiYXNlNjREZWNvZGUgfSBmcm9tICcuL2NyeXB0JztcbmltcG9ydCB7IGpzb25FdmFsIH0gZnJvbSAnLi9qc29uJztcblxuaW50ZXJmYWNlIENsYWltcyB7XG4gIFtrZXk6IHN0cmluZ106IHt9O1xufVxuXG5pbnRlcmZhY2UgRGVjb2RlZFRva2VuIHtcbiAgaGVhZGVyOiBvYmplY3Q7XG4gIGNsYWltczogQ2xhaW1zO1xuICBkYXRhOiBvYmplY3Q7XG4gIHNpZ25hdHVyZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBpbnRvIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIHdpdGggaW52YWxpZCAvIGluY29tcGxldGUgY2xhaW1zIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uKHRva2VuOiBzdHJpbmcpOiBEZWNvZGVkVG9rZW4ge1xuICBsZXQgaGVhZGVyID0ge30sXG4gICAgY2xhaW1zOiBDbGFpbXMgPSB7fSxcbiAgICBkYXRhID0ge30sXG4gICAgc2lnbmF0dXJlID0gJyc7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgaGVhZGVyID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzBdKSB8fCAnJykgYXMgb2JqZWN0O1xuICAgIGNsYWltcyA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1sxXSkgfHwgJycpIGFzIENsYWltcztcbiAgICBzaWduYXR1cmUgPSBwYXJ0c1syXTtcbiAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XG4gICAgZGVsZXRlIGNsYWltc1snZCddO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHJldHVybiB7XG4gICAgaGVhZGVyLFxuICAgIGNsYWltcyxcbiAgICBkYXRhLFxuICAgIHNpZ25hdHVyZVxuICB9O1xufTtcblxuaW50ZXJmYWNlIERlY29kZWRUb2tlbiB7XG4gIGhlYWRlcjogb2JqZWN0O1xuICBjbGFpbXM6IENsYWltcztcbiAgZGF0YTogb2JqZWN0O1xuICBzaWduYXR1cmU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIHRpbWUtYmFzZWQgY2xhaW1zLiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZVxuICogdG9rZW4gaXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvdyBhdXRob3JpemVkIGJ5IHRoZSAnbmJmJyAobm90LWJlZm9yZSkgYW5kICdpYXQnIChpc3N1ZWQtYXQpIGNsYWltcy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbih0b2tlbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNsYWltczogQ2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gIGNvbnN0IG5vdzogbnVtYmVyID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuICBsZXQgdmFsaWRTaW5jZTogbnVtYmVyID0gMCxcbiAgICB2YWxpZFVudGlsOiBudW1iZXIgPSAwO1xuXG4gIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ25iZicpKSB7XG4gICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWyduYmYnXSBhcyBudW1iZXI7XG4gICAgfSBlbHNlIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XG4gICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWydpYXQnXSBhcyBudW1iZXI7XG4gICAgfVxuXG4gICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcbiAgICAgIHZhbGlkVW50aWwgPSBjbGFpbXNbJ2V4cCddIGFzIG51bWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgMjRoIGJ5IGRlZmF1bHRcbiAgICAgIHZhbGlkVW50aWwgPSB2YWxpZFNpbmNlICsgODY0MDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICAhIW5vdyAmJlxuICAgICEhdmFsaWRTaW5jZSAmJlxuICAgICEhdmFsaWRVbnRpbCAmJlxuICAgIG5vdyA+PSB2YWxpZFNpbmNlICYmXG4gICAgbm93IDw9IHZhbGlkVW50aWxcbiAgKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCByZXR1cm5zIGl0cyBpc3N1ZWQgYXQgdGltZSBpZiB2YWxpZCwgbnVsbCBvdGhlcndpc2UuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gbnVsbCBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmV4cG9ydCBjb25zdCBpc3N1ZWRBdFRpbWUgPSBmdW5jdGlvbih0b2tlbjogc3RyaW5nKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IGNsYWltczogQ2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XG4gICAgcmV0dXJuIGNsYWltc1snaWF0J10gYXMgbnVtYmVyO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIGZvcm1hdC4gRXhwZWN0cyBhIHZhbGlkIGlzc3VlZC1hdCB0aW1lLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uKHRva2VuOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0b2tlbiksXG4gICAgY2xhaW1zID0gZGVjb2RlZC5jbGFpbXM7XG5cbiAgcmV0dXJuICEhY2xhaW1zICYmIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0Jyk7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5leHBvcnQgY29uc3QgaXNBZG1pbiA9IGZ1bmN0aW9uKHRva2VuOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgY2xhaW1zOiBDbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIHdpbGwgZW5hYmxlIGFmdGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvcHVsbC8xODExIGlzIG1lcmdlZFxuXG5pbnRlcmZhY2UgVXRpbE9iamVjdDxWPiB7XG4gIFtrZXk6IHN0cmluZ106IFY7XG59XG5cbi8vIFNlZSBodHRwOi8vd3d3LmRldnRob3VnaHQuY29tLzIwMTIvMDEvMTgvYW4tb2JqZWN0LWlzLW5vdC1hLWhhc2gvXG5leHBvcnQgY29uc3QgY29udGFpbnMgPSBmdW5jdGlvbjxWPihvYmo6IFV0aWxPYmplY3Q8Vj4sIGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNhZmVHZXQgPSBmdW5jdGlvbjxWPihcbiAgb2JqOiBVdGlsT2JqZWN0PFY+LFxuICBrZXk6IHN0cmluZ1xuKTogViB8IHVuZGVmaW5lZCB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXR1cm4gb2JqW2tleV07XG4gIC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZC5cbn07XG5cbi8qKlxuICogRW51bWVyYXRlcyB0aGUga2V5cy92YWx1ZXMgaW4gYW4gb2JqZWN0LCBleGNsdWRpbmcga2V5cyBkZWZpbmVkIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHs/T2JqZWN0LjxLLFY+fSBvYmogT2JqZWN0IHRvIGVudW1lcmF0ZS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKEssIFYpfSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGtleSBhbmQgdmFsdWUuXG4gKiBAdGVtcGxhdGUgSyxWXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoID0gZnVuY3Rpb248Vj4oXG4gIG9iajogVXRpbE9iamVjdDxWPixcbiAgZm46IChrZXk6IHN0cmluZywgdmFsdWU6IFYpID0+IHZvaWRcbik6IHZvaWQge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgZm4oa2V5LCBvYmpba2V5XSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENvcGllcyBhbGwgdGhlIChvd24pIHByb3BlcnRpZXMgZnJvbSBvbmUgb2JqZWN0IHRvIGFub3RoZXIuXG4gKiBAcGFyYW0geyFPYmplY3R9IG9ialRvXG4gKiBAcGFyYW0geyFPYmplY3R9IG9iakZyb21cbiAqIEByZXR1cm4geyFPYmplY3R9IG9ialRvXG4gKi9cbmV4cG9ydCBjb25zdCBleHRlbmQgPSBmdW5jdGlvbjxWPihcbiAgb2JqVG86IFV0aWxPYmplY3Q8Vj4sXG4gIG9iakZyb206IFV0aWxPYmplY3Q8Vj5cbik6IFV0aWxPYmplY3Q8Vj4ge1xuICBmb3JFYWNoKG9iakZyb20sIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBvYmpUb1trZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gb2JqVG87XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBjbG9uZWQgb2JqLlxuICovXG5leHBvcnQgY29uc3QgY2xvbmUgPSBmdW5jdGlvbjxWPihvYmo6IFV0aWxPYmplY3Q8Vj4pIHtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgb2JqKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBoYXMgdHlwZW9mIFwib2JqZWN0XCIgYW5kIGlzIG5vdCBudWxsLiAgVW5saWtlIGdvb2cuaXNPYmplY3QoKSwgZG9lcyBub3QgcmV0dXJuIHRydWVcbiAqIGZvciBmdW5jdGlvbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBpc05vbk51bGxPYmplY3QgPSBmdW5jdGlvbjxWPihvYmo6IFV0aWxPYmplY3Q8Vj4pOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0VtcHR5ID0gZnVuY3Rpb248Vj4ob2JqOiBVdGlsT2JqZWN0PFY+KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q291bnQgPSBmdW5jdGlvbjxWPihvYmo6IFV0aWxPYmplY3Q8Vj4pOiBudW1iZXIge1xuICB2YXIgcnYgPSAwO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgcnYrKztcbiAgfVxuICByZXR1cm4gcnY7XG59O1xuXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb248Vj4oXG4gIG9iajogVXRpbE9iamVjdDxWPixcbiAgZm46ICh2YWx1ZTogViwga2V5OiBzdHJpbmcgfCBudW1iZXIsIG9iajogVXRpbE9iamVjdDxWPikgPT4gdW5rbm93bixcbiAgY29udGV4dD86IHVua25vd25cbikge1xuICB2YXIgcmVzOiBVdGlsT2JqZWN0PFY+ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICByZXNba2V5XSA9IGZuLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbmRLZXkgPSBmdW5jdGlvbjxWPihcbiAgb2JqOiBVdGlsT2JqZWN0PFY+LFxuICBmbjogKHZhbHVlOiBWLCBrZXk6IHN0cmluZyB8IG51bWJlciwgb2JqOiBVdGlsT2JqZWN0PFY+KSA9PiB1bmtub3duLFxuICBjb250ZXh0PzogdW5rbm93blxuKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoZm4uY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbmRWYWx1ZSA9IGZ1bmN0aW9uPFY+KFxuICBvYmo6IFV0aWxPYmplY3Q8Vj4sXG4gIGZuOiAodmFsdWU6IFYsIGtleTogc3RyaW5nIHwgbnVtYmVyLCBvYmo6IFV0aWxPYmplY3Q8Vj4pID0+IHVua25vd24sXG4gIGNvbnRleHQ/OiB1bmtub3duXG4pIHtcbiAgdmFyIGtleSA9IGZpbmRLZXkob2JqLCBmbiwgY29udGV4dCk7XG4gIHJldHVybiBrZXkgJiYgb2JqW2tleV07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QW55S2V5ID0gZnVuY3Rpb248Vj4ob2JqOiBVdGlsT2JqZWN0PFY+KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICByZXR1cm4ga2V5O1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VmFsdWVzID0gZnVuY3Rpb248Vj4ob2JqOiBVdGlsT2JqZWN0PFY+KSB7XG4gIHZhciByZXM6IFZbXSA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICByZXNbaSsrXSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgZXZlcnkga2V5L3ZhbHVlIHBhaXIgaW4gYW4gb2JqZWN0IHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWRcbiAqIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7P09iamVjdC48SyxWPn0gb2JqIE9iamVjdCB0byB0ZXN0LlxuICogQHBhcmFtIHshZnVuY3Rpb24oSywgVil9IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2gga2V5IGFuZCB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBLLFZcbiAqL1xuZXhwb3J0IGNvbnN0IGV2ZXJ5ID0gZnVuY3Rpb248Vj4oXG4gIG9iajogVXRpbE9iamVjdDxWPixcbiAgZm46IChrOiBzdHJpbmcsIHY/OiBWKSA9PiBib29sZWFuXG4pOiBib29sZWFuIHtcbiAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBpZiAoIWZuKGtleSwgb2JqW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGZvckVhY2ggfSBmcm9tICcuL29iaic7XG5cbi8qKlxuICogUmV0dXJucyBhIHF1ZXJ5c3RyaW5nLWZvcm1hdHRlZCBzdHJpbmcgKGUuZy4gJmFyZz12YWwmYXJnMj12YWwyKSBmcm9tIGEgcGFyYW1zXG4gKiBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXG4gKiBOb3RlOiBZb3UgbXVzdCBwcmVwZW5kIGl0IHdpdGggPyB3aGVuIGFkZGluZyBpdCB0byBhIFVSTC5cbiAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5c3RyaW5nID0gZnVuY3Rpb248Vj4ocXVlcnlzdHJpbmdQYXJhbXM6IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nO1xufSk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcmFtczogc3RyaW5nW10gPSBbXTtcbiAgZm9yRWFjaChxdWVyeXN0cmluZ1BhcmFtcywgKGtleTogc3RyaW5nLCB2YWx1ZSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChhcnJheVZhbCA9PiB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFxuICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBhcmFtcy5sZW5ndGggPyAnJicgKyBwYXJhbXMuam9pbignJicpIDogJyc7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBxdWVyeXN0cmluZyAoZS5nLiA/YXJnPXZhbCZhcmcyPXZhbDIpIGludG8gYSBwYXJhbXMgb2JqZWN0IChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeXN0cmluZ1xuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5c3RyaW5nRGVjb2RlID0gZnVuY3Rpb24ocXVlcnlzdHJpbmc6IHN0cmluZyk6IG9iamVjdCB7XG4gIGNvbnN0IG9iajogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0gPSB7fTtcbiAgY29uc3QgdG9rZW5zID0gcXVlcnlzdHJpbmcucmVwbGFjZSgvXlxcPy8sICcnKS5zcGxpdCgnJicpO1xuXG4gIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGNvbnN0IGtleSA9IHRva2VuLnNwbGl0KCc9Jyk7XG4gICAgICBvYmpba2V5WzBdXSA9IGtleVsxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxuICogVmFyaWFibGUgbmFtZXMgZm9sbG93IHRoZSBub3RhdGlvbiBpbiBGSVBTIFBVQiAxODAtMzpcbiAqIGh0dHA6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtMy9maXBzMTgwLTNfZmluYWwucGRmLlxuICpcbiAqIFVzYWdlOlxuICogICB2YXIgc2hhMSA9IG5ldyBzaGExKCk7XG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcbiAqICAgdmFyIGhhc2ggPSBzaGExLmRpZ2VzdCgpO1xuICpcbiAqIFBlcmZvcm1hbmNlOlxuICogICBDaHJvbWUgMjM6ICAgfjQwMCBNYml0L3NcbiAqICAgRmlyZWZveCAxNjogIH4yNTAgTWJpdC9zXG4gKlxuICovXG5cbi8qKlxuICogU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoIGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSBwcm9wZXJ0aWVzIGRlY2xhcmVkIGhlcmUgYXJlIGRpc2N1c3NlZCBpbiB0aGUgYWJvdmUgYWxnb3JpdGhtIGRvY3VtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqL1xuZXhwb3J0IGNsYXNzIFNoYTEge1xuICAvKipcbiAgICogSG9sZHMgdGhlIHByZXZpb3VzIHZhbHVlcyBvZiBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYS1lIGluIHRoZSBjb21wcmVzc19cbiAgICogZnVuY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNoYWluXzogbnVtYmVyW10gPSBbXTtcblxuICAvKipcbiAgICogQSBidWZmZXIgaG9sZGluZyB0aGUgcGFydGlhbGx5IGNvbXB1dGVkIGhhc2ggcmVzdWx0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBidWZfOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiA4MCBieXRlcywgZWFjaCBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gYmUgaGFzaGVkLiAgUmVmZXJyZWQgdG9cbiAgICogYXMgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgaW4gdGhlIGRvY3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIFdfOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBDb250YWlucyBkYXRhIG5lZWRlZCB0byBwYWQgbWVzc2FnZXMgbGVzcyB0aGFuIDY0IGJ5dGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBwYWRfOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgKi9cbiAgcHJpdmF0ZSBpbmJ1Zl86IG51bWJlciA9IDA7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAqL1xuICBwcml2YXRlIHRvdGFsXzogbnVtYmVyID0gMDtcblxuICBibG9ja1NpemU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJsb2NrU2l6ZSA9IDUxMiAvIDg7XG5cbiAgICB0aGlzLnBhZF9bMF0gPSAxMjg7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgKytpKSB7XG4gICAgICB0aGlzLnBhZF9baV0gPSAwO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY2hhaW5fWzBdID0gMHg2NzQ1MjMwMTtcbiAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XG4gICAgdGhpcy5jaGFpbl9bMl0gPSAweDk4YmFkY2ZlO1xuICAgIHRoaXMuY2hhaW5fWzNdID0gMHgxMDMyNTQ3NjtcbiAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XG5cbiAgICB0aGlzLmluYnVmXyA9IDA7XG4gICAgdGhpcy50b3RhbF8gPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGNvbXByZXNzIGhlbHBlciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cbiAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgb2YgdGhlIGJsb2NrIGluIHRoZSBidWZmZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wcmVzc18oYnVmOiBudW1iZXJbXSB8IFVpbnQ4QXJyYXkgfCBzdHJpbmcsIG9mZnNldD86IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IFcgPSB0aGlzLldfO1xuXG4gICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcbiAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXG4gICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XG4gICAgICAgIC8vIGR1cmluZyBKSVQgY29tcGlsYXRpb24uICBXZSBoYXZlIGNvZGUgdGhhdCBkZXBlbmRzIGhlYXZpbHkgb24gU0hBLTEgZm9yXG4gICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXG4gICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcbiAgICAgICAgLy8gdGhpcyBjaGFuZ2Ugb25jZSB0aGUgU2FmYXJpIGJ1Z1xuICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXG4gICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgV1tpXSA9XG4gICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQpIHxcbiAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYpIHxcbiAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxuICAgICAgICAgIGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDMpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIFdbaV0gPVxuICAgICAgICAgIChidWZbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgICAgIChidWZbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICBidWZbb2Zmc2V0ICsgM107XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4cGFuZCB0byA4MCB3b3Jkc1xuICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGNvbnN0IHQgPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuICAgICAgV1tpXSA9ICgodCA8PCAxKSB8ICh0ID4+PiAzMSkpICYgMHhmZmZmZmZmZjtcbiAgICB9XG5cbiAgICBsZXQgYSA9IHRoaXMuY2hhaW5fWzBdO1xuICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XG4gICAgbGV0IGMgPSB0aGlzLmNoYWluX1syXTtcbiAgICBsZXQgZCA9IHRoaXMuY2hhaW5fWzNdO1xuICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XG4gICAgbGV0IGYsIGs7XG5cbiAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDQwKSB7XG4gICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XG4gICAgICAgICAgayA9IDB4NWE4Mjc5OTk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICBrID0gMHg2ZWQ5ZWJhMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGkgPCA2MCkge1xuICAgICAgICAgIGYgPSAoYiAmIGMpIHwgKGQgJiAoYiB8IGMpKTtcbiAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XG4gICAgdGhpcy5jaGFpbl9bMV0gPSAodGhpcy5jaGFpbl9bMV0gKyBiKSAmIDB4ZmZmZmZmZmY7XG4gICAgdGhpcy5jaGFpbl9bMl0gPSAodGhpcy5jaGFpbl9bMl0gKyBjKSAmIDB4ZmZmZmZmZmY7XG4gICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XG4gICAgdGhpcy5jaGFpbl9bNF0gPSAodGhpcy5jaGFpbl9bNF0gKyBlKSAmIDB4ZmZmZmZmZmY7XG4gIH1cblxuICB1cGRhdGUoYnl0ZXM/OiBudW1iZXJbXSB8IFVpbnQ4QXJyYXkgfCBzdHJpbmcsIGxlbmd0aD86IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFRPRE8oam9obmxlbnopOiB0aWdodGVuIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgYW5kIHJlbW92ZSB0aGlzIGNoZWNrXG4gICAgaWYgKGJ5dGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGhNaW51c0Jsb2NrID0gbGVuZ3RoIC0gdGhpcy5ibG9ja1NpemU7XG4gICAgbGV0IG4gPSAwO1xuICAgIC8vIFVzaW5nIGxvY2FsIGluc3RlYWQgb2YgbWVtYmVyIHZhcmlhYmxlcyBnaXZlcyB+NSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LlxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuYnVmXztcbiAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcblxuICAgIC8vIFRoZSBvdXRlciB3aGlsZSBsb29wIHNob3VsZCBleGVjdXRlIGF0IG1vc3QgdHdpY2UuXG4gICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxuICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcbiAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcbiAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cbiAgICAgIGlmIChpbmJ1ZiA9PT0gMCkge1xuICAgICAgICB3aGlsZSAobiA8PSBsZW5ndGhNaW51c0Jsb2NrKSB7XG4gICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xuICAgICAgICAgIG4gKz0gdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXMuY2hhckNvZGVBdChuKTtcbiAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICsrbjtcbiAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xuICAgICAgICAgICAgaW5idWYgPSAwO1xuICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xuICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlc1tuXTtcbiAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICsrbjtcbiAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xuICAgICAgICAgICAgaW5idWYgPSAwO1xuICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmJ1Zl8gPSBpbmJ1ZjtcbiAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRpZ2VzdCgpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgZGlnZXN0OiBudW1iZXJbXSA9IFtdO1xuICAgIGxldCB0b3RhbEJpdHMgPSB0aGlzLnRvdGFsXyAqIDg7XG5cbiAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXG4gICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcbiAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgNTYgLSB0aGlzLmluYnVmXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgdGhpcy5ibG9ja1NpemUgLSAodGhpcy5pbmJ1Zl8gLSA1NikpO1xuICAgIH1cblxuICAgIC8vIEFkZCAjIGJpdHMuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuYmxvY2tTaXplIC0gMTsgaSA+PSA1NjsgaS0tKSB7XG4gICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XG4gICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXG4gICAgfVxuXG4gICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcblxuICAgIGxldCBuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgICBkaWdlc3Rbbl0gPSAodGhpcy5jaGFpbl9baV0gPj4gaikgJiAyNTU7XG4gICAgICAgICsrbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZ2VzdDtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgdHlwZSBOZXh0Rm48VD4gPSAodmFsdWU6IFQpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBFcnJvckZuID0gKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIENvbXBsZXRlRm4gPSAoKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9ic2VydmVyPFQ+IHtcbiAgLy8gQ2FsbGVkIG9uY2UgZm9yIGVhY2ggdmFsdWUgaW4gYSBzdHJlYW0gb2YgdmFsdWVzLlxuICBuZXh0OiBOZXh0Rm48VD47XG5cbiAgLy8gQSBzdHJlYW0gdGVybWluYXRlcyBieSBhIHNpbmdsZSBjYWxsIHRvIEVJVEhFUiBlcnJvcigpIG9yIGNvbXBsZXRlKCkuXG4gIGVycm9yOiBFcnJvckZuO1xuXG4gIC8vIE5vIGV2ZW50cyB3aWxsIGJlIHNlbnQgdG8gbmV4dCgpIG9uY2UgY29tcGxldGUoKSBpcyBjYWxsZWQuXG4gIGNvbXBsZXRlOiBDb21wbGV0ZUZuO1xufVxuXG5leHBvcnQgdHlwZSBQYXJ0aWFsT2JzZXJ2ZXI8VD4gPSBQYXJ0aWFsPE9ic2VydmVyPFQ+PjtcblxuLy8gVE9ETzogU3VwcG9ydCBhbHNvIFVuc3Vic2NyaWJlLnVuc3Vic2NyaWJlP1xuZXhwb3J0IHR5cGUgVW5zdWJzY3JpYmUgPSAoKSA9PiB2b2lkO1xuXG4vKipcbiAqIFRoZSBTdWJzY3JpYmUgaW50ZXJmYWNlIGhhcyB0d28gZm9ybXMgLSBwYXNzaW5nIHRoZSBpbmxpbmUgZnVuY3Rpb25cbiAqIGNhbGxiYWNrcywgb3IgYSBvYmplY3QgaW50ZXJmYWNlIHdpdGggY2FsbGJhY2sgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpYmU8VD4ge1xuICAobmV4dD86IE5leHRGbjxUPiwgZXJyb3I/OiBFcnJvckZuLCBjb21wbGV0ZT86IENvbXBsZXRlRm4pOiBVbnN1YnNjcmliZTtcbiAgKG9ic2VydmVyOiBQYXJ0aWFsT2JzZXJ2ZXI8VD4pOiBVbnN1YnNjcmliZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgLy8gU3Vic2NyaWJlIG1ldGhvZFxuICBzdWJzY3JpYmU6IFN1YnNjcmliZTxUPjtcbn1cblxuZXhwb3J0IHR5cGUgRXhlY3V0b3I8VD4gPSAob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB2b2lkO1xuXG4vKipcbiAqIEhlbHBlciB0byBtYWtlIGEgU3Vic2NyaWJlIGZ1bmN0aW9uIChqdXN0IGxpa2UgUHJvbWlzZSBoZWxwcyBtYWtlIGFcbiAqIFRoZW5hYmxlKS5cbiAqXG4gKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAqICAgICBhcyBhIHByb3h5LlxuICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlPFQ+KFxuICBleGVjdXRvcjogRXhlY3V0b3I8VD4sXG4gIG9uTm9PYnNlcnZlcnM/OiBFeGVjdXRvcjxUPlxuKTogU3Vic2NyaWJlPFQ+IHtcbiAgY29uc3QgcHJveHkgPSBuZXcgT2JzZXJ2ZXJQcm94eTxUPihleGVjdXRvciwgb25Ob09ic2VydmVycyk7XG4gIHJldHVybiBwcm94eS5zdWJzY3JpYmUuYmluZChwcm94eSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50IGZhbi1vdXQgZm9yIGFueSBudW1iZXIgb2YgT2JzZXJ2ZXJzIGF0dGFjaGVkIHZpYSBhIHN1YnNjcmliZVxuICogZnVuY3Rpb24uXG4gKi9cbmNsYXNzIE9ic2VydmVyUHJveHk8VD4gaW1wbGVtZW50cyBPYnNlcnZlcjxUPiB7XG4gIHByaXZhdGUgb2JzZXJ2ZXJzOiBBcnJheTxPYnNlcnZlcjxUPj4gfCB1bmRlZmluZWQgPSBbXTtcbiAgcHJpdmF0ZSB1bnN1YnNjcmliZXM6IFVuc3Vic2NyaWJlW10gPSBbXTtcbiAgcHJpdmF0ZSBvbk5vT2JzZXJ2ZXJzOiBFeGVjdXRvcjxUPiB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBvYnNlcnZlckNvdW50ID0gMDtcbiAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXG4gIHByaXZhdGUgdGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBwcml2YXRlIGZpbmFsaXplZCA9IGZhbHNlO1xuICBwcml2YXRlIGZpbmFsRXJyb3I6IEVycm9yO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAgICogICAgIGFzIGEgcHJveHkuXG4gICAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yOiBFeGVjdXRvcjxUPiwgb25Ob09ic2VydmVycz86IEV4ZWN1dG9yPFQ+KSB7XG4gICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gb25Ob09ic2VydmVycztcbiAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcbiAgICAvLyBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgc3Vic2NyaWJlIGZ1bmN0aW9uXG4gICAgLy8gY2FuIHN0aWxsIHJlY2VpdmUgdGhlIHZlcnkgZmlyc3QgdmFsdWUgZ2VuZXJhdGVkIGluIHRoZSBleGVjdXRvci5cbiAgICB0aGlzLnRhc2tcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZXhlY3V0b3IodGhpcyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgfSk7XG4gIH1cblxuICBuZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xuICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBlcnJvcihlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XG4gICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgdGhpcy5jbG9zZShlcnJvcik7XG4gIH1cblxuICBjb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XG4gICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYW4gT2JzZXJ2ZXIgdG8gdGhlIGZhbi1vdXQgbGlzdC5cbiAgICpcbiAgICogLSBXZSByZXF1aXJlIHRoYXQgbm8gZXZlbnQgaXMgc2VudCB0byBhIHN1YnNjcmliZXIgc3ljaHJvbm91c2x5IHRvIHRoZWlyXG4gICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cbiAgICovXG4gIHN1YnNjcmliZShcbiAgICBuZXh0T3JPYnNlcnZlcjogUGFydGlhbE9ic2VydmVyPFQ+IHwgRnVuY3Rpb24sXG4gICAgZXJyb3I/OiBFcnJvckZuLFxuICAgIGNvbXBsZXRlPzogQ29tcGxldGVGblxuICApOiBVbnN1YnNjcmliZSB7XG4gICAgbGV0IG9ic2VydmVyOiBPYnNlcnZlcjxUPjtcblxuICAgIGlmIChcbiAgICAgIG5leHRPck9ic2VydmVyID09PSB1bmRlZmluZWQgJiZcbiAgICAgIGVycm9yID09PSB1bmRlZmluZWQgJiZcbiAgICAgIGNvbXBsZXRlID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBPYnNlcnZlci4nKTtcbiAgICB9XG5cbiAgICAvLyBBc3NlbWJsZSBhbiBPYnNlcnZlciBvYmplY3Qgd2hlbiBwYXNzZWQgYXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgIGlmIChpbXBsZW1lbnRzQW55TWV0aG9kcyhuZXh0T3JPYnNlcnZlciwgWyduZXh0JywgJ2Vycm9yJywgJ2NvbXBsZXRlJ10pKSB7XG4gICAgICBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyIGFzIE9ic2VydmVyPFQ+O1xuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgbmV4dDogbmV4dE9yT2JzZXJ2ZXIgYXMgTmV4dEZuPFQ+LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgY29tcGxldGVcbiAgICAgIH0gYXMgT2JzZXJ2ZXI8VD47XG4gICAgfVxuXG4gICAgaWYgKG9ic2VydmVyLm5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXIubmV4dCA9IG5vb3AgYXMgTmV4dEZuPFQ+O1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBub29wIGFzIEVycm9yRm47XG4gICAgfVxuICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IG5vb3AgYXMgQ29tcGxldGVGbjtcbiAgICB9XG5cbiAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycyEubGVuZ3RoKTtcblxuICAgIC8vIEF0dGVtcHQgdG8gc3Vic2NyaWJlIHRvIGEgdGVybWluYXRlZCBPYnNlcnZhYmxlIC0gd2VcbiAgICAvLyBqdXN0IHJlc3BvbmQgdG8gdGhlIE9ic2VydmVyIHdpdGggdGhlIGZpbmFsIGVycm9yIG9yIGNvbXBsZXRlXG4gICAgLy8gZXZlbnQuXG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodGhpcy5maW5hbEVycm9yKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcih0aGlzLmZpbmFsRXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm9ic2VydmVycyEucHVzaChvYnNlcnZlciBhcyBPYnNlcnZlcjxUPik7XG5cbiAgICByZXR1cm4gdW5zdWI7XG4gIH1cblxuICAvLyBVbnN1YnNjcmliZSBpcyBzeW5jaHJvbm91cyAtIHdlIGd1YXJhbnRlZSB0aGF0IG5vIGV2ZW50cyBhcmUgc2VudCB0b1xuICAvLyBhbnkgdW5zdWJzY3JpYmVkIE9ic2VydmVyLlxuICBwcml2YXRlIHVuc3Vic2NyaWJlT25lKGk6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLm9ic2VydmVycyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub2JzZXJ2ZXJzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbaV07XG5cbiAgICB0aGlzLm9ic2VydmVyQ291bnQgLT0gMTtcbiAgICBpZiAodGhpcy5vYnNlcnZlckNvdW50ID09PSAwICYmIHRoaXMub25Ob09ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9uTm9PYnNlcnZlcnModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmb3JFYWNoT2JzZXJ2ZXIoZm46IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIC8vIEFscmVhZHkgY2xvc2VkIGJ5IHByZXZpb3VzIGV2ZW50Li4uLmp1c3QgZWF0IHRoZSBhZGRpdGlvbmFsIHZhbHVlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSBzZW5kT25lIGNhbGxzIGFzeW5jaHJvbm91c2x5IC0gdGhlcmUgaXMgbm8gY2hhbmNlIHRoYXRcbiAgICAvLyB0aGlzLm9ic2VydmVycyB3aWxsIGJlY29tZSB1bmRlZmluZWQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycyEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc2VuZE9uZShpLCBmbik7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbCB0aGUgT2JzZXJ2ZXIgdmlhIG9uZSBvZiBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uLiBXZSBhcmUgY2FyZWZ1bCB0b1xuICAvLyBjb25maXJtIHRoYXQgdGhlIG9ic2VydmUgaGFzIG5vdCBiZWVuIHVuc3Vic2NyaWJlZCBzaW5jZSB0aGlzIGFzeW5jaHJvbm91c1xuICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXG4gIHByaXZhdGUgc2VuZE9uZShpOiBudW1iZXIsIGZuOiAob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgLy8gRXhlY3V0ZSB0aGUgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHlcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy5vYnNlcnZlcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9ic2VydmVyc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm4odGhpcy5vYnNlcnZlcnNbaV0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGV4Y2VwdGlvbnMgcmFpc2VkIGluIE9ic2VydmVycyBvciBtaXNzaW5nIG1ldGhvZHMgb2YgYW5cbiAgICAgICAgICAvLyBPYnNlcnZlci5cbiAgICAgICAgICAvLyBMb2cgZXJyb3IgdG8gY29uc29sZS4gYi8zMTQwNDgwNlxuICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY2xvc2UoZXJyPzogRXJyb3IpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xuICAgIH1cbiAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiogVHVybiBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIG9uZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICovXG5leHBvcnQgZnVuY3Rpb24gYXN5bmMoZm46IEZ1bmN0aW9uLCBvbkVycm9yPzogRXJyb3JGbik6IEZ1bmN0aW9uIHtcbiAgcmV0dXJuICguLi5hcmdzOiB1bmtub3duW10pID0+IHtcbiAgICBQcm9taXNlLnJlc29sdmUodHJ1ZSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaW1wbGVtZW50cyBhbnkgb2YgdGhlIG5hbWVkIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKFxuICBvYmo6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9LFxuICBtZXRob2RzOiBzdHJpbmdbXVxuKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKTogdm9pZCB7XG4gIC8vIGRvIG5vdGhpbmdcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxuICpcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcbiAqIEBwYXJhbSBtaW5Db3VudCBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIG1heENvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudCB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSBhcmdDb3VudCBUaGUgYWN0dWFsIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUFyZ0NvdW50ID0gZnVuY3Rpb24oXG4gIGZuTmFtZTogc3RyaW5nLFxuICBtaW5Db3VudDogbnVtYmVyLFxuICBtYXhDb3VudDogbnVtYmVyLFxuICBhcmdDb3VudDogbnVtYmVyXG4pOiB2b2lkIHtcbiAgbGV0IGFyZ0Vycm9yO1xuICBpZiAoYXJnQ291bnQgPCBtaW5Db3VudCkge1xuICAgIGFyZ0Vycm9yID0gJ2F0IGxlYXN0ICcgKyBtaW5Db3VudDtcbiAgfSBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XG4gICAgYXJnRXJyb3IgPSBtYXhDb3VudCA9PT0gMCA/ICdub25lJyA6ICdubyBtb3JlIHRoYW4gJyArIG1heENvdW50O1xuICB9XG4gIGlmIChhcmdFcnJvcikge1xuICAgIGNvbnN0IGVycm9yID1cbiAgICAgIGZuTmFtZSArXG4gICAgICAnIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoICcgK1xuICAgICAgYXJnQ291bnQgK1xuICAgICAgKGFyZ0NvdW50ID09PSAxID8gJyBhcmd1bWVudC4nIDogJyBhcmd1bWVudHMuJykgK1xuICAgICAgJyBFeHBlY3RzICcgK1xuICAgICAgYXJnRXJyb3IgK1xuICAgICAgJy4nO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIGFyZ3VtZW50TnVtYmVyIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnRcbiAqIEBwYXJhbSBvcHRpb25hbCBXaGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiAqIEByZXR1cm4gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yUHJlZml4KFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROdW1iZXI6IG51bWJlcixcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbik6IHN0cmluZyB7XG4gIGxldCBhcmdOYW1lID0gJyc7XG4gIHN3aXRjaCAoYXJndW1lbnROdW1iZXIpIHtcbiAgICBjYXNlIDE6XG4gICAgICBhcmdOYW1lID0gb3B0aW9uYWwgPyAnZmlyc3QnIDogJ0ZpcnN0JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGFyZ05hbWUgPSBvcHRpb25hbCA/ICdzZWNvbmQnIDogJ1NlY29uZCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBhcmdOYW1lID0gb3B0aW9uYWwgPyAndGhpcmQnIDogJ1RoaXJkJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGFyZ05hbWUgPSBvcHRpb25hbCA/ICdmb3VydGgnIDogJ0ZvdXJ0aCc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnZXJyb3JQcmVmaXggY2FsbGVkIHdpdGggYXJndW1lbnROdW1iZXIgPiA0LiAgTmVlZCB0byB1cGRhdGUgaXQ/J1xuICAgICAgKTtcbiAgfVxuXG4gIGxldCBlcnJvciA9IGZuTmFtZSArICcgZmFpbGVkOiAnO1xuXG4gIGVycm9yICs9IGFyZ05hbWUgKyAnIGFyZ3VtZW50ICc7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBAcGFyYW0gZm5OYW1lXG4gKiBAcGFyYW0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcbiAqIEBwYXJhbSBvcHRpb25hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVOYW1lc3BhY2UoXG4gIGZuTmFtZTogc3RyaW5nLFxuICBhcmd1bWVudE51bWJlcjogbnVtYmVyLFxuICBuYW1lc3BhY2U6IHN0cmluZyxcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbik6IHZvaWQge1xuICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvL1RPRE86IEkgc2hvdWxkIGRvIG1vcmUgdmFsaWRhdGlvbiBoZXJlLiBXZSBvbmx5IGFsbG93IGNlcnRhaW4gY2hhcnMgaW4gbmFtZXNwYWNlcy5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIG5hbWVzcGFjZS4nXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhcbiAgZm5OYW1lOiBzdHJpbmcsXG4gIGFyZ3VtZW50TnVtYmVyOiBudW1iZXIsXG4gIGNhbGxiYWNrOiBGdW5jdGlvbixcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbik6IHZvaWQge1xuICBpZiAob3B0aW9uYWwgJiYgIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGZ1bmN0aW9uLidcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRPYmplY3QoXG4gIGZuTmFtZTogc3RyaW5nLFxuICBhcmd1bWVudE51bWJlcjogbnVtYmVyLFxuICBjb250ZXh0OiB1bmtub3duLFxuICBvcHRpb25hbDogYm9vbGVhblxuKTogdm9pZCB7XG4gIGlmIChvcHRpb25hbCAmJiAhY29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGNvbnRleHQgb2JqZWN0LidcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi9hc3NlcnQnO1xuXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXG4vLyBzbyBpdCdzIGJlZW4gbW9kaWZpZWQuXG5cbi8vIE5vdGUgdGhhdCBub3QgYWxsIFVuaWNvZGUgY2hhcmFjdGVycyBhcHBlYXIgYXMgc2luZ2xlIGNoYXJhY3RlcnMgaW4gSmF2YVNjcmlwdCBzdHJpbmdzLlxuLy8gZnJvbUNoYXJDb2RlIHJldHVybnMgdGhlIFVURi0xNiBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciAtIHNvIHNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzXG4vLyB1c2UgMiBjaGFyYWN0ZXJzIGluIEphdmFzY3JpcHQuICBBbGwgNC1ieXRlIFVURi04IGNoYXJhY3RlcnMgYmVnaW4gd2l0aCBhIGZpcnN0XG4vLyBjaGFyYWN0ZXIgaW4gdGhlIHJhbmdlIDB4RDgwMCAtIDB4REJGRiAodGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHNvLWNhbGxlZCBzdXJyb2dhdGVcbi8vIHBhaXIpLlxuLy8gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xNS4xLjNcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24oc3RyOiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gIGNvbnN0IG91dDogbnVtYmVyW10gPSBbXTtcbiAgbGV0IHAgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAvLyBJcyB0aGlzIHRoZSBsZWFkIHN1cnJvZ2F0ZSBpbiBhIHN1cnJvZ2F0ZSBwYWlyP1xuICAgIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xuICAgICAgY29uc3QgaGlnaCA9IGMgLSAweGQ4MDA7IC8vIHRoZSBoaWdoIDEwIGJpdHMuXG4gICAgICBpKys7XG4gICAgICBhc3NlcnQoaSA8IHN0ci5sZW5ndGgsICdTdXJyb2dhdGUgcGFpciBtaXNzaW5nIHRyYWlsIHN1cnJvZ2F0ZS4nKTtcbiAgICAgIGNvbnN0IGxvdyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gMHhkYzAwOyAvLyB0aGUgbG93IDEwIGJpdHMuXG4gICAgICBjID0gMHgxMDAwMCArIChoaWdoIDw8IDEwKSArIGxvdztcbiAgICB9XG5cbiAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgb3V0W3ArK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgIH0gZWxzZSBpZiAoYyA8IDY1NTM2KSB7XG4gICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSBsZW5ndGggd2l0aG91dCBhY3R1YWxseSBjb252ZXJ0aW5nOyB1c2VmdWwgZm9yIGRvaW5nIGNoZWFwZXIgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uKHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgbGV0IHAgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgcCsrO1xuICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgIHAgKz0gMjtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxuICAgICAgcCArPSA0O1xuICAgICAgaSsrOyAvLyBza2lwIHRyYWlsIHN1cnJvZ2F0ZS5cbiAgICB9IGVsc2Uge1xuICAgICAgcCArPSAzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vcmVnZXhwL2VzY2FwZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC1wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxudmFyIERFRklORV9QUk9QRVJUWSA9IFwiZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIGRlZmluZShPLCBrZXksIHZhbHVlKSB7XG4gIE9ba2V5XSB8fCBPYmplY3RbREVGSU5FX1BST1BFUlRZXShPLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRMZWZ0XCIsIFwiXCIucGFkU3RhcnQpO1xuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkUmlnaHRcIiwgXCJcIi5wYWRFbmQpO1xuXG5cInBvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMsaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcyxqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YscmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbFwiLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgW11ba2V5XSAmJiBkZWZpbmUoQXJyYXksIGtleSwgRnVuY3Rpb24uY2FsbC5iaW5kKFtdW2tleV0pKTtcbn0pOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5SZWdFeHAuZXNjYXBlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIG1zZykge1xuICBpZiAodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYUxlbiA8IDIpIGZvciAoOzspIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSBuW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uICgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuNCcgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pKSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgTlVNQkVSID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgaWYgKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5leGVjJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5cbnZhciBTUEVDSUVTID0gd2tzKCdzcGVjaWVzJyk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vICNyZXBsYWNlIG5lZWRzIGJ1aWx0LWluIHN1cHBvcnQgZm9yIG5hbWVkIGdyb3Vwcy5cbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xuICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAyICYmIHJlc3VsdFswXSA9PT0gJ2EnICYmIHJlc3VsdFsxXSA9PT0gJ2InO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgPyAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICB9XG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KSA6IHVuZGVmaW5lZDtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICAoS0VZID09PSAncmVwbGFjZScgJiYgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTKSB8fFxuICAgIChLRVkgPT09ICdzcGxpdCcgJiYgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQylcbiAgKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBmbnMgPSBleGVjKFxuICAgICAgZGVmaW5lZCxcbiAgICAgIFNZTUJPTCxcbiAgICAgICcnW0tFWV0sXG4gICAgICBmdW5jdGlvbiBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG4gICAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICk7XG4gICAgdmFyIHN0cmZuID0gZm5zWzBdO1xuICAgIHZhciByeGZuID0gZm5zWzFdO1xuXG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUZsYXR0ZW5JbnRvQXJyYXlcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSByZXF1aXJlKCcuL193a3MnKSgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBjdHgobWFwcGVyLCB0aGlzQXJnLCAzKSA6IGZhbHNlO1xuICB2YXIgZWxlbWVudCwgc3ByZWFkYWJsZTtcblxuICB3aGlsZSAoc291cmNlSW5kZXggPCBzb3VyY2VMZW4pIHtcbiAgICBpZiAoc291cmNlSW5kZXggaW4gc291cmNlKSB7XG4gICAgICBlbGVtZW50ID0gbWFwRm4gPyBtYXBGbihzb3VyY2Vbc291cmNlSW5kZXhdLCBzb3VyY2VJbmRleCwgb3JpZ2luYWwpIDogc291cmNlW3NvdXJjZUluZGV4XTtcblxuICAgICAgc3ByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKGlzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgIHNwcmVhZGFibGUgPSBlbGVtZW50W0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgICAgICAgc3ByZWFkYWJsZSA9IHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcHJlYWRhYmxlICYmIGRlcHRoID4gMCkge1xuICAgICAgICB0YXJnZXRJbmRleCA9IGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgZWxlbWVudCwgdG9MZW5ndGgoZWxlbWVudC5sZW5ndGgpLCB0YXJnZXRJbmRleCwgZGVwdGggLSAxKSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gMHgxZmZmZmZmZmZmZmZmZikgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgIHRhcmdldFt0YXJnZXRJbmRleF0gPSBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRJbmRleCsrO1xuICAgIH1cbiAgICBzb3VyY2VJbmRleCsrO1xuICB9XG4gIHJldHVybiB0YXJnZXRJbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuSW50b0FycmF5O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIEVQU0lMT04gPSBwb3coMiwgLTUyKTtcbnZhciBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKTtcbnZhciBNQVgzMiA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpO1xudmFyIE1JTjMyID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZyb3VuZCB8fCBmdW5jdGlvbiBmcm91bmQoeCkge1xuICB2YXIgJGFicyA9IE1hdGguYWJzKHgpO1xuICB2YXIgJHNpZ24gPSBzaWduKHgpO1xuICB2YXIgYSwgcmVzdWx0O1xuICBpZiAoJGFicyA8IE1JTjMyKSByZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmIChyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KSByZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgcmV0dXJuICRzaWduICogcmVzdWx0O1xufTtcbiIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCkge1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59O1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNjYWxlIHx8IGZ1bmN0aW9uIHNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkge1xuICBpZiAoXG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgeCAhPSB4XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBpbkxvdyAhPSBpbkxvd1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgaW5IaWdoICE9IGluSGlnaFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgb3V0TG93ICE9IG91dExvd1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgb3V0SGlnaCAhPSBvdXRIaWdoXG4gICkgcmV0dXJuIE5hTjtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkgcmV0dXJuIHg7XG4gIHJldHVybiAoeCAtIGluTG93KSAqIChvdXRIaWdoIC0gb3V0TG93KSAvIChpbkhpZ2ggLSBpbkxvdykgKyBvdXRMb3c7XG59O1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBNYXAgPSByZXF1aXJlKCcuL2VzNi5tYXAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ21ldGFkYXRhJyk7XG52YXIgc3RvcmUgPSBzaGFyZWQuc3RvcmUgfHwgKHNoYXJlZC5zdG9yZSA9IG5ldyAocmVxdWlyZSgnLi9lczYud2Vhay1tYXAnKSkoKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5LCBjcmVhdGUpIHtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIGlmICghdGFyZ2V0TWV0YWRhdGEpIHtcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXAoKSk7XG4gIH1cbiAgdmFyIGtleU1ldGFkYXRhID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KHRhcmdldEtleSk7XG4gIGlmICgha2V5TWV0YWRhdGEpIHtcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXAoKSk7XG4gIH0gcmV0dXJuIGtleU1ldGFkYXRhO1xufTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XG4gIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgdHJ1ZSkuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbn07XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHRhcmdldEtleSwgZmFsc2UpO1xuICB2YXIga2V5cyA9IFtdO1xuICBpZiAobWV0YWRhdGFNYXApIG1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24gKF8sIGtleSkgeyBrZXlzLnB1c2goa2V5KTsgfSk7XG4gIHJldHVybiBrZXlzO1xufTtcbnZhciB0b01ldGFLZXkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcbnZhciBleHAgPSBmdW5jdGlvbiAoTykge1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRm9yY2VkIHJlcGxhY2VtZW50IHByb3RvdHlwZSBhY2Nlc3NvcnMgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19saWJyYXJ5JykgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgSyA9IE1hdGgucmFuZG9tKCk7XG4gIC8vIEluIEZGIHRocm93cyBvbmx5IGRlZmluZSBtZXRob2RzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZiwgbm8tdXNlbGVzcy1jYWxsXG4gIF9fZGVmaW5lU2V0dGVyX18uY2FsbChudWxsLCBLLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICBkZWxldGUgcmVxdWlyZSgnLi9fZ2xvYmFsJylbS107XG59KTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsInZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgaXNFbnVtID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKE8sIGtleSA9IGtleXNbaSsrXSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdPUE4uZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHZhciByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG4iLCJ2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VJbnQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgd3MgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcbnZhciBoZXggPSAvXlstK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICByZXR1cm4gJHBhcnNlSW50KHN0cmluZywgKHJhZGl4ID4+PiAwKSB8fCAoaGV4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgJHRvU3RyaW5nID0gcmVxdWlyZSgnLi9fZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBidWlsdGluRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcblxuIC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cbiAgcmV0dXJuIGJ1aWx0aW5FeGVjLmNhbGwoUiwgUyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS8sXG4gICAgICByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMVtMQVNUX0lOREVYXSAhPT0gMCB8fCByZTJbTEFTVF9JTkRFWF0gIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmVbTEFTVF9JTkRFWF07XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVnRXhwLCByZXBsYWNlKSB7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwRm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgIGFGdW5jdGlvbih0aGlzKTtcbiAgICBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAobWFwcGluZykgYUZ1bmN0aW9uKG1hcEZuKTtcbiAgICBpZiAoc291cmNlID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgQSA9IFtdO1xuICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICBuID0gMDtcbiAgICAgIGNiID0gY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgZnVuY3Rpb24gKG5leHRJdGVtKSB7XG4gICAgICAgIEEucHVzaChjYihuZXh0SXRlbSwgbisrKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgQS5wdXNoLCBBKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBBID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSBBW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBxdW90ID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24gKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIGV4ZWMpIHtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKSByZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gIHZhciBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKTtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbiA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc3BhY2VzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgc3BhY2UgPSAnWycgKyBzcGFjZXMgKyAnXSc7XG52YXIgbm9uID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEFMSUFTKSB7XG4gIHZhciBleHAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZiAoQUxJQVMpIGV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW5kZXhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IHRvSW50ZWdlcihpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCEnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpIHtcbiAgdmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbiAgdmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbiAgdmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiAgdmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG4gIHZhciAkYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG4gIHZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuICB2YXIgcHJvcGVydHlEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiAgdmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG4gIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuICB2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuICB2YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbiAgdmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG4gIHZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuICB2YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG4gIHZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbiAgdmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuICB2YXIgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJyk7XG4gIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG4gIHZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG4gIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbiAgdmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuICB2YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuICB2YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKTtcbiAgdmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuICB2YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuICB2YXIgZFAgPSAkRFAuZjtcbiAgdmFyIGdPUEQgPSAkR09QRC5mO1xuICB2YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4gIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICB2YXIgJEFycmF5QnVmZmVyID0gJGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbiAgdmFyICREYXRhVmlldyA9ICRidWZmZXIuRGF0YVZpZXc7XG4gIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgdmFyIGFycmF5RmlsdGVyID0gY3JlYXRlQXJyYXlNZXRob2QoMik7XG4gIHZhciBhcnJheVNvbWUgPSBjcmVhdGVBcnJheU1ldGhvZCgzKTtcbiAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgdmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xuICB2YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbiAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICB2YXIgYXJyYXlJbmRleE9mID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSk7XG4gIHZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbiAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gIHZhciBhcnJheUVudHJpZXMgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzO1xuICB2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2Y7XG4gIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICB2YXIgYXJyYXlSZWR1Y2VSaWdodCA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQ7XG4gIHZhciBhcnJheUpvaW4gPSBBcnJheVByb3RvLmpvaW47XG4gIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXlQcm90by5zbGljZTtcbiAgdmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheVByb3RvLnRvU3RyaW5nO1xuICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbiAgdmFyIFRBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbiAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICB2YXIgREVGX0NPTlNUUlVDVE9SID0gdWlkKCdkZWZfY29uc3RydWN0b3InKTtcbiAgdmFyIEFMTF9DT05TVFJVQ1RPUlMgPSAkdHlwZWQuQ09OU1RSO1xuICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gIHZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIChDLCBsZW5ndGgpIHtcbiAgICBpZiAoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiAoTywgbGlzdCkge1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5LCBpbnRlcm5hbCkge1xuICAgIGRQKGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfSB9KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKiAuLi5pdGVtcyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKCFBTExfQ09OU1RSVUNUT1JTKSB7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKSB7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogJHNsaWNlLFxuICAgIHNldDogJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkgeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgS0VZO1xuICAgIHZhciBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdO1xuICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICB2YXIgVEFDID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KTtcbiAgICB2YXIgRk9SQ0VEID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlY7XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5KDEpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheSgxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBCYXNlKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5KSkgaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZiAoIUxJQlJBUlkpIFR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl07XG4gICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3JcbiAgICAgICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpO1xuICAgIHZhciAkaXRlcmF0b3IgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmIChDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIHtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTXG4gICAgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgQmFzZS5vZi5jYWxsKFR5cGVkQXJyYXksIDEpOyB9KSwgTkFNRSwge1xuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHsgc2V0OiAkc2V0IH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHsgc2xpY2U6ICRzbGljZSB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwgeyB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nIH0pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYgKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4ISc7XG52YXIgJEFycmF5QnVmZmVyID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl07XG52YXIgJERhdGFWaWV3ID0gZ2xvYmFsW0RBVEFfVklFV107XG52YXIgTWF0aCA9IGdsb2JhbC5NYXRoO1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1xudmFyIEluZmluaXR5ID0gZ2xvYmFsLkluZmluaXR5O1xudmFyIEJhc2VCdWZmZXIgPSAkQXJyYXlCdWZmZXI7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xudmFyIEJVRkZFUiA9ICdidWZmZXInO1xudmFyIEJZVEVfTEVOR1RIID0gJ2J5dGVMZW5ndGgnO1xudmFyIEJZVEVfT0ZGU0VUID0gJ2J5dGVPZmZzZXQnO1xudmFyICRCVUZGRVIgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVI7XG52YXIgJExFTkdUSCA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIO1xudmFyICRPRkZTRVQgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbmZ1bmN0aW9uIHBhY2tJRUVFNzU0KHZhbHVlLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShuQnl0ZXMpO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG4gIHZhciBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIHVucGFja0lFRUU3NTQoYnVmZmVyLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGVMZW4gLSA3O1xuICB2YXIgaSA9IG5CeXRlcyAtIDE7XG4gIHZhciBzID0gYnVmZmVyW2ktLV07XG4gIHZhciBlID0gcyAmIDEyNztcbiAgdmFyIG07XG4gIHMgPj49IDc7XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tJMzIoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59XG5mdW5jdGlvbiBwYWNrSTgoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kxNihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kzMihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tGNjQoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59XG5mdW5jdGlvbiBwYWNrRjMyKGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufVxuXG5mdW5jdGlvbiBhZGRHZXR0ZXIoQywga2V5LCBpbnRlcm5hbCkge1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9IH0pO1xufVxuXG5mdW5jdGlvbiBnZXQodmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBzZXQodmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSBzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn1cblxuaWYgKCEkdHlwZWQuQUJWKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleChsZW5ndGgpO1xuICAgIHRoaXMuX2IgPSBhcnJheUZpbGwuY2FsbChuZXcgQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICRBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcihOYU4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiAkQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIGhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfVxuICAgIGlmICghTElCUkFSWSkgQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKSByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgVFlQRUQgPSB1aWQoJ3R5cGVkX2FycmF5Jyk7XG52YXIgVklFVyA9IHVpZCgndmlldycpO1xudmFyIEFCViA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIENPTlNUUiA9IEFCVjtcbnZhciBpID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUgKGkgPCBsKSB7XG4gIGlmIChUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKSB7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6IFRZUEVELFxuICBWSUVXOiBWSUVXXG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbWluZ3IvUmV4RXhwLmVzY2FwZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmUgPSByZXF1aXJlKCcuL19yZXBsYWNlcicpKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZ0V4cCcsIHsgZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoaXQpIHsgcmV0dXJuICRyZShpdCk7IH0gfSk7XG4iLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGNvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRldmVyeSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg0KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmV2ZXJ5LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHsgZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmlsbCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZmlsdGVyLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNyAvIDE1LjQuNC4yMCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNik7XG52YXIgS0VZID0gJ2ZpbmRJbmRleCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpO1xudmFyIEtFWSA9ICdmaW5kJztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciBTVFJJQ1QgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgJG5hdGl2ZSA9IFtdLmluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIvLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHsgaXNBcnJheTogcmVxdWlyZSgnLi9faXMtYXJyYXknKSB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmpvaW4oc2VwYXJhdG9yKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlKb2luID0gW10uam9pbjtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIHN0cmluZ3NcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKHJlcXVpcmUoJy4vX2lvYmplY3QnKSAhPSBPYmplY3QgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShhcnJheUpvaW4pKSwgJ0FycmF5Jywge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0b0lPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciAkbmF0aXZlID0gW10ubGFzdEluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gQFsqLTFdICovKSB7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmIChORUdBVElWRV9aRVJPKSByZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yICg7aW5kZXggPj0gMDsgaW5kZXgtLSkgaWYgKGluZGV4IGluIE8pIGlmIChPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJG1hcCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlIChhTGVuID4gaW5kZXgpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIHRydWUpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGh0bWwpIGFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKTtcbiAgICB2YXIga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYgKGtsYXNzID09ICdBcnJheScpIHJldHVybiBhcnJheVNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW4pO1xuICAgIHZhciB1cFRvID0gdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKTtcbiAgICB2YXIgc2l6ZSA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydCk7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBzaXplOyBpKyspIGNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkc29tZSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJHNvcnQgPSBbXS5zb3J0O1xudmFyIHRlc3QgPSBbMSwgMiwgM107XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnQXJyYXknKTtcbiIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywgeyBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9IH0pO1xuIiwiLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JU09TdHJpbmcgPSByZXF1aXJlKCcuL19kYXRlLXRvLWlzby1zdHJpbmcnKTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAhPT0gdG9JU09TdHJpbmcpLCAnRGF0ZScsIHtcbiAgdG9JU09TdHJpbmc6IHRvSVNPU3RyaW5nXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbFxuICAgIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHsgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0gfSkgIT09IDE7XG59KSwgJ0RhdGUnLCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pO1xuIiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpO1xudmFyIHByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG5cbmlmICghKFRPX1BSSU1JVElWRSBpbiBwcm90bykpIHJlcXVpcmUoJy4vX2hpZGUnKShwcm90bywgVE9fUFJJTUlUSVZFLCByZXF1aXJlKCcuL19kYXRlLXRvLXByaW1pdGl2ZScpKTtcbiIsInZhciBEYXRlUHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IERhdGVQcm90b1tUT19TVFJJTkddO1xudmFyIGdldFRpbWUgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmIChuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn1cbiIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7IGJpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKSB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIEhBU19JTlNUQU5DRSA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpO1xudmFyIEZ1bmN0aW9uUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmICghKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSkgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHsgdmFsdWU6IGZ1bmN0aW9uIChPKSB7XG4gIGlmICh0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSkgcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKSBpZiAodGhpcy5wcm90b3R5cGUgPT09IE8pIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59IH0pO1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTUFQID0gJ01hcCc7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcbiIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbG9nMXAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyk7XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciAkYWNvc2ggPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTlxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHsgYXNpbmg6IGFzaW5oIH0pO1xuIiwiLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXRhbmggPSBNYXRoLmF0YW5oO1xuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCkge1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7IGV4cG0xOiAkZXhwbTEgfSk7XG4iLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgZnJvdW5kOiByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpIH0pO1xuIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbXVsID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciB4biA9ICt4O1xuICAgIHZhciB5biA9ICt5O1xuICAgIHZhciB4bCA9IFVJTlQxNiAmIHhuO1xuICAgIHZhciB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpIH0pO1xuIiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpIH0pO1xuIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpO1xuICAgIHZhciBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KSB7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgJE51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIEJhc2UgPSAkTnVtYmVyO1xudmFyIHByb3RvID0gJE51bWJlci5wcm90b3R5cGU7XG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ09GID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUjtcbnZhciBUUklNID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgY2FzZSA2NjogY2FzZSA5ODogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5OiBjYXNlIDExMTogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYgKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSkge1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWU7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uICgpIHsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHtcbiAgICBpZiAoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSkge1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufVxuIiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpIH0pO1xuIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgaXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJykgfSk7XG4iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcikge1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSAweDFmZmZmZmZmZmZmZmZmO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZiB9KTtcbiIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgJ051bWJlcicsIHsgcGFyc2VJbnQ6ICRwYXJzZUludCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyICR0b0ZpeGVkID0gMS4wLnRvRml4ZWQ7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGRhdGEgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG52YXIgRVJST1IgPSAnTnVtYmVyLnRvRml4ZWQ6IGluY29ycmVjdCBpbnZvY2F0aW9uISc7XG52YXIgWkVSTyA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGMyID0gYztcbiAgd2hpbGUgKCsraSA8IDYpIHtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG52YXIgZGl2aWRlID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgYyA9IDA7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IDY7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApIHtcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbChaRVJPLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbiA9IDA7XG4gIHZhciB4MiA9IHg7XG4gIHdoaWxlICh4MiA+PSA0MDk2KSB7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG4gIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgbiArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKTtcbiAgICB2YXIgZiA9IHRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgdmFyIHMgPSAnJztcbiAgICB2YXIgbSA9IFpFUk87XG4gICAgdmFyIGUsIHosIGosIGs7XG4gICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkgdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmICh4ICE9IHgpIHJldHVybiAnTmFOJztcbiAgICBpZiAoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpIHJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICBzID0gJy0nO1xuICAgICAgeCA9IC14O1xuICAgIH1cbiAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlIChqID49IDcpIHtcbiAgICAgICAgICBtdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGYgPiAwKSB7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcbnZhciAkdG9QcmVjaXNpb24gPSAxLjAudG9QcmVjaXNpb247XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7XG4gIH1cbn0pO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuIiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbiAoJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcbiIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbiAoJGlzRXh0ZW5zaWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbiAoJGlzRnJvemVuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uICgkaXNTZWFsZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzU2VhbGVkKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGlzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJykgfSk7XG4iLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24gKCRwcmV2ZW50RXh0ZW5zaW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpIHtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbiAoJHNlYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpIHtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYgKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHsgcGFyc2VJbnQ6ICRwYXJzZUludCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjggfHwgJyc7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuICAgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG4gICAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuICAgICAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHJBcHBseSA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseTtcbnZhciBmQXBwbHkgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJBcHBseShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpO1xuICAgIHZhciBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9fYmluZCcpO1xudmFyIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0O1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyogLCBuZXdUYXJnZXQgKi8pIHtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwgeyB2YWx1ZTogMSB9KSwgMSwgeyB2YWx1ZTogMiB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBFbnVtZXJhdGUgPSBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW107ICAgICAgLy8ga2V5c1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBpdGVyYXRlZCkga2V5cy5wdXNoKGtleSk7XG59O1xucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKShFbnVtZXJhdGUsICdPYmplY3QnLCBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIGtleXMgPSB0aGF0Ll9rO1xuICB2YXIga2V5O1xuICBkbyB7XG4gICAgaWYgKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfSB3aGlsZSAoISgoa2V5ID0ga2V5c1t0aGF0Ll9pKytdKSBpbiB0aGF0Ll90KSk7XG4gIHJldHVybiB7IHZhbHVlOiBrZXksIGRvbmU6IGZhbHNlIH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gbmV3IEVudW1lcmF0ZSh0YXJnZXQpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCkge1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIGRlc2MsIHByb3RvO1xuICBpZiAoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpIHJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZiAoZGVzYyA9IGdPUEQuZih0YXJnZXQsIHByb3BlcnR5S2V5KSkgcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSByZXR1cm4gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IGdldDogZ2V0IH0pO1xuIiwiLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgb3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKSB9KTtcbiIsIi8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoJHByZXZlbnRFeHRlbnNpb25zKSAkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNldFByb3RvID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJyk7XG5cbmlmIChzZXRQcm90bykgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmICghb3duRGVzYykge1xuICAgIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZiAoaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkpIHtcbiAgICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IuZ2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci5zZXQgfHwgZXhpc3RpbmdEZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIH0gZWxzZSBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgY3JlYXRlRGVzYygwLCBWKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgc2V0OiBzZXQgfSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyICRSZWdFeHAgPSBnbG9iYWwuUmVnRXhwO1xudmFyIEJhc2UgPSAkUmVnRXhwO1xudmFyIHByb3RvID0gJFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgcmUxID0gL2EvZztcbnZhciByZTIgPSAvYS9nO1xuLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG52YXIgQ09SUkVDVF9ORVcgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICghQ09SUkVDVF9ORVcgfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpIHtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKSB7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cDtcbiAgICB2YXIgcGlSRSA9IGlzUmVnRXhwKHApO1xuICAgIHZhciBmaVUgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChpdCkgeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlKSwgaSA9IDA7IGtleXMubGVuZ3RoID4gaTspIHByb3h5KGtleXNbaSsrXSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbn1cblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5yZXF1aXJlKCcuL19leHBvcnQnKSh7XG4gIHRhcmdldDogJ1JlZ0V4cCcsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IHJlZ2V4cEV4ZWMgIT09IC8uLy5leGVjXG59LCB7XG4gIGV4ZWM6IHJlZ2V4cEV4ZWNcbn0pO1xuIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcblxuLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBNQVRDSCwgJG1hdGNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5tYXRjaFxuICAgIGZ1bmN0aW9uIG1hdGNoKHJlZ2V4cCkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAbWF0Y2hcbiAgICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKCRtYXRjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmICghcnguZ2xvYmFsKSByZXR1cm4gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBBID0gW107XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKSkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIEFbbl0gPSBtYXRjaFN0cjtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgICAgbisrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG4gPT09IDAgPyBudWxsIDogQTtcbiAgICB9XG4gIF07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXCQoWyQmYCddfFxcZFxcZD98PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmYCddfFxcZFxcZD8pL2c7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkcmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgfVxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcblxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gICAgfSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBzYW1lVmFsdWUgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNlYXJjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zZWFyY2hcbiAgICBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzZWFyY2hcbiAgICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKCRzZWFyY2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgcHJldmlvdXNMYXN0SW5kZXggPSByeC5sYXN0SW5kZXg7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShwcmV2aW91c0xhc3RJbmRleCwgMCkpIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShyeC5sYXN0SW5kZXgsIHByZXZpb3VzTGFzdEluZGV4KSkgcngubGFzdEluZGV4ID0gcHJldmlvdXNMYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gLTEgOiByZXN1bHQuaW5kZXg7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjYWxsUmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgJFNQTElUID0gJ3NwbGl0JztcbnZhciBMRU5HVEggPSAnbGVuZ3RoJztcbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG52YXIgTUFYX1VJTlQzMiA9IDB4ZmZmZmZmZmY7XG5cbi8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgneCcsICd5JykgLT4gL3gveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgU1VQUE9SVFNfWSA9ICFmYWlscyhmdW5jdGlvbiAoKSB7IFJlZ0V4cChNQVhfVUlOVDMyLCAneScpOyB9KTtcblxuLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG4gIGlmIChcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gJHNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogJHNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gJHNwbGl0O1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzcGxpdHRlci5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpXG4gICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09ICRzcGxpdCk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4LnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKFNVUFBPUlRTX1kgPyAneScgOiAnZycpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoU1VQUE9SVFNfWSA/IHJ4IDogJ14oPzonICsgcnguc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gU1VQUE9SVFNfWSA/IHEgOiAwO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTVVBQT1JUU19ZID8gUyA6IFMuc2xpY2UocSkpO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAoZSA9ICRtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmIChyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNFVCA9ICdTZXQnO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShTRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIFNFVCksIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjIgU3RyaW5nLnByb3RvdHlwZS5hbmNob3IobmFtZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2FuY2hvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhbmNob3IobmFtZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ25hbWUnLCBuYW1lKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMyBTdHJpbmcucHJvdG90eXBlLmJpZygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdiaWcnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiaWcnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy40IFN0cmluZy5wcm90b3R5cGUuYmxpbmsoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmxpbmsnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmxpbmsoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JsaW5rJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNSBTdHJpbmcucHJvdG90eXBlLmJvbGQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYm9sZCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBib2xkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuIiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIEVORFNfV0lUSCA9ICdlbmRzV2l0aCc7XG52YXIgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKTtcbiAgICB2YXIgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpO1xuICAgIHZhciBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOCBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplKHNpemUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250c2l6ZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250c2l6ZShzaXplKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuICB9O1xufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY29kZTtcbiAgICB3aGlsZSAoYUxlbiA+IGkpIHtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZiAodG9BYnNvbHV0ZUluZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSkgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG4iLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjkgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2l0YWxpY3MnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnaScsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfTtcbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKSB7XG4gICAgdmFyIHRwbCA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0cGwubGVuZ3RoKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAobGVuID4gaSkge1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZiAoaSA8IGFMZW4pIHJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5zbWFsbCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzbWFsbCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc21hbGwnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnO1xudmFyICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSCk7XG4gICAgdmFyIGluZGV4ID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3RyaWtlKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xNCBTdHJpbmcucHJvdG90eXBlLnN1cCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdXAnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3VwKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdXAnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5BcnJheUJ1ZmZlcjtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyO1xudmFyICREYXRhVmlldyA9IGJ1ZmZlci5EYXRhVmlldztcbnZhciAkaXNWaWV3ID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXc7XG52YXIgJHNsaWNlID0gJEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbnZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQXJyYXlCdWZmZXIgIT09ICRBcnJheUJ1ZmZlciksIHsgQXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlciB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KSB7XG4gICAgcmV0dXJuICRpc1ZpZXcgJiYgJGlzVmlldyhpdCkgfHwgaXNPYmplY3QoaXQpICYmIFZJRVcgaW4gaXQ7XG4gIH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuVSArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpIHJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB2YXIgbGVuID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aDtcbiAgICB2YXIgZmlyc3QgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluIC0gZmlyc3QpKTtcbiAgICB2YXIgdmlld1MgPSBuZXcgJERhdGFWaWV3KHRoaXMpO1xuICAgIHZhciB2aWV3VCA9IG5ldyAkRGF0YVZpZXcocmVzdWx0KTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChmaXJzdCA8IGZpbikge1xuICAgICAgdmlld1Quc2V0VWludDgoaW5kZXgrKywgdmlld1MuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL190eXBlZCcpLkFCViwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJykuRGF0YVZpZXdcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQ2NCcsIDgsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyk7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTkFUSVZFX1dFQUtfTUFQID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIElTX0lFMTEgPSAhZ2xvYmFsLkFjdGl2ZVhPYmplY3QgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIGdsb2JhbDtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKE5BVElWRV9XRUFLX01BUCAmJiBJU19JRTExKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfU0VUID0gJ1dlYWtTZXQnO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX1NFVCksIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXRNYXBcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiwgQTtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIDEsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmxhdE1hcCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXR0ZW5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbigvKiBkZXB0aEFyZyA9IDEgKi8pIHtcbiAgICB2YXIgZGVwdGhBcmcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCBkZXB0aEFyZyA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aEFyZykpO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZsYXR0ZW4nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBwcm9jZXNzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2VzcztcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1pcy1lcnJvclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdFcnJvcicsIHtcbiAgaXNFcnJvcjogZnVuY3Rpb24gaXNFcnJvcihpdCkge1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKSB9KTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKSB9KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2xhbXA6IGZ1bmN0aW9uIGNsYW1wKHgsIGxvd2VyLCB1cHBlcikge1xuICAgIHJldHVybiBNYXRoLm1pbih1cHBlciwgTWF0aC5tYXgobG93ZXIsIHgpKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IERFR19QRVJfUkFEOiBNYXRoLlBJIC8gMTgwIH0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBSQURfUEVSX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZGVncmVlczogZnVuY3Rpb24gZGVncmVlcyhyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBSQURfUEVSX0RFRztcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNjYWxlID0gcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpO1xudmFyIGZyb3VuZCA9IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnNjYWxlOiBmdW5jdGlvbiBmc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSB7XG4gICAgcmV0dXJuIGZyb3VuZChzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpc3ViaDogZnVuY3Rpb24gaXN1YmgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxIC0gKHkxID4+PiAwKSAtICgofiR4MCAmICR5MCB8IH4oJHgwIF4gJHkwKSAmICR4MCAtICR5MCA+Pj4gMCkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBSQURfUEVSX0RFRzogMTgwIC8gTWF0aC5QSSB9KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgREVHX1BFUl9SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHJhZGlhbnM6IGZ1bmN0aW9uIHJhZGlhbnMoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogREVHX1BFUl9SQUQ7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzY2FsZTogcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpIH0pO1xuIiwiLy8gaHR0cDovL2pmYmFzdGllbi5naXRodWIuaW8vcGFwZXJzL01hdGguc2lnbmJpdC5odG1sXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ25iaXQ6IGZ1bmN0aW9uIHNpZ25iaXQoeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSAhPSB4ID8geCA6IHggPT0gMCA/IDEgLyB4ID09IEluZmluaXR5IDogeCA+IDA7XG59IH0pO1xuIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciAkdSA9ICt1O1xuICAgIHZhciAkdiA9ICt2O1xuICAgIHZhciB1MCA9ICR1ICYgVUlOVDE2O1xuICAgIHZhciB2MCA9ICR2ICYgVUlOVDE2O1xuICAgIHZhciB1MSA9ICR1ID4+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+Pj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwgeyBnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKSB7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHsgc2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCkge1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4vX293bi1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldERlc2MgPSBnT1BELmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleSwgZGVzYztcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpKSB7XG4gICAgICBkZXNjID0gZ2V0RGVzYyhPLCBrZXkgPSBrZXlzW2krK10pO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cEdldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cEdldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELmdldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELnNldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgT0JTRVJWQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgUkVUVVJOID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcbiAgaWYgKGNsZWFudXApIHtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpO1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJykgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKSBjbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmICghbSkgdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCkge1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkgdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkobCk7IGkgPCBsOykgaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tqXSk7XG4gICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgT2JzZXJ2YWJsZTogJE9ic2VydmFibGUgfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHsgZGVmaW5lTWV0YWRhdGE6IGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSkge1xuICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCBhbk9iamVjdCh0YXJnZXQpLCB0b01ldGFLZXkodGFyZ2V0S2V5KSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwO1xudmFyIHN0b3JlID0gbWV0YWRhdGEuc3RvcmU7XG5cbm1ldGFkYXRhLmV4cCh7IGRlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHZhciB0YXJnZXRLZXkgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pO1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZiAobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobWV0YWRhdGFNYXAuc2l6ZSkgcmV0dXJuIHRydWU7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbn0gfSk7XG4iLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9lczYuc2V0Jyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbnZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbiAoTywgUCkge1xuICB2YXIgb0tleXMgPSBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICBpZiAocGFyZW50ID09PSBudWxsKSByZXR1cm4gb0tleXM7XG4gIHZhciBwS2V5cyA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGdldE1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldDtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogdW5kZWZpbmVkO1xufTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0TWV0YWRhdGE6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRPd25NZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0O1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0T3duTWV0YWRhdGE6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5SGFzTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZiAoaGFzT3duKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IGZhbHNlO1xufTtcblxubWV0YWRhdGEuZXhwKHsgaGFzTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgaGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciAkbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvTWV0YUtleSA9ICRtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9ICRtZXRhZGF0YS5zZXQ7XG5cbiRtZXRhZGF0YS5leHAoeyBtZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHRhcmdldEtleSkge1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufSB9KTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1NldCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdTZXQnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0JywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbC9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZ2V0RmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyIFJlZ0V4cFByb3RvID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uIChyZWdleHAsIHN0cmluZykge1xuICB0aGlzLl9yID0gcmVnZXhwO1xuICB0aGlzLl9zID0gc3RyaW5nO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKSgkUmVnRXhwU3RyaW5nSXRlcmF0b3IsICdSZWdFeHAgU3RyaW5nJywgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xuICByZXR1cm4geyB2YWx1ZTogbWF0Y2gsIGRvbmU6IG1hdGNoID09PSBudWxsIH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApIHtcbiAgICBkZWZpbmVkKHRoaXMpO1xuICAgIGlmICghaXNSZWdFeHAocmVnZXhwKSkgdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBmbGFncyA9ICdmbGFncycgaW4gUmVnRXhwUHJvdG8gPyBTdHJpbmcocmVnZXhwLmZsYWdzKSA6IGdldEZsYWdzLmNhbGwocmVnZXhwKTtcbiAgICB2YXIgcnggPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIH5mbGFncy5pbmRleE9mKCdnJykgPyBmbGFncyA6ICdnJyArIGZsYWdzKTtcbiAgICByeC5sYXN0SW5kZXggPSB0b0xlbmd0aChyZWdleHAubGFzdEluZGV4KTtcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIC9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KSwgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltTGVmdCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDEpO1xuICB9O1xufSwgJ3RyaW1TdGFydCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywgeyBnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrU2V0Jyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrU2V0Jyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHRhc2sgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcbiIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xudmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgTVNJRSA9IC9NU0lFIC5cXC4vLnRlc3QodXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZm4sIHRpbWUgLyogLCAuLi5hcmdzICovKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogZmFsc2U7XG4gICAgcmV0dXJuIHNldChib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IDogZm4sIHRpbWUpO1xuICB9O1xufTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CICsgJGV4cG9ydC5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG4iLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNicnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jbHozMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5leHBtMScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaW11bCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy50cmltJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5iaWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcubGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS5ub3cnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29ydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZXZlcnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5leGVjJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5oYXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5mc2NhbGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5zY2FsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2lnbmJpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXNhcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzTWFwID0gcmVxdWlyZSgnLi9pc01hcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU2V0ID0gcmVxdWlyZSgnLi9pc1NldCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXA7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1NldDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURlZXA7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUlzTWFwID0gcmVxdWlyZSgnLi9fYmFzZUlzTWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFwO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanMhLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTIhLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTUtMyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTUtNCEuL25vcm1hbGl6ZS5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanMhLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTIhLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTUtMyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTUtNCEuL25vcm1hbGl6ZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcyEuLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMiEuLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNS0zIS4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tNS00IS4vbm9ybWFsaXplLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4iLCJpbXBvcnQgaXNCcm93c2VyIGZyb20gJy4vaXNCcm93c2VyJztcblxuY29uc3QgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xubGV0IHRpbWVvdXREdXJhdGlvbiA9IDA7XG5mb3IgKGxldCBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICB0aW1lb3V0RHVyYXRpb24gPSAxO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICBsZXQgY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlXG4gICAgICBmbigpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIGxldCBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2VcblxuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xuZXhwb3J0IGRlZmF1bHQgKHN1cHBvcnRzTWljcm9UYXNrc1xuICA/IG1pY3JvdGFza0RlYm91bmNlXG4gIDogdGFza0RlYm91bmNlKTtcbiIsIi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgY29uc3QgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gKFxuICAgIGZ1bmN0aW9uVG9DaGVjayAmJlxuICAgIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICk7XG59XG4iLCIvKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIGNvbnN0IHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgY29uc3QgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG4iLCIvKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuIiwiaW1wb3J0IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSBmcm9tICcuL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSc7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tICcuL2dldFBhcmVudE5vZGUnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keVxuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgY29uc3QgeyBvdmVyZmxvdywgb3ZlcmZsb3dYLCBvdmVyZmxvd1kgfSA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuIiwiaW1wb3J0IGlzQnJvd3NlciBmcm9tICcuL2lzQnJvd3Nlcic7XG5cbmNvbnN0IGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbmNvbnN0IGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cbiIsImltcG9ydCBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkgZnJvbSAnLi9nZXRTdHlsZUNvbXB1dGVkUHJvcGVydHknO1xuaW1wb3J0IGlzSUUgZnJvbSAnLi9pc0lFJztcbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgY29uc3Qgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIGxldCBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBudWxsO1xuICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ID09PSBub09mZnNldFBhcmVudCAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgIG9mZnNldFBhcmVudCA9IChlbGVtZW50ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDtcbiAgfVxuXG4gIGNvbnN0IG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcblxuICBpZiAoIW5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEgsIFREIG9yIFRBQkxFIGluIGNhc2VcbiAgLy8gbm8gb2Zmc2V0UGFyZW50IGlzIHByZXNlbnQsIEkgaGF0ZSB0aGlzIGpvYi4uLlxuICBpZiAoXG4gICAgWydUSCcsICdURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiZcbiAgICBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYydcbiAgKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cbiIsImltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi9nZXRPZmZzZXRQYXJlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIGNvbnN0IHsgbm9kZU5hbWUgfSA9IGVsZW1lbnQ7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnRcbiAgKTtcbn1cbiIsIi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuIiwiaW1wb3J0IGlzT2Zmc2V0Q29udGFpbmVyIGZyb20gJy4vaXNPZmZzZXRDb250YWluZXInO1xuaW1wb3J0IGdldFJvb3QgZnJvbSAnLi9nZXRSb290JztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi9nZXRPZmZzZXRQYXJlbnQnO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIGNvbnN0IG9yZGVyID1cbiAgICBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJlxuICAgIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICBjb25zdCBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgY29uc3QgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgY29uc3QgeyBjb21tb25BbmNlc3RvckNvbnRhaW5lciB9ID0gcmFuZ2U7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuICBpZiAoXG4gICAgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJlxuICAgICAgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSB8fFxuICAgIHN0YXJ0LmNvbnRhaW5zKGVuZClcbiAgKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICBjb25zdCBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cbiIsIi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCwgc2lkZSA9ICd0b3AnKSB7XG4gIGNvbnN0IHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIGNvbnN0IG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgY29uc3QgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY29uc3Qgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG4iLCJpbXBvcnQgZ2V0U2Nyb2xsIGZyb20gJy4vZ2V0U2Nyb2xsJztcblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50LCBzdWJ0cmFjdCA9IGZhbHNlKSB7XG4gIGNvbnN0IHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIGNvbnN0IHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgY29uc3QgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG4iLCIvKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAqIFJlc3VsdCBvZiBgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5YCBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgLSBgeGAgb3IgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCBheGlzKSB7XG4gIGNvbnN0IHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIGNvbnN0IHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gKFxuICAgIHBhcnNlRmxvYXQoc3R5bGVzW2Bib3JkZXIke3NpZGVBfVdpZHRoYF0sIDEwKSArXG4gICAgcGFyc2VGbG9hdChzdHlsZXNbYGJvcmRlciR7c2lkZUJ9V2lkdGhgXSwgMTApXG4gICk7XG59XG4iLCJpbXBvcnQgaXNJRSBmcm9tICcuL2lzSUUnO1xuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KFxuICAgIGJvZHlbYG9mZnNldCR7YXhpc31gXSxcbiAgICBib2R5W2BzY3JvbGwke2F4aXN9YF0sXG4gICAgaHRtbFtgY2xpZW50JHtheGlzfWBdLFxuICAgIGh0bWxbYG9mZnNldCR7YXhpc31gXSxcbiAgICBodG1sW2BzY3JvbGwke2F4aXN9YF0sXG4gICAgaXNJRSgxMClcbiAgICAgID8gKHBhcnNlSW50KGh0bWxbYG9mZnNldCR7YXhpc31gXSkgKyBcbiAgICAgIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbYG1hcmdpbiR7YXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0J31gXSkgKyBcbiAgICAgIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbYG1hcmdpbiR7YXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCd9YF0pKVxuICAgIDogMCBcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgfTtcbn1cbiIsIi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4ge1xuICAgIC4uLm9mZnNldHMsXG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0LFxuICB9O1xufVxuIiwiaW1wb3J0IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSBmcm9tICcuL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSc7XG5pbXBvcnQgZ2V0Qm9yZGVyc1NpemUgZnJvbSAnLi9nZXRCb3JkZXJzU2l6ZSc7XG5pbXBvcnQgZ2V0V2luZG93U2l6ZXMgZnJvbSAnLi9nZXRXaW5kb3dTaXplcyc7XG5pbXBvcnQgZ2V0U2Nyb2xsIGZyb20gJy4vZ2V0U2Nyb2xsJztcbmltcG9ydCBnZXRDbGllbnRSZWN0IGZyb20gJy4vZ2V0Q2xpZW50UmVjdCc7XG5pbXBvcnQgaXNJRSBmcm9tICcuL2lzSUUnO1xuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIGxldCByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICB0cnkge1xuICAgIGlmIChpc0lFKDEwKSkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgY29uc3Qgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9XG4gIGNhdGNoKGUpe31cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wLFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgY29uc3Qgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcyhlbGVtZW50Lm93bmVyRG9jdW1lbnQpIDoge307XG4gIGNvbnN0IHdpZHRoID1cbiAgICBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC5yaWdodCAtIHJlc3VsdC5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPVxuICAgIHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICBsZXQgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIGxldCB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuIiwiaW1wb3J0IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSBmcm9tICcuL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSc7XG5pbXBvcnQgaW5jbHVkZVNjcm9sbCBmcm9tICcuL2luY2x1ZGVTY3JvbGwnO1xuaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tICcuL2dldFNjcm9sbFBhcmVudCc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcbmltcG9ydCBydW5Jc0lFIGZyb20gJy4vaXNJRSc7XG5pbXBvcnQgZ2V0Q2xpZW50UmVjdCBmcm9tICcuL2dldENsaWVudFJlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCwgZml4ZWRQb3NpdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGlzSUUxMCA9IHJ1bklzSUUoMTApO1xuICBjb25zdCBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgY29uc3QgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgY29uc3QgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICBjb25zdCBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICBjb25zdCBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoLCAxMCk7XG4gIGNvbnN0IGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCwgMTApO1xuXG4gIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBwYXJlbnQgaXMgZml4ZWQsIHdlIG11c3QgaWdub3JlIG5lZ2F0aXZlIHNjcm9sbCBpbiBvZmZzZXQgY2FsY1xuICBpZihmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AsIDApO1xuICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCwgMCk7XG4gIH1cbiAgbGV0IG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0LFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICBjb25zdCBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AsIDEwKTtcbiAgICBjb25zdCBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCwgMTApO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChcbiAgICBpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb25cbiAgICAgID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudClcbiAgICAgIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWSdcbiAgKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuIiwiaW1wb3J0IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSBmcm9tICcuL2dldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSc7XG5pbXBvcnQgZ2V0U2Nyb2xsIGZyb20gJy4vZ2V0U2Nyb2xsJztcbmltcG9ydCBnZXRDbGllbnRSZWN0IGZyb20gJy4vZ2V0Q2xpZW50UmVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50LCBleGNsdWRlU2Nyb2xsID0gZmFsc2UpIHtcbiAgY29uc3QgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGNvbnN0IHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXG4gIGNvbnN0IHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgY29uc3Qgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIGNvbnN0IG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG4iLCJpbXBvcnQgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5IGZyb20gJy4vZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5JztcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gJy4vZ2V0UGFyZW50Tm9kZSc7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgY29uc3Qgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKHBhcmVudE5vZGUpO1xufVxuIiwiaW1wb3J0IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSBmcm9tICcuL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSc7XG5pbXBvcnQgaXNJRSBmcm9tICcuL2lzSUUnO1xuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgcGFyZW50IG9mIGFuIGVsZW1lbnQgdGhhdCBoYXMgYSB0cmFuc2Zvcm1lZCBwcm9wZXJ0eSBkZWZpbmVkXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBmaXJzdCB0cmFuc2Zvcm1lZCBwYXJlbnQgb3IgZG9jdW1lbnRFbGVtZW50XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICBsZXQgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbn1cbiIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSAnLi9nZXRTY3JvbGxQYXJlbnQnO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcbmltcG9ydCBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50IGZyb20gJy4vZmluZENvbW1vbk9mZnNldFBhcmVudCc7XG5pbXBvcnQgZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlIGZyb20gJy4vZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlJztcbmltcG9ydCBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUgZnJvbSAnLi9nZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUnO1xuaW1wb3J0IGdldFdpbmRvd1NpemVzIGZyb20gJy4vZ2V0V2luZG93U2l6ZXMnO1xuaW1wb3J0IGlzRml4ZWQgZnJvbSAnLi9pc0ZpeGVkJztcbmltcG9ydCBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50IGZyb20gJy4vZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudCc7XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kYXJpZXMoXG4gIHBvcHBlcixcbiAgcmVmZXJlbmNlLFxuICBwYWRkaW5nLFxuICBib3VuZGFyaWVzRWxlbWVudCxcbiAgZml4ZWRQb3NpdGlvbiA9IGZhbHNlXG4pIHtcbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICBsZXQgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcgKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9XG5cbiAgZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIGxldCBib3VuZGFyaWVzTm9kZTtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoXG4gICAgICBib3VuZGFyaWVzTm9kZSxcbiAgICAgIG9mZnNldFBhcmVudCxcbiAgICAgIGZpeGVkUG9zaXRpb25cbiAgICApO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCk7XG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gIGNvbnN0IGlzUGFkZGluZ051bWJlciA9IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJztcbiAgYm91bmRhcmllcy5sZWZ0ICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmxlZnQgfHwgMDsgXG4gIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwOyBcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwOyBcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcuYm90dG9tIHx8IDA7IFxuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuIiwiaW1wb3J0IGdldEJvdW5kYXJpZXMgZnJvbSAnLi4vdXRpbHMvZ2V0Qm91bmRhcmllcyc7XG5cbmZ1bmN0aW9uIGdldEFyZWEoeyB3aWR0aCwgaGVpZ2h0IH0pIHtcbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KFxuICBwbGFjZW1lbnQsXG4gIHJlZlJlY3QsXG4gIHBvcHBlcixcbiAgcmVmZXJlbmNlLFxuICBib3VuZGFyaWVzRWxlbWVudCxcbiAgcGFkZGluZyA9IDBcbikge1xuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgY29uc3QgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoXG4gICAgcG9wcGVyLFxuICAgIHJlZmVyZW5jZSxcbiAgICBwYWRkaW5nLFxuICAgIGJvdW5kYXJpZXNFbGVtZW50XG4gICk7XG5cbiAgY29uc3QgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcCxcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0LFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbSxcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0LFxuICAgIH0sXG4gIH07XG5cbiAgY29uc3Qgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cylcbiAgICAubWFwKGtleSA9PiAoe1xuICAgICAga2V5LFxuICAgICAgLi4ucmVjdHNba2V5XSxcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSksXG4gICAgfSkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuYXJlYSAtIGEuYXJlYSk7XG5cbiAgY29uc3QgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihcbiAgICAoeyB3aWR0aCwgaGVpZ2h0IH0pID0+XG4gICAgICB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHRcbiAgKTtcblxuICBjb25zdCBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMFxuICAgID8gZmlsdGVyZWRBcmVhc1swXS5rZXlcbiAgICA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICBjb25zdCB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gYC0ke3ZhcmlhdGlvbn1gIDogJycpO1xufVxuIiwiaW1wb3J0IGZpbmRDb21tb25PZmZzZXRQYXJlbnQgZnJvbSAnLi9maW5kQ29tbW9uT2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUgZnJvbSAnLi9nZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUnO1xuaW1wb3J0IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQgZnJvbSAnLi9nZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50JztcblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBmaXhlZFBvc2l0aW9uID0gbnVsbCkge1xuICBjb25zdCBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuIiwiLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgY29uc3QgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSB8fCAwKTtcbiAgY29uc3QgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeCxcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIGNvbnN0IGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgbWF0Y2hlZCA9PiBoYXNoW21hdGNoZWRdKTtcbn1cbiIsImltcG9ydCBnZXRPdXRlclNpemVzIGZyb20gJy4vZ2V0T3V0ZXJTaXplcyc7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSAnLi9nZXRPcHBvc2l0ZVBsYWNlbWVudCc7XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIGNvbnN0IHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICBjb25zdCBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHQsXG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICBjb25zdCBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgY29uc3QgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIGNvbnN0IHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIGNvbnN0IG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgY29uc3Qgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9XG4gICAgcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gK1xuICAgIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtXG4gICAgcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9XG4gICAgICByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9XG4gICAgICByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuIiwiLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cbiIsImltcG9ydCBmaW5kIGZyb20gJy4vZmluZCc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGN1ciA9PiBjdXJbcHJvcF0gPT09IHZhbHVlKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIGNvbnN0IG1hdGNoID0gZmluZChhcnIsIG9iaiA9PiBvYmpbcHJvcF0gPT09IHZhbHVlKTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbic7XG5pbXBvcnQgZmluZEluZGV4IGZyb20gJy4vZmluZEluZGV4JztcbmltcG9ydCBnZXRDbGllbnRSZWN0IGZyb20gJy4uL3V0aWxzL2dldENsaWVudFJlY3QnO1xuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIGNvbnN0IG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkXG4gICAgPyBtb2RpZmllcnNcbiAgICA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKG1vZGlmaWVyID0+IHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgY29uc3QgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQnO1xuaW1wb3J0IGdldFJlZmVyZW5jZU9mZnNldHMgZnJvbSAnLi4vdXRpbHMvZ2V0UmVmZXJlbmNlT2Zmc2V0cyc7XG5pbXBvcnQgZ2V0UG9wcGVyT2Zmc2V0cyBmcm9tICcuLi91dGlscy9nZXRQb3BwZXJPZmZzZXRzJztcbmltcG9ydCBydW5Nb2RpZmllcnMgZnJvbSAnLi4vdXRpbHMvcnVuTW9kaWZpZXJzJztcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge30sXG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKFxuICAgIHRoaXMuc3RhdGUsXG4gICAgdGhpcy5wb3BwZXIsXG4gICAgdGhpcy5yZWZlcmVuY2UsXG4gICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWRcbiAgKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChcbiAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LFxuICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgdGhpcy5wb3BwZXIsXG4gICAgdGhpcy5yZWZlcmVuY2UsXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LFxuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nXG4gICk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgZGF0YS5wb3NpdGlvbkZpeGVkID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHMoXG4gICAgdGhpcy5wb3BwZXIsXG4gICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSxcbiAgICBkYXRhLnBsYWNlbWVudFxuICApO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZFxuICAgID8gJ2ZpeGVkJ1xuICAgIDogJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG4iLCIvKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKFxuICAgICh7IG5hbWUsIGVuYWJsZWQgfSkgPT4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWVcbiAgKTtcbn1cbiIsIi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIGNvbnN0IHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIGNvbnN0IHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIGNvbnN0IHRvQ2hlY2sgPSBwcmVmaXggPyBgJHtwcmVmaXh9JHt1cHBlclByb3B9YCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBpc01vZGlmaWVyRW5hYmxlZCBmcm9tICcuLi91dGlscy9pc01vZGlmaWVyRW5hYmxlZCc7XG5pbXBvcnQgZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIGZyb20gJy4uL3V0aWxzL2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSc7XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsIi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cbiIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSAnLi9nZXRTY3JvbGxQYXJlbnQnO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgY29uc3QgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKFxuICAgICAgZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSxcbiAgICAgIGV2ZW50LFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBzY3JvbGxQYXJlbnRzXG4gICAgKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMoXG4gIHJlZmVyZW5jZSxcbiAgb3B0aW9ucyxcbiAgc3RhdGUsXG4gIHVwZGF0ZUJvdW5kXG4pIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBjb25zdCBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhcbiAgICBzY3JvbGxFbGVtZW50LFxuICAgICdzY3JvbGwnLFxuICAgIHN0YXRlLnVwZGF0ZUJvdW5kLFxuICAgIHN0YXRlLnNjcm9sbFBhcmVudHNcbiAgKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCBzZXR1cEV2ZW50TGlzdGVuZXJzIGZyb20gJy4uL3V0aWxzL3NldHVwRXZlbnRMaXN0ZW5lcnMnO1xuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKFxuICAgICAgdGhpcy5yZWZlcmVuY2UsXG4gICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICB0aGlzLnN0YXRlLFxuICAgICAgdGhpcy5zY2hlZHVsZVVwZGF0ZVxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2godGFyZ2V0ID0+IHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQpO1xuICB9KTtcblxuICAvLyBSZXNldCBzdGF0ZVxuICBzdGF0ZS51cGRhdGVCb3VuZCA9IG51bGw7XG4gIHN0YXRlLnNjcm9sbFBhcmVudHMgPSBbXTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHJlbW92ZUV2ZW50TGlzdGVuZXJzIGZyb20gJy4uL3V0aWxzL3JlbW92ZUV2ZW50TGlzdGVuZXJzJztcblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cbiIsIi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cbiIsImltcG9ydCBpc051bWVyaWMgZnJvbSAnLi9pc051bWVyaWMnO1xuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgIGxldCB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFxuICAgICAgWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT1cbiAgICAgICAgLTEgJiZcbiAgICAgIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pXG4gICAgKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCBzZXRTdHlsZXMgZnJvbSAnLi4vdXRpbHMvc2V0U3R5bGVzJztcbmltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gJy4uL3V0aWxzL3NldEF0dHJpYnV0ZXMnO1xuaW1wb3J0IGdldFJlZmVyZW5jZU9mZnNldHMgZnJvbSAnLi4vdXRpbHMvZ2V0UmVmZXJlbmNlT2Zmc2V0cyc7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQnO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgaWYgKGRhdGEuYXJyb3dFbGVtZW50ICYmIE9iamVjdC5rZXlzKGRhdGEuYXJyb3dTdHlsZXMpLmxlbmd0aCkge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5hcnJvd1N0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKFxuICByZWZlcmVuY2UsXG4gIHBvcHBlcixcbiAgb3B0aW9ucyxcbiAgbW9kaWZpZXJPcHRpb25zLFxuICBzdGF0ZVxuKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBjb25zdCByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGNvbnN0IHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KFxuICAgIG9wdGlvbnMucGxhY2VtZW50LFxuICAgIHJlZmVyZW5jZU9mZnNldHMsXG4gICAgcG9wcGVyLFxuICAgIHJlZmVyZW5jZSxcbiAgICBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LFxuICAgIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZ1xuICApO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuIiwiLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gc2hvdWxkUm91bmQgLSBJZiB0aGUgb2Zmc2V0cyBzaG91bGQgYmUgcm91bmRlZCBhdCBhbGxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwb3BwZXIncyBwb3NpdGlvbiBvZmZzZXRzIHJvdW5kZWRcbiAqXG4gKiBUaGUgdGFsZSBvZiBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLiBJdCdzIHN0aWxsIG5vdCAxMDAlIHBlcmZlY3QsIGJ1dCBhc1xuICogZ29vZCBhcyBpdCBjYW4gYmUgd2l0aGluIHJlYXNvbi5cbiAqIERpc2N1c3Npb24gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvcHVsbC83MTVcbiAqXG4gKiBMb3cgRFBJIHNjcmVlbnMgY2F1c2UgYSBwb3BwZXIgdG8gYmUgYmx1cnJ5IGlmIG5vdCB1c2luZyBmdWxsIHBpeGVscyAoU2FmYXJpXG4gKiBhcyB3ZWxsIG9uIEhpZ2ggRFBJIHNjcmVlbnMpLlxuICpcbiAqIEZpcmVmb3ggcHJlZmVycyBubyByb3VuZGluZyBmb3IgcG9zaXRpb25pbmcgYW5kIGRvZXMgbm90IGhhdmUgYmx1cnJpbmVzcyBvblxuICogaGlnaCBEUEkgc2NyZWVucy5cbiAqXG4gKiBPbmx5IGhvcml6b250YWwgcGxhY2VtZW50IGFuZCBsZWZ0L3JpZ2h0IHZhbHVlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHNob3VsZFJvdW5kKSB7XG4gIGNvbnN0IHsgcG9wcGVyLCByZWZlcmVuY2UgfSA9IGRhdGEub2Zmc2V0cztcbiAgY29uc3QgeyByb3VuZCwgZmxvb3IgfSA9IE1hdGg7XG4gIGNvbnN0IG5vUm91bmQgPSB2ID0+IHY7XG4gIFxuICBjb25zdCByZWZlcmVuY2VXaWR0aCA9IHJvdW5kKHJlZmVyZW5jZS53aWR0aCk7XG4gIGNvbnN0IHBvcHBlcldpZHRoID0gcm91bmQocG9wcGVyLndpZHRoKTtcbiAgXG4gIGNvbnN0IGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGRhdGEucGxhY2VtZW50KSAhPT0gLTE7XG4gIGNvbnN0IGlzVmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignLScpICE9PSAtMTtcbiAgY29uc3Qgc2FtZVdpZHRoUGFyaXR5ID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSBwb3BwZXJXaWR0aCAlIDI7XG4gIGNvbnN0IGJvdGhPZGRXaWR0aCA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gMSAmJiBwb3BwZXJXaWR0aCAlIDIgPT09IDE7XG5cbiAgY29uc3QgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZFxuICAgID8gbm9Sb3VuZFxuICAgIDogaXNWZXJ0aWNhbCB8fCBpc1ZhcmlhdGlvbiB8fCBzYW1lV2lkdGhQYXJpdHlcbiAgICA/IHJvdW5kXG4gICAgOiBmbG9vcjtcbiAgY29uc3QgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogcm91bmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKFxuICAgICAgYm90aE9kZFdpZHRoICYmICFpc1ZhcmlhdGlvbiAmJiBzaG91bGRSb3VuZFxuICAgICAgICA/IHBvcHBlci5sZWZ0IC0gMVxuICAgICAgICA6IHBvcHBlci5sZWZ0XG4gICAgKSxcbiAgICB0b3A6IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IGhvcml6b250YWxUb0ludGVnZXIocG9wcGVyLnJpZ2h0KSxcbiAgfTtcbn1cbiIsImltcG9ydCBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUgZnJvbSAnLi4vdXRpbHMvZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lJztcbmltcG9ydCBmaW5kIGZyb20gJy4uL3V0aWxzL2ZpbmQnO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuLi91dGlscy9nZXRPZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tICcuLi91dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGdldFJvdW5kZWRPZmZzZXRzIGZyb20gJy4uL3V0aWxzL2dldFJvdW5kZWRPZmZzZXRzJztcbmltcG9ydCBpc0Jyb3dzZXIgZnJvbSAnLi4vdXRpbHMvaXNCcm93c2VyJztcblxuY29uc3QgaXNGaXJlZm94ID0gaXNCcm93c2VyICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBvcHRpb25zO1xuICBjb25zdCB7IHBvcHBlciB9ID0gZGF0YS5vZmZzZXRzO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuICBjb25zdCBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kKFxuICAgIGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLFxuICAgIG1vZGlmaWVyID0+IG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJ1xuICApLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJ1xuICAgICk7XG4gIH1cbiAgY29uc3QgZ3B1QWNjZWxlcmF0aW9uID1cbiAgICBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgPyBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb25cbiAgICAgIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgY29uc3Qgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICBjb25zdCBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvbixcbiAgfTtcblxuICBjb25zdCBvZmZzZXRzID0gZ2V0Um91bmRlZE9mZnNldHMoXG4gICAgZGF0YSxcbiAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA8IDIgfHwgIWlzRmlyZWZveFxuICApO1xuXG4gIGNvbnN0IHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICBjb25zdCBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICBjb25zdCBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICBsZXQgbGVmdCwgdG9wO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgLy8gd2hlbiBvZmZzZXRQYXJlbnQgaXMgPGh0bWw+IHRoZSBwb3NpdGlvbmluZyBpcyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gKGV4Y2x1ZGluZyB0aGUgc2Nyb2xsYmFyKVxuICAgIC8vIGFuZCBub3QgdGhlIGJvdHRvbSBvZiB0aGUgaHRtbCBlbGVtZW50XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudC5jbGllbnRXaWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50UmVjdC53aWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gYHRyYW5zbGF0ZTNkKCR7bGVmdH1weCwgJHt0b3B9cHgsIDApYDtcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIGNvbnN0IGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IGAke3NpZGVBfSwgJHtzaWRlQn1gO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50LFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSB7IC4uLmF0dHJpYnV0ZXMsIC4uLmRhdGEuYXR0cmlidXRlcyB9O1xuICBkYXRhLnN0eWxlcyA9IHsgLi4uc3R5bGVzLCAuLi5kYXRhLnN0eWxlcyB9O1xuICBkYXRhLmFycm93U3R5bGVzID0geyAuLi5kYXRhLm9mZnNldHMuYXJyb3csIC4uLmRhdGEuYXJyb3dTdHlsZXMgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsImltcG9ydCBmaW5kIGZyb20gJy4vZmluZCc7XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChcbiAgbW9kaWZpZXJzLFxuICByZXF1ZXN0aW5nTmFtZSxcbiAgcmVxdWVzdGVkTmFtZVxuKSB7XG4gIGNvbnN0IHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgKHsgbmFtZSB9KSA9PiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZSk7XG5cbiAgY29uc3QgaXNSZXF1aXJlZCA9XG4gICAgISFyZXF1ZXN0aW5nICYmXG4gICAgbW9kaWZpZXJzLnNvbWUobW9kaWZpZXIgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJlxuICAgICAgICBtb2RpZmllci5lbmFibGVkICYmXG4gICAgICAgIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlclxuICAgICAgKTtcbiAgICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICBjb25zdCByZXF1ZXN0aW5nID0gYFxcYCR7cmVxdWVzdGluZ05hbWV9XFxgYDtcbiAgICBjb25zdCByZXF1ZXN0ZWQgPSBgXFxgJHtyZXF1ZXN0ZWROYW1lfVxcYGA7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYCR7cmVxdWVzdGVkfSBtb2RpZmllciBpcyByZXF1aXJlZCBieSAke3JlcXVlc3Rpbmd9IG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJHtyZXF1ZXN0aW5nfSFgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cbiIsImltcG9ydCBnZXRDbGllbnRSZWN0IGZyb20gJy4uL3V0aWxzL2dldENsaWVudFJlY3QnO1xuaW1wb3J0IGdldE91dGVyU2l6ZXMgZnJvbSAnLi4vdXRpbHMvZ2V0T3V0ZXJTaXplcyc7XG5pbXBvcnQgaXNNb2RpZmllclJlcXVpcmVkIGZyb20gJy4uL3V0aWxzL2lzTW9kaWZpZXJSZXF1aXJlZCc7XG5pbXBvcnQgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5IGZyb20gJy4uL3V0aWxzL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSc7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgbGV0IGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50ISdcbiAgICAgICk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBjb25zdCB7IHBvcHBlciwgcmVmZXJlbmNlIH0gPSBkYXRhLm9mZnNldHM7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIGNvbnN0IGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIGNvbnN0IHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgY29uc3Qgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICBjb25zdCBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICBjb25zdCBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG5cbiAgLy9cbiAgLy8gZXh0ZW5kcyBrZWVwVG9nZXRoZXIgYmVoYXZpb3IgbWFraW5nIHN1cmUgdGhlIHBvcHBlciBhbmQgaXRzXG4gIC8vIHJlZmVyZW5jZSBoYXZlIGVub3VnaCBwaXhlbHMgaW4gY29uanVuY3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09XG4gICAgICBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPVxuICAgICAgcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgY29uc3QgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIGNvbnN0IGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIGNvbnN0IHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1tgbWFyZ2luJHtzaWRlQ2FwaXRhbGl6ZWR9YF0sIDEwKTtcbiAgY29uc3QgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzW2Bib3JkZXIke3NpZGVDYXBpdGFsaXplZH1XaWR0aGBdLCAxMCk7XG4gIGxldCBzaWRlVmFsdWUgPVxuICAgIGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0ge1xuICAgIFtzaWRlXTogTWF0aC5yb3VuZChzaWRlVmFsdWUpLFxuICAgIFthbHRTaWRlXTogJycsIC8vIG1ha2Ugc3VyZSB0byB1bnNldCBhbnkgZXZlbnR1YWwgYWx0U2lkZSB2YWx1ZSBmcm9tIHRoZSBET00gbm9kZVxuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cbiIsIi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgW1xuICAnYXV0by1zdGFydCcsXG4gICdhdXRvJyxcbiAgJ2F1dG8tZW5kJyxcbiAgJ3RvcC1zdGFydCcsXG4gICd0b3AnLFxuICAndG9wLWVuZCcsXG4gICdyaWdodC1zdGFydCcsXG4gICdyaWdodCcsXG4gICdyaWdodC1lbmQnLFxuICAnYm90dG9tLWVuZCcsXG4gICdib3R0b20nLFxuICAnYm90dG9tLXN0YXJ0JyxcbiAgJ2xlZnQtZW5kJyxcbiAgJ2xlZnQnLFxuICAnbGVmdC1zdGFydCcsXG5dO1xuIiwiaW1wb3J0IHBsYWNlbWVudHMgZnJvbSAnLi4vbWV0aG9kcy9wbGFjZW1lbnRzJztcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG5jb25zdCB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQsIGNvdW50ZXIgPSBmYWxzZSkge1xuICBjb25zdCBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFyciA9IHZhbGlkUGxhY2VtZW50c1xuICAgIC5zbGljZShpbmRleCArIDEpXG4gICAgLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuIiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50JztcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvbiBmcm9tICcuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvbic7XG5pbXBvcnQgZ2V0UG9wcGVyT2Zmc2V0cyBmcm9tICcuLi91dGlscy9nZXRQb3BwZXJPZmZzZXRzJztcbmltcG9ydCBydW5Nb2RpZmllcnMgZnJvbSAnLi4vdXRpbHMvcnVuTW9kaWZpZXJzJztcbmltcG9ydCBnZXRCb3VuZGFyaWVzIGZyb20gJy4uL3V0aWxzL2dldEJvdW5kYXJpZXMnO1xuaW1wb3J0IGlzTW9kaWZpZXJFbmFibGVkIGZyb20gJy4uL3V0aWxzL2lzTW9kaWZpZXJFbmFibGVkJztcbmltcG9ydCBjbG9ja3dpc2UgZnJvbSAnLi4vdXRpbHMvY2xvY2t3aXNlJztcblxuY29uc3QgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJyxcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKFxuICAgIGRhdGEuaW5zdGFuY2UucG9wcGVyLFxuICAgIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLFxuICAgIG9wdGlvbnMucGFkZGluZyxcbiAgICBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LFxuICAgIGRhdGEucG9zaXRpb25GaXhlZFxuICApO1xuXG4gIGxldCBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBsZXQgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBsZXQgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICBsZXQgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICBjb25zdCBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICBjb25zdCByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIGNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICBjb25zdCBvdmVybGFwc1JlZiA9XG4gICAgICAocGxhY2VtZW50ID09PSAnbGVmdCcgJiZcbiAgICAgICAgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpKSB8fFxuICAgICAgKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJlxuICAgICAgICBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkpIHx8XG4gICAgICAocGxhY2VtZW50ID09PSAndG9wJyAmJlxuICAgICAgICBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkpIHx8XG4gICAgICAocGxhY2VtZW50ID09PSAnYm90dG9tJyAmJlxuICAgICAgICBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSkpO1xuXG4gICAgY29uc3Qgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIGNvbnN0IG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICBjb25zdCBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgY29uc3Qgb3ZlcmZsb3dzQm90dG9tID1cbiAgICAgIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIGNvbnN0IG92ZXJmbG93c0JvdW5kYXJpZXMgPVxuICAgICAgKHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQpIHx8XG4gICAgICAocGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0KSB8fFxuICAgICAgKHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wKSB8fFxuICAgICAgKHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIGNvbnN0IGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgY29uc3QgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID1cbiAgICAgICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJlxuICAgICAgKChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0KSB8fFxuICAgICAgICAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0KSB8fFxuICAgICAgICAoIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCkgfHxcbiAgICAgICAgKCFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKSk7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcG9wcGVyIGNvbnRlbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICBjb25zdCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID1cbiAgICAgICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9uc0J5Q29udGVudCAmJlxuICAgICAgKChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCkgfHxcbiAgICAgICAgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NMZWZ0KSB8fFxuICAgICAgICAoIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0JvdHRvbSkgfHxcbiAgICAgICAgKCFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKSk7XG5cbiAgICBjb25zdCBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0ge1xuICAgICAgICAuLi5kYXRhLm9mZnNldHMucG9wcGVyLFxuICAgICAgICAuLi5nZXRQb3BwZXJPZmZzZXRzKFxuICAgICAgICAgIGRhdGEuaW5zdGFuY2UucG9wcGVyLFxuICAgICAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgICAgZGF0YS5wbGFjZW1lbnRcbiAgICAgICAgKSxcbiAgICAgIH07XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG4iLCIvKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgY29uc3QgeyBwb3BwZXIsIHJlZmVyZW5jZSB9ID0gZGF0YS5vZmZzZXRzO1xuICBjb25zdCBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBjb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICBjb25zdCBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgY29uc3Qgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICBjb25zdCBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgaWYgKHBvcHBlcltzaWRlXSA8IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9XG4gICAgICBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgaXNOdW1lcmljIGZyb20gJy4uL3V0aWxzL2lzTnVtZXJpYyc7XG5pbXBvcnQgZ2V0Q2xpZW50UmVjdCBmcm9tICcuLi91dGlscy9nZXRDbGllbnRSZWN0JztcbmltcG9ydCBmaW5kIGZyb20gJy4uL3V0aWxzL2ZpbmQnO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIGNvbnN0IHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgY29uc3QgdmFsdWUgPSArc3BsaXRbMV07XG4gIGNvbnN0IHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHVuaXQuaW5kZXhPZignJScpID09PSAwKSB7XG4gICAgbGV0IGVsZW1lbnQ7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICclcCc6XG4gICAgICAgIGVsZW1lbnQgPSBwb3BwZXJPZmZzZXRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgY2FzZSAnJXInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IHJlZmVyZW5jZU9mZnNldHM7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIGxldCBzaXplO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgd2luZG93LmlubmVyV2lkdGggfHwgMFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU9mZnNldChcbiAgb2Zmc2V0LFxuICBwb3BwZXJPZmZzZXRzLFxuICByZWZlcmVuY2VPZmZzZXRzLFxuICBiYXNlUGxhY2VtZW50XG4pIHtcbiAgY29uc3Qgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIGNvbnN0IHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIGNvbnN0IGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZyYWcgPT4gZnJhZy50cmltKCkpO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICBjb25zdCBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoXG4gICAgZmluZChmcmFnbWVudHMsIGZyYWcgPT4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xKVxuICApO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLidcbiAgICApO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgY29uc3Qgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIGxldCBvcHMgPSBkaXZpZGVyICE9PSAtMVxuICAgID8gW1xuICAgICAgICBmcmFnbWVudHNcbiAgICAgICAgICAuc2xpY2UoMCwgZGl2aWRlcilcbiAgICAgICAgICAuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSxcbiAgICAgICAgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KFxuICAgICAgICAgIGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSlcbiAgICAgICAgKSxcbiAgICAgIF1cbiAgICA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICBjb25zdCBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpXG4gICAgICA/ICdoZWlnaHQnXG4gICAgICA6ICd3aWR0aCc7XG4gICAgbGV0IG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIChcbiAgICAgIG9wXG4gICAgICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgICAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pXG4gICAgICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgICAgICAubWFwKHN0ciA9PiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpKVxuICAgICk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaCgob3AsIGluZGV4KSA9PiB7XG4gICAgb3AuZm9yRWFjaCgoZnJhZywgaW5kZXgyKSA9PiB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvZmZzZXQoZGF0YSwgeyBvZmZzZXQgfSkge1xuICBjb25zdCB7IHBsYWNlbWVudCwgb2Zmc2V0czogeyBwb3BwZXIsIHJlZmVyZW5jZSB9IH0gPSBkYXRhO1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgbGV0IG9mZnNldHM7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuLi91dGlscy9nZXRPZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldEJvdW5kYXJpZXMgZnJvbSAnLi4vdXRpbHMvZ2V0Qm91bmRhcmllcyc7XG5pbXBvcnQgZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIGZyb20gJy4uL3V0aWxzL2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSc7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIGxldCBib3VuZGFyaWVzRWxlbWVudCA9XG4gICAgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIGNvbnN0IHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICBjb25zdCBwb3BwZXJTdHlsZXMgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5zdHlsZTsgLy8gYXNzaWdubWVudCB0byBoZWxwIG1pbmlmaWNhdGlvblxuICBjb25zdCB7IHRvcCwgbGVmdCwgW3RyYW5zZm9ybVByb3BdOiB0cmFuc2Zvcm0gfSA9IHBvcHBlclN0eWxlcztcbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICBjb25zdCBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhcbiAgICBkYXRhLmluc3RhbmNlLnBvcHBlcixcbiAgICBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSxcbiAgICBvcHRpb25zLnBhZGRpbmcsXG4gICAgYm91bmRhcmllc0VsZW1lbnQsXG4gICAgZGF0YS5wb3NpdGlvbkZpeGVkXG4gICk7XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSBvZmZzZXRzIGhhdmUgYmVlbiBjb21wdXRlZFxuICBwb3BwZXJTdHlsZXMudG9wID0gdG9wO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9IGxlZnQ7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblxuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuXG4gIGNvbnN0IG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgbGV0IHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgY29uc3QgY2hlY2sgPSB7XG4gICAgcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKFxuICAgICAgICBwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJlxuICAgICAgICAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlXG4gICAgICApIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IFtwbGFjZW1lbnRdOiB2YWx1ZSB9O1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5KHBsYWNlbWVudCkge1xuICAgICAgY29uc3QgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIGxldCB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAoXG4gICAgICAgIHBvcHBlcltwbGFjZW1lbnRdID4gYm91bmRhcmllc1twbGFjZW1lbnRdICYmXG4gICAgICAgICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2VcbiAgICAgICkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKFxuICAgICAgICAgIHBvcHBlclttYWluU2lkZV0sXG4gICAgICAgICAgYm91bmRhcmllc1twbGFjZW1lbnRdIC1cbiAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgW21haW5TaWRlXTogdmFsdWUgfTtcbiAgICB9LFxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2gocGxhY2VtZW50ID0+IHtcbiAgICBjb25zdCBzaWRlID1cbiAgICAgIFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0geyAuLi5wb3BwZXIsIC4uLmNoZWNrW3NpZGVdKHBsYWNlbWVudCkgfTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsIi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgY29uc3QgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3Qgc2hpZnR2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgaWYgKHNoaWZ0dmFyaWF0aW9uKSB7XG4gICAgY29uc3QgeyByZWZlcmVuY2UsIHBvcHBlciB9ID0gZGF0YS5vZmZzZXRzO1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICBjb25zdCBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIGNvbnN0IHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiB7IFtzaWRlXTogcmVmZXJlbmNlW3NpZGVdIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgW3NpZGVdOiByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSB7IC4uLnBvcHBlciwgLi4uc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSB9O1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgaXNNb2RpZmllclJlcXVpcmVkIGZyb20gJy4uL3V0aWxzL2lzTW9kaWZpZXJSZXF1aXJlZCc7XG5pbXBvcnQgZmluZCBmcm9tICcuLi91dGlscy9maW5kJztcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICBjb25zdCBib3VuZCA9IGZpbmQoXG4gICAgZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsXG4gICAgbW9kaWZpZXIgPT4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdydcbiAgKS5ib3VuZGFyaWVzO1xuXG4gIGlmIChcbiAgICByZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fFxuICAgIHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8XG4gICAgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHxcbiAgICByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdFxuICApIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSB0cnVlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cbiIsImltcG9ydCBnZXRDbGllbnRSZWN0IGZyb20gJy4uL3V0aWxzL2dldENsaWVudFJlY3QnO1xuaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50JztcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICBjb25zdCBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgY29uc3QgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBjb25zdCB7IHBvcHBlciwgcmVmZXJlbmNlIH0gPSBkYXRhLm9mZnNldHM7XG4gIGNvbnN0IGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICBjb25zdCBzdWJ0cmFjdExlbmd0aCA9IFsndG9wJywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID09PSAtMTtcblxuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9XG4gICAgcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC1cbiAgICAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgYXBwbHlTdHlsZSwgeyBhcHBseVN0eWxlT25Mb2FkIH0gZnJvbSAnLi9hcHBseVN0eWxlJztcbmltcG9ydCBjb21wdXRlU3R5bGUgZnJvbSAnLi9jb21wdXRlU3R5bGUnO1xuaW1wb3J0IGFycm93IGZyb20gJy4vYXJyb3cnO1xuaW1wb3J0IGZsaXAgZnJvbSAnLi9mbGlwJztcbmltcG9ydCBrZWVwVG9nZXRoZXIgZnJvbSAnLi9rZWVwVG9nZXRoZXInO1xuaW1wb3J0IG9mZnNldCBmcm9tICcuL29mZnNldCc7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gJy4vcHJldmVudE92ZXJmbG93JztcbmltcG9ydCBzaGlmdCBmcm9tICcuL3NoaWZ0JztcbmltcG9ydCBoaWRlIGZyb20gJy4vaGlkZSc7XG5pbXBvcnQgaW5uZXIgZnJvbSAnLi9pbm5lcic7XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHN0YXJ0IG9yIGVuZCBvZiBpdHMgcmVmZXJlbmNlXG4gICAqIGVsZW1lbnQuPGJyIC8+XG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgdmFyaWF0aW9uIG9mIHRoZSBgcGxhY2VtZW50YCBwcm9wZXJ0eS48YnIgLz5cbiAgICogSXQgY2FuIGJlIG9uZSBlaXRoZXIgYC1lbmRgIG9yIGAtc3RhcnRgLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgc2hpZnQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAxMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBzaGlmdCxcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMCxcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIuIFRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGFsd2F5cyBoYXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllci4gQ2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCcsXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2UgYW5kIGl0cyBwb3BwZXIgc3RheSBuZWFyIGVhY2ggb3RoZXJcbiAgICogd2l0aG91dCBsZWF2aW5nIGFueSBnYXAgYmV0d2VlbiB0aGUgdHdvLiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHRoZSBhcnJvdyBpc1xuICAgKiBlbmFibGVkIGFuZCB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCBpdCBwb2ludHMgdG8gaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBJdCBjYXJlcyBvbmx5IGFib3V0IHRoZSBmaXJzdCBheGlzLiBZb3UgY2FuIHN0aWxsIGhhdmUgcG9wcGVycyB3aXRoIG1hcmdpblxuICAgKiBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGtlZXBUb2dldGhlcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj00MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDQwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGtlZXBUb2dldGhlcixcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJyxcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucylcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYgYGtlZXBUb2dldGhlcmAgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0JyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnM9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zQnlDb250ZW50PWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHBvcHBlciBlbGVtZW50IG92ZXJsYXBzIGl0cyByZWZlcmVuY2UgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zQnlDb250ZW50OiBmYWxzZSxcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyLFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGUsXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnLFxuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdXIgb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkLFxuICB9LFxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuIiwiaW1wb3J0IG1vZGlmaWVycyBmcm9tICcuLi9tb2RpZmllcnMvaW5kZXgnO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZC5cbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6ICgpID0+IHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiAoKSA9PiB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnMsXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG4iLCIvLyBVdGlsc1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vdXRpbHMvZGVib3VuY2UnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi91dGlscy9pc0Z1bmN0aW9uJztcblxuLy8gTWV0aG9kc1xuaW1wb3J0IHVwZGF0ZSBmcm9tICcuL21ldGhvZHMvdXBkYXRlJztcbmltcG9ydCBkZXN0cm95IGZyb20gJy4vbWV0aG9kcy9kZXN0cm95JztcbmltcG9ydCBlbmFibGVFdmVudExpc3RlbmVycyBmcm9tICcuL21ldGhvZHMvZW5hYmxlRXZlbnRMaXN0ZW5lcnMnO1xuaW1wb3J0IGRpc2FibGVFdmVudExpc3RlbmVycyBmcm9tICcuL21ldGhvZHMvZGlzYWJsZUV2ZW50TGlzdGVuZXJzJztcbmltcG9ydCBEZWZhdWx0cyBmcm9tICcuL21ldGhvZHMvZGVmYXVsdHMnO1xuaW1wb3J0IHBsYWNlbWVudHMgZnJvbSAnLi9tZXRob2RzL3BsYWNlbWVudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3BwZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIC8gWE1MIGVsZW1lbnQgdXNlZCBhcyB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uUG9wcGVyLkRlZmF1bHRzLCAuLi5vcHRpb25zIH07XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXSxcbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh7XG4gICAgICAuLi5Qb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLFxuICAgICAgLi4ub3B0aW9ucy5tb2RpZmllcnMsXG4gICAgfSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSB7XG4gICAgICAgIC8vIElmIGl0J3MgYSBidWlsdC1pbiBtb2RpZmllciwgdXNlIGl0IGFzIGJhc2VcbiAgICAgICAgLi4uKFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30pLFxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgY3VzdG9tIG9wdGlvbnMsIG92ZXJyaWRlIGFuZCBtZXJnZSB3aXRoIGRlZmF1bHQgb25lc1xuICAgICAgICAuLi4ob3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KSxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpXG4gICAgICAubWFwKG5hbWUgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSxcbiAgICAgIH0pKVxuICAgICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5vcmRlciAtIGIub3JkZXIpO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXJPcHRpb25zID0+IHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoXG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2UsXG4gICAgICAgICAgdGhpcy5wb3BwZXIsXG4gICAgICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgICAgIG1vZGlmaWVyT3B0aW9ucyxcbiAgICAgICAgICB0aGlzLnN0YXRlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgY29uc3QgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcbiAgdXBkYXRlKCkge1xuICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cbiAgZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gIH1cbiAgZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICovXG4gIHNjaGVkdWxlVXBkYXRlID0gKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlKTtcblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAqXG4gICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgKiBAbWVtYmVyIFV0aWxzXG4gICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICovXG4gIHN0YXRpYyBVdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5cbiAgc3RhdGljIHBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuXG4gIHN0YXRpYyBEZWZhdWx0cyA9IERlZmF1bHRzO1xufVxuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwucHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWwucHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IGdsb2JhbC5wcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcblx0XHQgPyBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKSBcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCJleHBvcnQgY29uc3QgaXNCcm93c2VyID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5jb25zdCB1YSA9IGlzQnJvd3NlciA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiAnJ1xuXG5leHBvcnQgY29uc3QgaXNJRSA9IC9NU0lFIHxUcmlkZW50XFwvLy50ZXN0KHVhKVxuZXhwb3J0IGNvbnN0IGlzVUNCcm93c2VyID0gL1VDQnJvd3NlclxcLy8udGVzdCh1YSlcbmV4cG9ydCBjb25zdCBpc0lPUyA9XG4gIGlzQnJvd3NlciAmJlxuICAvaVBob25lfGlQYWR8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pICYmXG4gICEod2luZG93IGFzIGFueSkuTVNTdHJlYW1cbiIsImltcG9ydCB7IFByb3BzIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQcm9wczogUHJvcHMgPSB7XG4gIGExMXk6IHRydWUsXG4gIGFsbG93SFRNTDogdHJ1ZSxcbiAgYW5pbWF0ZUZpbGw6IHRydWUsXG4gIGFuaW1hdGlvbjogJ3NoaWZ0LWF3YXknLFxuICBhcHBlbmRUbzogKCkgPT4gZG9jdW1lbnQuYm9keSxcbiAgYXJpYTogJ2Rlc2NyaWJlZGJ5JyxcbiAgYXJyb3c6IGZhbHNlLFxuICBhcnJvd1R5cGU6ICdzaGFycCcsXG4gIGJvdW5kYXJ5OiAnc2Nyb2xsUGFyZW50JyxcbiAgY29udGVudDogJycsXG4gIGRlbGF5OiAwLFxuICBkaXN0YW5jZTogMTAsXG4gIGR1cmF0aW9uOiBbMzI1LCAyNzVdLFxuICBmbGlwOiB0cnVlLFxuICBmbGlwQmVoYXZpb3I6ICdmbGlwJyxcbiAgZmxpcE9uVXBkYXRlOiBmYWxzZSxcbiAgZm9sbG93Q3Vyc29yOiBmYWxzZSxcbiAgaGlkZU9uQ2xpY2s6IHRydWUsXG4gIGlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlLFxuICBpbmVydGlhOiBmYWxzZSxcbiAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZUJvcmRlcjogMixcbiAgaW50ZXJhY3RpdmVEZWJvdW5jZTogMCxcbiAgbGF6eTogdHJ1ZSxcbiAgbWF4V2lkdGg6IDM1MCxcbiAgbXVsdGlwbGU6IGZhbHNlLFxuICBvZmZzZXQ6IDAsXG4gIG9uSGlkZGVuKCkge30sXG4gIG9uSGlkZSgpIHt9LFxuICBvbk1vdW50KCkge30sXG4gIG9uU2hvdygpIHt9LFxuICBvblNob3duKCkge30sXG4gIG9uVHJpZ2dlcigpIHt9LFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICBwb3BwZXJPcHRpb25zOiB7fSxcbiAgcm9sZTogJ3Rvb2x0aXAnLFxuICBzaG93T25Jbml0OiBmYWxzZSxcbiAgc2l6ZTogJ3JlZ3VsYXInLFxuICBzdGlja3k6IGZhbHNlLFxuICB0YXJnZXQ6ICcnLFxuICB0aGVtZTogJ2RhcmsnLFxuICB0b3VjaDogdHJ1ZSxcbiAgdG91Y2hIb2xkOiBmYWxzZSxcbiAgdHJpZ2dlcjogJ21vdXNlZW50ZXIgZm9jdXMnLFxuICB0cmlnZ2VyVGFyZ2V0OiBudWxsLFxuICB1cGRhdGVEdXJhdGlvbjogMCxcbiAgd2FpdDogbnVsbCxcbiAgekluZGV4OiA5OTk5LFxufVxuXG4vKipcbiAqIElmIHRoZSBzZXQoKSBtZXRob2QgZW5jb3VudGVycyBvbmUgb2YgdGhlc2UsIHRoZSBwb3BwZXJJbnN0YW5jZSBtdXN0IGJlXG4gKiByZWNyZWF0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IFBPUFBFUl9JTlNUQU5DRV9ERVBFTkRFTkNJRVM6IEFycmF5PGtleW9mIFByb3BzPiA9IFtcbiAgJ2Fycm93JyxcbiAgJ2Fycm93VHlwZScsXG4gICdib3VuZGFyeScsXG4gICdkaXN0YW5jZScsXG4gICdmbGlwJyxcbiAgJ2ZsaXBCZWhhdmlvcicsXG4gICdmbGlwT25VcGRhdGUnLFxuICAnb2Zmc2V0JyxcbiAgJ3BsYWNlbWVudCcsXG4gICdwb3BwZXJPcHRpb25zJyxcbl1cbiIsImltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4vYnJvd3NlcidcblxuY29uc3QgZWxlbWVudFByb3RvOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gaXNCcm93c2VyID8gRWxlbWVudC5wcm90b3R5cGUgOiB7fVxuXG5leHBvcnQgY29uc3QgbWF0Y2hlcyA9XG4gIGVsZW1lbnRQcm90by5tYXRjaGVzIHx8XG4gIGVsZW1lbnRQcm90by5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgZWxlbWVudFByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICBlbGVtZW50UHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gIGVsZW1lbnRQcm90by5tc01hdGNoZXNTZWxlY3RvclxuXG4vKipcbiAqIFBvbnlmaWxsIGZvciBBcnJheS5mcm9tIC0gY29udmVydHMgaXRlcmFibGUgdmFsdWVzIHRvIGFuIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUZyb20odmFsdWU6IEFycmF5TGlrZTxhbnk+KTogYW55W10ge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbCh2YWx1ZSlcbn1cblxuLyoqXG4gKiBQb255ZmlsbCBmb3IgRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdChlbGVtZW50OiBFbGVtZW50LCBzZWxlY3Rvcjogc3RyaW5nKTogRWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gY2xvc2VzdENhbGxiYWNrKGVsZW1lbnQsIChlbDogRWxlbWVudCkgPT4gbWF0Y2hlcy5jYWxsKGVsLCBzZWxlY3RvcikpXG59XG5cbi8qKlxuICogV29ya3MgbGlrZSBFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0LCBidXQgdXNlcyBhIGNhbGxiYWNrIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RDYWxsYmFjayhcbiAgZWxlbWVudDogRWxlbWVudCB8IG51bGwsXG4gIGNhbGxiYWNrOiBGdW5jdGlvbixcbik6IEVsZW1lbnQgfCBudWxsIHtcbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBpZiAoY2FsbGJhY2soZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudFxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsImltcG9ydCB7IGlzSU9TIH0gZnJvbSAnLi9icm93c2VyJ1xuaW1wb3J0IHsgUEFTU0lWRSwgSU9TX0NMQVNTIH0gZnJvbSAnLi9jb25zdGFudHMnXG5cbmV4cG9ydCBsZXQgaXNVc2luZ1RvdWNoID0gZmFsc2VcblxuZXhwb3J0IGZ1bmN0aW9uIG9uRG9jdW1lbnRUb3VjaCgpOiB2b2lkIHtcbiAgaWYgKGlzVXNpbmdUb3VjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaXNVc2luZ1RvdWNoID0gdHJ1ZVxuXG4gIGlmIChpc0lPUykge1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChJT1NfQ0xBU1MpXG4gIH1cblxuICBpZiAod2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Eb2N1bWVudE1vdXNlTW92ZSlcbiAgfVxufVxuXG5sZXQgbGFzdE1vdXNlTW92ZVRpbWUgPSAwXG5leHBvcnQgZnVuY3Rpb24gb25Eb2N1bWVudE1vdXNlTW92ZSgpOiB2b2lkIHtcbiAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAvLyBDaHJvbWUgNjArIGlzIDEgbW91c2Vtb3ZlIHBlciBhbmltYXRpb24gZnJhbWUsIHVzZSAyMG1zIHRpbWUgZGlmZmVyZW5jZVxuICBpZiAobm93IC0gbGFzdE1vdXNlTW92ZVRpbWUgPCAyMCkge1xuICAgIGlzVXNpbmdUb3VjaCA9IGZhbHNlXG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRvY3VtZW50TW91c2VNb3ZlKVxuXG4gICAgaWYgKCFpc0lPUykge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKElPU19DTEFTUylcbiAgICB9XG4gIH1cblxuICBsYXN0TW91c2VNb3ZlVGltZSA9IG5vd1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25XaW5kb3dCbHVyKCk6IHZvaWQge1xuICBjb25zdCB7IGFjdGl2ZUVsZW1lbnQgfTogeyBhY3RpdmVFbGVtZW50OiBhbnkgfSA9IGRvY3VtZW50XG5cbiAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5ibHVyICYmIGFjdGl2ZUVsZW1lbnQuX3RpcHB5KSB7XG4gICAgYWN0aXZlRWxlbWVudC5ibHVyKClcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIG5lZWRlZCBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRHbG9iYWxFdmVudExpc3RlbmVycygpOiB2b2lkIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uRG9jdW1lbnRUb3VjaCwgUEFTU0lWRSlcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbldpbmRvd0JsdXIpXG59XG4iLCJpbXBvcnQgeyBQcm9wcywgVmlydHVhbFJlZmVyZW5jZSwgUmVmZXJlbmNlRWxlbWVudCB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyBkZWZhdWx0UHJvcHMgfSBmcm9tICcuL3Byb3BzJ1xuXG5jb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFByb3BzKVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIG9wdGlvbmFsIHByb3BzIGZyb20gZGF0YS10aXBweS0qIGF0dHJpYnV0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFBdHRyaWJ1dGVPcHRpb25zKFxuICByZWZlcmVuY2U6IFJlZmVyZW5jZUVsZW1lbnQgfCBWaXJ0dWFsUmVmZXJlbmNlLFxuKTogUHJvcHMge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGFjYzogYW55LCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZUFzU3RyaW5nID0gKFxuICAgICAgcmVmZXJlbmNlLmdldEF0dHJpYnV0ZShgZGF0YS10aXBweS0ke2tleX1gKSB8fCAnJ1xuICAgICkudHJpbSgpXG5cbiAgICBpZiAoIXZhbHVlQXNTdHJpbmcpIHtcbiAgICAgIHJldHVybiBhY2NcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWVBc1N0cmluZ1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBhY2Nba2V5XSA9IEpTT04ucGFyc2UodmFsdWVBc1N0cmluZylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYWNjW2tleV0gPSB2YWx1ZUFzU3RyaW5nXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSlcbn1cblxuLyoqXG4gKiBQb2x5ZmlsbHMgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIChwbGFpbiBvYmplY3QpIHdpdGggRWxlbWVudC5wcm90b3R5cGUgcHJvcHNcbiAqIE11dGF0aW5nIGJlY2F1c2UgRE9NIGVsZW1lbnRzIGFyZSBtdXRhdGVkLCBhZGRzIGBfdGlwcHlgIHByb3BlcnR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2x5ZmlsbEVsZW1lbnRQcm90b3R5cGVQcm9wZXJ0aWVzKFxuICB2aXJ0dWFsUmVmZXJlbmNlOiBWaXJ0dWFsUmVmZXJlbmNlICYgUmVjb3JkPHN0cmluZywgYW55Pixcbik6IHZvaWQge1xuICBjb25zdCBwb2x5ZmlsbHM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XG4gICAgaXNWaXJ0dWFsOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHZpcnR1YWxSZWZlcmVuY2UuYXR0cmlidXRlcyB8fCB7fSxcbiAgICBjb250YWlucygpIHt9LFxuICAgIHNldEF0dHJpYnV0ZShrZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgICAgdmlydHVhbFJlZmVyZW5jZS5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuICAgIH0sXG4gICAgZ2V0QXR0cmlidXRlKGtleTogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdmlydHVhbFJlZmVyZW5jZS5hdHRyaWJ1dGVzW2tleV1cbiAgICB9LFxuICAgIHJlbW92ZUF0dHJpYnV0ZShrZXk6IHN0cmluZykge1xuICAgICAgZGVsZXRlIHZpcnR1YWxSZWZlcmVuY2UuYXR0cmlidXRlc1trZXldXG4gICAgfSxcbiAgICBoYXNBdHRyaWJ1dGUoa2V5OiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBrZXkgaW4gdmlydHVhbFJlZmVyZW5jZS5hdHRyaWJ1dGVzXG4gICAgfSxcbiAgICBhZGRFdmVudExpc3RlbmVyKCkge30sXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9LFxuICAgIGNsYXNzTGlzdDoge1xuICAgICAgY2xhc3NOYW1lczoge30sXG4gICAgICBhZGQoa2V5OiBzdHJpbmcpIHtcbiAgICAgICAgdmlydHVhbFJlZmVyZW5jZS5jbGFzc0xpc3QuY2xhc3NOYW1lc1trZXldID0gdHJ1ZVxuICAgICAgfSxcbiAgICAgIHJlbW92ZShrZXk6IHN0cmluZykge1xuICAgICAgICBkZWxldGUgdmlydHVhbFJlZmVyZW5jZS5jbGFzc0xpc3QuY2xhc3NOYW1lc1trZXldXG4gICAgICB9LFxuICAgICAgY29udGFpbnMoa2V5OiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB2aXJ0dWFsUmVmZXJlbmNlLmNsYXNzTGlzdC5jbGFzc05hbWVzXG4gICAgICB9LFxuICAgIH0sXG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBpbiBwb2x5ZmlsbHMpIHtcbiAgICB2aXJ0dWFsUmVmZXJlbmNlW2tleV0gPSBwb2x5ZmlsbHNba2V5XVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBPcHRpb25zLFxuICBQcm9wcyxcbiAgUmVmZXJlbmNlRWxlbWVudCxcbiAgVGFyZ2V0cyxcbiAgVmlydHVhbFJlZmVyZW5jZSxcbn0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IGFycmF5RnJvbSwgbWF0Y2hlcyB9IGZyb20gJy4vcG9ueWZpbGxzJ1xuaW1wb3J0IHsgaXNVQ0Jyb3dzZXIgfSBmcm9tICcuL2Jyb3dzZXInXG5pbXBvcnQgeyBnZXREYXRhQXR0cmlidXRlT3B0aW9ucyB9IGZyb20gJy4vcmVmZXJlbmNlJ1xuaW1wb3J0IHsgUE9QUEVSX1NFTEVDVE9SIH0gZnJvbSAnLi9jb25zdGFudHMnXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHZhbHVlIGlzIGEgXCJiYXJlXCIgdmlydHVhbCBlbGVtZW50IChiZWZvcmUgbXV0YXRpb25zIGRvbmVcbiAqIGJ5IGBwb2x5ZmlsbEVsZW1lbnRQcm90b3R5cGVQcm9wZXJ0aWVzKClgKS4gSlNET00gZWxlbWVudHMgc2hvdyB1cCBhc1xuICogW29iamVjdCBPYmplY3RdLCB3ZSBjYW4gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIFwiZWxlbWVudC1saWtlXCIgaWYgaXQgaGFzXG4gKiBgYWRkRXZlbnRMaXN0ZW5lcmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmFyZVZpcnR1YWxFbGVtZW50KHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB7fS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgIXZhbHVlLmFkZEV2ZW50TGlzdGVuZXJcbiAgKVxufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIGEgcmVmZXJlbmNlIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVmZXJlbmNlRWxlbWVudCh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVmZXJlbmNlRWxlbWVudCB7XG4gIHJldHVybiAhIXZhbHVlLl90aXBweSAmJiAhbWF0Y2hlcy5jYWxsKHZhbHVlLCBQT1BQRVJfU0VMRUNUT1IpXG59XG5cbi8qKlxuICogU2FmZSAuaGFzT3duUHJvcGVydHkgY2hlY2ssIGZvciBwcm90b3R5cGUtbGVzcyBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBlbGVtZW50cyBiYXNlZCBvbiB0aGUgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5T2ZFbGVtZW50cyh2YWx1ZTogVGFyZ2V0cyk6IEVsZW1lbnRbXSB7XG4gIGlmIChpc1Npbmd1bGFyKHZhbHVlKSkge1xuICAgIC8vIFRPRE86IFZpcnR1YWxSZWZlcmVuY2UgaXMgbm90IGNvbXBhdGlibGUgdG8gdHlwZSBFbGVtZW50XG4gICAgcmV0dXJuIFt2YWx1ZSBhcyBFbGVtZW50XVxuICB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTm9kZUxpc3QpIHtcbiAgICByZXR1cm4gYXJyYXlGcm9tKHZhbHVlKVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBhcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBhdCBhIGdpdmVuIGluZGV4IGRlcGVuZGluZyBvbiBpZiBpdCdzIGFuIGFycmF5IG9yIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWU6IGFueSwgaW5kZXg6IG51bWJlciwgZGVmYXVsdFZhbHVlOiBhbnkpOiBhbnkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCB2ID0gdmFsdWVbaW5kZXhdXG4gICAgcmV0dXJuIHYgPT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IHZcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIERlYm91bmNlIHV0aWxpdHkuIFRvIGF2b2lkIGJsb2F0aW5nIGJ1bmRsZSBzaXplLCB3ZSdyZSBvbmx5IHBhc3NpbmcgMVxuICogYXJndW1lbnQgaGVyZSwgYSBtb3JlIGdlbmVyaWMgZnVuY3Rpb24gd291bGQgcGFzcyBhbGwgYXJndW1lbnRzLiBPbmx5XG4gKiBgb25Nb3VzZU1vdmVgIHVzZXMgdGhpcyB3aGljaCB0YWtlcyB0aGUgZXZlbnQgb2JqZWN0IGZvciBub3cuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZTxUPihcbiAgZm46IChhcmc6IFQpID0+IHZvaWQsXG4gIG1zOiBudW1iZXIsXG4pOiAoYXJnOiBUKSA9PiB2b2lkIHtcbiAgLy8gQXZvaWQgd3JhcHBpbmcgaW4gYHNldFRpbWVvdXRgIGlmIG1zIGlzIDAgYW55d2F5XG4gIGlmIChtcyA9PT0gMCkge1xuICAgIHJldHVybiBmblxuICB9XG5cbiAgbGV0IHRpbWVvdXQ6IGFueVxuXG4gIHJldHVybiAoYXJnKTogdm9pZCA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCk6IHZvaWQgPT4ge1xuICAgICAgZm4oYXJnKVxuICAgIH0sIG1zKVxuICB9XG59XG5cbi8qKlxuICogUHJldmVudHMgZXJyb3JzIGZyb20gYmVpbmcgdGhyb3duIHdoaWxlIGFjY2Vzc2luZyBuZXN0ZWQgbW9kaWZpZXIgb2JqZWN0c1xuICogaW4gYHBvcHBlck9wdGlvbnNgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2RpZmllcihvYmo6IGFueSwga2V5OiBzdHJpbmcpOiBhbnkge1xuICByZXR1cm4gb2JqICYmIG9iai5tb2RpZmllcnMgJiYgb2JqLm1vZGlmaWVyc1trZXldXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhbiBhcnJheSBvciBzdHJpbmcgaW5jbHVkZXMgYSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkZXMoYTogYW55W10gfCBzdHJpbmcsIGI6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYS5pbmRleE9mKGIpID4gLTFcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBhIHJlYWwgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFsRWxlbWVudCh2YWx1ZTogYW55KTogdmFsdWUgaXMgRWxlbWVudCB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnRcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBzaW5ndWxhci1saWtlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Npbmd1bGFyKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBWaXJ0dWFsUmVmZXJlbmNlIHwgRWxlbWVudCB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiBoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgJ2lzVmlydHVhbCcpKSB8fCBpc1JlYWxFbGVtZW50KHZhbHVlKVxufVxuXG4vKipcbiAqIEZpcmVmb3ggZXh0ZW5zaW9ucyBkb24ndCBhbGxvdyBzZXR0aW5nIC5pbm5lckhUTUwgZGlyZWN0bHksIHRoaXMgd2lsbCB0cmljayBpdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5uZXJIVE1MKCk6ICdpbm5lckhUTUwnIHtcbiAgcmV0dXJuICdpbm5lckhUTUwnXG59XG5cbi8qKlxuICogRXZhbHVhdGVzIGEgZnVuY3Rpb24gaWYgb25lLCBvciByZXR1cm5zIHRoZSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlV2l0aEFyZ3NPclJldHVybih2YWx1ZTogYW55LCBhcmdzOiBhbnlbXSk6IGFueSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS5hcHBseShudWxsLCBhcmdzKSA6IHZhbHVlXG59XG5cbi8qKlxuICogU2V0cyBhIHBvcHBlckluc3RhbmNlIGBmbGlwYCBtb2RpZmllcidzIGVuYWJsZWQgc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZsaXBNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzOiBhbnlbXSwgdmFsdWU6IGFueSk6IHZvaWQge1xuICBtb2RpZmllcnMuZmlsdGVyKG0gPT4gbS5uYW1lID09PSAnZmxpcCcpWzBdLmVuYWJsZWQgPSB2YWx1ZVxufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBjYW4gcmVjZWl2ZSBmb2N1c1xuICogQWx3YXlzIHJldHVybnMgdHJ1ZSBmb3IgdmlydHVhbCBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5SZWNlaXZlRm9jdXMoZWxlbWVudDogRWxlbWVudCB8IFZpcnR1YWxSZWZlcmVuY2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzUmVhbEVsZW1lbnQoZWxlbWVudClcbiAgICA/IG1hdGNoZXMuY2FsbChcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgJ2FbaHJlZl0sYXJlYVtocmVmXSxidXR0b24sZGV0YWlscyxpbnB1dCx0ZXh0YXJlYSxzZWxlY3QsaWZyYW1lLFt0YWJpbmRleF0nLFxuICAgICAgKSAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJylcbiAgICA6IHRydWVcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBkaXZgIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpdigpOiBIVE1MRGl2RWxlbWVudCB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxufVxuXG4vKipcbiAqIEFwcGxpZXMgYSB0cmFuc2l0aW9uIGR1cmF0aW9uIHRvIGEgbGlzdCBvZiBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFxuICBlbHM6IChIVE1MRGl2RWxlbWVudCB8IG51bGwpW10sXG4gIHZhbHVlOiBudW1iZXIsXG4pOiB2b2lkIHtcbiAgZWxzLmZvckVhY2goZWwgPT4ge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7dmFsdWV9bXNgXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZpc2liaWxpdHkgc3RhdGUgdG8gZWxlbWVudHMgc28gdGhleSBjYW4gYmVnaW4gdG8gdHJhbnNpdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VmlzaWJpbGl0eVN0YXRlKFxuICBlbHM6IChIVE1MRGl2RWxlbWVudCB8IG51bGwpW10sXG4gIHN0YXRlOiAndmlzaWJsZScgfCAnaGlkZGVuJyxcbik6IHZvaWQge1xuICBlbHMuZm9yRWFjaChlbCA9PiB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCBzdGF0ZSlcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBwcm9wcyBvYmplY3QgYnkgbWVyZ2luZyBkYXRhIGF0dHJpYnV0ZXMgYW5kXG4gKiBkaXNhYmxpbmcgY29uZmxpY3Rpbmcgb3B0aW9ucyB3aGVyZSBuZWNlc3NhcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlUHJvcHMoXG4gIHJlZmVyZW5jZTogUmVmZXJlbmNlRWxlbWVudCB8IFZpcnR1YWxSZWZlcmVuY2UsXG4gIHByb3BzOiBQcm9wcyxcbik6IFByb3BzIHtcbiAgY29uc3Qgb3V0ID0ge1xuICAgIC4uLnByb3BzLFxuICAgIGNvbnRlbnQ6IGludm9rZVdpdGhBcmdzT3JSZXR1cm4ocHJvcHMuY29udGVudCwgW3JlZmVyZW5jZV0pLFxuICAgIC4uLihwcm9wcy5pZ25vcmVBdHRyaWJ1dGVzID8ge30gOiBnZXREYXRhQXR0cmlidXRlT3B0aW9ucyhyZWZlcmVuY2UpKSxcbiAgfVxuXG4gIGlmIChvdXQuYXJyb3cgfHwgaXNVQ0Jyb3dzZXIpIHtcbiAgICBvdXQuYW5pbWF0ZUZpbGwgPSBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBhbiBvYmplY3Qgb2Ygb3B0aW9ucyB3aXRoIHRoZSB2YWxpZCBkZWZhdWx0IHByb3BzIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnM6IE9wdGlvbnMsIGRlZmF1bHRQcm9wczogUHJvcHMpOiB2b2lkIHtcbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkoZGVmYXVsdFByb3BzLCBvcHRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFt0aXBweV06IFxcYCR7b3B0aW9ufVxcYCBpcyBub3QgYSB2YWxpZCBvcHRpb25gKVxuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCB7XG4gIFBvcHBlckVsZW1lbnQsXG4gIFByb3BzLFxuICBQb3BwZXJDaGlsZHJlbixcbiAgSGlkZUFsbE9wdGlvbnMsXG4gIEJhc2ljUGxhY2VtZW50LFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgYXJyYXlGcm9tIH0gZnJvbSAnLi9wb255ZmlsbHMnXG5pbXBvcnQgeyBpbm5lckhUTUwsIGRpdiwgaXNSZWZlcmVuY2VFbGVtZW50LCBpc1JlYWxFbGVtZW50IH0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7IGlzVUNCcm93c2VyIH0gZnJvbSAnLi9icm93c2VyJ1xuaW1wb3J0IHtcbiAgUE9QUEVSX0NMQVNTLFxuICBUT09MVElQX0NMQVNTLFxuICBCQUNLRFJPUF9DTEFTUyxcbiAgQ09OVEVOVF9DTEFTUyxcbiAgQVJST1dfQ0xBU1MsXG4gIFJPVU5EX0FSUk9XX0NMQVNTLFxuICBQT1BQRVJfU0VMRUNUT1IsXG4gIFRPT0xUSVBfU0VMRUNUT1IsXG4gIEJBQ0tEUk9QX1NFTEVDVE9SLFxuICBDT05URU5UX1NFTEVDVE9SLFxuICBBUlJPV19TRUxFQ1RPUixcbiAgUk9VTkRfQVJST1dfU0VMRUNUT1IsXG4gIFBMQUNFTUVOVF9BVFRSSUJVVEUsXG59IGZyb20gJy4vY29uc3RhbnRzJ1xuXG4vKipcbiAqIFNldHMgdGhlIGlubmVySFRNTCBvZiBhbiBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRJbm5lckhUTUwoZWxlbWVudDogRWxlbWVudCwgaHRtbDogc3RyaW5nIHwgRWxlbWVudCk6IHZvaWQge1xuICBlbGVtZW50W2lubmVySFRNTCgpXSA9IGlzUmVhbEVsZW1lbnQoaHRtbCkgPyBodG1sW2lubmVySFRNTCgpXSA6IGh0bWxcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBjb250ZW50IG9mIGEgdG9vbHRpcFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGVudChcbiAgY29udGVudEVsOiBQb3BwZXJDaGlsZHJlblsnY29udGVudCddLFxuICBwcm9wczogUHJvcHMsXG4pOiB2b2lkIHtcbiAgaWYgKGlzUmVhbEVsZW1lbnQocHJvcHMuY29udGVudCkpIHtcbiAgICBzZXRJbm5lckhUTUwoY29udGVudEVsLCAnJylcbiAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocHJvcHMuY29udGVudClcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuY29udGVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGtleTogJ2lubmVySFRNTCcgfCAndGV4dENvbnRlbnQnID0gcHJvcHMuYWxsb3dIVE1MXG4gICAgICA/ICdpbm5lckhUTUwnXG4gICAgICA6ICd0ZXh0Q29udGVudCdcbiAgICBjb250ZW50RWxba2V5XSA9IHByb3BzLmNvbnRlbnRcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNoaWxkIGVsZW1lbnRzIG9mIGEgcG9wcGVyIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkcmVuKHBvcHBlcjogUG9wcGVyRWxlbWVudCk6IFBvcHBlckNoaWxkcmVuIHtcbiAgcmV0dXJuIHtcbiAgICB0b29sdGlwOiBwb3BwZXIucXVlcnlTZWxlY3RvcihUT09MVElQX1NFTEVDVE9SKSBhcyBIVE1MRGl2RWxlbWVudCxcbiAgICBiYWNrZHJvcDogcG9wcGVyLnF1ZXJ5U2VsZWN0b3IoQkFDS0RST1BfU0VMRUNUT1IpLFxuICAgIGNvbnRlbnQ6IHBvcHBlci5xdWVyeVNlbGVjdG9yKENPTlRFTlRfU0VMRUNUT1IpIGFzIEhUTUxEaXZFbGVtZW50LFxuICAgIGFycm93OlxuICAgICAgcG9wcGVyLnF1ZXJ5U2VsZWN0b3IoQVJST1dfU0VMRUNUT1IpIHx8XG4gICAgICBwb3BwZXIucXVlcnlTZWxlY3RvcihST1VORF9BUlJPV19TRUxFQ1RPUiksXG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGBkYXRhLWluZXJ0aWFgIGF0dHJpYnV0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkSW5lcnRpYSh0b29sdGlwOiBQb3BwZXJDaGlsZHJlblsndG9vbHRpcCddKTogdm9pZCB7XG4gIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnLCAnJylcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBkYXRhLWluZXJ0aWFgIGF0dHJpYnV0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSW5lcnRpYSh0b29sdGlwOiBQb3BwZXJDaGlsZHJlblsndG9vbHRpcCddKTogdm9pZCB7XG4gIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyb3cgZWxlbWVudCBhbmQgcmV0dXJucyBpdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXJyb3dFbGVtZW50KFxuICBhcnJvd1R5cGU6IFByb3BzWydhcnJvd1R5cGUnXSxcbik6IEhUTUxEaXZFbGVtZW50IHtcbiAgY29uc3QgYXJyb3cgPSBkaXYoKVxuICBpZiAoYXJyb3dUeXBlID09PSAncm91bmQnKSB7XG4gICAgYXJyb3cuY2xhc3NOYW1lID0gUk9VTkRfQVJST1dfQ0xBU1NcbiAgICBzZXRJbm5lckhUTUwoXG4gICAgICBhcnJvdyxcbiAgICAgICc8c3ZnIHZpZXdCb3g9XCIwIDAgMTggN1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTAgN3MyLjAyMS0uMDE1IDUuMjUzLTQuMjE4QzYuNTg0IDEuMDUxIDcuNzk3LjAwNyA5IDBjMS4yMDMtLjAwNyAyLjQxNiAxLjAzNSAzLjc2MSAyLjc4MkMxNi4wMTIgNy4wMDUgMTggNyAxOCA3SDB6XCIvPjwvc3ZnPicsXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGFycm93LmNsYXNzTmFtZSA9IEFSUk9XX0NMQVNTXG4gIH1cbiAgcmV0dXJuIGFycm93XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhY2tkcm9wIGVsZW1lbnQgYW5kIHJldHVybnMgaXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpOiBIVE1MRGl2RWxlbWVudCB7XG4gIGNvbnN0IGJhY2tkcm9wID0gZGl2KClcbiAgYmFja2Ryb3AuY2xhc3NOYW1lID0gQkFDS0RST1BfQ0xBU1NcbiAgYmFja2Ryb3Auc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgJ2hpZGRlbicpXG4gIHJldHVybiBiYWNrZHJvcFxufVxuXG4vKipcbiAqIEFkZHMgaW50ZXJhY3RpdmUtcmVsYXRlZCBhdHRyaWJ1dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRJbnRlcmFjdGl2ZShcbiAgcG9wcGVyOiBQb3BwZXJFbGVtZW50LFxuICB0b29sdGlwOiBQb3BwZXJDaGlsZHJlblsndG9vbHRpcCddLFxuKTogdm9pZCB7XG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJylcbiAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJhY3RpdmUnLCAnJylcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGludGVyYWN0aXZlLXJlbGF0ZWQgYXR0cmlidXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3RpdmUoXG4gIHBvcHBlcjogUG9wcGVyRWxlbWVudCxcbiAgdG9vbHRpcDogUG9wcGVyQ2hpbGRyZW5bJ3Rvb2x0aXAnXSxcbik6IHZvaWQge1xuICBwb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpXG4gIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWludGVyYWN0aXZlJylcbn1cblxuLyoqXG4gKiBBZGQvcmVtb3ZlIHRyYW5zaXRpb25lbmQgbGlzdGVuZXIgZnJvbSB0b29sdGlwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoXG4gIHRvb2x0aXA6IFBvcHBlckNoaWxkcmVuWyd0b29sdGlwJ10sXG4gIGFjdGlvbjogJ2FkZCcgfCAncmVtb3ZlJyxcbiAgbGlzdGVuZXI6IChldmVudDogVHJhbnNpdGlvbkV2ZW50KSA9PiB2b2lkLFxuKTogdm9pZCB7XG4gIC8vIFVDIEJyb3dzZXIgaGFzbid0IGFkb3B0ZWQgdGhlIGB0cmFuc2l0aW9uZW5kYCBldmVudCBkZXNwaXRlIHN1cHBvcnRpbmdcbiAgLy8gdW5wcmVmaXhlZCB0cmFuc2l0aW9ucy4uLlxuICBjb25zdCBldmVudE5hbWUgPVxuICAgIGlzVUNCcm93c2VyICYmIGRvY3VtZW50LmJvZHkuc3R5bGUud2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/ICd3ZWJraXRUcmFuc2l0aW9uRW5kJ1xuICAgICAgOiAndHJhbnNpdGlvbmVuZCdcbiAgdG9vbHRpcFtcbiAgICAoYWN0aW9uICsgJ0V2ZW50TGlzdGVuZXInKSBhcyAnYWRkRXZlbnRMaXN0ZW5lcicgfCAncmVtb3ZlRXZlbnRMaXN0ZW5lcidcbiAgXShldmVudE5hbWUsIGxpc3RlbmVyIGFzIEV2ZW50TGlzdGVuZXIpXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LCBpZ25vcmluZyBzaGlmdGluZyAodG9wLXN0YXJ0LCBldGMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNpY1BsYWNlbWVudChwb3BwZXI6IFBvcHBlckVsZW1lbnQpOiBCYXNpY1BsYWNlbWVudCB7XG4gIGNvbnN0IGZ1bGxQbGFjZW1lbnQgPSBwb3BwZXIuZ2V0QXR0cmlidXRlKFBMQUNFTUVOVF9BVFRSSUJVVEUpXG4gIHJldHVybiAoZnVsbFBsYWNlbWVudCA/IGZ1bGxQbGFjZW1lbnQuc3BsaXQoJy0nKVswXSA6ICcnKSBhcyBCYXNpY1BsYWNlbWVudFxufVxuXG4vKipcbiAqIFRyaWdnZXJzIHJlZmxvd1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmbG93KHBvcHBlcjogUG9wcGVyRWxlbWVudCk6IHZvaWQge1xuICB2b2lkIHBvcHBlci5vZmZzZXRIZWlnaHRcbn1cblxuLyoqXG4gKiBBZGRzL3JlbW92ZXMgdGhlbWUgZnJvbSB0b29sdGlwJ3MgY2xhc3NMaXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUaGVtZShcbiAgdG9vbHRpcDogUG9wcGVyQ2hpbGRyZW5bJ3Rvb2x0aXAnXSxcbiAgYWN0aW9uOiAnYWRkJyB8ICdyZW1vdmUnLFxuICB0aGVtZTogUHJvcHNbJ3RoZW1lJ10sXG4pOiB2b2lkIHtcbiAgdGhlbWUuc3BsaXQoJyAnKS5mb3JFYWNoKHRoZW1lTmFtZSA9PiB7XG4gICAgdG9vbHRpcC5jbGFzc0xpc3RbYWN0aW9uXSh0aGVtZU5hbWUgKyAnLXRoZW1lJylcbiAgfSlcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIHRoZSBwb3BwZXIgZWxlbWVudCBhbmQgcmV0dXJucyBpdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9wcGVyRWxlbWVudChpZDogbnVtYmVyLCBwcm9wczogUHJvcHMpOiBQb3BwZXJFbGVtZW50IHtcbiAgY29uc3QgcG9wcGVyID0gZGl2KClcbiAgcG9wcGVyLmNsYXNzTmFtZSA9IFBPUFBFUl9DTEFTU1xuICBwb3BwZXIuaWQgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tJHtpZH1gXG4gIHBvcHBlci5zdHlsZS56SW5kZXggPSAnJyArIHByb3BzLnpJbmRleFxuICBwb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gIHBvcHBlci5zdHlsZS50b3AgPSAnMCdcbiAgcG9wcGVyLnN0eWxlLmxlZnQgPSAnMCdcblxuICBpZiAocHJvcHMucm9sZSkge1xuICAgIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCBwcm9wcy5yb2xlKVxuICB9XG5cbiAgY29uc3QgdG9vbHRpcCA9IGRpdigpXG4gIHRvb2x0aXAuY2xhc3NOYW1lID0gVE9PTFRJUF9DTEFTU1xuICB0b29sdGlwLnN0eWxlLm1heFdpZHRoID1cbiAgICBwcm9wcy5tYXhXaWR0aCArICh0eXBlb2YgcHJvcHMubWF4V2lkdGggPT09ICdudW1iZXInID8gJ3B4JyA6ICcnKVxuICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1zaXplJywgcHJvcHMuc2l6ZSlcbiAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJywgcHJvcHMuYW5pbWF0aW9uKVxuICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKVxuICB1cGRhdGVUaGVtZSh0b29sdGlwLCAnYWRkJywgcHJvcHMudGhlbWUpXG5cbiAgY29uc3QgY29udGVudCA9IGRpdigpXG4gIGNvbnRlbnQuY2xhc3NOYW1lID0gQ09OVEVOVF9DTEFTU1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKVxuXG4gIGlmIChwcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgIGFkZEludGVyYWN0aXZlKHBvcHBlciwgdG9vbHRpcClcbiAgfVxuXG4gIGlmIChwcm9wcy5hcnJvdykge1xuICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQoY3JlYXRlQXJyb3dFbGVtZW50KHByb3BzLmFycm93VHlwZSkpXG4gIH1cblxuICBpZiAocHJvcHMuYW5pbWF0ZUZpbGwpIHtcbiAgICB0b29sdGlwLmFwcGVuZENoaWxkKGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpKVxuICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGVmaWxsJywgJycpXG4gIH1cblxuICBpZiAocHJvcHMuaW5lcnRpYSkge1xuICAgIGFkZEluZXJ0aWEodG9vbHRpcClcbiAgfVxuXG4gIHNldENvbnRlbnQoY29udGVudCwgcHJvcHMpXG5cbiAgdG9vbHRpcC5hcHBlbmRDaGlsZChjb250ZW50KVxuICBwb3BwZXIuYXBwZW5kQ2hpbGQodG9vbHRpcClcblxuICByZXR1cm4gcG9wcGVyXG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9wcGVyIGVsZW1lbnQgYmFzZWQgb24gdGhlIG5ldyBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUG9wcGVyRWxlbWVudChcbiAgcG9wcGVyOiBQb3BwZXJFbGVtZW50LFxuICBwcmV2UHJvcHM6IFByb3BzLFxuICBuZXh0UHJvcHM6IFByb3BzLFxuKTogdm9pZCB7XG4gIGNvbnN0IHsgdG9vbHRpcCwgY29udGVudCwgYmFja2Ryb3AsIGFycm93IH0gPSBnZXRDaGlsZHJlbihwb3BwZXIpXG5cbiAgcG9wcGVyLnN0eWxlLnpJbmRleCA9ICcnICsgbmV4dFByb3BzLnpJbmRleFxuICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1zaXplJywgbmV4dFByb3BzLnNpemUpXG4gIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicsIG5leHRQcm9wcy5hbmltYXRpb24pXG4gIHRvb2x0aXAuc3R5bGUubWF4V2lkdGggPVxuICAgIG5leHRQcm9wcy5tYXhXaWR0aCArICh0eXBlb2YgbmV4dFByb3BzLm1heFdpZHRoID09PSAnbnVtYmVyJyA/ICdweCcgOiAnJylcblxuICBpZiAobmV4dFByb3BzLnJvbGUpIHtcbiAgICBwb3BwZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgbmV4dFByb3BzLnJvbGUpXG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpXG4gIH1cblxuICBpZiAocHJldlByb3BzLmNvbnRlbnQgIT09IG5leHRQcm9wcy5jb250ZW50KSB7XG4gICAgc2V0Q29udGVudChjb250ZW50LCBuZXh0UHJvcHMpXG4gIH1cblxuICAvLyBhbmltYXRlRmlsbFxuICBpZiAoIXByZXZQcm9wcy5hbmltYXRlRmlsbCAmJiBuZXh0UHJvcHMuYW5pbWF0ZUZpbGwpIHtcbiAgICB0b29sdGlwLmFwcGVuZENoaWxkKGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpKVxuICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGVmaWxsJywgJycpXG4gIH0gZWxzZSBpZiAocHJldlByb3BzLmFuaW1hdGVGaWxsICYmICFuZXh0UHJvcHMuYW5pbWF0ZUZpbGwpIHtcbiAgICB0b29sdGlwLnJlbW92ZUNoaWxkKGJhY2tkcm9wISlcbiAgICB0b29sdGlwLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbmltYXRlZmlsbCcpXG4gIH1cblxuICAvLyBhcnJvd1xuICBpZiAoIXByZXZQcm9wcy5hcnJvdyAmJiBuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICB0b29sdGlwLmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3dUeXBlKSlcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMuYXJyb3cgJiYgIW5leHRQcm9wcy5hcnJvdykge1xuICAgIHRvb2x0aXAucmVtb3ZlQ2hpbGQoYXJyb3chKVxuICB9XG5cbiAgLy8gYXJyb3dUeXBlXG4gIGlmIChcbiAgICBwcmV2UHJvcHMuYXJyb3cgJiZcbiAgICBuZXh0UHJvcHMuYXJyb3cgJiZcbiAgICBwcmV2UHJvcHMuYXJyb3dUeXBlICE9PSBuZXh0UHJvcHMuYXJyb3dUeXBlXG4gICkge1xuICAgIHRvb2x0aXAucmVwbGFjZUNoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3dUeXBlKSwgYXJyb3chKVxuICB9XG5cbiAgLy8gaW50ZXJhY3RpdmVcbiAgaWYgKCFwcmV2UHJvcHMuaW50ZXJhY3RpdmUgJiYgbmV4dFByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgYWRkSW50ZXJhY3RpdmUocG9wcGVyLCB0b29sdGlwKVxuICB9IGVsc2UgaWYgKHByZXZQcm9wcy5pbnRlcmFjdGl2ZSAmJiAhbmV4dFByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgcmVtb3ZlSW50ZXJhY3RpdmUocG9wcGVyLCB0b29sdGlwKVxuICB9XG5cbiAgLy8gaW5lcnRpYVxuICBpZiAoIXByZXZQcm9wcy5pbmVydGlhICYmIG5leHRQcm9wcy5pbmVydGlhKSB7XG4gICAgYWRkSW5lcnRpYSh0b29sdGlwKVxuICB9IGVsc2UgaWYgKHByZXZQcm9wcy5pbmVydGlhICYmICFuZXh0UHJvcHMuaW5lcnRpYSkge1xuICAgIHJlbW92ZUluZXJ0aWEodG9vbHRpcClcbiAgfVxuXG4gIC8vIHRoZW1lXG4gIGlmIChwcmV2UHJvcHMudGhlbWUgIT09IG5leHRQcm9wcy50aGVtZSkge1xuICAgIHVwZGF0ZVRoZW1lKHRvb2x0aXAsICdyZW1vdmUnLCBwcmV2UHJvcHMudGhlbWUpXG4gICAgdXBkYXRlVGhlbWUodG9vbHRpcCwgJ2FkZCcsIG5leHRQcm9wcy50aGVtZSlcbiAgfVxufVxuXG4vKipcbiAqIEhpZGVzIGFsbCB2aXNpYmxlIHBvcHBlcnMgb24gdGhlIGRvY3VtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoaWRlQWxsKHtcbiAgZXhjbHVkZTogZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlLFxuICBkdXJhdGlvbixcbn06IEhpZGVBbGxPcHRpb25zID0ge30pOiB2b2lkIHtcbiAgYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUE9QUEVSX1NFTEVDVE9SKSkuZm9yRWFjaChcbiAgICAocG9wcGVyOiBQb3BwZXJFbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IHBvcHBlci5fdGlwcHlcblxuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBpc0V4Y2x1ZGVkID0gZmFsc2VcbiAgICAgICAgaWYgKGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSkge1xuICAgICAgICAgIGlzRXhjbHVkZWQgPSBpc1JlZmVyZW5jZUVsZW1lbnQoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKVxuICAgICAgICAgICAgPyBpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZVxuICAgICAgICAgICAgOiBwb3BwZXIgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZS5wb3BwZXJcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNFeGNsdWRlZCkge1xuICAgICAgICAgIGluc3RhbmNlLmhpZGUoZHVyYXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICApXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgbW91c2UgY3Vyc29yIGlzIG91dHNpZGUgb2YgdGhlIHBvcHBlcidzIGludGVyYWN0aXZlIGJvcmRlclxuICogcmVnaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcihcbiAgcG9wcGVyUGxhY2VtZW50OiBCYXNpY1BsYWNlbWVudCxcbiAgcG9wcGVyUmVjdDogQ2xpZW50UmVjdCxcbiAgZXZlbnQ6IE1vdXNlRXZlbnQsXG4gIHByb3BzOiBQcm9wcyxcbik6IGJvb2xlYW4ge1xuICBpZiAoIXBvcHBlclBsYWNlbWVudCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCB7IGNsaWVudFg6IHgsIGNsaWVudFk6IHkgfSA9IGV2ZW50XG4gIGNvbnN0IHsgaW50ZXJhY3RpdmVCb3JkZXIsIGRpc3RhbmNlIH0gPSBwcm9wc1xuXG4gIGNvbnN0IGV4Y2VlZHNUb3AgPVxuICAgIHBvcHBlclJlY3QudG9wIC0geSA+XG4gICAgKHBvcHBlclBsYWNlbWVudCA9PT0gJ3RvcCdcbiAgICAgID8gaW50ZXJhY3RpdmVCb3JkZXIgKyBkaXN0YW5jZVxuICAgICAgOiBpbnRlcmFjdGl2ZUJvcmRlcilcblxuICBjb25zdCBleGNlZWRzQm90dG9tID1cbiAgICB5IC0gcG9wcGVyUmVjdC5ib3R0b20gPlxuICAgIChwb3BwZXJQbGFjZW1lbnQgPT09ICdib3R0b20nXG4gICAgICA/IGludGVyYWN0aXZlQm9yZGVyICsgZGlzdGFuY2VcbiAgICAgIDogaW50ZXJhY3RpdmVCb3JkZXIpXG5cbiAgY29uc3QgZXhjZWVkc0xlZnQgPVxuICAgIHBvcHBlclJlY3QubGVmdCAtIHggPlxuICAgIChwb3BwZXJQbGFjZW1lbnQgPT09ICdsZWZ0J1xuICAgICAgPyBpbnRlcmFjdGl2ZUJvcmRlciArIGRpc3RhbmNlXG4gICAgICA6IGludGVyYWN0aXZlQm9yZGVyKVxuXG4gIGNvbnN0IGV4Y2VlZHNSaWdodCA9XG4gICAgeCAtIHBvcHBlclJlY3QucmlnaHQgPlxuICAgIChwb3BwZXJQbGFjZW1lbnQgPT09ICdyaWdodCdcbiAgICAgID8gaW50ZXJhY3RpdmVCb3JkZXIgKyBkaXN0YW5jZVxuICAgICAgOiBpbnRlcmFjdGl2ZUJvcmRlcilcblxuICByZXR1cm4gZXhjZWVkc1RvcCB8fCBleGNlZWRzQm90dG9tIHx8IGV4Y2VlZHNMZWZ0IHx8IGV4Y2VlZHNSaWdodFxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpc3RhbmNlIG9mZnNldCwgdGFraW5nIGludG8gYWNjb3VudCB0aGUgZGVmYXVsdCBvZmZzZXQgZHVlIHRvXG4gKiB0aGUgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSBydWxlICgxMHB4KSBpbiBDU1NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9mZnNldERpc3RhbmNlSW5QeChkaXN0YW5jZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIC0oZGlzdGFuY2UgLSAxMCkgKyAncHgnXG59XG4iLCJpbXBvcnQgUG9wcGVyIGZyb20gJ3BvcHBlci5qcydcbmltcG9ydCB7XG4gIFJlZmVyZW5jZUVsZW1lbnQsXG4gIFBvcHBlckluc3RhbmNlLFxuICBQcm9wcyxcbiAgT3B0aW9ucyxcbiAgSW5zdGFuY2UsXG4gIENvbnRlbnQsXG4gIExpc3RlbmVyLFxuICBWaXJ0dWFsUmVmZXJlbmNlLFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgaXNJRSB9IGZyb20gJy4vYnJvd3NlcidcbmltcG9ydCB7IGNsb3Nlc3QsIGNsb3Nlc3RDYWxsYmFjaywgYXJyYXlGcm9tIH0gZnJvbSAnLi9wb255ZmlsbHMnXG5pbXBvcnQge1xuICBQQVNTSVZFLFxuICBQQURESU5HLFxuICBQTEFDRU1FTlRfQVRUUklCVVRFLFxuICBPVVRfT0ZfQk9VTkRBUklFU19BVFRSSUJVVEUsXG4gIEFDVElWRV9DTEFTUyxcbiAgUE9QUEVSX1NFTEVDVE9SLFxufSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IGlzVXNpbmdUb3VjaCB9IGZyb20gJy4vYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzJ1xuaW1wb3J0IHsgZGVmYXVsdFByb3BzLCBQT1BQRVJfSU5TVEFOQ0VfREVQRU5ERU5DSUVTIH0gZnJvbSAnLi9wcm9wcydcbmltcG9ydCB7XG4gIGNyZWF0ZVBvcHBlckVsZW1lbnQsXG4gIHVwZGF0ZVBvcHBlckVsZW1lbnQsXG4gIGdldENoaWxkcmVuLFxuICBnZXRCYXNpY1BsYWNlbWVudCxcbiAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyLFxuICBpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcixcbiAgZ2V0T2Zmc2V0RGlzdGFuY2VJblB4LFxuICByZWZsb3csXG59IGZyb20gJy4vcG9wcGVyJ1xuaW1wb3J0IHtcbiAgaGFzT3duUHJvcGVydHksXG4gIGRlYm91bmNlLFxuICBnZXRWYWx1ZSxcbiAgZ2V0TW9kaWZpZXIsXG4gIGluY2x1ZGVzLFxuICBpbnZva2VXaXRoQXJnc09yUmV0dXJuLFxuICBzZXRGbGlwTW9kaWZpZXJFbmFibGVkLFxuICBjYW5SZWNlaXZlRm9jdXMsXG4gIHZhbGlkYXRlT3B0aW9ucyxcbiAgZXZhbHVhdGVQcm9wcyxcbiAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uLFxuICBzZXRWaXNpYmlsaXR5U3RhdGUsXG4gIGlzUmVhbEVsZW1lbnQsXG59IGZyb20gJy4vdXRpbHMnXG5cbmxldCBpZENvdW50ZXIgPSAxXG4vLyBXb3JrYXJvdW5kIGZvciBJRTExJ3MgbGFjayBvZiBuZXcgTW91c2VFdmVudCBjb25zdHJ1Y3RvclxubGV0IG1vdXNlTW92ZUxpc3RlbmVyczogKChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZClbXSA9IFtdXG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIFRpcHB5IG9iamVjdC4gV2UncmUgdXNpbmcgYSBjbG9zdXJlIHBhdHRlcm4gaW5zdGVhZCBvZlxuICogYSBjbGFzcyBzbyB0aGF0IHRoZSBleHBvc2VkIG9iamVjdCBBUEkgaXMgY2xlYW4gd2l0aG91dCBwcml2YXRlIG1lbWJlcnNcbiAqIHByZWZpeGVkIHdpdGggYF9gLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUaXBweShcbiAgcmVmZXJlbmNlOiBSZWZlcmVuY2VFbGVtZW50IHwgVmlydHVhbFJlZmVyZW5jZSxcbiAgY29sbGVjdGlvblByb3BzOiBQcm9wcyxcbik6IEluc3RhbmNlIHwgbnVsbCB7XG4gIGNvbnN0IHByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIGNvbGxlY3Rpb25Qcm9wcylcblxuICAvLyBJZiB0aGUgcmVmZXJlbmNlIHNob3VsZG4ndCBoYXZlIG11bHRpcGxlIHRpcHB5cywgcmV0dXJuIG51bGwgZWFybHlcbiAgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiByZWZlcmVuY2UuX3RpcHB5KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qID09PT09PT09PT09PT09PT09PT09PT09IPCflJIgUHJpdmF0ZSBtZW1iZXJzIPCflJIgPT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgbGV0IGxhc3RUcmlnZ2VyRXZlbnRUeXBlOiBzdHJpbmdcbiAgbGV0IGxhc3RNb3VzZU1vdmVFdmVudDogTW91c2VFdmVudFxuICBsZXQgc2hvd1RpbWVvdXRJZDogbnVtYmVyXG4gIGxldCBoaWRlVGltZW91dElkOiBudW1iZXJcbiAgbGV0IHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lSWQ6IG51bWJlclxuICBsZXQgaXNTY2hlZHVsZWRUb1Nob3cgPSBmYWxzZVxuICBsZXQgaXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlXG4gIGxldCBwcmV2aW91c1BsYWNlbWVudDogc3RyaW5nXG4gIGxldCB3YXNWaXNpYmxlRHVyaW5nUHJldmlvdXNVcGRhdGUgPSBmYWxzZVxuICBsZXQgaGFzTW91bnRDYWxsYmFja1J1biA9IGZhbHNlXG4gIGxldCBjdXJyZW50TW91bnRDYWxsYmFjazogKCkgPT4gdm9pZFxuICBsZXQgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcjogKGV2ZW50OiBUcmFuc2l0aW9uRXZlbnQpID0+IHZvaWRcbiAgbGV0IGxpc3RlbmVyczogTGlzdGVuZXJbXSA9IFtdXG4gIGxldCBjdXJyZW50Q29tcHV0ZWRQYWRkaW5nOiB7XG4gICAgdG9wOiBudW1iZXJcbiAgICBib3R0b206IG51bWJlclxuICAgIGxlZnQ6IG51bWJlclxuICAgIHJpZ2h0OiBudW1iZXJcbiAgICBba2V5OiBzdHJpbmddOiBudW1iZXJcbiAgfVxuICBsZXQgZGVib3VuY2VkT25Nb3VzZU1vdmUgPSBkZWJvdW5jZShvbk1vdXNlTW92ZSwgcHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSlcblxuICAvKiA9PT09PT09PT09PT09PT09PT09PT09PSDwn5SRIFB1YmxpYyBtZW1iZXJzIPCflJEgPT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgY29uc3QgaWQgPSBpZENvdW50ZXIrK1xuICBjb25zdCBwb3BwZXIgPSBjcmVhdGVQb3BwZXJFbGVtZW50KGlkLCBwcm9wcylcbiAgY29uc3QgcG9wcGVyQ2hpbGRyZW4gPSBnZXRDaGlsZHJlbihwb3BwZXIpXG4gIGNvbnN0IHBvcHBlckluc3RhbmNlOiBQb3BwZXJJbnN0YW5jZSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgLy8gSXMgdGhlIGluc3RhbmNlIGN1cnJlbnRseSBlbmFibGVkP1xuICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyBJcyB0aGUgdGlwcHkgY3VycmVudGx5IHNob3dpbmcgYW5kIG5vdCB0cmFuc2l0aW9uaW5nIG91dD9cbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgIC8vIEhhcyB0aGUgaW5zdGFuY2UgYmVlbiBkZXN0cm95ZWQ/XG4gICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgbW91bnRlZCB0byB0aGUgRE9NP1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSB0aXBweSBmaW5pc2hlZCB0cmFuc2l0aW9uaW5nIGluP1xuICAgIGlzU2hvd246IGZhbHNlLFxuICB9XG5cbiAgY29uc3QgaW5zdGFuY2U6IEluc3RhbmNlID0ge1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICBpZCxcbiAgICByZWZlcmVuY2UsXG4gICAgcG9wcGVyLFxuICAgIHBvcHBlckNoaWxkcmVuLFxuICAgIHBvcHBlckluc3RhbmNlLFxuICAgIHByb3BzLFxuICAgIHN0YXRlLFxuICAgIC8vIG1ldGhvZHNcbiAgICBjbGVhckRlbGF5VGltZW91dHMsXG4gICAgc2V0LFxuICAgIHNldENvbnRlbnQsXG4gICAgc2hvdyxcbiAgICBoaWRlLFxuICAgIGVuYWJsZSxcbiAgICBkaXNhYmxlLFxuICAgIGRlc3Ryb3ksXG4gIH1cblxuICAvKiA9PT09PT09PT09PT09PT09PT09PSBJbml0aWFsIGluc3RhbmNlIG11dGF0aW9ucyA9PT09PT09PT09PT09PT09PT09ICovXG4gIHJlZmVyZW5jZS5fdGlwcHkgPSBpbnN0YW5jZVxuICBwb3BwZXIuX3RpcHB5ID0gaW5zdGFuY2VcblxuICBhZGRUcmlnZ2Vyc1RvUmVmZXJlbmNlKClcblxuICBpZiAoIXByb3BzLmxhenkpIHtcbiAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpXG4gIH1cblxuICBpZiAocHJvcHMuc2hvd09uSW5pdCkge1xuICAgIHNjaGVkdWxlU2hvdygpXG4gIH1cblxuICAvLyBFbnN1cmUgdGhlIGV2ZW50IGxpc3RlbmVycyB0YXJnZXQgY2FuIHJlY2VpdmUgZm9jdXNcbiAgaWYgKFxuICAgIHByb3BzLmExMXkgJiZcbiAgICAhcHJvcHMudGFyZ2V0ICYmXG4gICAgIWNhblJlY2VpdmVGb2N1cyhnZXRFdmVudExpc3RlbmVyc1RhcmdldCgpKVxuICApIHtcbiAgICBnZXRFdmVudExpc3RlbmVyc1RhcmdldCgpLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpXG4gIH1cblxuICAvLyBQcmV2ZW50IGEgdGlwcHkgd2l0aCBhIGRlbGF5IGZyb20gaGlkaW5nIGlmIHRoZSBjdXJzb3IgbGVmdCB0aGVuIHJldHVybmVkXG4gIC8vIGJlZm9yZSBpdCBzdGFydGVkIGhpZGluZ1xuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmXG4gICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiZcbiAgICAgIGxhc3RUcmlnZ2VyRXZlbnRUeXBlID09PSAnbW91c2VlbnRlcidcbiAgICApIHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgcHJvcHMub25UcmlnZ2VyKCkgdG8gYmUgY2FsbGVkIGhlcmUsIHNpbmNlIHRoZSBgZXZlbnRgXG4gICAgICAvLyBvYmplY3QgaXMgbm90IHJlbGF0ZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAgICBzY2hlZHVsZVNob3coZXZlbnQsIHRydWUpXG4gICAgfVxuICB9KVxuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgbGFzdFRyaWdnZXJFdmVudFR5cGUgPT09ICdtb3VzZWVudGVyJykge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBpbnN0YW5jZVxuXG4gIC8qID09PT09PT09PT09PT09PT09PT09PT09IPCflJIgUHJpdmF0ZSBtZXRob2RzIPCflJIgPT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGZvbGxvdyBjdXJzb3IgbGlzdGVuZXJcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUZvbGxvd0N1cnNvckxpc3RlbmVyKCk6IHZvaWQge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgIHBvc2l0aW9uVmlydHVhbFJlZmVyZW5jZU5lYXJDdXJzb3IsXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCBpbnRlcmFjdGl2ZSBtb3VzZSBsaXN0ZW5lcnNcbiAgICovXG4gIGZ1bmN0aW9uIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHNjaGVkdWxlSGlkZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSlcbiAgICBtb3VzZU1vdmVMaXN0ZW5lcnMgPSBtb3VzZU1vdmVMaXN0ZW5lcnMuZmlsdGVyKFxuICAgICAgKGxpc3RlbmVyKTogYm9vbGVhbiA9PiBsaXN0ZW5lciAhPT0gZGVib3VuY2VkT25Nb3VzZU1vdmUsXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29ycmVjdCB0YXJnZXQgdXNlZCBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFdmVudExpc3RlbmVyc1RhcmdldCgpOiBSZWZlcmVuY2VFbGVtZW50IHwgVmlydHVhbFJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZG9jdW1lbnQgY2xpY2sgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkRG9jdW1lbnRDbGlja0xpc3RlbmVyKCk6IHZvaWQge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25Eb2N1bWVudENsaWNrLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGRvY3VtZW50IGNsaWNrIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZURvY3VtZW50Q2xpY2tMaXN0ZW5lcigpOiB2b2lkIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uRG9jdW1lbnRDbGljaywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRyYW5zaXRpb25hYmxlIGlubmVyIGVsZW1lbnRzIHVzZWQgaW4gc2hvdy9oaWRlIG1ldGhvZHNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFRyYW5zaXRpb25hYmxlRWxlbWVudHMoKTogKEhUTUxEaXZFbGVtZW50IHwgbnVsbClbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGluc3RhbmNlLnBvcHBlckNoaWxkcmVuLnRvb2x0aXAsXG4gICAgICBpbnN0YW5jZS5wb3BwZXJDaGlsZHJlbi5iYWNrZHJvcCxcbiAgICAgIGluc3RhbmNlLnBvcHBlckNoaWxkcmVuLmNvbnRlbnQsXG4gICAgXVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIGluc3RhbmNlIGlzIGluIGBmb2xsb3dDdXJzb3JgIG1vZGUuXG4gICAqIE5PVEU6IGluIHY1LCB0b3VjaCBkZXZpY2VzIHdpbGwgdXNlIGBpbml0aWFsYCBiZWhhdmlvciBubyBtYXR0ZXIgdGhlIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXNJbkxvb3NlRm9sbG93Q3Vyc29yTW9kZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCB7IGZvbGxvd0N1cnNvciB9ID0gaW5zdGFuY2UucHJvcHNcbiAgICByZXR1cm4gKFxuICAgICAgKGZvbGxvd0N1cnNvciAmJiBsYXN0VHJpZ2dlckV2ZW50VHlwZSAhPT0gJ2ZvY3VzJykgfHxcbiAgICAgIChpc1VzaW5nVG91Y2ggJiYgZm9sbG93Q3Vyc29yID09PSAnaW5pdGlhbCcpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHRvb2x0aXAncyBwb3NpdGlvbiBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVN0aWNreSgpOiB2b2lkIHtcbiAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW3BvcHBlcl0sIGlzSUUgPyAwIDogaW5zdGFuY2UucHJvcHMudXBkYXRlRHVyYXRpb24pXG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpOiB2b2lkIHtcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlIS5zY2hlZHVsZVVwZGF0ZSgpXG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZVBvc2l0aW9uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtwb3BwZXJdLCAwKVxuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVBvc2l0aW9uKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGEgY2FsbGJhY2sgb25jZSB0aGUgdG9vbHRpcCBoYXMgZnVsbHkgdHJhbnNpdGlvbmVkIG91dFxuICAgKi9cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRPdXQoZHVyYXRpb246IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sICgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJlxuICAgICAgICBwb3BwZXIucGFyZW50Tm9kZSAmJlxuICAgICAgICBwb3BwZXIucGFyZW50Tm9kZS5jb250YWlucyhwb3BwZXIpXG4gICAgICApIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSW52b2tlcyBhIGNhbGxiYWNrIG9uY2UgdGhlIHRvb2x0aXAgaGFzIGZ1bGx5IHRyYW5zaXRpb25lZCBpblxuICAgKi9cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbjogbnVtYmVyLCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogSW52b2tlcyBhIGNhbGxiYWNrIG9uY2UgdGhlIHRvb2x0aXAncyBDU1MgdHJhbnNpdGlvbiBlbmRzXG4gICAqL1xuICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZHVyYXRpb246IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjb25zdCB7IHRvb2x0aXAgfSA9IGluc3RhbmNlLnBvcHBlckNoaWxkcmVuXG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW5lciBhZGRlZCBhcyB0aGUgYHRyYW5zaXRpb25lbmRgIGhhbmRsZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcihldmVudDogVHJhbnNpdGlvbkV2ZW50KTogdm9pZCB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0b29sdGlwKSB7XG4gICAgICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcih0b29sdGlwLCAncmVtb3ZlJywgbGlzdGVuZXIpXG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIGNhbGxiYWNrIHN5bmNocm9ub3VzIGlmIGR1cmF0aW9uIGlzIDBcbiAgICAvLyBgdHJhbnNpdGlvbmVuZGAgd29uJ3QgZmlyZSBvdGhlcndpc2VcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKHRvb2x0aXAsICdyZW1vdmUnLCBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyKVxuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcih0b29sdGlwLCAnYWRkJywgbGlzdGVuZXIpXG5cbiAgICBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyID0gbGlzdGVuZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSByZWZlcmVuY2UgYW5kIHN0b3JlcyBpdCBpbiBgbGlzdGVuZXJzYFxuICAgKi9cbiAgZnVuY3Rpb24gb24oXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgaGFuZGxlcjogRXZlbnRMaXN0ZW5lcixcbiAgICBvcHRpb25zOiBib29sZWFuIHwgb2JqZWN0ID0gZmFsc2UsXG4gICk6IHZvaWQge1xuICAgIGdldEV2ZW50TGlzdGVuZXJzVGFyZ2V0KCkuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpXG4gICAgbGlzdGVuZXJzLnB1c2goeyBldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgcmVmZXJlbmNlIGJhc2VkIG9uIHRoZSBgdHJpZ2dlcmAgcHJvcFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkVHJpZ2dlcnNUb1JlZmVyZW5jZSgpOiB2b2lkIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMudG91Y2hIb2xkICYmICFpbnN0YW5jZS5wcm9wcy50YXJnZXQpIHtcbiAgICAgIG9uKCd0b3VjaHN0YXJ0Jywgb25UcmlnZ2VyLCBQQVNTSVZFKVxuICAgICAgb24oJ3RvdWNoZW5kJywgb25Nb3VzZUxlYXZlIGFzIEV2ZW50TGlzdGVuZXIsIFBBU1NJVkUpXG4gICAgfVxuXG4gICAgaW5zdGFuY2UucHJvcHMudHJpZ2dlclxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5mb3JFYWNoKGV2ZW50VHlwZSA9PiB7XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb24tZGVsZWdhdGVzXG4gICAgICAgIGlmICghaW5zdGFuY2UucHJvcHMudGFyZ2V0KSB7XG4gICAgICAgICAgb24oZXZlbnRUeXBlLCBvblRyaWdnZXIpXG4gICAgICAgICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICAgICAgICBvbignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSBhcyBFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICBvbihpc0lFID8gJ2ZvY3Vzb3V0JyA6ICdibHVyJywgb25CbHVyIGFzIEV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERlbGVnYXRlc1xuICAgICAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdtb3VzZWVudGVyJzpcbiAgICAgICAgICAgICAgb24oJ21vdXNlb3ZlcicsIG9uRGVsZWdhdGVTaG93KVxuICAgICAgICAgICAgICBvbignbW91c2VvdXQnLCBvbkRlbGVnYXRlSGlkZSlcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICAgICAgb24oJ2ZvY3VzaW4nLCBvbkRlbGVnYXRlU2hvdylcbiAgICAgICAgICAgICAgb24oJ2ZvY3Vzb3V0Jywgb25EZWxlZ2F0ZUhpZGUpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgIG9uKGV2ZW50VHlwZSwgb25EZWxlZ2F0ZVNob3cpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIHJlZmVyZW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlVHJpZ2dlcnNGcm9tUmVmZXJlbmNlKCk6IHZvaWQge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKCh7IGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyB9OiBMaXN0ZW5lcikgPT4ge1xuICAgICAgZ2V0RXZlbnRMaXN0ZW5lcnNUYXJnZXQoKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucylcbiAgICB9KVxuICAgIGxpc3RlbmVycyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogUG9zaXRpb25zIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBuZWFyIHRoZSBjdXJzb3JcbiAgICovXG4gIGZ1bmN0aW9uIHBvc2l0aW9uVmlydHVhbFJlZmVyZW5jZU5lYXJDdXJzb3IoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNsaWVudFg6IHgsIGNsaWVudFk6IHkgfSA9IChsYXN0TW91c2VNb3ZlRXZlbnQgPSBldmVudClcblxuICAgIC8vIEdldHMgc2V0IG9uY2UgcG9wcGVySW5zdGFuY2UgYG9uQ3JlYXRlYCBoYXMgYmVlbiBjYWxsZWRcbiAgICBpZiAoIWN1cnJlbnRDb21wdXRlZFBhZGRpbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBpbnN0YW5jZSBpcyBpbnRlcmFjdGl2ZSwgYXZvaWQgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHVubGVzcyBpdCdzXG4gICAgLy8gb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICBjb25zdCBpc0N1cnNvck92ZXJSZWZlcmVuY2UgPSBjbG9zZXN0Q2FsbGJhY2soXG4gICAgICBldmVudC50YXJnZXQgYXMgRWxlbWVudCxcbiAgICAgIChlbDogRWxlbWVudCk6IGJvb2xlYW4gPT4gZWwgPT09IHJlZmVyZW5jZSxcbiAgICApXG5cbiAgICBjb25zdCByZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgeyBmb2xsb3dDdXJzb3IgfSA9IGluc3RhbmNlLnByb3BzXG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCdcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gZm9sbG93Q3Vyc29yID09PSAndmVydGljYWwnXG5cbiAgICAvLyBUaGUgdmlydHVhbCByZWZlcmVuY2UgbmVlZHMgc29tZSBzaXplIHRvIHByZXZlbnQgaXRzZWxmIGZyb20gb3ZlcmZsb3dpbmdcbiAgICBjb25zdCBpc1ZlcnRpY2FsUGxhY2VtZW50ID0gaW5jbHVkZXMoXG4gICAgICBbJ3RvcCcsICdib3R0b20nXSxcbiAgICAgIGdldEJhc2ljUGxhY2VtZW50KHBvcHBlciksXG4gICAgKVxuICAgIGNvbnN0IGZ1bGxQbGFjZW1lbnQgPSBwb3BwZXIuZ2V0QXR0cmlidXRlKFBMQUNFTUVOVF9BVFRSSUJVVEUpXG4gICAgY29uc3QgaXNWYXJpYXRpb24gPSBmdWxsUGxhY2VtZW50ID8gISFmdWxsUGxhY2VtZW50LnNwbGl0KCctJylbMV0gOiBmYWxzZVxuICAgIGNvbnN0IHNpemUgPSBpc1ZlcnRpY2FsUGxhY2VtZW50ID8gcG9wcGVyLm9mZnNldFdpZHRoIDogcG9wcGVyLm9mZnNldEhlaWdodFxuICAgIGNvbnN0IGhhbGZTaXplID0gc2l6ZSAvIDJcbiAgICBjb25zdCB2ZXJ0aWNhbEluY3JlYXNlID0gaXNWZXJ0aWNhbFBsYWNlbWVudFxuICAgICAgPyAwXG4gICAgICA6IGlzVmFyaWF0aW9uXG4gICAgICA/IHNpemVcbiAgICAgIDogaGFsZlNpemVcbiAgICBjb25zdCBob3Jpem9udGFsSW5jcmVhc2UgPSBpc1ZlcnRpY2FsUGxhY2VtZW50XG4gICAgICA/IGlzVmFyaWF0aW9uXG4gICAgICAgID8gc2l6ZVxuICAgICAgICA6IGhhbGZTaXplXG4gICAgICA6IDBcblxuICAgIGlmIChpc0N1cnNvck92ZXJSZWZlcmVuY2UgfHwgIWluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSEucmVmZXJlbmNlID0ge1xuICAgICAgICAuLi5pbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSEucmVmZXJlbmNlLFxuICAgICAgICAvLyBUaGVzZSBgY2xpZW50YCB2YWx1ZXMgZG9uJ3QgZ2V0IHVzZWQgYnkgUG9wcGVyLmpzIGlmIHRoZXkgYXJlIDBcbiAgICAgICAgY2xpZW50V2lkdGg6IDAsXG4gICAgICAgIGNsaWVudEhlaWdodDogMCxcbiAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKTogRE9NUmVjdCB8IENsaWVudFJlY3QgPT4gKHtcbiAgICAgICAgICB3aWR0aDogaXNWZXJ0aWNhbFBsYWNlbWVudCA/IHNpemUgOiAwLFxuICAgICAgICAgIGhlaWdodDogaXNWZXJ0aWNhbFBsYWNlbWVudCA/IDAgOiBzaXplLFxuICAgICAgICAgIHRvcDogKGlzSG9yaXpvbnRhbCA/IHJlY3QudG9wIDogeSkgLSB2ZXJ0aWNhbEluY3JlYXNlLFxuICAgICAgICAgIGJvdHRvbTogKGlzSG9yaXpvbnRhbCA/IHJlY3QuYm90dG9tIDogeSkgKyB2ZXJ0aWNhbEluY3JlYXNlLFxuICAgICAgICAgIGxlZnQ6IChpc1ZlcnRpY2FsID8gcmVjdC5sZWZ0IDogeCkgLSBob3Jpem9udGFsSW5jcmVhc2UsXG4gICAgICAgICAgcmlnaHQ6IChpc1ZlcnRpY2FsID8gcmVjdC5yaWdodCA6IHgpICsgaG9yaXpvbnRhbEluY3JlYXNlLFxuICAgICAgICB9KSxcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UhLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgaWYgKGZvbGxvd0N1cnNvciA9PT0gJ2luaXRpYWwnICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmVtb3ZlRm9sbG93Q3Vyc29yTGlzdGVuZXIoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSB0aXBweSBpbnN0YW5jZSBmb3IgYSBkZWxlZ2F0ZSB3aGVuIGl0J3MgYmVlbiB0cmlnZ2VyZWRcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZURlbGVnYXRlQ2hpbGRUaXBweShldmVudD86IEV2ZW50KTogdm9pZCB7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb25zdCB0YXJnZXRFbDogUmVmZXJlbmNlRWxlbWVudCB8IG51bGwgPSBjbG9zZXN0KFxuICAgICAgICBldmVudC50YXJnZXQgYXMgRWxlbWVudCxcbiAgICAgICAgaW5zdGFuY2UucHJvcHMudGFyZ2V0LFxuICAgICAgKVxuXG4gICAgICBpZiAodGFyZ2V0RWwgJiYgIXRhcmdldEVsLl90aXBweSkge1xuICAgICAgICBjcmVhdGVUaXBweSh0YXJnZXRFbCwge1xuICAgICAgICAgIC4uLmluc3RhbmNlLnByb3BzLFxuICAgICAgICAgIGNvbnRlbnQ6IGludm9rZVdpdGhBcmdzT3JSZXR1cm4oY29sbGVjdGlvblByb3BzLmNvbnRlbnQsIFt0YXJnZXRFbF0pLFxuICAgICAgICAgIGFwcGVuZFRvOiBjb2xsZWN0aW9uUHJvcHMuYXBwZW5kVG8sXG4gICAgICAgICAgdGFyZ2V0OiAnJyxcbiAgICAgICAgICBzaG93T25Jbml0OiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBsaXN0ZW5lciBpbnZva2VkIHVwb24gdHJpZ2dlclxuICAgKi9cbiAgZnVuY3Rpb24gb25UcmlnZ2VyKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkIHx8IGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgbGFzdFRyaWdnZXJFdmVudFR5cGUgPSBldmVudC50eXBlXG5cbiAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcbiAgICAgICAgbGFzdE1vdXNlTW92ZUV2ZW50ID0gZXZlbnRcblxuICAgICAgICAvLyBJZiBzY3JvbGxpbmcsIGBtb3VzZWVudGVyYCBldmVudHMgY2FuIGJlIGZpcmVkIGlmIHRoZSBjdXJzb3IgbGFuZHNcbiAgICAgICAgLy8gb3ZlciBhIG5ldyB0YXJnZXQsIGJ1dCBgbW91c2Vtb3ZlYCBldmVudHMgZG9uJ3QgZ2V0IGZpcmVkLiBUaGlzXG4gICAgICAgIC8vIGNhdXNlcyBpbnRlcmFjdGl2ZSB0b29sdGlwcyB0byBnZXQgc3R1Y2sgb3BlbiB1bnRpbCB0aGUgY3Vyc29yIGlzXG4gICAgICAgIC8vIG1vdmVkXG4gICAgICAgIG1vdXNlTW92ZUxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcik6IHZvaWQgPT4gbGlzdGVuZXIoZXZlbnQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRvZ2dsZSBzaG93L2hpZGUgd2hlbiBjbGlja2luZyBjbGljay10cmlnZ2VyZWQgdG9vbHRpcHNcbiAgICBpZiAoXG4gICAgICBldmVudC50eXBlID09PSAnY2xpY2snICYmXG4gICAgICBpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayAhPT0gZmFsc2UgJiZcbiAgICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZVxuICAgICkge1xuICAgICAgc2NoZWR1bGVIaWRlKClcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVTaG93KGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBsaXN0ZW5lciB1c2VkIGZvciBpbnRlcmFjdGl2ZSB0b29sdGlwcyB0byBkZXRlY3Qgd2hlbiB0aGV5IHNob3VsZFxuICAgKiBoaWRlXG4gICAqL1xuICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGlzQ3Vyc29yT3ZlclBvcHBlciA9XG4gICAgICBjbG9zZXN0KGV2ZW50LnRhcmdldCBhcyBFbGVtZW50LCBQT1BQRVJfU0VMRUNUT1IpID09PSBwb3BwZXJcbiAgICBjb25zdCBpc0N1cnNvck92ZXJSZWZlcmVuY2UgPSBjbG9zZXN0Q2FsbGJhY2soXG4gICAgICBldmVudC50YXJnZXQgYXMgRWxlbWVudCxcbiAgICAgIChlbDogRWxlbWVudCkgPT4gZWwgPT09IHJlZmVyZW5jZSxcbiAgICApXG5cbiAgICBpZiAoaXNDdXJzb3JPdmVyUG9wcGVyIHx8IGlzQ3Vyc29yT3ZlclJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIoXG4gICAgICAgIGdldEJhc2ljUGxhY2VtZW50KHBvcHBlciksXG4gICAgICAgIHBvcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGluc3RhbmNlLnByb3BzLFxuICAgICAgKVxuICAgICkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKVxuICAgICAgc2NoZWR1bGVIaWRlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgbGlzdGVuZXIgaW52b2tlZCB1cG9uIG1vdXNlbGVhdmVcbiAgICovXG4gIGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGlmIChpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBzY2hlZHVsZUhpZGUpXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSlcbiAgICAgIG1vdXNlTW92ZUxpc3RlbmVycy5wdXNoKGRlYm91bmNlZE9uTW91c2VNb3ZlKVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGxpc3RlbmVyIGludm9rZWQgdXBvbiBibHVyXG4gICAqL1xuICBmdW5jdGlvbiBvbkJsdXIoZXZlbnQ6IEZvY3VzRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBnZXRFdmVudExpc3RlbmVyc1RhcmdldCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJlxuICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCAmJlxuICAgICAgcG9wcGVyLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQgYXMgRWxlbWVudClcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNjaGVkdWxlSGlkZSgpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgbGlzdGVuZXIgaW52b2tlZCB3aGVuIGEgY2hpbGQgdGFyZ2V0IGlzIHRyaWdnZXJlZFxuICAgKi9cbiAgZnVuY3Rpb24gb25EZWxlZ2F0ZVNob3coZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgaWYgKGNsb3Nlc3QoZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQsIGluc3RhbmNlLnByb3BzLnRhcmdldCkpIHtcbiAgICAgIHNjaGVkdWxlU2hvdyhldmVudClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgbGlzdGVuZXIgaW52b2tlZCB3aGVuIGEgY2hpbGQgdGFyZ2V0IHNob3VsZCBoaWRlXG4gICAqL1xuICBmdW5jdGlvbiBvbkRlbGVnYXRlSGlkZShldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAoY2xvc2VzdChldmVudC50YXJnZXQgYXMgRWxlbWVudCwgaW5zdGFuY2UucHJvcHMudGFyZ2V0KSkge1xuICAgICAgc2NoZWR1bGVIaWRlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhbiBldmVudCBsaXN0ZW5lciBzaG91bGQgc3RvcCBmdXJ0aGVyIGV4ZWN1dGlvbiBkdWUgdG8gdGhlXG4gICAqIGB0b3VjaEhvbGRgIG9wdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudDogRXZlbnQpOiBib29sZWFuIHtcbiAgICBjb25zdCBzdXBwb3J0c1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93XG4gICAgY29uc3QgaXNUb3VjaEV2ZW50ID0gaW5jbHVkZXMoZXZlbnQudHlwZSwgJ3RvdWNoJylcbiAgICBjb25zdCB7IHRvdWNoSG9sZCB9ID0gaW5zdGFuY2UucHJvcHNcblxuICAgIHJldHVybiAoXG4gICAgICAoc3VwcG9ydHNUb3VjaCAmJiBpc1VzaW5nVG91Y2ggJiYgdG91Y2hIb2xkICYmICFpc1RvdWNoRXZlbnQpIHx8XG4gICAgICAoaXNVc2luZ1RvdWNoICYmICF0b3VjaEhvbGQgJiYgaXNUb3VjaEV2ZW50KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBtb3VudCBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gcnVuTW91bnRDYWxsYmFjaygpOiB2b2lkIHtcbiAgICBpZiAoIWhhc01vdW50Q2FsbGJhY2tSdW4gJiYgY3VycmVudE1vdW50Q2FsbGJhY2spIHtcbiAgICAgIGhhc01vdW50Q2FsbGJhY2tSdW4gPSB0cnVlXG4gICAgICByZWZsb3cocG9wcGVyKVxuICAgICAgY3VycmVudE1vdW50Q2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBwb3BwZXIgaW5zdGFuY2UgZm9yIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlUG9wcGVySW5zdGFuY2UoKTogdm9pZCB7XG4gICAgY29uc3QgeyBwb3BwZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5wcm9wc1xuICAgIGNvbnN0IHsgdG9vbHRpcCwgYXJyb3cgfSA9IGluc3RhbmNlLnBvcHBlckNoaWxkcmVuXG4gICAgY29uc3QgcHJldmVudE92ZXJmbG93TW9kaWZpZXIgPSBnZXRNb2RpZmllcihcbiAgICAgIHBvcHBlck9wdGlvbnMsXG4gICAgICAncHJldmVudE92ZXJmbG93JyxcbiAgICApXG5cbiAgICBmdW5jdGlvbiBhcHBseU11dGF0aW9ucyhkYXRhOiBQb3BwZXIuRGF0YSk6IHZvaWQge1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZsaXAgJiYgIWluc3RhbmNlLnByb3BzLmZsaXBPblVwZGF0ZSkge1xuICAgICAgICBpZiAoZGF0YS5mbGlwcGVkKSB7XG4gICAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UhLm9wdGlvbnMucGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEZsaXBNb2RpZmllckVuYWJsZWQoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UhLm1vZGlmaWVycywgZmFsc2UpXG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IGFsbCBvZiB0aGUgcG9wcGVyJ3MgYXR0cmlidXRlcyB0byB0aGUgdG9vdGlwIG5vZGUgYXMgd2VsbC5cbiAgICAgIC8vIEFsbG93cyB1c2VycyB0byBhdm9pZCB1c2luZyB0aGUgLnRpcHB5LXBvcHBlciBzZWxlY3RvciBmb3IgdGhlbWVzLlxuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoUExBQ0VNRU5UX0FUVFJJQlVURSwgZGF0YS5wbGFjZW1lbnQpXG5cbiAgICAgIGlmIChkYXRhLmF0dHJpYnV0ZXNbT1VUX09GX0JPVU5EQVJJRVNfQVRUUklCVVRFXSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoT1VUX09GX0JPVU5EQVJJRVNfQVRUUklCVVRFLCAnJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKE9VVF9PRl9CT1VOREFSSUVTX0FUVFJJQlVURSlcbiAgICAgIH1cblxuICAgICAgLy8gUHJldmVudHMgYSB0cmFuc2l0aW9uIHdoZW4gY2hhbmdpbmcgcGxhY2VtZW50cyAod2hpbGUgdGlwcHkgaXMgdmlzaWJsZSlcbiAgICAgIC8vIGZvciBzY3JvbGwvcmVzaXplIHVwZGF0ZXNcbiAgICAgIGlmIChcbiAgICAgICAgcHJldmlvdXNQbGFjZW1lbnQgJiZcbiAgICAgICAgcHJldmlvdXNQbGFjZW1lbnQgIT09IGRhdGEucGxhY2VtZW50ICYmXG4gICAgICAgIHdhc1Zpc2libGVEdXJpbmdQcmV2aW91c1VwZGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHRvb2x0aXAuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJ1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHRvb2x0aXAuc3R5bGUudHJhbnNpdGlvbiA9ICcnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBwcmV2aW91c1BsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50XG4gICAgICB3YXNWaXNpYmxlRHVyaW5nUHJldmlvdXNVcGRhdGUgPSBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGVcblxuICAgICAgY29uc3QgYmFzaWNQbGFjZW1lbnQgPSBnZXRCYXNpY1BsYWNlbWVudChwb3BwZXIpXG4gICAgICBjb25zdCBzdHlsZXMgPSB0b29sdGlwLnN0eWxlXG5cbiAgICAgIC8vIEFjY291bnQgZm9yIHRoZSBgZGlzdGFuY2VgIG9mZnNldFxuICAgICAgc3R5bGVzLnRvcCA9IHN0eWxlcy5ib3R0b20gPSBzdHlsZXMubGVmdCA9IHN0eWxlcy5yaWdodCA9ICcnXG4gICAgICBzdHlsZXNbYmFzaWNQbGFjZW1lbnRdID0gZ2V0T2Zmc2V0RGlzdGFuY2VJblB4KGluc3RhbmNlLnByb3BzLmRpc3RhbmNlKVxuXG4gICAgICBjb25zdCBwYWRkaW5nID1cbiAgICAgICAgcHJldmVudE92ZXJmbG93TW9kaWZpZXIgJiYgcHJldmVudE92ZXJmbG93TW9kaWZpZXIucGFkZGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBwcmV2ZW50T3ZlcmZsb3dNb2RpZmllci5wYWRkaW5nXG4gICAgICAgICAgOiBQQURESU5HXG4gICAgICBjb25zdCBpc1BhZGRpbmdOdW1iZXIgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcidcblxuICAgICAgY29uc3QgY29tcHV0ZWRQYWRkaW5nID0ge1xuICAgICAgICB0b3A6IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCxcbiAgICAgICAgYm90dG9tOiBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20sXG4gICAgICAgIGxlZnQ6IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCxcbiAgICAgICAgLi4uKCFpc1BhZGRpbmdOdW1iZXIgJiYgcGFkZGluZyksXG4gICAgICB9XG5cbiAgICAgIGNvbXB1dGVkUGFkZGluZ1tiYXNpY1BsYWNlbWVudF0gPSBpc1BhZGRpbmdOdW1iZXJcbiAgICAgICAgPyBwYWRkaW5nICsgaW5zdGFuY2UucHJvcHMuZGlzdGFuY2VcbiAgICAgICAgOiAocGFkZGluZ1tiYXNpY1BsYWNlbWVudF0gfHwgMCkgKyBpbnN0YW5jZS5wcm9wcy5kaXN0YW5jZVxuXG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSEubW9kaWZpZXJzLmZpbHRlcihcbiAgICAgICAgbSA9PiBtLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgKVswXS5wYWRkaW5nID0gY29tcHV0ZWRQYWRkaW5nXG5cbiAgICAgIGN1cnJlbnRDb21wdXRlZFBhZGRpbmcgPSBjb21wdXRlZFBhZGRpbmdcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBldmVudHNFbmFibGVkOiBmYWxzZSxcbiAgICAgIHBsYWNlbWVudDogaW5zdGFuY2UucHJvcHMucGxhY2VtZW50LFxuICAgICAgLi4ucG9wcGVyT3B0aW9ucyxcbiAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAuLi4ocG9wcGVyT3B0aW9ucyA/IHBvcHBlck9wdGlvbnMubW9kaWZpZXJzIDoge30pLFxuICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogaW5zdGFuY2UucHJvcHMuYm91bmRhcnksXG4gICAgICAgICAgcGFkZGluZzogUEFERElORyxcbiAgICAgICAgICAuLi5wcmV2ZW50T3ZlcmZsb3dNb2RpZmllcixcbiAgICAgICAgfSxcbiAgICAgICAgYXJyb3c6IHtcbiAgICAgICAgICBlbGVtZW50OiBhcnJvdyxcbiAgICAgICAgICBlbmFibGVkOiAhIWFycm93LFxuICAgICAgICAgIC4uLmdldE1vZGlmaWVyKHBvcHBlck9wdGlvbnMsICdhcnJvdycpLFxuICAgICAgICB9LFxuICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgZW5hYmxlZDogaW5zdGFuY2UucHJvcHMuZmxpcCxcbiAgICAgICAgICAvLyBUaGUgdG9vbHRpcCBpcyBvZmZzZXQgYnkgMTBweCBmcm9tIHRoZSBwb3BwZXIgaW4gQ1NTLFxuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgaXRzIGRpc3RhbmNlXG4gICAgICAgICAgcGFkZGluZzogaW5zdGFuY2UucHJvcHMuZGlzdGFuY2UgKyBQQURESU5HLFxuICAgICAgICAgIGJlaGF2aW9yOiBpbnN0YW5jZS5wcm9wcy5mbGlwQmVoYXZpb3IsXG4gICAgICAgICAgLi4uZ2V0TW9kaWZpZXIocG9wcGVyT3B0aW9ucywgJ2ZsaXAnKSxcbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgb2Zmc2V0OiBpbnN0YW5jZS5wcm9wcy5vZmZzZXQsXG4gICAgICAgICAgLi4uZ2V0TW9kaWZpZXIocG9wcGVyT3B0aW9ucywgJ29mZnNldCcpLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIG9uQ3JlYXRlKGRhdGE6IFBvcHBlci5EYXRhKSB7XG4gICAgICAgIGFwcGx5TXV0YXRpb25zKGRhdGEpXG4gICAgICAgIHJ1bk1vdW50Q2FsbGJhY2soKVxuXG4gICAgICAgIGlmIChwb3BwZXJPcHRpb25zICYmIHBvcHBlck9wdGlvbnMub25DcmVhdGUpIHtcbiAgICAgICAgICBwb3BwZXJPcHRpb25zLm9uQ3JlYXRlKGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZShkYXRhOiBQb3BwZXIuRGF0YSkge1xuICAgICAgICBhcHBseU11dGF0aW9ucyhkYXRhKVxuICAgICAgICBydW5Nb3VudENhbGxiYWNrKClcblxuICAgICAgICBpZiAocG9wcGVyT3B0aW9ucyAmJiBwb3BwZXJPcHRpb25zLm9uVXBkYXRlKSB7XG4gICAgICAgICAgcG9wcGVyT3B0aW9ucy5vblVwZGF0ZShkYXRhKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH1cblxuICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlID0gbmV3IFBvcHBlcihcbiAgICAgIHJlZmVyZW5jZSxcbiAgICAgIHBvcHBlcixcbiAgICAgIGNvbmZpZyxcbiAgICApIGFzIFBvcHBlckluc3RhbmNlXG4gIH1cblxuICAvKipcbiAgICogTW91bnRzIHRoZSB0b29sdGlwIHRvIHRoZSBET01cbiAgICovXG4gIGZ1bmN0aW9uIG1vdW50KCk6IHZvaWQge1xuICAgIGhhc01vdW50Q2FsbGJhY2tSdW4gPSBmYWxzZVxuXG4gICAgY29uc3QgaXNJbkxvb3NlRm9sbG93Q3Vyc29yTW9kZSA9IGdldElzSW5Mb29zZUZvbGxvd0N1cnNvck1vZGUoKVxuXG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBzZXRGbGlwTW9kaWZpZXJFbmFibGVkKFxuICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5tb2RpZmllcnMsXG4gICAgICAgIGluc3RhbmNlLnByb3BzLmZsaXAsXG4gICAgICApXG5cbiAgICAgIGlmICghaXNJbkxvb3NlRm9sbG93Q3Vyc29yTW9kZSkge1xuICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5yZWZlcmVuY2UgPSByZWZlcmVuY2VcbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKVxuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5zY2hlZHVsZVVwZGF0ZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKClcblxuICAgICAgaWYgKCFpc0luTG9vc2VGb2xsb3dDdXJzb3JNb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlIS5lbmFibGVFdmVudExpc3RlbmVycygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBhcHBlbmRUbyB9ID0gaW5zdGFuY2UucHJvcHNcbiAgICBjb25zdCBwYXJlbnROb2RlID1cbiAgICAgIGFwcGVuZFRvID09PSAncGFyZW50J1xuICAgICAgICA/IHJlZmVyZW5jZS5wYXJlbnROb2RlXG4gICAgICAgIDogaW52b2tlV2l0aEFyZ3NPclJldHVybihhcHBlbmRUbywgW3JlZmVyZW5jZV0pXG5cbiAgICBpZiAoIXBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKSkge1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwb3BwZXIpXG4gICAgICBpbnN0YW5jZS5wcm9wcy5vbk1vdW50KGluc3RhbmNlKVxuICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBiZWZvcmUgc2hvdygpIGlzIGludm9rZWQgKGRlbGF5cywgZXRjLilcbiAgICovXG4gIGZ1bmN0aW9uIHNjaGVkdWxlU2hvdyhcbiAgICBldmVudD86IEV2ZW50LFxuICAgIHNob3VsZEF2b2lkQ2FsbGluZ09uVHJpZ2dlcj86IGJvb2xlYW4sXG4gICk6IHZvaWQge1xuICAgIGNsZWFyRGVsYXlUaW1lb3V0cygpXG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJcyBhIGRlbGVnYXRlLCBjcmVhdGUgYW4gaW5zdGFuY2UgZm9yIHRoZSBjaGlsZCB0YXJnZXRcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMudGFyZ2V0KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVsZWdhdGVDaGlsZFRpcHB5KGV2ZW50KVxuICAgIH1cblxuICAgIGlzU2NoZWR1bGVkVG9TaG93ID0gdHJ1ZVxuXG4gICAgaWYgKGV2ZW50ICYmICFzaG91bGRBdm9pZENhbGxpbmdPblRyaWdnZXIpIHtcbiAgICAgIGluc3RhbmNlLnByb3BzLm9uVHJpZ2dlcihpbnN0YW5jZSwgZXZlbnQpXG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLndhaXQpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcy53YWl0KGluc3RhbmNlLCBldmVudClcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdG9vbHRpcCBoYXMgYSBkZWxheSwgd2UgbmVlZCB0byBiZSBsaXN0ZW5pbmcgdG8gdGhlIG1vdXNlbW92ZSBhc1xuICAgIC8vIHNvb24gYXMgdGhlIHRyaWdnZXIgZXZlbnQgaXMgZmlyZWQsIHNvIHRoYXQgaXQncyBpbiB0aGUgY29ycmVjdCBwb3NpdGlvblxuICAgIC8vIHVwb24gbW91bnQuXG4gICAgLy8gRWRnZSBjYXNlOiBpZiB0aGUgdG9vbHRpcCBpcyBzdGlsbCBtb3VudGVkLCBidXQgdGhlbiBzY2hlZHVsZVNob3coKSBpc1xuICAgIC8vIGNhbGxlZCwgaXQgY2F1c2VzIGEganVtcC5cbiAgICBpZiAoZ2V0SXNJbkxvb3NlRm9sbG93Q3Vyc29yTW9kZSgpICYmICFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgIGlmICghaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKVxuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBwb3NpdGlvblZpcnR1YWxSZWZlcmVuY2VOZWFyQ3Vyc29yKVxuICAgIH1cblxuICAgIGFkZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpXG5cbiAgICBjb25zdCBkZWxheSA9IGdldFZhbHVlKGluc3RhbmNlLnByb3BzLmRlbGF5LCAwLCBkZWZhdWx0UHJvcHMuZGVsYXkpXG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIHNob3dUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2hvdygpXG4gICAgICB9LCBkZWxheSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGJlZm9yZSBoaWRlKCkgaXMgaW52b2tlZCAoZGVsYXlzLCBldGMuKVxuICAgKi9cbiAgZnVuY3Rpb24gc2NoZWR1bGVIaWRlKCk6IHZvaWQge1xuICAgIGNsZWFyRGVsYXlUaW1lb3V0cygpXG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuIHJlbW92ZUZvbGxvd0N1cnNvckxpc3RlbmVyKClcbiAgICB9XG5cbiAgICBpc1NjaGVkdWxlZFRvU2hvdyA9IGZhbHNlXG5cbiAgICBjb25zdCBkZWxheSA9IGdldFZhbHVlKGluc3RhbmNlLnByb3BzLmRlbGF5LCAxLCBkZWZhdWx0UHJvcHMuZGVsYXkpXG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGhpZGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICAgIGhpZGUoKVxuICAgICAgICB9XG4gICAgICB9LCBkZWxheSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRml4ZXMgYSBgdHJhbnNpdGlvbmVuZGAgcHJvYmxlbSB3aGVuIGl0IGZpcmVzIDEgZnJhbWUgdG9vXG4gICAgICAvLyBsYXRlIHNvbWV0aW1lcywgd2UgZG9uJ3Qgd2FudCBoaWRlKCkgdG8gYmUgY2FsbGVkLlxuICAgICAgc2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGhpZGUoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuZXIgdG8gaGFuZGxlIGNsaWNrcyBvbiB0aGUgZG9jdW1lbnQgdG8gZGV0ZXJtaW5lIGlmIHRoZVxuICAgKiBpbnN0YW5jZSBzaG91bGQgaGlkZVxuICAgKi9cbiAgZnVuY3Rpb24gb25Eb2N1bWVudENsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgLy8gQ2xpY2tlZCBvbiBpbnRlcmFjdGl2ZSBwb3BwZXJcbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJlxuICAgICAgcG9wcGVyLmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQ2xpY2tlZCBvbiB0aGUgZXZlbnQgbGlzdGVuZXJzIHRhcmdldFxuICAgIGlmIChnZXRFdmVudExpc3RlbmVyc1RhcmdldCgpLmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KSkge1xuICAgICAgaWYgKGlzVXNpbmdUb3VjaCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiZcbiAgICAgICAgaW5jbHVkZXMoaW5zdGFuY2UucHJvcHMudHJpZ2dlciwgJ2NsaWNrJylcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaGlkZU9uQ2xpY2sgPT09IHRydWUpIHtcbiAgICAgIGNsZWFyRGVsYXlUaW1lb3V0cygpXG4gICAgICBoaWRlKClcbiAgICB9XG4gIH1cblxuICAvKiA9PT09PT09PT09PT09PT09PT09PT09PSDwn5SRIFB1YmxpYyBtZXRob2RzIPCflJEgPT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIGluc3RhbmNlIHRvIGFsbG93IGl0IHRvIHNob3cgb3IgaGlkZVxuICAgKi9cbiAgZnVuY3Rpb24gZW5hYmxlKCk6IHZvaWQge1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgaW5zdGFuY2UgdG8gZGlzYWxsb3cgaXQgdG8gc2hvdyBvciBoaWRlXG4gICAqL1xuICBmdW5jdGlvbiBkaXNhYmxlKCk6IHZvaWQge1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHBlbmRpbmcgdGltZW91dHMgcmVsYXRlZCB0byB0aGUgYGRlbGF5YCBwcm9wIGlmIGFueVxuICAgKi9cbiAgZnVuY3Rpb24gY2xlYXJEZWxheVRpbWVvdXRzKCk6IHZvaWQge1xuICAgIGNsZWFyVGltZW91dChzaG93VGltZW91dElkKVxuICAgIGNsZWFyVGltZW91dChoaWRlVGltZW91dElkKVxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lSWQpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBuZXcgcHJvcHMgZm9yIHRoZSBpbnN0YW5jZSBhbmQgcmVkcmF3cyB0aGUgdG9vbHRpcFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0KG9wdGlvbnM6IE9wdGlvbnMpOiB2b2lkIHtcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJsZSBhZnRlciBUeXBlU2NyaXB0IGNoYW5nZVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdFByb3BzKVxuXG4gICAgcmVtb3ZlVHJpZ2dlcnNGcm9tUmVmZXJlbmNlKClcblxuICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzXG4gICAgY29uc3QgbmV4dFByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIHtcbiAgICAgIC4uLmluc3RhbmNlLnByb3BzLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGlnbm9yZUF0dHJpYnV0ZXM6IHRydWUsXG4gICAgfSlcbiAgICBuZXh0UHJvcHMuaWdub3JlQXR0cmlidXRlcyA9IGhhc093blByb3BlcnR5KG9wdGlvbnMsICdpZ25vcmVBdHRyaWJ1dGVzJylcbiAgICAgID8gb3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzIHx8IGZhbHNlXG4gICAgICA6IHByZXZQcm9wcy5pZ25vcmVBdHRyaWJ1dGVzXG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHNcblxuICAgIGFkZFRyaWdnZXJzVG9SZWZlcmVuY2UoKVxuXG4gICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKVxuICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlID0gZGVib3VuY2Uob25Nb3VzZU1vdmUsIG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKVxuXG4gICAgdXBkYXRlUG9wcGVyRWxlbWVudChwb3BwZXIsIHByZXZQcm9wcywgbmV4dFByb3BzKVxuICAgIGluc3RhbmNlLnBvcHBlckNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4ocG9wcGVyKVxuXG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIFBPUFBFUl9JTlNUQU5DRV9ERVBFTkRFTkNJRVMuc29tZShwcm9wID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaGFzT3duUHJvcGVydHkob3B0aW9ucywgcHJvcCkgJiYgb3B0aW9uc1twcm9wXSAhPT0gcHJldlByb3BzW3Byb3BdXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKSB7XG4gICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLmRlc3Ryb3koKVxuICAgICAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpXG5cbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLmVuYWJsZUV2ZW50TGlzdGVuZXJzKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IgJiYgbGFzdE1vdXNlTW92ZUV2ZW50KSB7XG4gICAgICAgICAgcG9zaXRpb25WaXJ0dWFsUmVmZXJlbmNlTmVhckN1cnNvcihsYXN0TW91c2VNb3ZlRXZlbnQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IGZvciAuc2V0KHsgY29udGVudDogbmV3Q29udGVudCB9KVxuICAgKi9cbiAgZnVuY3Rpb24gc2V0Q29udGVudChjb250ZW50OiBDb250ZW50KTogdm9pZCB7XG4gICAgc2V0KHsgY29udGVudCB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSB0b29sdGlwXG4gICAqL1xuICBmdW5jdGlvbiBzaG93KFxuICAgIGR1cmF0aW9uOiBudW1iZXIgPSBnZXRWYWx1ZShcbiAgICAgIGluc3RhbmNlLnByb3BzLmR1cmF0aW9uLFxuICAgICAgMCxcbiAgICAgIChkZWZhdWx0UHJvcHMuZHVyYXRpb24gYXMgW251bWJlciwgbnVtYmVyXSlbMV0sXG4gICAgKSxcbiAgKTogdm9pZCB7XG4gICAgaWYgKFxuICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQgfHxcbiAgICAgICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgfHxcbiAgICAgIChpc1VzaW5nVG91Y2ggJiYgIWluc3RhbmNlLnByb3BzLnRvdWNoKVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gU3RhbmRhcmRpemUgYGRpc2FibGVkYCBiZWhhdmlvciBhY3Jvc3MgYnJvd3NlcnMuXG4gICAgLy8gRmlyZWZveCBhbGxvd3MgZXZlbnRzIG9uIGRpc2FibGVkIGVsZW1lbnRzLCBidXQgQ2hyb21lIGRvZXNuJ3QuXG4gICAgLy8gVXNpbmcgYSB3cmFwcGVyIGVsZW1lbnQgKGkuZS4gPHNwYW4+KSBpcyByZWNvbW1lbmRlZC5cbiAgICBpZiAoZ2V0RXZlbnRMaXN0ZW5lcnNUYXJnZXQoKS5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5vblNob3coaW5zdGFuY2UpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYWRkRG9jdW1lbnRDbGlja0xpc3RlbmVyKClcblxuICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gdHJ1ZVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICBnZXRFdmVudExpc3RlbmVyc1RhcmdldCgpLmNsYXNzTGlzdC5hZGQoQUNUSVZFX0NMQVNTKVxuICAgIH1cblxuICAgIC8vIFByZXZlbnQgYSB0cmFuc2l0aW9uIGlmIHRoZSBwb3BwZXIgaXMgYXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudFxuICAgIGNvbnN0IHRyYW5zaXRpb25hYmxlRWxlbWVudHMgPSBnZXRUcmFuc2l0aW9uYWJsZUVsZW1lbnRzKClcbiAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24odHJhbnNpdGlvbmFibGVFbGVtZW50cy5jb25jYXQocG9wcGVyKSwgMClcblxuICAgIGN1cnJlbnRNb3VudENhbGxiYWNrID0gKCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzSW5Mb29zZUZvbGxvd0N1cnNvck1vZGUgPSBnZXRJc0luTG9vc2VGb2xsb3dDdXJzb3JNb2RlKClcblxuICAgICAgaWYgKGlzSW5Mb29zZUZvbGxvd0N1cnNvck1vZGUgJiYgbGFzdE1vdXNlTW92ZUV2ZW50KSB7XG4gICAgICAgIHBvc2l0aW9uVmlydHVhbFJlZmVyZW5jZU5lYXJDdXJzb3IobGFzdE1vdXNlTW92ZUV2ZW50KVxuICAgICAgfSBlbHNlIGlmICghaXNJbkxvb3NlRm9sbG93Q3Vyc29yTW9kZSkge1xuICAgICAgICAvLyBEb3VibGUgdXBkYXRlIHdpbGwgYXBwbHkgY29ycmVjdCBtdXRhdGlvbnNcbiAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UhLnVwZGF0ZSgpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbnN0YW5jZS5wb3BwZXJDaGlsZHJlbi5iYWNrZHJvcCkge1xuICAgICAgICBpbnN0YW5jZS5wb3BwZXJDaGlsZHJlbi5jb250ZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9XG4gICAgICAgICAgTWF0aC5yb3VuZChkdXJhdGlvbiAvIDEyKSArICdtcydcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnN0aWNreSkge1xuICAgICAgICBtYWtlU3RpY2t5KClcbiAgICAgIH1cblxuICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtwb3BwZXJdLCBpbnN0YW5jZS5wcm9wcy51cGRhdGVEdXJhdGlvbilcbiAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbih0cmFuc2l0aW9uYWJsZUVsZW1lbnRzLCBkdXJhdGlvbilcbiAgICAgIHNldFZpc2liaWxpdHlTdGF0ZSh0cmFuc2l0aW9uYWJsZUVsZW1lbnRzLCAndmlzaWJsZScpXG5cbiAgICAgIG9uVHJhbnNpdGlvbmVkSW4oXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAoKTogdm9pZCA9PiB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmFyaWEpIHtcbiAgICAgICAgICAgIGdldEV2ZW50TGlzdGVuZXJzVGFyZ2V0KCkuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICBgYXJpYS0ke2luc3RhbmNlLnByb3BzLmFyaWF9YCxcbiAgICAgICAgICAgICAgcG9wcGVyLmlkLFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGluc3RhbmNlLnByb3BzLm9uU2hvd24oaW5zdGFuY2UpXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IHRydWVcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICB9XG5cbiAgICBtb3VudCgpXG4gIH1cblxuICAvKipcbiAgICogSGlkZXMgdGhlIHRvb2x0aXBcbiAgICovXG4gIGZ1bmN0aW9uIGhpZGUoXG4gICAgZHVyYXRpb246IG51bWJlciA9IGdldFZhbHVlKFxuICAgICAgaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sXG4gICAgICAxLFxuICAgICAgKGRlZmF1bHRQcm9wcy5kdXJhdGlvbiBhcyBbbnVtYmVyLCBudW1iZXJdKVsxXSxcbiAgICApLFxuICApOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCB8fFxuICAgICAgKCFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgJiYgIWlzQmVpbmdEZXN0cm95ZWQpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMub25IaWRlKGluc3RhbmNlKSA9PT0gZmFsc2UgJiYgIWlzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJlbW92ZURvY3VtZW50Q2xpY2tMaXN0ZW5lcigpXG5cbiAgICBwb3BwZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gZmFsc2VcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc1Nob3duID0gZmFsc2VcbiAgICB3YXNWaXNpYmxlRHVyaW5nUHJldmlvdXNVcGRhdGUgPSBmYWxzZVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICBnZXRFdmVudExpc3RlbmVyc1RhcmdldCgpLmNsYXNzTGlzdC5yZW1vdmUoQUNUSVZFX0NMQVNTKVxuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zaXRpb25hYmxlRWxlbWVudHMgPSBnZXRUcmFuc2l0aW9uYWJsZUVsZW1lbnRzKClcbiAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24odHJhbnNpdGlvbmFibGVFbGVtZW50cywgZHVyYXRpb24pXG4gICAgc2V0VmlzaWJpbGl0eVN0YXRlKHRyYW5zaXRpb25hYmxlRWxlbWVudHMsICdoaWRkZW4nKVxuXG4gICAgb25UcmFuc2l0aW9uZWRPdXQoZHVyYXRpb24sICgpID0+IHtcbiAgICAgIGlmICghaXNTY2hlZHVsZWRUb1Nob3cpIHtcbiAgICAgICAgcmVtb3ZlRm9sbG93Q3Vyc29yTGlzdGVuZXIoKVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYXJpYSkge1xuICAgICAgICBnZXRFdmVudExpc3RlbmVyc1RhcmdldCgpLnJlbW92ZUF0dHJpYnV0ZShgYXJpYS0ke2luc3RhbmNlLnByb3BzLmFyaWF9YClcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UhLmRpc2FibGVFdmVudExpc3RlbmVycygpXG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSEub3B0aW9ucy5wbGFjZW1lbnQgPSBpbnN0YW5jZS5wcm9wcy5wbGFjZW1lbnRcblxuICAgICAgcG9wcGVyLnBhcmVudE5vZGUhLnJlbW92ZUNoaWxkKHBvcHBlcilcbiAgICAgIGluc3RhbmNlLnByb3BzLm9uSGlkZGVuKGluc3RhbmNlKVxuICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkID0gZmFsc2VcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSB0b29sdGlwXG4gICAqL1xuICBmdW5jdGlvbiBkZXN0cm95KGRlc3Ryb3lUYXJnZXRJbnN0YW5jZXM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpc0JlaW5nRGVzdHJveWVkID0gdHJ1ZVxuXG4gICAgLy8gSWYgdGhlIHBvcHBlciBpcyBjdXJyZW50bHkgbW91bnRlZCB0byB0aGUgRE9NLCB3ZSB3YW50IHRvIGVuc3VyZSBpdCBnZXRzXG4gICAgLy8gaGlkZGVuIGFuZCB1bm1vdW50ZWQgaW5zdGFudGx5IHVwb24gZGVzdHJ1Y3Rpb25cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICBoaWRlKDApXG4gICAgfVxuXG4gICAgcmVtb3ZlVHJpZ2dlcnNGcm9tUmVmZXJlbmNlKClcblxuICAgIGRlbGV0ZSByZWZlcmVuY2UuX3RpcHB5XG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gaW5zdGFuY2UucHJvcHNcbiAgICBpZiAodGFyZ2V0ICYmIGRlc3Ryb3lUYXJnZXRJbnN0YW5jZXMgJiYgaXNSZWFsRWxlbWVudChyZWZlcmVuY2UpKSB7XG4gICAgICBhcnJheUZyb20ocmVmZXJlbmNlLnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KSkuZm9yRWFjaChcbiAgICAgICAgKGNoaWxkOiBSZWZlcmVuY2VFbGVtZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLl90aXBweSkge1xuICAgICAgICAgICAgY2hpbGQuX3RpcHB5LmRlc3Ryb3koKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIGlzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZVxuICAgIGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZVxuICB9XG59XG4iLCJpbXBvcnQgeyBHcm91cGVkSW5zdGFuY2UsIEdyb3VwT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5cbi8qKlxuICogR3JvdXBzIGFuIGFycmF5IG9mIGluc3RhbmNlcyBieSB0YWtpbmcgY29udHJvbCBvZiB0aGVpciBwcm9wcyBkdXJpbmdcbiAqIGNlcnRhaW4gbGlmZWN5Y2xlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JvdXAoXG4gIGluc3RhbmNlczogR3JvdXBlZEluc3RhbmNlW10sXG4gIHsgZGVsYXkgPSBpbnN0YW5jZXNbMF0ucHJvcHMuZGVsYXksIGR1cmF0aW9uID0gMCB9OiBHcm91cE9wdGlvbnMgPSB7fSxcbik6IHZvaWQge1xuICBsZXQgaXNBbnlUaXBweU9wZW4gPSBmYWxzZVxuXG4gIGluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICBpZiAoaW5zdGFuY2UuX29yaWdpbmFsUHJvcHMpIHtcbiAgICAgIGluc3RhbmNlLnNldChpbnN0YW5jZS5fb3JpZ2luYWxQcm9wcylcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UuX29yaWdpbmFsUHJvcHMgPSB7IC4uLmluc3RhbmNlLnByb3BzIH1cbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gc2V0SXNBbnlUaXBweU9wZW4odmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpc0FueVRpcHB5T3BlbiA9IHZhbHVlXG4gICAgdXBkYXRlSW5zdGFuY2VzKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2hvdyhpbnN0YW5jZTogR3JvdXBlZEluc3RhbmNlKTogdm9pZCB7XG4gICAgaW5zdGFuY2UuX29yaWdpbmFsUHJvcHMub25TaG93KGluc3RhbmNlKVxuXG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgaW5zdGFuY2Uuc2V0KHsgZHVyYXRpb24gfSlcblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5oaWRlKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgc2V0SXNBbnlUaXBweU9wZW4odHJ1ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSGlkZShpbnN0YW5jZTogR3JvdXBlZEluc3RhbmNlKTogdm9pZCB7XG4gICAgaW5zdGFuY2UuX29yaWdpbmFsUHJvcHMub25IaWRlKGluc3RhbmNlKVxuICAgIHNldElzQW55VGlwcHlPcGVuKGZhbHNlKVxuICB9XG5cbiAgZnVuY3Rpb24gb25TaG93bihpbnN0YW5jZTogR3JvdXBlZEluc3RhbmNlKTogdm9pZCB7XG4gICAgaW5zdGFuY2UuX29yaWdpbmFsUHJvcHMub25TaG93bihpbnN0YW5jZSlcbiAgICBpbnN0YW5jZS5zZXQoeyBkdXJhdGlvbjogaW5zdGFuY2UuX29yaWdpbmFsUHJvcHMuZHVyYXRpb24gfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUluc3RhbmNlcygpOiB2b2lkIHtcbiAgICBpbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICBpbnN0YW5jZS5zZXQoe1xuICAgICAgICBvblNob3csXG4gICAgICAgIG9uU2hvd24sXG4gICAgICAgIG9uSGlkZSxcbiAgICAgICAgZGVsYXk6IGlzQW55VGlwcHlPcGVuXG4gICAgICAgICAgPyBbMCwgQXJyYXkuaXNBcnJheShkZWxheSkgPyBkZWxheVsxXSA6IGRlbGF5XVxuICAgICAgICAgIDogZGVsYXksXG4gICAgICAgIGR1cmF0aW9uOiBpc0FueVRpcHB5T3BlbiA/IGR1cmF0aW9uIDogaW5zdGFuY2UuX29yaWdpbmFsUHJvcHMuZHVyYXRpb24sXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGVJbnN0YW5jZXMoKVxufVxuIiwiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uL3BhY2thZ2UuanNvbidcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4vYnJvd3NlcidcbmltcG9ydCB7IGRlZmF1bHRQcm9wcyB9IGZyb20gJy4vcHJvcHMnXG5pbXBvcnQgY3JlYXRlVGlwcHkgZnJvbSAnLi9jcmVhdGVUaXBweSdcbmltcG9ydCBiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi9iaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMnXG5pbXBvcnQgZ3JvdXAgZnJvbSAnLi9ncm91cCdcbmltcG9ydCB7IHBvbHlmaWxsRWxlbWVudFByb3RvdHlwZVByb3BlcnRpZXMgfSBmcm9tICcuL3JlZmVyZW5jZSdcbmltcG9ydCB7IGFycmF5RnJvbSB9IGZyb20gJy4vcG9ueWZpbGxzJ1xuaW1wb3J0IHsgaGlkZUFsbCB9IGZyb20gJy4vcG9wcGVyJ1xuaW1wb3J0IHtcbiAgaXNTaW5ndWxhcixcbiAgaXNCYXJlVmlydHVhbEVsZW1lbnQsXG4gIGdldEFycmF5T2ZFbGVtZW50cyxcbiAgdmFsaWRhdGVPcHRpb25zLFxufSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgT3B0aW9ucywgUHJvcHMsIEluc3RhbmNlLCBUYXJnZXRzLCBWaXJ0dWFsUmVmZXJlbmNlIH0gZnJvbSAnLi90eXBlcydcblxubGV0IGdsb2JhbEV2ZW50TGlzdGVuZXJzQm91bmQgPSBmYWxzZVxuXG4vKipcbiAqIEV4cG9ydGVkIG1vZHVsZVxuICovXG5mdW5jdGlvbiB0aXBweSh0YXJnZXRzOiBUYXJnZXRzLCBvcHRpb25zPzogT3B0aW9ucyk6IEluc3RhbmNlIHwgSW5zdGFuY2VbXSB7XG4gIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zIHx8IHt9LCBkZWZhdWx0UHJvcHMpXG5cbiAgaWYgKCFnbG9iYWxFdmVudExpc3RlbmVyc0JvdW5kKSB7XG4gICAgYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKClcbiAgICBnbG9iYWxFdmVudExpc3RlbmVyc0JvdW5kID0gdHJ1ZVxuICB9XG5cbiAgY29uc3QgcHJvcHM6IFByb3BzID0geyAuLi5kZWZhdWx0UHJvcHMsIC4uLm9wdGlvbnMgfVxuXG4gIC8vIElmIHRoZXkgYXJlIHNwZWNpZnlpbmcgYSB2aXJ0dWFsIHBvc2l0aW9uaW5nIHJlZmVyZW5jZSwgd2UgbmVlZCB0byBwb2x5ZmlsbFxuICAvLyBzb21lIG5hdGl2ZSBET00gcHJvcHNcbiAgaWYgKGlzQmFyZVZpcnR1YWxFbGVtZW50KHRhcmdldHMpKSB7XG4gICAgcG9seWZpbGxFbGVtZW50UHJvdG90eXBlUHJvcGVydGllcyh0YXJnZXRzIGFzIFZpcnR1YWxSZWZlcmVuY2UpXG4gIH1cblxuICBjb25zdCBpbnN0YW5jZXMgPSBnZXRBcnJheU9mRWxlbWVudHModGFyZ2V0cykucmVkdWNlPEluc3RhbmNlW10+KFxuICAgIChhY2MsIHJlZmVyZW5jZSkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSByZWZlcmVuY2UgJiYgY3JlYXRlVGlwcHkocmVmZXJlbmNlLCBwcm9wcylcblxuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGFjYy5wdXNoKGluc3RhbmNlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSxcbiAgICBbXSxcbiAgKVxuXG4gIHJldHVybiBpc1Npbmd1bGFyKHRhcmdldHMpID8gaW5zdGFuY2VzWzBdIDogaW5zdGFuY2VzXG59XG5cbi8qKlxuICogU3RhdGljIHByb3BzXG4gKi9cbnRpcHB5LnZlcnNpb24gPSB2ZXJzaW9uXG50aXBweS5kZWZhdWx0cyA9IGRlZmF1bHRQcm9wc1xuXG4vKipcbiAqIFN0YXRpYyBtZXRob2RzXG4gKi9cbnRpcHB5LnNldERlZmF1bHRzID0gKHBhcnRpYWxEZWZhdWx0czogT3B0aW9ucykgPT4ge1xuICBPYmplY3Qua2V5cyhwYXJ0aWFsRGVmYXVsdHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZGVmYXVsdFByb3BzW2tleV0gPSBwYXJ0aWFsRGVmYXVsdHNba2V5XVxuICB9KVxufVxudGlwcHkuaGlkZUFsbCA9IGhpZGVBbGxcbnRpcHB5Lmdyb3VwID0gZ3JvdXBcblxuLyoqXG4gKiBBdXRvLWluaXQgdG9vbHRpcHMgZm9yIGVsZW1lbnRzIHdpdGggYSBgZGF0YS10aXBweT1cIi4uLlwiYCBhdHRyaWJ1dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9Jbml0KCk6IHZvaWQge1xuICBhcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGlwcHldJykpLmZvckVhY2goZWwgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGlwcHknKVxuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHRpcHB5KGVsLCB7IGNvbnRlbnQgfSlcbiAgICB9XG4gIH0pXG59XG5cbmlmIChpc0Jyb3dzZXIpIHtcbiAgc2V0VGltZW91dChhdXRvSW5pdClcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGlwcHlcbiIsImltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4vYnJvd3NlcidcblxuLyoqXG4gKiBJbmplY3RzIGEgc3RyaW5nIG9mIENTUyBzdHlsZXMgdG8gYSBzdHlsZSBub2RlIGluIDxoZWFkPlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0Q1NTKGNzczogc3RyaW5nKTogdm9pZCB7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJ1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzXG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdkYXRhLV9fTkFNRVNQQUNFX1BSRUZJWF9fLXN0eWxlc2hlZXQnLCAnJylcbiAgICBjb25zdCBoZWFkID0gZG9jdW1lbnQuaGVhZFxuICAgIGNvbnN0IHsgZmlyc3RDaGlsZCB9ID0gaGVhZFxuXG4gICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBmaXJzdENoaWxkKVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGNzcyBmcm9tICcuLi9pbmRleC5jc3MnXG5pbXBvcnQgdGlwcHkgZnJvbSAnLi4vc3JjL2luZGV4LnRzJ1xuaW1wb3J0IHsgaW5qZWN0Q1NTIH0gZnJvbSAnLi4vc3JjL2NzcydcblxuaW5qZWN0Q1NTKGNzcylcblxuZXhwb3J0IGRlZmF1bHQgdGlwcHlcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0ICdub3JtYWxpemUuY3NzJztcblxuaW1wb3J0ICcuL2pzL2NvbXBvbmVudHMvdXNlcnMnO1xuIiwiaW1wb3J0ICcuL3Njc3MvaW5kZXguc2Nzcyc7XG5cbmltcG9ydCBVc2VycyBmcm9tICcuL2pzL3VzZXJzLmNvbXBvbmVudCc7XG5cbmNvbnN0IHVzZXJzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNvbXBvbmVudD1cInVzZXJzXCJdJyldLm1hcChuID0+IG5ldyBVc2VycyhuKSk7XG4iLCJjb25zdCBnZXRTdHJpbmdUeXBlID0gKHR5cGUsIHRvb2x0aXAgPSBmYWxzZSkgPT4ge1xuXG4gIGlmICh0b29sdGlwKSB7XG4gICAgaWYgKHR5cGUgPT09ICcxJykge1xuICAgICAgcmV0dXJuIFwi0KTQuNC30LjRh9C10YHQutC+0LUg0LvQuNGG0L5cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJzInKSB7XG4gICAgICByZXR1cm4gXCLQrtGA0LjQtNC40YfQtdGB0LrQvtC1INC70LjRhtC+XCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09ICcxJykge1xuICAgIHJldHVybiBcItCkXCI7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gJzInKSB7XG4gICAgcmV0dXJuIFwi0K5cIjtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJUZW1wbGF0ZSA9ICh1c2VyKSA9PiB7XG4gIHJldHVybiBgXG4gICAgICA8dHIgY2xhc3M9XCJ1c2Vyc19fcm93XCI+XG4gICAgICAgIDx0ZCBjbGFzcz1cInVzZXJzX19jZWxsIHVzZXJzX19jZWxsLS1uYW1lXCI+XG4gICAgICAgICAgICAke3VzZXIuZmlyc3ROYW1lfVxuICAgICAgICA8L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJ1c2Vyc19fY2VsbFwiPlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzPVwidXNlcnNfX2J1dHRvbi10b29sdGlwXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS11c2Vycy1yZWY9XCJ0b29sdGlwXCJcbiAgICAgICAgICAgIGRhdGEtdGlwcHktY29udGVudD1cIiR7Z2V0U3RyaW5nVHlwZSh1c2VyLnR5cGUsIHRydWUpfVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgJHtnZXRTdHJpbmdUeXBlKHVzZXIudHlwZSl9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvdGQ+XG4gICAgICAgIDx0ZCBjbGFzcz1cInVzZXJzX19jZWxsXCI+XG4gICAgICAgICAgICAke3VzZXIudXNlck51bWJlcn1cbiAgICAgICAgPC90ZD5cbiAgICAgICAgPHRkIGNsYXNzPVwidXNlcnNfX2NlbGxcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBjbGFzcz1cInVzZXJzX19idXR0b24tZWRpdCBidXR0b25cIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGRhdGEtdXNlcnMtcmVmPVwiZWRpdFwiXG4gICAgICAgICAgICAgICAgZGF0YS11c2Vycy1vcHRpb25zPSR7dXNlci5pZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAg0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0YxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJ1c2Vyc19fY2VsbFwiPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwidXNlcnNfX2J1dHRvbi1kZWxldGUgYnV0dG9uXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBkYXRhLXVzZXJzLXJlZj1cImRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgZGF0YS11c2Vycy1vcHRpb25zPSR7dXNlci5pZH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICDQo9C00LDQu9C40YLRjFxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvdGQ+XG4gICAgICA8L3RyPlxuICBgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJFZGl0VGVtcGxhdGUgPSAodXNlcikgPT4ge1xuICByZXR1cm4gYFxuICAgICAgPHRyIGNsYXNzPVwidXNlcnNfX3Jvd1wiPlxuICAgICAgICA8dGQgY2xhc3M9XCJ1c2Vyc19fY2VsbCB1c2Vyc19fY2VsbC0tbmFtZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVzZXJzX19jZWxsLWVsZW1lbnRcIj5cbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ1c2Vyc19fY2VsbC1pbnB1dFwiXG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPVwiJHt1c2VyLmZpcnN0TmFtZX1cIlxuICAgICAgICAgICAgICAgIGRhdGEtdXNlcnMtcmVmPVwiZmlyc3QtbmFtZS11cGRhdGVcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXNlcnNfX21lc3NhZ2VcIiBkYXRhLXVzZXJzLXJlZj1cIm1lc3NhZ2VcIj48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJ1c2Vyc19fY2VsbFwiPlxuICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XCJ1c2Vyc19fc2VsZWN0LXVwZGF0ZVwiIGRhdGEtdXNlcnMtcmVmPVwidHlwZS11cGRhdGVcIj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+0KTQuNC30LjRh9C10YHQutC+0LUg0LvQuNGG0L48L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyXCI+0K7RgNC40LTQuNGH0LXRgdC60L7QtSDQu9C40YbQvjwvb3B0aW9uPlxuICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJ1c2Vyc19fY2VsbFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVzZXJzX19jZWxsLWVsZW1lbnRcIj5cbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICBjbGFzcz1cInVzZXJzX19jZWxsLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPVwiJHt1c2VyLnVzZXJOdW1iZXJ9XCJcbiAgICAgICAgICAgICAgICAgIGRhdGEtdXNlcnMtcmVmPVwidXNlci1udW1iZXItdXBkYXRlXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVzZXJzX19tZXNzYWdlXCIgZGF0YS11c2Vycy1yZWY9XCJtZXNzYWdlXCI+PC9kaXY+XG4gICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJ1c2Vyc19fY2VsbFwiPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwidXNlcnNfX2J1dHRvbi1lZGl0IGJ1dHRvblwiXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgZGF0YS11c2Vycy1yZWY9XCJ1cGRhdGVcIlxuICAgICAgICAgICAgICAgIGRhdGEtdXNlcnMtb3B0aW9ucz0ke3VzZXIuaWR9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgINCe0LHQvdC+0LLQuNGC0YxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJ1c2Vyc19fY2VsbFwiPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzPVwidXNlcnNfX2J1dHRvbi1kZWxldGUgYnV0dG9uXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBkYXRhLXVzZXJzLXJlZj1cImNsb3NlXCJcbiAgICAgICAgICAgICAgICBkYXRhLXVzZXJzLW9wdGlvbnM9JHt1c2VyLmlkfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgINCX0LDQutGA0YvRgtGMXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvdHI+XG4gIGA7XG59O1xuIiwiaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCc7XG5pbXBvcnQgZGF0YVNlcnZpY2UgZnJvbSAnLi4vLi4vLi4vZ2VuZXJhbC9qcy9kYXRhLXNlcnZpY2UnO1xuaW1wb3J0IHZhbGlkYXRvcnMgZnJvbSAnLi4vLi4vLi4vZ2VuZXJhbC9qcy92YWxpZGF0b3JzJztcbmltcG9ydCB7IGdldFVzZXJUZW1wbGF0ZSwgZ2V0VXNlckVkaXRUZW1wbGF0ZSB9IGZyb20gJy4vdGVtcGxhdGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlcnMge1xuICBjb25zdHJ1Y3RvcihlbCkge1xuICAgIHRoaXMuZWwgPSBlbDtcblxuICAgIHRoaXMuZmlsdGVyU3RhdGUgPSB7XG4gICAgICBmaWx0ZXJCeVplcm9TdGF0ZTogZmFsc2UsXG4gICAgICBmaWx0ZXJCeU9uZVN0YXRlOiBmYWxzZSxcbiAgICAgIGZpbHRlckJ5VHdvU3RhdGU6IGZhbHNlLFxuICAgIH07XG5cbiAgICB0aGlzLmZvcm0gPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXVzZXJzLXJlZj1cImZvcm1cIl0nKTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXVzZXJzLXJlZj1cIm5hbWVcIl0nKTtcbiAgICB0aGlzLnR5cGUgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXVzZXJzLXJlZj1cInR5cGVcIl0nKTtcbiAgICB0aGlzLnVzZXJOdW1iZXIgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXVzZXJzLXJlZj1cInVzZXItbnVtYmVyXCJdJyk7XG4gICAgdGhpcy51c2Vyc1Rib2R5ID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS11c2Vycy1yZWY9XCJ1c2Vycy10Ym9keVwiXScpO1xuICAgIHRoaXMuc2VsZWN0RmlsdGVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS11c2Vycy1yZWY9XCJmaWx0ZXJcIl0nKTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy51c2VySGFuZGxlcik7XG4gICAgdGhpcy5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuY3JlYXRlQWQpO1xuICAgIHRoaXMuc2VsZWN0RmlsdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuc2VsZWN0RmlsdGVySGFuZGxlcik7XG5cbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuXG4gICAgdGhpcy5mZXRjaEFkcygpO1xuICB9XG5cbiAgc2VsZWN0RmlsdGVySGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC50YXJnZXQudmFsdWUgPT09ICcwJykge1xuICAgICAgdGhpcy5maWx0ZXJCeVplcm8oKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlID09PSAnMScpIHtcbiAgICAgIHRoaXMuZmlsdGVyQnlPbmUoKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlID09PSAnMicpIHtcbiAgICAgIHRoaXMuZmlsdGVyQnlUd28oKTtcbiAgICB9XG4gIH1cblxuICBmaWx0ZXJCeVplcm8gPSAoKSA9PiB7XG4gICAgdGhpcy5maWx0ZXJTdGF0ZS5maWx0ZXJCeU9uZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5maWx0ZXJTdGF0ZS5maWx0ZXJCeVR3b1N0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5kYXRhKTtcbiAgfVxuXG4gIGZpbHRlckJ5T25lID0gKCkgPT4ge1xuICAgIHRoaXMuZmlsdGVyU3RhdGUuZmlsdGVyQnlPbmVTdGF0ZSA9IHRydWU7XG4gICAgdGhpcy5maWx0ZXJTdGF0ZS5maWx0ZXJCeVR3b1N0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5kYXRhKTtcbiAgfVxuXG4gIGZpbHRlckJ5VHdvID0gKCkgPT4ge1xuICAgIHRoaXMuZmlsdGVyU3RhdGUuZmlsdGVyQnlPbmVTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuZmlsdGVyU3RhdGUuZmlsdGVyQnlUd29TdGF0ZSA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5kYXRhKTtcbiAgfVxuXG4gIGZldGNoQWRzID0gKCkgPT4ge1xuICAgIGRhdGFTZXJ2aWNlLmZldGNoQWRzKClcbiAgICAgIC50aGVuKCh1c2VycykgPT4ge1xuICAgICAgICB0aGlzLmRhdGEgPSBjbG9uZURlZXAodXNlcnMpO1xuICAgICAgICB0aGlzLnJlbmRlcih0aGlzLmRhdGEpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJlbmRlciA9IChkYXRhLCBtb2RlID0gbnVsbCwgaWQgPSBudWxsKSA9PiB7XG4gICAgbGV0IHVzZXJzID0gZGF0YTtcblxuICAgIHVzZXJzID0gdXNlcnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgbmFtZUEgPSBhLmZpcnN0TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgbmFtZUIgPSBiLmZpcnN0TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAobmFtZUEgPCBuYW1lQikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lQSA+IG5hbWVCKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmZpbHRlclN0YXRlLmZpbHRlckJ5T25lU3RhdGUpIHtcbiAgICAgIHVzZXJzID0gdXNlcnMuZmlsdGVyKCh1c2VyKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VyLnR5cGUgPT09ICcxJztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbHRlclN0YXRlLmZpbHRlckJ5VHdvU3RhdGUpIHtcbiAgICAgIHVzZXJzID0gdXNlcnMuZmlsdGVyKCh1c2VyKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VyLnR5cGUgPT09ICcyJztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMudXNlcnNUYm9keS5pbm5lckhUTUwgPSAnJztcblxuICAgIGlmIChtb2RlID09PSAnZWRpdCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHVzZXJzW2ldLmlkID09PSBpZCkge1xuICAgICAgICAgIHRoaXMudXNlcnNUYm9keS5pbm5lckhUTUwgKz0gZ2V0VXNlckVkaXRUZW1wbGF0ZSh1c2Vyc1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51c2Vyc1Rib2R5LmlubmVySFRNTCArPSBnZXRVc2VyVGVtcGxhdGUodXNlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1c2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnVzZXJzVGJvZHkuaW5uZXJIVE1MICs9IGdldFVzZXJUZW1wbGF0ZSh1c2Vyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50b29sdGlwSW5pdCgpO1xuICB9XG5cbiAgdG9vbHRpcEluaXQgPSAoKSA9PiB7XG4gICAgdGhpcy50b29sdGlwRWxlbWVudHMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXVzZXJzLXJlZj1cInRvb2x0aXBcIl0nKTtcblxuICAgIHRoaXMudG9vbHRpcCA9IHRpcHB5KHRoaXMudG9vbHRpcEVsZW1lbnRzKTtcbiAgfVxuXG4gIGNyZWF0ZUFkID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZS52YWx1ZSxcbiAgICAgIHVzZXJOdW1iZXI6IHRoaXMudXNlck51bWJlci52YWx1ZVxuICAgIH07XG5cbiAgICBjb25zdCBub2RlcyA9IHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHVzZXJOdW1iZXI6IHRoaXMudXNlck51bWJlclxuICAgIH07XG5cbiAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9ycy5yZXF1aXJlZCh0aGlzLmVsLCB2YWx1ZXMsIG5vZGVzKTtcblxuICAgIGlmICghaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIGZpcnN0TmFtZTogdGhpcy5uYW1lLnZhbHVlLFxuICAgICAgdHlwZTogdGhpcy50eXBlLnZhbHVlLFxuICAgICAgdXNlck51bWJlcjogdGhpcy51c2VyTnVtYmVyLnZhbHVlXG4gICAgfTtcblxuICAgIGRhdGFTZXJ2aWNlLmNyZWF0ZUFkKHBheWxvYWQpO1xuXG4gICAgdGhpcy5uYW1lLnZhbHVlID0gJyc7XG4gICAgdGhpcy51c2VyTnVtYmVyLnZhbHVlID0gJyc7XG5cbiAgICB0aGlzLmZldGNoQWRzKCk7XG4gIH1cblxuICBkZWxldGVBZCA9IChpZCkgPT4ge1xuICAgIGRhdGFTZXJ2aWNlLmRlbGV0ZUFkKGlkKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmZldGNoQWRzKCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlQWQgPSAoaWQpID0+IHtcbiAgICBjb25zdCBmaXJzdE5hbWUgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXVzZXJzLXJlZj1cImZpcnN0LW5hbWUtdXBkYXRlXCJdJyk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignW2RhdGEtdXNlcnMtcmVmPVwidHlwZS11cGRhdGVcIl0nKTtcbiAgICBjb25zdCB1c2VyTnVtYmVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS11c2Vycy1yZWY9XCJ1c2VyLW51bWJlci11cGRhdGVcIl0nKTtcblxuICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgIG5hbWU6IGZpcnN0TmFtZS52YWx1ZSxcbiAgICAgIHVzZXJOdW1iZXI6IHVzZXJOdW1iZXIudmFsdWVcbiAgICB9O1xuXG4gICAgY29uc3Qgbm9kZXMgPSB7XG4gICAgICBuYW1lOiBmaXJzdE5hbWUsXG4gICAgICB1c2VyTnVtYmVyOiB1c2VyTnVtYmVyXG4gICAgfTtcblxuICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3JzLnJlcXVpcmVkKHRoaXMuZWwsIHZhbHVlcywgbm9kZXMpO1xuXG4gICAgaWYgKCFpc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgZmlyc3ROYW1lOiBmaXJzdE5hbWUudmFsdWUsXG4gICAgICB0eXBlOiB0eXBlLnZhbHVlLFxuICAgICAgdXNlck51bWJlcjogdXNlck51bWJlci52YWx1ZVxuICAgIH07XG5cbiAgICBkYXRhU2VydmljZS51cGRhdGVBZChpZCwgcGF5bG9hZClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5mZXRjaEFkcygpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIGVkaXRBZCA9IChpZCkgPT4ge1xuICAgIHRoaXMucmVuZGVyKHRoaXMuZGF0YSwgJ2VkaXQnLCBpZCk7XG4gIH1cblxuICBjbG9zZUFkID0gKCkgPT4ge1xuICAgIHRoaXMucmVuZGVyKHRoaXMuZGF0YSk7XG4gIH1cblxuICB1c2VySGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGRhdGFTZXQgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXVzZXJzLXJlZicpO1xuICAgIGNvbnN0IGlkID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS11c2Vycy1vcHRpb25zJyk7XG5cbiAgICBpZiAoZGF0YVNldCA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgIHRoaXMuZGVsZXRlQWQoaWQpO1xuICAgIH1cblxuICAgIGlmIChkYXRhU2V0ID09PSAnZWRpdCcpIHtcbiAgICAgIHRoaXMuZWRpdEFkKGlkKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YVNldCA9PT0gJ2Nsb3NlJykge1xuICAgICAgdGhpcy5jbG9zZUFkKGlkKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YVNldCA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgIHRoaXMudXBkYXRlQWQoaWQpO1xuICAgIH1cblxuICAgIC8vIGlmIChldmVudC50YXJnZXQuZGF0YXNldC51c2Vyc1JlZiA9PT0gJ2VkaXQnKSB7XG4gICAgLy8gICB0aGlzLmVkaXRVc2VyKGV2ZW50LnRhcmdldC5kYXRhc2V0LnVzZXJzT3B0aW9ucyk7XG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gaWYgKGV2ZW50LnRhcmdldC5kYXRhc2V0LnVzZXJzUmVmID09PSAndXBkYXRlJykge1xuICAgIC8vICAgdGhpcy51cGRhdGVVc2VyKGV2ZW50LnRhcmdldC5kYXRhc2V0LnVzZXJzT3B0aW9ucyk7XG4gICAgLy8gfVxuICB9XG5cbn1cbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNy0yIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNy0zIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTctNCEuL2luZGV4LnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS03LTIhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS03LTMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tNy00IS4vaW5kZXguc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS03LTIhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS03LTMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tNy00IS4vaW5kZXguc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIGh0dHBzOi8vY29uc29sZS5maXJlYmFzZS5nb29nbGUuY29tL1xuaW1wb3J0IGZiIGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5pbXBvcnQgJ2ZpcmViYXNlL2RhdGFiYXNlJztcblxuY2xhc3MgQWQge1xuICBjb25zdHJ1Y3RvcihmaXJzdE5hbWUsIHR5cGUsIHVzZXJOdW1iZXIsIGlkID0gbnVsbCkge1xuICAgIHRoaXMuZmlyc3ROYW1lID0gZmlyc3ROYW1lO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy51c2VyTnVtYmVyID0gdXNlck51bWJlcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cbn1cblxuY2xhc3MgRGF0YVNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuXG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGFwaUtleTogJ0FJemFTeUJ0dnpabHhEX1RMd3NvRTJrTVpVTVJQbkZnejIwUnlqQScsXG4gICAgICBhdXRoRG9tYWluOiAnamF2YXNjcmlwdC1hcHAtODgwNGEuZmlyZWJhc2VhcHAuY29tJyxcbiAgICAgIGRhdGFiYXNlVVJMOiAnaHR0cHM6Ly9qYXZhc2NyaXB0LWFwcC04ODA0YS5maXJlYmFzZWlvLmNvbScsXG4gICAgICBwcm9qZWN0SWQ6ICdqYXZhc2NyaXB0LWFwcC04ODA0YScsXG4gICAgICBzdG9yYWdlQnVja2V0OiAnamF2YXNjcmlwdC1hcHAtODgwNGEuYXBwc3BvdC5jb20nLFxuICAgICAgbWVzc2FnaW5nU2VuZGVySWQ6ICc5MTYzOTAyNDMzNDEnLFxuICAgICAgYXBwSWQ6ICcxOjkxNjM5MDI0MzM0MTp3ZWI6ZDkzMzIyZWE1M2Q1MGJhZSdcbiAgICB9O1xuXG4gICAgZmIuaW5pdGlhbGl6ZUFwcChjb25maWcpO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hBZHMoKSB7XG5cbiAgICBjb25zdCByZXN1bHRBZHMgPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmYlZhbCA9IGF3YWl0IGZiLmRhdGFiYXNlKClcbiAgICAgICAgLnJlZigndXNlcnMnKVxuICAgICAgICAub25jZSgndmFsdWUnKTtcblxuICAgICAgY29uc3QgYWRzID0gZmJWYWwudmFsKCk7XG5cbiAgICAgIGlmICghYWRzKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRBZHM7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5rZXlzKGFkcylcbiAgICAgICAgLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBjb25zdCBhZCA9IGFkc1trZXldO1xuXG4gICAgICAgICAgcmVzdWx0QWRzLnB1c2goXG4gICAgICAgICAgICBuZXcgQWQoYWQuZmlyc3ROYW1lLCBhZC50eXBlLCBhZC51c2VyTnVtYmVyLCBrZXkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGF0YSA9IHJlc3VsdEFkcztcblxuICAgICAgY29uc29sZS5sb2coJ2RhdGEnLCB0aGlzLmRhdGEpO1xuXG4gICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjcmVhdGVBZChwYXlsb2FkKSB7XG4gICAgY29uc3QgbmV3QWQgPSBuZXcgQWQoXG4gICAgICBwYXlsb2FkLmZpcnN0TmFtZSxcbiAgICAgIHBheWxvYWQudHlwZSxcbiAgICAgIHBheWxvYWQudXNlck51bWJlclxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWQgPSBhd2FpdCBmYi5kYXRhYmFzZSgpXG4gICAgICAgIC5yZWYoJ3VzZXJzJylcbiAgICAgICAgLnB1c2gobmV3QWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkZWxldGVBZChpZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZCA9IGF3YWl0IGZiLmRhdGFiYXNlKClcbiAgICAgICAgLnJlZigndXNlcnMnKVxuICAgICAgICAuY2hpbGQoaWQpXG4gICAgICAgIC5yZW1vdmUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlQWQoaWQsIHBheWxvYWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWQgPSBhd2FpdCBmYi5kYXRhYmFzZSgpXG4gICAgICAgIC5yZWYoJ3VzZXJzJylcbiAgICAgICAgLmNoaWxkKGlkKVxuICAgICAgICAudXBkYXRlKHBheWxvYWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaW5zdGFuY2UgPSBuZXcgRGF0YVNlcnZpY2UoKTtcbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIiwiZXhwb3J0IGNsYXNzIFZhbGlkYXRvcnMge1xuICByZXF1aXJlZChlbCwgdmFsdWUsIG5vZGVzKSB7XG4gICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgIGxldCBuYW1lTGVuZ3RoID0gdHJ1ZTtcbiAgICBsZXQgdXNlck51bWJlclN0YXRlID0gdHJ1ZTtcblxuICAgIE9iamVjdC5rZXlzKG5vZGVzKVxuICAgICAgLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgbm9kZXNbbl0ubmV4dEVsZW1lbnRTaWJsaW5nLmlubmVySFRNTCA9ICcnO1xuICAgICAgfSk7XG5cbiAgICBPYmplY3Qua2V5cyh2YWx1ZSlcbiAgICAgIC5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVt2XSA9PT0gJycpIHtcbiAgICAgICAgICB0aGlzLmdldE1lc3NhZ2Uobm9kZXNbdl0sIHYpO1xuXG4gICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYgPT09ICduYW1lJykge1xuICAgICAgICAgIG5hbWVMZW5ndGggPSB0aGlzLnZhbGlkYXRpb25OYW1lKHZhbHVlW3ZdKTtcblxuICAgICAgICAgIGlmICghbmFtZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5nZXRNZXNzYWdlKG5vZGVzW3ZdLCB2KTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodiA9PT0gJ3VzZXJOdW1iZXInKSB7XG4gICAgICAgICAgdXNlck51bWJlclN0YXRlID0gdGhpcy52YWxpZGF0aW9uVXNlck51bWJlcih2YWx1ZVt2XSk7XG5cbiAgICAgICAgICBpZiAoIXVzZXJOdW1iZXJTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5nZXRNZXNzYWdlKG5vZGVzW3ZdLCB2KTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIGlzVmFsaWQ7XG4gIH1cblxuICB2YWxpZGF0aW9uTmFtZSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKG5hbWUubGVuZ3RoID4gMjU1KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YWxpZGF0aW9uVXNlck51bWJlciA9IChudW1iZXIpID0+IHtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCAhPT0gMTMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldE1lc3NhZ2UgPSAobm9kZSwgdmFsdWUpID0+IHtcbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xuXG4gICAgaWYgKHZhbHVlID09PSAndXNlck51bWJlcicpIHtcbiAgICAgIG1lc3NhZ2UgPSAn0JLQstC10LTQuNGC0LUg0YLRgNC40L3QsNC00YbQsNGC0Ywg0YbQuNGE0YAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gJ9Cd0LXQstCw0LvQuNC00L3Ri9C1INC00LDQvdC90YvQtS4g0JrQvtC70LjRh9C10YHRgtCy0L4g0YHQuNC80LLQvtC70L7QstC+INC90LUg0LTQvtC70LbQvdC+INC/0YDQtdCy0LDRiNCw0YLRjCAyNTUuJztcbiAgICB9XG5cbiAgICBub2RlLm5leHRFbGVtZW50U2libGluZy5pbm5lckhUTUwgPSBtZXNzYWdlO1xuICB9XG59XG5cbmNvbnN0IGluc3RhbmNlID0gbmV3IFZhbGlkYXRvcnMoKTtcbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==